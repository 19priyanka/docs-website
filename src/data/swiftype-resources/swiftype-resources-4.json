{
  "/docs/apm/agents/java-agent/troubleshooting/host-links-missing-java-apps-apm-summary": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.17003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.628815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/java-solr-data-does-not-appear": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.17003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81137,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.628815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.16994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.62874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/no-browser-data-appears-java": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.16994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.62874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/no-data-appears-java": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.169846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.628654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/no-log-file-java": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.169846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.628654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/no-stack-traces-java": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.169754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.62857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/nullpointerexception-issues-java": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.169754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.62857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/resolve-metric-grouping-issues-java-apps": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.16966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.628494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/ssl-or-connection-errors-java": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.16966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.628494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/java-agent/troubleshooting/update-java-config-legacy-agent-versions": [
    {
      "sections": [
        "Install Java agent using Maven",
        "Install agent package using Maven",
        "Install complete agent package",
        "Zip example",
        "Install individual components",
        "Individual components example"
      ],
      "title": "Install Java agent using Maven",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "2251ba32d223587d0242fd92d03d691a764e10bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/additional-installation/install-java-agent-using-maven/",
      "published_at": "2021-12-05T04:14:30Z",
      "updated_at": "2021-12-05T04:14:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the Java agent using Maven. For information on manually installing the Java agent, see Install the Java agent and Java agent configuration: Config file. Install agent package using Maven Install the New Relic Java agent, using either of these options: Install complete agent package This section explains how to configure Maven to download and unzip the newrelic-java.zip file, which contains all New Relic Java agent components. newrelic.yml (agent configuration file) newrelic.jar (Java agent jar) newrelic-api.jar (Java agent API jar) README To do this: Configure your pom.xml to download newrelic-java.zip. For example: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Unzip newrelic-java.zip by configuring maven-dependency-plugin in your pom.xml. For example: <!-- Unzip New Relic Java agent into target/ --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <!-- you can optionally exclude files --> <!-- <excludes>**/newrelic.yml</excludes> --> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> Copy This will unzip all the files into the newly created newrelic/ within project.build.directory: Zip example Here is an example pom.xml that downloads and extracts newrelic-java.zip. <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> <type>zip</type> </dependency> </dependencies> <!-- boilerplate code so Maven can generate a .war archive without requiring a web.xml file --> <build> <finalName>my-example-app</finalName> <plugins> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-war-plugin</artifactId> <version>3.2.2</version> <configuration> <failOnMissingWebXml>false</failOnMissingWebXml> </configuration> </plugin> <!-- Unzip New Relic Java agent into project.build.directory --> <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.1.1</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.build.directory}</outputDirectory> </configuration> </execution> </executions> </plugin> </plugins> </build> </project> Copy Install individual components This section explains how to configure Maven to download individual components of the Java agent, specifically the newrelic.jar and the newrelic-api.jar. Configure your pom.xml to download either newrelic.jar or newrelic-api.jar. Here's an example for downloading newrelic.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>provided</scope> </dependency> Copy Here's an example for downloading newrelic-api.jar: <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>JAVA_AGENT_VERSION</version> <scope>compile</scope> </dependency> Copy Replace JAVA_AGENT_VERSION with the latest Java agent version. Locate the newrelic.yml file you received when creating your New Relic account, or download one for the version of the agent that you are using. Individual components example Here is an example pom.xml for working with the individual components (Java agent and API jars). <project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"> <modelVersion>4.0.0</modelVersion> <groupId>com.example.application</groupId> <artifactId>my-example-app</artifactId> <packaging>war</packaging> <version>1.0</version> <name>My Example Application</name> <url>http://example.com</url> <dependencies> <!-- The newrelic.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-agent</artifactId> <version>3.47.1</version> <scope>provided</scope> </dependency> <!-- The newrelic-api.jar dependency. --> <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-api</artifactId> <version>3.47.1</version> <scope>compile</scope> </dependency> </project> Copy Place newrelic.yml in the same folder as newrelic.jar, unless you specify otherwise in the JVM arg -Dnewrelic.config.file. Configure the newrelic.yml file (or JVM system properties) with your license_key and app_name. Pass -javaagent:/path/to/newrelic.jar to the JVM running your application server. Optional: If using the New Relic Java agent API, make the API jar available at compile time by adding it to your application class path. Generate some traffic for your app, then wait a few minutes for data to appear in the APM Summary page. If nothing appears, follow the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.16957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Java</em> <em>agent</em> using Maven",
        "sections": "Install <em>Java</em> <em>agent</em> using Maven",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document explains how to install the <em>Java</em> <em>agent</em> using Maven. For information on manually installing the <em>Java</em> <em>agent</em>, see Install the <em>Java</em> <em>agent</em> and <em>Java</em> <em>agent</em> configuration: Config file. Install <em>agent</em> package using Maven Install the New Relic <em>Java</em> <em>agent</em>, using either of these options: Install"
      },
      "id": "617e5b37e7b9d2906ec04c62"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Supported Java versions",
        "Requirements and Usage Instructions",
        "Important",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource-intensive code paths with flame graphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "d556f73f870034cfe054ca826fcdbbc289b1934b",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-12-05T03:49:24Z",
      "updated_at": "2021-11-26T09:33:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The JFR daemon is an exporter for JFR events which allows you to harness the power of the New Relic One platform for visualizing your JVM's behavior. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. There are three different usage scenarios for the JFR daemon: New Relic Java agent JFR service (RECOMMENDED) - JFR monitoring built into the flagship New Relic Java agent. No additional setup is needed, simply install the Java agent, make sure that the JFR service is enabled, and JFR data will flow into the same APM application as the Java agent. Requires New Relic Java agent version 7.0.0+. Standalone process - Run the jfr-daemon as a standalone process and configure it to monitor an existing Java process using remote JMX. Standalone Java agent - Attach the jfr-daemon to your Java process as a Java agent. A lightweight alternative to the New Relic Java agent. Supported Java versions While the JFR daemon supports any version of Java 11 and above, we don't recommend using any non-LTS version of Java in production environments. Some vendors have backported JFR to their Java 8 binaries. For instance, OpenJDK backported JFR on version 8u262. The JFR daemon is compatible with those Java versions. Requirements and Usage Instructions Requirements and instructions vary for each usage scenario. For full details please see the links for your specific usage scenario: New Relic Java agent JFR service - Requirements, configuration, and usage instructions Standalone process - Requirements, configuration, and usage instructions Standalone Java agent - Requirements, configuration, and usage instructions Important Apps running with the JFR daemon should expect the JFR subsystem to use additional memory. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource-intensive code paths with flame graphs Important The flame graph feature is only compatible with the New Relic Java agent JFR service usage scenario. A \"flame graph\" is a way of visualizing the call tree. Each block in the graph represents a function. The more CPU time and memory resources a method consumes, the wider that block is. Use flame graphs to identify the Java classes and methods that are most frequently executed in your application code. By using flame graphs to optimize the hot spots in your code, you can reduce resource consumption and increase your application’s overall performance. Here are some details about the flame graph colors: Light color: methods from a Java SE package. Dark color: methods from other libraries. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flame graphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.81122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "617e616728ccbc33fd7fed4d"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.62842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s <em>Java</em> <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/agent-data/agent-attributes": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "47ea348bf8d620acfae2fbf48452147553d329ba",
      "image": "https://docs.newrelic.com/static/bfccf48174daa734a2359d7c15354222/c1b63/RTS-small.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-12-05T05:33:11Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "617e63f228ccbc68a6800a0a"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "df68b7e1064ffd08c3471f8543e71465ecf843f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-12-05T06:17:41Z",
      "updated_at": "2021-10-23T19:42:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the below APM agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "617e715f196a673207f7da50"
    },
    {
      "sections": [
        "Link your applications to Kubernetes"
      ],
      "title": "Link your applications to Kubernetes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "f38fa2f86a7bace81dbe42d5a77c42c4d2b28282",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes/",
      "published_at": "2021-12-05T06:43:52Z",
      "updated_at": "2021-10-23T19:42:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Agents can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on agent compatibility and installation instructions, see our Kubernetes documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>Agents</em> can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on <em>agent</em> compatibility and installation instructions, see our Kubernetes documentation."
      },
      "id": "617e522028ccbc69cb80111e"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/agent-data/collect-custom-metrics": [
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "account switcher",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation delay",
        "aggregation function",
        "aggregation method",
        "aggregation timer",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "child account",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "parent account",
        "permalink",
        "pinger",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/44172b3e07c1f24191825360676b9d99/c1b63/account-dropdown.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-12-05T06:29:41Z",
      "updated_at": "2021-12-05T06:29:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown In the upper right of the New Relic UI, the account dropdown gives you access to your account settings. If you're trying to switch between accounts, use the account switcher. account switcher If you have access to more than one account in a multi-account organization, you can use the account switcher to switch between accounts. This is located in the top right of most New Relic UI pages. For more on factors that affect access to accounts, see Factors affecting access. To find account settings, use the account dropdown. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic Instant Observability Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation delay The length of time in seconds to wait for the aggregation window to fill with data. Required when using CADENCE or EVENT_FLOW aggreation_method types. aggregation function You can use NRQL query functions, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation method New Relic aggregates data into windows, and needs to determine when the current window ends and the next one begins. The aggregation_method is the logic that tells us when we have all the data for a given aggregation window. Once the window is closed, the data is aggregated into a single point and evaluated against the threshold. This field is optional. One of the following three values can be specified: EVENT_FLOW: (Default) Each aggregation window will wait until it starts to see timestamps arrive that are past its own delay setting. Once this occurs, the data is published. Relies on the timestamps of arriving data, so wall-clock time is no longer relevant. Works best for sources that come in frequently and with low event spread (high througput metrics) CADENCE: Classic New Relic logic where each evaluation window waits exactly as long as the aggregation_delay setting, using the wall-clock time as a timer. aggregation_delay is required when using this option. Data arriving too late will be dropped, which can cause false alerts. EVENT_TIMER: Each aggregation window has a timer on it, set to the aggregation_timer setting. The Timer starts running as soon as the first data point appears for that aggregation window (based on the data point’s timestamp). The aggregation_timer is reset for each new data point that arrives for that window. Once the aggregation_timer reaches 0, the aggregation window is published. Ideal for sparse and batched data, such as cloud integrations and infrequent error logs. aggregation timer The length of time in seconds to wait after each data point received, to ensure the entire batch is processed. Required when using EVENT_TIMER aggregation_method type. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. child account See parent account. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing model. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, the browser monitoring agent, the mobile monitoring agents, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integration quickstarts in New Relic I/O. Flex New Relic Flex is an application-agnostic, all-in-one infrastructure integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure monitoring By connecting changes in host performance to changes in your configuration, infrastructure monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, as well as the ability to query and chart your New Relic data. These features are now a fundamental part of the New Relic One platform and are no longer governed by the Insights product or name. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some places. For example: Some APM agents still have Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For New Relic organizations on our original pricing model, Insights Pro is still the product name governing custom event data ingest and retention. There is an API key called the Insights insert key. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). All our integrations can be found as quickstarts in New Relic Instant Observability. interaction In our mobile monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. You can see much of the data included in an interaction in the BrowserInteraction event. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account See parent account. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, mobile monitoring, and browser monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile monitoring Mobile monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing model, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. parent account New Relic organizations can have a parent/child account structure. This structure was much more important for organizations on our original user model, but is still used for some features for organizations on the New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as \"master accounts\", and child accounts were previously referred to as \"sub-accounts\". permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.86224,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>custom</em> <em>metric</em>",
        "body": " of the agent. Here are some agent API docs: <em>APM</em> agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API <em>Browser</em> agent: <em>Browser</em> agent API <em>Mobile</em> agents: iOS SDK API Android SDK API aggregated <em>metrics</em> Aggregated <em>metric</em> data summarizes"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    },
    {
      "sections": [
        "Introduction to New Relic for Python",
        "Monitor app performance",
        "Install the Python agent",
        "Monitor non-web scripts, background tasks, and functions",
        "What's next after installation?",
        "Troubleshooting",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Python",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "e3621b5589469c2b3b20d5d140027e5c105e1dd3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/python-agent/getting-started/introduction-new-relic-python/",
      "published_at": "2021-12-05T09:30:38Z",
      "updated_at": "2021-12-05T09:30:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Python agent monitors your Python application to help you identify and solve performance issues. You can also extend your performance monitoring to collect and analyze business data to help you improve the customer experience and make data-driven business decisions. With flexible options for custom instrumentation and APIs, The Python agent offers multiple building blocks to customize the data you need from your app. Our Python works with a wide variety of web frameworks and hosting mechanisms, including Django, Gunicorn, WSGI, CherryPy, uWSGI, and more. You can also install the Python agent in a Google App Engine flexible environment. Monitor app performance After you install the Python agent, it begins to collect data about your app. You can view the data as charts and tables in New Relic One. View the big picture of your app. Monitor your app's Apdex (user satisfaction). Get a high-level summary of your app with Summary page. Enable distributed tracing to see activity across an architecture having many services. Install Infrastructure monitoring and view detailed server/host data for your app. Find errors and problems quickly. Track key transactions specific to your business. Create custom dashboards for important metrics. Alert your team when an error or problem occurs before it affects your users. View performance after a deployment. Drill down into performance details. Examine code-level transaction traces. Examine database query traces. Examine error traces. Use thread profiler sessions to see detailed stack traces of sampled threads View logs for your APM and infrastructure data Bring your logs and application's data together to make troubleshooting easier and faster. No need to switch to another UI page in New Relic One. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. Extend agent instrumentation Other helpful tools include: Tools Description Browser monitoring Integrate the Python agent with browser monitoring to gain visibility into end-user browser activity. Simple scripts and background tasks Monitor job-based or task queuing systems, like Celery, or other standalone non-web functions. Business data analysis with data exploration. Use the Python agent with our data explorer to organize, query, and visualize your data to answer key questions about application performance and customer experience. Use default transaction attributes, or add your own. Query your data using the New Relic Query Language (NRQL). Send your own event data. Create and share customizable, interactive dashboards. Install the Python agent Before you install the Python agent, make sure your system meets the system requirements. You must also create a New Relic account. We support a number of web frameworks and libraries right out of the box, including Django, WSGI, and Gunicorn. If you use one of the supported web frameworks, installation is easy. If you use an unsupported framework, the process will involve some additions to your app code and/or web server files. For a quick and simple install process that will work for the majority of setups, follow these simple steps: Download and install the Python package. Create config file. Integrate the Python agent with your application. Read the Quick Start guide Add Python data Monitor non-web scripts, background tasks, and functions The Python agent also lets you monitor non-web scripts, worker processes, tasks, and functions. The installation process for these non-web transactions is similar to the one used for a web app, with one major difference: instead of going through the standard integration process described in the install instructions, you would manually \"wrap\" any function you want to monitor. For more information, see Non-web tasks and processes. For instructions on monitoring Celery tasks, see Celery background tasks. What's next after installation? Once you get the agent up and running, some suggested next steps are: Explore your data in and get comfortable with the user interface. Read our docs on our other observability solutions and the APM page. Change your application's name, or other configuration options. Learn about setting up custom instrumentation for application activity not monitored by default. Consider the Python Telemetry SDK. Troubleshooting After you complete the install process, your data should appear in the APM UI within five minutes. If it does not, use these troubleshooting resources: If no data appears, follow these troubleshooting steps. If you experience issues when installing or running the Python agent on a new host, test that the package is installed correctly and that it can contact New Relic's data collector service. For other problems, see the full list of troubleshooting documentation. Check the source code The Python agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.25961,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " business. Create <em>custom</em> dashboards for important <em>metrics</em>. Alert your team when an error or problem occurs before it affects your users. View performance after a deployment. Drill down into performance details. Examine code-level transaction traces. Examine database query traces. Examine error traces. Use"
      },
      "id": "61749d4d196a6727702f1368"
    },
    {
      "sections": [
        "New Relic data types",
        "Get started",
        "Tip",
        "Metrics",
        "Metrics in the monitoring industry",
        "Metrics at New Relic",
        "Dimensional metrics (used by Metric API and many integrations)",
        "Metric timeslice data (used by APM, browser, mobile)",
        "Metric timeslice examples",
        "Metrics attached to events (used by Infrastructure, other products)",
        "Metrics as a computation of events (used in some charts and queries)",
        "Event data",
        "Events in the monitoring industry",
        "Events at New Relic",
        "Log data",
        "Logs in the monitoring industry",
        "Logs at New Relic",
        "Trace data",
        "Tracing in the monitoring industry",
        "Tracing at New Relic",
        "Query and send data",
        "Learn more"
      ],
      "title": "New Relic data types",
      "type": "docs",
      "tags": [
        "Ingest and manage data",
        "Understand data"
      ],
      "external_id": "8e4ab82bb58db47bc412f57231d4956c6068262b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/understand-data/new-relic-data-types/",
      "published_at": "2021-12-04T21:48:30Z",
      "updated_at": "2021-12-04T21:48:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic platform is built around the four fundamental telemetry data types we believe are necessary for complete and effective system monitoring: metrics, events, logs, and traces. After you sign up for a free New Relic account and install any of our monitoring services, you can start working with your data. Get started This doc will give you a fairly technical explanation of our core data types, their structure, and how they're used in our features. You can use most of our features without needing to understand the underlying data structure. But having a better understanding of this can help you get data into New Relic, understand the data you see in our UI, and query your data. For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types. Another good way to understand your data is to just start querying it. Tip Access your data easily on one.newrelic.com: Click the Browse data dropdown menu and select the data type (metrics, events, logs, and traces) you want to explore. Metrics First, we’ll explain the definition of metrics from a monitoring industry perspective, and then we’ll explain how New Relic handles metrics. For a list of the metrics we collect, see our documentation on metrics. Metrics in the monitoring industry In the software monitoring industry, a metric means a numeric measurement of an application or system. Metrics are typically reported on a regular schedule. Two major types of metrics are: Aggregated data. For example: a count of events over one minute’s time, or the rate of some event per minute. A numeric status at a moment in time. For example: a CPU temperature reading, or a “CPU% used” status. Metrics are relatively easy to report and store because a single record can represent a range of time. They can also be aggregated more and more over time. For example, per-minute data may be “rolled up” to per-hour aggregations after some amount of time, and eventually may be rolled up to a per-day aggregation. This approach is efficient for long-term data storage. Metrics are a strong solution for storing data long-term, and understanding trends over time. One potential downside is that it can be difficult to do detailed analysis of older data that has been aggregated over time; when high detail is required about specific important actions, event data can be used. Metrics at New Relic Conceptually, \"metrics\" is a broad, general category. There are various ways New Relic measures and reports metrics but, in practice, when using the New Relic UI, you usually won't have to understand how exactly this happens. In our documentation, we typically will just refer to \"metrics,\" regardless of how that data is reported, unless there's a reason you need to know more (like understanding how to query your data). Here are some of the ways metrics are reported and stored across the New Relic platform: Dimensional metrics (used by Metric API and many integrations) In the monitoring industry, \"dimensional\" metrics refer to metric data that has a variety of attributes (dimensions) attached, such as duration-related attributes (start time, end time), entity ID, region, host, etc. This amount of detail allows for in-depth analysis and querying. At New Relic, this metric data is attached to the Metric data type and is sent from several sources: Some open-source integrations, such as the Prometheus exporter. Our Telemetry SDKs Infrastructure services The Metric API (the underlying API used by the above tools) The events-to-metrics service To query this data and see its attributes (\"dimensions\"), you could use a NRQL query like: Select * from Metric Copy As time passes, these metrics are increasingly aggregated into larger time buckets. This is done to optimize your ability to query data over a long period of time. For more details about the metric data type, see our docs. To learn how this data is ingested and stored, see the Metric API documentation. For tips on querying, see Metric query examples. Metric timeslice data (used by APM, browser, mobile) New Relic's APM, browser, and mobile report and display metrics in a simple data format that we refer to as metric timeslice data. A metric timeslice consists of three parts: a metric name, the segment of time the metric represents (the \"timeslice\"), and a numeric value (the measurement). For example: an APM metric timeslice for time spent in a particular transaction is named WebTransaction/URI/foo, and might have a response time of 0.793 for a one-minute time slice from 10:20am to 10:21am. These metrics usually follow a pattern like <category>/<class>/<method>. Our agents (APM, browser, and mobile) can collect thousands of metric timeslices per minute for a variety of performance metrics. For example: error rate, bandwidth usage, and garbage collection time. You also have the ability to create custom metrics. Metric timeslice data is a lightweight data type and lacks the detail that dimensional metrics have. Ways to explore and query metric timeslice data: For APM: metric timeslice data is converted to dimensional metrics and can be queried via NRQL Use the REST API If you want to learn more about the structure of metric timeslice data and see some examples, expand the collapser below. Metric timeslice examples Here are some common metric timeslice data examples, with a focus on common ones used by Ruby applications. ActiveMerchant New Relic tracks a variety of metrics on ActiveMerchant transactions which can be used for business analytics as well as performance monitoring. The metrics are summarized by operation as well as by gateway. regex sample metric legend name ActiveMerchant/. * ActiveMerchant/PayJunctionGateway ActiveMerchant/gateway/. * ActiveMerchant/gateway/PayJunctionGateway/purchase PayJunctionGateway ActiveMerchant/operation/. * ActiveMerchant/operation/purchase purchase For more information, see the ActiveMerchant website. ActiveRecord ActiveRecord is the Object-Relational Mapping API used by Ruby on Rails applications. The metrics shown here measure the performance of ActiveRecord's find and save methods. regex sample metric legend name ActiveRecord/. * /find ActiveRecord/User/find User#find ActiveRecord/. * /save ActiveRecord/Product/save Product#save For more information, see the API documentation for ActiveRecord. Apdex Apdex is a measure of user satisfaction with page load times. Controller In Ruby on Rails applications, HTTP requests are handled by Controller actions. A Rails application has many controllers, each of which has one or more actions. When your rails application receives an http request, that request is routed to the appropriate controller and action, based on the URL of that request. That action then does whatever processing is neccesary to generate an http response, which is most often a web page, but could also be a page fragment, an xml document, or any other kind of data that is requested by the client. The following metrics track the performance of controller actions, regardless of routing, and without taking into account any network or web server effects. regex sample metric legend name Controller/. * Controller/Users/show /Users/show Controller/. * /(?! \\ (other \\ )). * Controller/Users/show /Users/show Controller$ Controller All Controller Actions ControllerCPU/ ControllerCPU/Users/Show /Users/show For more information, see the API documentation for ActionController. Errors This metric tracks the number of errors or exceptions raised while processing requests. regex sample metric legend name Errors/all Errors/all External services External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud and any other network calls. It does not include other first class back-end components such as MemCache and the database. In Ruby applications we instrument the Net::Http library to capture all HTTP services. regex sample metric legend name External/ [ ^/]+/all$ External/service.example.com/all All service.example.com calls External/ External/host.aws.com/Net::Http : :POST Net::Http : :POST [ host.aws.com] External/all$ External/all External Services External/ [ ^/]+/(?!all)/ External/service.example.com/all All service.example.com calls HTTP dispatcher This metric represents a summary of the throughput and response time of all web requests. regex sample metric legend name ^HttpDispatcher$ HttpDispatcher HttpDispatcher MemCache MemCache is a popular technology that enables applications to access shared memory provided by any number of physical machines as a global cache. Applications that heavily use the database often use MemCache for performance and scalability benefits. These metrics measure the frequency and response time of calls to MemCache to read and write data from the cache. Response times should be low (less than 5 ms) for a well performing MemCache deployment. regex sample metric legend name MemCache/. * MemCache/read MemCache read operations MemCache/read MemCache/read MemCache read operations MemCache/write MemCache/write MemCache write operations Mongrel This metric measures the length of the mongrel queue, which holds pending http requests to be processed by mongrel. The HTTP Activity graph overlays the maximimum queue length for a given period. The value is zero if mongrel is processing a request but has no other requests waiting in its queue. When looking at this value across an aggregate cluster of mongrels, the queue lengths of all mongrels is added together, showing the sum of all queue lengths. A mongrel queue length should be at or near zero; if it is consistently at a higher level, then it indicates that your rails application is having trouble keeping up with its load requirements. regex sample metric legend name Mongrel/Queue Length Mongrel/Queue Length Queue Length View ActionView is a package in Rails that is used to render the output that is the response to an http request, such as an html page or an xml document. The View is rendered by the controller that is handling the request. If View metrics represent a large portion of your controller's response time, it could mean you are doing a lot of database operations inside the view template itself. regex sample metric legend name View/. * View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Partial View/Users/ _ child.html.erb/Partial Users/ _ child.html.erb View/. * /Rendering View/Users/show.html.erb/Rendering Users/show.html.erb For more information, see the API documentation for ActionView. Metrics attached to events (used by Infrastructure, other products) Because event-type data can have any type of key-value pair data attached to it, one way metrics can be reported is as attributes attached to an event. A couple examples of this at New Relic: Our infrastructure monitoring reports many metrics that are attached to events. For example, we report a ProcessSample event, which has various sample-based metrics attached to it, like CPU percentage. To learn more about infrastructure monitoring data, see Infrastructure data. In APM, the Transaction event has several metrics attached to it, including databaseDuration. To learn more about this data and how to query it, see Events. Metrics as a computation of events (used in some charts and queries) Metrics can be formed by counting New Relic events, or doing some other mathematical calculation on those events. For example, if you wanted to measure the total number of Transaction events over the last half hour, you might run this NRQL query: Select count(*) from Transaction since 30 minutes ago Copy Another example: if you wanted to compute the average response time for your service, you might run a query like: FROM Transaction SELECT average(duration) SINCE 30 minutes ago Copy Some New Relic charts are generated with these kinds of queries. The downside of this approach is that there are limits on how many events a monitoring system (including ours) can report. This means that sometimes, for high-throughput systems, the count may not accurately represent the total activity on that system. To learn more about how this can be addressed, see Event limits and sampling. Want to report custom metrics? See Get data into New Relic. Event data First, we’ll explain the definition of events from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles event data. Events in the monitoring industry In the software industry, events can be thought of as simply “things that occur in a system.” For example, a server setting being changed would be an event. Another example: a website user clicking a mouse. Some events will generate a stored record, and that record is typically also called an event. Event data represents discrete occurrences and typically will have a high level of detail, so event data is suited for detailed analysis and querying. The downside to the use of event data is that there are typically so many events reported that it can become difficult to query that large dataset over longer time ranges. Events at New Relic At New Relic, we report events to data objects also called events. These events have multiple attributes (key-value pairs) attached. Event data is used in some UI charts and tables, and you can also query it. How long event data remains available is determined by data retention rules. One example of an event: APM reports an event type named Transaction, which represents a logical unit of work in an application. To see the attributes attached to this event, you could use a NRQL query like: Select * from Transaction Copy For examples of querying event data, see Introduction to NRQL. Other details about New Relic event data: Events can have any type of attributes attached. Some events have attributes that report metric data. You can report custom events. To increase the availability of your event data for querying/charting, you can turn events into metrics. Some systems generate a large number of events that exceeds collection limits and results in incomplete query results. For more on this, see Event sampling. Because event is a general term, in some New Relic contexts it will refer to any data type that can be queried via NRQL. For example, when you run a NRQL query, it returns a count of inspected events: this is a count of all data types queried. Log data First, we’ll explain the definition of logs from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles log reporting. Logs in the monitoring industry A log is a message about a system used to understand the activity of the system and to diagnose problems. Logs at New Relic New Relic's Logs gives you a centralized log management platform that connects your log data with other New Relic-monitored data. For example, you can see logs alongside your APM data. In New Relic, log data is reported with multiple attributes (key-value data) attached. To query your log data, you could use a NRQL query like: Select * from Log Copy To report custom log data, see the Log API. Trace data First, we’ll explain the definition of traces from a monitoring industry perspective, and then we’ll explain some specifics about how New Relic handles tracing. Tracing in the monitoring industry In the application/infrastructure-monitoring world, tracing is a general term used to refer to various ways to report information about how a program or system is operating. For example, a stack trace provides in-depth information about a program’s subroutines. For large modern systems, which are often distributed across many services and micro-services, “tracing” often refers to distributed tracing, which is a way to monitor requests as they propagate through a complex, distributed environment. Tracing at New Relic New Relic offers a distributed tracing feature that tracks requests across a distributed system, and provides a dedicated UI for understanding and analyzing your traces. In New Relic, trace data is reported as Span objects, with multiple attributes (key-value pairs) attached. To query your tracing data, you could use a NRQL query like: Select * from Span Copy To learn more about how distributed tracing works, see Understand distributed tracing. To report custom distributed tracing data, see the Trace API. Query and send data Understanding New Relic data types can help you: Query data in New Relic Send data to New Relic Learn more For a simpler explanation of these data types using real-world examples, see Introduction to essential telemetry data types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.94986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Metric</em> timeslice data (used by <em>APM</em>, <em>browser</em>, <em>mobile</em>)",
        "body": ", and might have a response time of 0.793 for a one-minute time slice from 10:20am to 10:21am. These <em>metrics</em> usually follow a pattern like &lt;category&gt;&#x2F;&lt;class&gt;&#x2F;&lt;method&gt;. Our agents (<em>APM</em>, <em>browser</em>, and <em>mobile</em>) can <em>collect</em> thousands of <em>metric</em> timeslices per minute for a variety of performance <em>metrics</em>"
      },
      "id": "6045280de7b9d266e1579a0f"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/agent-data/custom-instrumentation": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "47ea348bf8d620acfae2fbf48452147553d329ba",
      "image": "https://docs.newrelic.com/static/bfccf48174daa734a2359d7c15354222/c1b63/RTS-small.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-12-05T05:33:11Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "617e63f228ccbc68a6800a0a"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "df68b7e1064ffd08c3471f8543e71465ecf843f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-12-05T06:17:41Z",
      "updated_at": "2021-10-23T19:42:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the below APM agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "617e715f196a673207f7da50"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "4cf9b83341980cee4119604839fb31d65ab9e2ba",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-12-05T03:46:15Z",
      "updated_at": "2021-10-23T19:42:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "617e51dde7b9d29437c0575c"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "47ea348bf8d620acfae2fbf48452147553d329ba",
      "image": "https://docs.newrelic.com/static/bfccf48174daa734a2359d7c15354222/c1b63/RTS-small.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-12-05T05:33:11Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "617e63f228ccbc68a6800a0a"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "df68b7e1064ffd08c3471f8543e71465ecf843f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-12-05T06:17:41Z",
      "updated_at": "2021-10-23T19:42:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the below APM agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "617e715f196a673207f7da50"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "4cf9b83341980cee4119604839fb31d65ab9e2ba",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-12-05T03:46:15Z",
      "updated_at": "2021-10-23T19:42:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "617e51dde7b9d29437c0575c"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "47ea348bf8d620acfae2fbf48452147553d329ba",
      "image": "https://docs.newrelic.com/static/bfccf48174daa734a2359d7c15354222/c1b63/RTS-small.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-12-05T05:33:11Z",
      "updated_at": "2021-10-23T19:43:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the data explorer to start building a chart. Select the advanced (NRQL) mode to refine your query. In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0 or higher Go"
      },
      "id": "617e63f228ccbc68a6800a0a"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "4cf9b83341980cee4119604839fb31d65ab9e2ba",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-12-05T03:46:15Z",
      "updated_at": "2021-10-23T19:42:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "617e51dde7b9d29437c0575c"
    },
    {
      "sections": [
        "Link your applications to Kubernetes"
      ],
      "title": "Link your applications to Kubernetes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "f38fa2f86a7bace81dbe42d5a77c42c4d2b28282",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes/",
      "published_at": "2021-12-05T06:43:52Z",
      "updated_at": "2021-10-23T19:42:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Agents can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on agent compatibility and installation instructions, see our Kubernetes documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>Agents</em> can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on <em>agent</em> compatibility and installation instructions, see our Kubernetes documentation."
      },
      "id": "617e522028ccbc69cb80111e"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/agent-data/real-time-streaming": [
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "df68b7e1064ffd08c3471f8543e71465ecf843f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-12-05T06:17:41Z",
      "updated_at": "2021-10-23T19:42:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the below APM agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "617e715f196a673207f7da50"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "4cf9b83341980cee4119604839fb31d65ab9e2ba",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-12-05T03:46:15Z",
      "updated_at": "2021-10-23T19:42:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in APM and dashboards. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "617e51dde7b9d29437c0575c"
    },
    {
      "sections": [
        "Link your applications to Kubernetes"
      ],
      "title": "Link your applications to Kubernetes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "f38fa2f86a7bace81dbe42d5a77c42c4d2b28282",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes/",
      "published_at": "2021-12-05T06:43:52Z",
      "updated_at": "2021-10-23T19:42:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Agents can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on agent compatibility and installation instructions, see our Kubernetes documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.57693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>Agents</em> can be configured to collect Kubernetes-related environment variables and add them to Transaction events to provide context between your Kubernetes cluster and your services. For details on the benefits see this blog post. For more information on <em>agent</em> compatibility and installation instructions, see our Kubernetes documentation."
      },
      "id": "617e522028ccbc69cb80111e"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/app-naming/name-your-application": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.69739,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use multiple <em>names</em> for an <em>app</em>",
        "sections": "<em>Name</em> <em>app</em> instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same <em>app</em> <em>name</em>, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored <em>app</em>. You can also view data for the individual hosts and instances from the <em>app</em>&#x27;s New Relic <em>APM</em> Overview page. To segment your <em>app</em> in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "image": "https://docs.newrelic.com/static/e8d42feaa627a4f1abd362c85a07596d/c1b63/example-doc-in-folder.png",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/understand-edit-docs-site-structure/",
      "sections": [
        "Understand and edit docs site structure (nav file, sidebar, categories)",
        "Terms",
        "Understand how the docs site structure works",
        "How is the displayed structure related to the actual folders?",
        "What determines a doc's URL?",
        "What does a nav file do?",
        "Where is the docs site structure exposed?",
        "What determines a doc's sidebar?",
        "When you click a sidebar category, what determines how that auto-index page displays?",
        "Nav file format",
        "Tip",
        "Procedures",
        "Overview of steps for a large docs site restructure project",
        "Add a new category",
        "Add a new nav file",
        "Add a new category to a nav file",
        "Add a doc to sidebar/nav-file",
        "Add doc in multiple sidebar locations",
        "Move docs to other categories",
        "Move docs using nav file",
        "Move docs between folders",
        "Move or delete a folder",
        "Create a \"dummy\" sub-category of docs that don't live in that category",
        "Make a sidebar category heading clickable",
        "Troubleshoot category views not working correctly"
      ],
      "published_at": "2021-12-05T03:59:53Z",
      "title": "Understand and edit docs site structure (nav file, sidebar, categories)",
      "updated_at": "2021-11-14T10:59:23Z",
      "type": "docs",
      "external_id": "5498c89c5d5497ac899f70f86bb8bf0cda4bc840",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains information and procedures pertaining to the structure of the docs site, including: the nav files, the sidebar, docs category (index) views, and more. For succinct instructions, see Procedures, but it is highly recommended you understand the general concepts of how the docs site structure works if you will be doing larger docs site projects. Terms When talking about the docs site structure, sometimes people use different words for the same things. Below is a list of terms that can help us communicate about the docs site structure: Nav files: In the github docs site, there are yaml files under the nav folder that are used to determine the docs site structure that we display. This structure is exposed in the docs site left sidebar and when you view docs category views (also known as index views, like this one). Folder: In this context, \"folders\" refers to the actual docs site folder structure (those folders and files in the content section). Referring to \"folders\" can be a helpful way to differentiate between the actual folder structure and the displayed structure that's set using the nav files. Sidebar: On public-facing docs, the sidebar is what is visible on the left hand side, showing the structure of that category of docs. The sidebar and index view are both determined by the structure set in the nav file. Category or sub-category: we use these words a bit interchangeably to refer to specific areas of the docs site. For example, this view shows a list of docs in a specific category, as does this higher level category view. In this doc, we'll often use the phrase \"category view\" to indicate a page load of a specific category of docs. Auto-index pages: This is another way, the more technical way, to refer to a category view of docs (for example, this view). \"Auto-index page\" and \"category view\" are used a bit interchangably in this doc, with \"category view\" being used as it's more informal and easy to parse. (Note that this use of \"index\" is a different use of \"index\" than the authored index.mdx files, which are used to display landing pages.) Understand how the docs site structure works This section will explain some of the logic behind how the docs site structure is determined and how the structure we display to the public relates to the actual docs folder structure. How is the displayed structure related to the actual folders? The actual docs folder structure (the folders and mdx files in the content folder) is entirely separate from the docs site structure in the sidebar. The displayed structure of the docs site is determined solely by the nav files (the yaml-format files in the nav folder). It's important to understand the above point. The divergence of the docs folder structure and the displayed docs site structure is necessary: we need a way to control the displayed site structure, which is used for the sidebar and auto-index pages, without requiring us to keep the folder structure and folder names and doc file names completely parallel and matching. Because these two things are so separate, it means we have some fairly complex behind-the-scenes logic to get them to work together. And this means that there can be fairly unintuitive aspects of how that logic works. We do have procedures for common use cases, but it will help you a lot to understand the specifics below of how the displayed structure is generated. What determines a doc's URL? Where a doc file (mdx file) is located in the content folder, and the associated folder and file names, are the only factors that govern that doc's URL. For example, consider the following doc file automated-user-provisioning-single-sign.mdx: This doc's URL is solely based on its folder location and the names of the folders. In this case, its URL is: docs.newrelic.com/docs/accounts/accounts/automated-user-management/automated-user-provisioning-single-sign Copy This has important implications, including: When you move a doc from one folder to another, its URL changes, and this means that you will have to add a redirect to that doc of its original URL. If you rename an mdx file name or a folder name, that changes its URL, so that means you would have to add a redirect to that doc for its original URL. What does a nav file do? The nav files are quite simple. A nav file controls these things: The docs structure (the various levels of docs) for that category of docs. The category headers, set by title (for example, On-host integrations list) and path (for example, /docs/integrations/on-host-integrations). The doc information, set by title (for example, NGINX integration) and path (the doc's URL). A category and a doc in a nav file have the same elements: a title and a `path. What separates a category from a doc is that: A category contains docs in the level below it. If a category has a path (which isn't required but should be present for most docs), the path points to a content docs folder that has at least one doc in it. For more on nav file format, see Nav file format Where is the docs site structure exposed? The structure set in the nav files is exposed in two places: The left sidebar of a doc that shows the structure of that category. When a category header in the sidebar is clicked, it shows a view of that docs site category. Doc category views, also sometimes called auto-index pages: for example, this view, which shows a particular section of docs. What determines a doc's sidebar? As stated above, the sidebar is just one way that the docs site structure governed by the nav files is exposed. When a doc is loaded, the docs site searches for that URL in the nav files. If it finds a match, it displays that nav file in the sidebar with that doc highlighted. If it finds that doc in more than one nav file, it attempts to find the right nav file by choosing the nav that matches the top level category in the doc URL. For example, if a doc with a relative URL /docs/accounts/accounts-billing/account-setup/create-your-new-relic-account was in two nav files, the docs site code would search to see if one of the nav files has docs/accounts as its first path field. If it finds a match, it uses that nav file. For an example of a doc that is placed in two different nav files, for this auto-index page click the Manage data doc and see how, when it loads, it displays the sidebar for the nav file that better matches its URL. When you click a sidebar category, what determines how that auto-index page displays? When you click on a docs category header in the sidebar and an auto-index page loads (like this one), what governs what is displayed there? Here is how this process works: A category header in the sidebar has an associated URL, which is set in the nav file. In the example nav file snippet below, the Get started category view has a path set to /docs/apis/intro-apis. This is what governs the sidebar heading title of \"Get started\" and tells it the URL to use. - title: APIs path: /docs/apis pages: - title: Get started path: /docs/apis/intro-apis pages: - title: New Relic APIs path: /docs/apis/intro-apis/introduction-new-relic-apis - title: API keys path: /docs/apis/intro-apis/new-relic-api-keys Copy If the associated folder of that path has an index mdx file (representing a landing page, like this one), the docs site displays that landing page. If there is no landing page, we display the docs and structure contained in that section of the nav file. For example, this view is based on the nav file section under that category header. For this to work correctly, the docs site verifies that that path matches an actual docs site folder that has at least one mdx file. Put another way: if we used a completely arbitrary URL path for a category's path, like docs/random-category/random-category-2, it would not work. To display a nav file, the path requires an existing folder with at least one doc in there. Other aspects to consider: A path is not required. A category header in the nav file does not require a path; that is just what tells it to create a link and a URL for that view. If a category in a nav file lacks a path, it won't have a link or associated URL for it (for an example, see the \"New Relic University\" category in this section). Having a category without an associated link/URL can be an acceptable choice if you are creating a category of docs that don't reside in that section and you simply want to give a helpful category view in the sidebar. Folder structure URLs aren't important. Every folder in the docs site can be the basis for a URL, but we should only consider valuable the URLs we've chosen for inclusion in the nav files. For example, here's a URL based on an actual folder containing one doc. But because there is no path in a nav file corresponding to that URL, it doesn't display anything. Nav file format Below is a snippet of the agents.yml nav file. Note that the file has indentation that corresponds to the level of the navigation hierarchy. When making changes or creating a new nav file, be sure to use the existing spacing format. yml title: Agents path: /docs/agents pages: - title: Manage APM agents path: /docs/agents/manage-apm-agents pages: - title: Agent data path: /docs/agents/manage-apm-agents/agent-data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Tip Navigation nesting is currently limited to a maximum of six levels deep. Please reach out to the engineering team if that is not enough. Here are important elements of the nav file: Key Required? Description title yes The text shown in the navigation, either of a doc or a category. path yes The URL path to the doc or the category view. Do not use trailing slashes. For docs categories in the nav file, the path is required to create an index view. Without the path, a docs category won't be clickable as a link and won't display a view of those docs. Learn more about index views. rootNav no rootNav controls whether a nav file will be displayed or hidden on the docs site home page. It is enabled by default. If you want to hide a category from the home page (as we do for our style guide docs, for example), you would set this to false, as shown below: title: Style guide path: /docs/style-guide Copy children no This is hardly ever used. It indicates a sub-navigation node. Procedures Below are instructions for several common procedures. It may help you to review the terms we use before starting a procedure. Procedures include: Add a new docs category Add a doc to sidebar/nav-file Move docs between folders or categories Move or delete folders Create a \"dummy\" category for docs that don’t live in that area Make a category heading clickable Troubleshoot messed up category views Overview of steps for a large docs site restructure project For some smaller docs site edits, you can sometimes simply edit the nav files and not have to touch the doc files or folders. But for larger projects, you may want to or need to edit and move the docs files and folders themselves. Below is a broad overview of the chunks of work such larger projects generally entail. Plan out what the new nav file structure will look like, and plan out the work of moving docs files or creating new folders. It can help to write down the chunks of work a large project will entail. Move the affected doc files to their new folder locations, making sure to add redirects. For more on that, see Move docs between folders. Delete any empty folders. Edit the nav files to reflect the new desired structure and point to the new doc URLs. If there are category header path URLs that are no longer needed, add those URLs as redirects to specific docs (preferred) or the taxonomy redirects file. For more specific and granular procedures, keep reading. Add a new category We'll explain two procedures: adding a subcategory of docs in an existing nav file, and adding an entirely new nav file. Add a new nav file Adding an entirely new nav file should be rare, and something we only do occasionally during large overhauls of site structure. To add an entirely new nav file: Copy an existing file nav file, or create a new nav file. Customize the new nav file with the categories and docs you want, using the structure of existing nav files as a template. For more on structure, see nav format. Tip You need at least one level of nesting inside the nav file. Without that, doc titles in the auto-generated category views will render as H2 headings. For example, src/content/level-one/level-two/doc will work, but src/content/level-one/doc will produce strange formatting. Add a new category to a nav file To add a new category to a nav file: In an existing nav file, add a new category, represented by its title and path. If you're adding a path for that category (recommended), it must use the URL of an existing folder with at least one mdx file in it. Add the docs you want in that section. Ensure your new content matches the indenting of the surrounding nav file. To learn more about how this works, see: How a doc's sidebar is determined How a doc category view is determined If a category view isn't clickable, see Make category view clickable. Add a doc to sidebar/nav-file Once you create a doc, you need to place it in one or more nav files. To do this: In the nav file location where you want to locate it, add the title (its short title displayed in the sidebar and category views) and the path, which is the doc's URL. Ensure that you've emulated the indenting based on the surrounding nav file content or other nav files. Add doc in multiple sidebar locations To add a doc in more than one sidebar location, simply add that doc (its title and path) wherever you want it to be in the nav file. For more on how the sidebar is determined for docs in multiple nav files, see Sidebar. You can add a doc URL in multiple nav file locations. Move docs to other categories Because the nav file and the actual folder structure aren't connected, there are two different ways to \"move docs\": Move a doc in the nav files: preferred and most common procedure. Move a doc between folders: less frequent, mainly when doing larger projects where we want to do a significant overhaul of the docs structure and want to ensure the folder structure doesn't become too divergent from the nav file structure. Move docs using nav file Move a doc in the nav file when you want to change where it's visible in the sidebar menus. To move a doc from one place to another in the nav file: In the first nav file, copy the two rows representing that doc's entry (the title and path lines) and paste that content into the place you want it to live in the new nav file. In the new nav file section, make sure that new content is aligned properly with the surrounding nav file content. See Nav format for more about nav file structure. Move docs between folders Note that moving docs between the folders should be relatively rare. The main reasons to do this are when the folder structure and nav file structure are becoming very different, which can be bad for a couple reasons: Too much divergence can create issues with category view displays or sidebar actions. Too much divergence can make finding and editing docs harder, so there can be value to keeping things fairly up to date and parallel. When you move a doc between folders or rename a doc, that changes its URL. Similarly, if you rename a folder, that changes the URL of all docs in that area. To move a doc between folders: Get the current URL of the doc you want to move and add that URL to its own list of redirects. Tips: One way to do this in VSCode is to right click the file and click \"Get relative path\". If you are moving many files, ask the team about ways to programmatically add redirects. Remove the trailing slash. Move the doc to the new folder. Update nav files with the new URL. This is easily overlooked but having the correct doc URL in the nav file, and not a redirect, is important. Note that a doc URL may be in more than one nav file so searching the site for that URL can help. Move or delete a folder Sometimes when we are doing a larger restructuring project, we may want to move or delete the actual folders instead of simply editing the nav files. If you are moving an entire folder or multiple folders to another folder, docs and all: Move the folder on your local disk to the new location (in Finder, for example). Next, because that move changes all the URLs of the docs and categories, you'll need to add redirects: For adding redirects for docs, see the procedures for moving a doc between folders. For category redirects: For the section of the nav file affected by your folder editing, gather all the category URLs (path fields) that relate to the moved or deleted folders. We don't need to redirect all folder-related URL paths: we only need to redirect the nav file paths because those represent the paths that we actually link to in the docs (in other words: we aren't using folder-based URLs if they don't have a nav file path). Add those category path URLs as redirects in specific docs or, if that won't work, in the taxonomy-redirects file. We should aim to add category redirects in specific docs and the reason for this is that the taxonomy-redirects file is hard to use and because it's a better customer experience to land on a doc versus a category if possible. In most cases, you'll be able to find a fitting doc to redirect to but if only a category view makes sense, use the taxonomy redirects file. For larger projects, this can be tough work, so you'll want to check out the build and make sure all the sidebar links and category headers are working as expected. For deleting folders, you'll want to essentially follow the same steps as above: either moving or deleting the docs in those folders first, gathering the affected category path URLs and adding them as redirects, adn then deleting the empty folders. Create a \"dummy\" sub-category of docs that don't live in that category Sometimes you want to create a category of docs that is there to help expose a related doc or set of docs. For example, in this view, we have added a category for 'New Relic University' even though that's not a doc that lives in that section; in this case, it's not even a doc on our site. In the example above, this 'New Relic University' category header is in regular text and not a link, and that's because it doesn't have a path set for it in the nav file. This also means that in the sidebar, this category header is not a clickable link and simply functions as a collapser/expander. This is acceptable if you don't mind it but below we explain how you can get a clickable category if you need it. To create a so-called \"dummy\" category: Add the category structure you want in the nav file. If you're okay not having a clickable category header, your new category doesn't require a path. If you want a clickable category header, you will need to use or create a folder that matches the new category path and that has at least one mdx file in it (details). In the nav file, add the title and path information for the docs you want in that new category. Test your new category to ensure it is working correctly. Make a sidebar category heading clickable If there's a sidebar category that's only acting as an expander/collapser and doesn't have a link, that's because it either a) doesn't have a path set in the nav file, or b) that path goes to a folder that doesn't have a doc in it. For more on this, see the instructions regarding clickable headers in the \"dummy\" category section. Troubleshoot category views not working correctly If a docs category view is not working correctly, review how category views are formed. If this does happen, get another opinion from another tech writer to make sure you're not missing something, as we should rarely have problems. One reason that a category view might not work is specifically for path URLs that are also landing pages. In this case, if that path is used in more than one location in the same nav file, the docs site can be confused about which category view to use. We may fix this with a coding fix but in meantime: consider pointing to other URLs and not that path, so that there's only one use of that path per nav file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;link-your-applications-kubernetes - title: <em>App</em> <em>naming</em> pages: - title: <em>Name</em> your application path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>app</em>-<em>naming</em>&#x2F;<em>name</em>-your-application - title: Use multiple names for an <em>app</em> path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>app</em>-<em>naming</em>&#x2F;use-multiple-names-<em>app</em> Copy"
      },
      "id": "612eff27e7b9d25b16b6f24c"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.6411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automatic <em>application</em> <em>naming</em>",
        "sections": "Automatic <em>application</em> <em>naming</em>",
        "tags": "<em>Agents</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s Java <em>agent</em> reports all transactions and other metrics in a single JVM to the application <em>name</em> specified in newrelic.yml under the setting <em>app_name</em> (for more information about application <em>naming</em>"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app": [
    {
      "sections": [
        "Name or change the name of your application",
        "Important",
        "Changing the name vs. the alias",
        "Give each app a descriptive name",
        "Assign the name in your config file",
        "Change the application's alias",
        "Tip",
        "Using multiple names for an app"
      ],
      "title": "Name or change the name of your application",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "0750a52decc0b0e42514f8964593479d92440b5e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/name-your-application/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-10-23T19:47:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic connects metrics to individual applications using your license key and the primary application name. You can change the app's name in your config file, or assign an alias to the app to change how it appears in the New Relic UI. Important If you do not specify the app name in your New Relic configuration file, most New Relic agents provide a generic application name by default. To ensure all aggregated data for the same app is reported accurately, make sure you give each app a descriptive name. Changing the name vs. the alias You can assign a new app name or change the app alias. These have two different effects: Term How to change it Effect Name Assign the name in your config file Changing the app name in the agent's configuration file will cause the application to report to a new heading in the New Relic user interface, with a total discontinuity of data. This is useful, for example, if you want to start over and report new data. If no other agents are reporting to the old app name, the old app name will appear gray and can be deleted. Alias Change the alias in the APM Settings UI Creating an alias for the app name only changes how the app name appears in the New Relic UI. Changing the alias does not affect how data is reported. It simply helps you keep track of your data with a useful alias. Give each app a descriptive name By default, most New Relic agents provide a default application name, such as My Application or PHP Application, for each app that is linked to your account. Important We recommend changing the default name of an app to a more descriptive name before deployment, and it can be up to 128 characters long. Each unique app name creates a new application record in your New Relic UI, which allows you to: Run an application on more than one host, and have all the data aggregated (collected) under the same name. Run multiple applications on a single host, and have all the data aggregated (collected) under different names. Assign the name in your config file To change the app name, set the app name value in the agent's configuration file. If you have deployed an app via one APM agent, and then deploy another app with the same name via a different APM agent, New Relic will automatically append the agent language name to the end of the second app's name. For example, if you deploy a Node.js app named New-App, and then deploy a .NET app named New-App, New Relic will automatically append the second app name as New-App (DOTNET). Agent Configuration file value C Identify a maximum of three names separated by a semicolon ;in your newrelic_app_config_t* config;. Go Set AppName to a maximum of three names separated by a semicolon. Java See the options for naming your Java application. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP See the options for naming your PHP application. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. Change the application's alias The application name you set in the New Relic user interface is a human-readable alias. If you rename your app, the visible name is updated everywhere in the New Relic UI, including in linked browser apps. Initially, this alias is the same as the app's identifier name in the New Relic agent configuration file. However, changing the UI alias does not affect the underlying app name used for data rollup, which is set in the agent config file. The application must be actively reporting data to change the alias. Changing the UI alias will cause all agents that report under the app identifier to restart themselves. To change the alias for your application's name in the New Relic user interface: Go to one.newrelic.com > APM > (select an app) > Settings > Application. In the Application alias field, type a new name (alias) for the selected app. Select Save application settings. Tip You can also change the app's alias with the New Relic REST API. Using multiple names for an app By giving your app multiple names, you can aggregate metrics for multiple agents across an entire app or service. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.06274,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "sections": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ", for example, if you want to start over and report new data. If no other <em>agents</em> are reporting to the old <em>app</em> <em>name</em>, the old <em>app</em> <em>name</em> will appear gray and can be deleted. Alias Change the alias in the <em>APM</em> Settings UI Creating an alias for the <em>app</em> <em>name</em> only changes how the <em>app</em> <em>name</em> appears in the New Relic"
      },
      "id": "617e6431196a678ff9f7c336"
    },
    {
      "image": "https://docs.newrelic.com/static/e8d42feaa627a4f1abd362c85a07596d/c1b63/example-doc-in-folder.png",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/understand-edit-docs-site-structure/",
      "sections": [
        "Understand and edit docs site structure (nav file, sidebar, categories)",
        "Terms",
        "Understand how the docs site structure works",
        "How is the displayed structure related to the actual folders?",
        "What determines a doc's URL?",
        "What does a nav file do?",
        "Where is the docs site structure exposed?",
        "What determines a doc's sidebar?",
        "When you click a sidebar category, what determines how that auto-index page displays?",
        "Nav file format",
        "Tip",
        "Procedures",
        "Overview of steps for a large docs site restructure project",
        "Add a new category",
        "Add a new nav file",
        "Add a new category to a nav file",
        "Add a doc to sidebar/nav-file",
        "Add doc in multiple sidebar locations",
        "Move docs to other categories",
        "Move docs using nav file",
        "Move docs between folders",
        "Move or delete a folder",
        "Create a \"dummy\" sub-category of docs that don't live in that category",
        "Make a sidebar category heading clickable",
        "Troubleshoot category views not working correctly"
      ],
      "published_at": "2021-12-05T03:59:53Z",
      "title": "Understand and edit docs site structure (nav file, sidebar, categories)",
      "updated_at": "2021-11-14T10:59:23Z",
      "type": "docs",
      "external_id": "5498c89c5d5497ac899f70f86bb8bf0cda4bc840",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc contains information and procedures pertaining to the structure of the docs site, including: the nav files, the sidebar, docs category (index) views, and more. For succinct instructions, see Procedures, but it is highly recommended you understand the general concepts of how the docs site structure works if you will be doing larger docs site projects. Terms When talking about the docs site structure, sometimes people use different words for the same things. Below is a list of terms that can help us communicate about the docs site structure: Nav files: In the github docs site, there are yaml files under the nav folder that are used to determine the docs site structure that we display. This structure is exposed in the docs site left sidebar and when you view docs category views (also known as index views, like this one). Folder: In this context, \"folders\" refers to the actual docs site folder structure (those folders and files in the content section). Referring to \"folders\" can be a helpful way to differentiate between the actual folder structure and the displayed structure that's set using the nav files. Sidebar: On public-facing docs, the sidebar is what is visible on the left hand side, showing the structure of that category of docs. The sidebar and index view are both determined by the structure set in the nav file. Category or sub-category: we use these words a bit interchangeably to refer to specific areas of the docs site. For example, this view shows a list of docs in a specific category, as does this higher level category view. In this doc, we'll often use the phrase \"category view\" to indicate a page load of a specific category of docs. Auto-index pages: This is another way, the more technical way, to refer to a category view of docs (for example, this view). \"Auto-index page\" and \"category view\" are used a bit interchangably in this doc, with \"category view\" being used as it's more informal and easy to parse. (Note that this use of \"index\" is a different use of \"index\" than the authored index.mdx files, which are used to display landing pages.) Understand how the docs site structure works This section will explain some of the logic behind how the docs site structure is determined and how the structure we display to the public relates to the actual docs folder structure. How is the displayed structure related to the actual folders? The actual docs folder structure (the folders and mdx files in the content folder) is entirely separate from the docs site structure in the sidebar. The displayed structure of the docs site is determined solely by the nav files (the yaml-format files in the nav folder). It's important to understand the above point. The divergence of the docs folder structure and the displayed docs site structure is necessary: we need a way to control the displayed site structure, which is used for the sidebar and auto-index pages, without requiring us to keep the folder structure and folder names and doc file names completely parallel and matching. Because these two things are so separate, it means we have some fairly complex behind-the-scenes logic to get them to work together. And this means that there can be fairly unintuitive aspects of how that logic works. We do have procedures for common use cases, but it will help you a lot to understand the specifics below of how the displayed structure is generated. What determines a doc's URL? Where a doc file (mdx file) is located in the content folder, and the associated folder and file names, are the only factors that govern that doc's URL. For example, consider the following doc file automated-user-provisioning-single-sign.mdx: This doc's URL is solely based on its folder location and the names of the folders. In this case, its URL is: docs.newrelic.com/docs/accounts/accounts/automated-user-management/automated-user-provisioning-single-sign Copy This has important implications, including: When you move a doc from one folder to another, its URL changes, and this means that you will have to add a redirect to that doc of its original URL. If you rename an mdx file name or a folder name, that changes its URL, so that means you would have to add a redirect to that doc for its original URL. What does a nav file do? The nav files are quite simple. A nav file controls these things: The docs structure (the various levels of docs) for that category of docs. The category headers, set by title (for example, On-host integrations list) and path (for example, /docs/integrations/on-host-integrations). The doc information, set by title (for example, NGINX integration) and path (the doc's URL). A category and a doc in a nav file have the same elements: a title and a `path. What separates a category from a doc is that: A category contains docs in the level below it. If a category has a path (which isn't required but should be present for most docs), the path points to a content docs folder that has at least one doc in it. For more on nav file format, see Nav file format Where is the docs site structure exposed? The structure set in the nav files is exposed in two places: The left sidebar of a doc that shows the structure of that category. When a category header in the sidebar is clicked, it shows a view of that docs site category. Doc category views, also sometimes called auto-index pages: for example, this view, which shows a particular section of docs. What determines a doc's sidebar? As stated above, the sidebar is just one way that the docs site structure governed by the nav files is exposed. When a doc is loaded, the docs site searches for that URL in the nav files. If it finds a match, it displays that nav file in the sidebar with that doc highlighted. If it finds that doc in more than one nav file, it attempts to find the right nav file by choosing the nav that matches the top level category in the doc URL. For example, if a doc with a relative URL /docs/accounts/accounts-billing/account-setup/create-your-new-relic-account was in two nav files, the docs site code would search to see if one of the nav files has docs/accounts as its first path field. If it finds a match, it uses that nav file. For an example of a doc that is placed in two different nav files, for this auto-index page click the Manage data doc and see how, when it loads, it displays the sidebar for the nav file that better matches its URL. When you click a sidebar category, what determines how that auto-index page displays? When you click on a docs category header in the sidebar and an auto-index page loads (like this one), what governs what is displayed there? Here is how this process works: A category header in the sidebar has an associated URL, which is set in the nav file. In the example nav file snippet below, the Get started category view has a path set to /docs/apis/intro-apis. This is what governs the sidebar heading title of \"Get started\" and tells it the URL to use. - title: APIs path: /docs/apis pages: - title: Get started path: /docs/apis/intro-apis pages: - title: New Relic APIs path: /docs/apis/intro-apis/introduction-new-relic-apis - title: API keys path: /docs/apis/intro-apis/new-relic-api-keys Copy If the associated folder of that path has an index mdx file (representing a landing page, like this one), the docs site displays that landing page. If there is no landing page, we display the docs and structure contained in that section of the nav file. For example, this view is based on the nav file section under that category header. For this to work correctly, the docs site verifies that that path matches an actual docs site folder that has at least one mdx file. Put another way: if we used a completely arbitrary URL path for a category's path, like docs/random-category/random-category-2, it would not work. To display a nav file, the path requires an existing folder with at least one doc in there. Other aspects to consider: A path is not required. A category header in the nav file does not require a path; that is just what tells it to create a link and a URL for that view. If a category in a nav file lacks a path, it won't have a link or associated URL for it (for an example, see the \"New Relic University\" category in this section). Having a category without an associated link/URL can be an acceptable choice if you are creating a category of docs that don't reside in that section and you simply want to give a helpful category view in the sidebar. Folder structure URLs aren't important. Every folder in the docs site can be the basis for a URL, but we should only consider valuable the URLs we've chosen for inclusion in the nav files. For example, here's a URL based on an actual folder containing one doc. But because there is no path in a nav file corresponding to that URL, it doesn't display anything. Nav file format Below is a snippet of the agents.yml nav file. Note that the file has indentation that corresponds to the level of the navigation hierarchy. When making changes or creating a new nav file, be sure to use the existing spacing format. yml title: Agents path: /docs/agents pages: - title: Manage APM agents path: /docs/agents/manage-apm-agents pages: - title: Agent data path: /docs/agents/manage-apm-agents/agent-data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Tip Navigation nesting is currently limited to a maximum of six levels deep. Please reach out to the engineering team if that is not enough. Here are important elements of the nav file: Key Required? Description title yes The text shown in the navigation, either of a doc or a category. path yes The URL path to the doc or the category view. Do not use trailing slashes. For docs categories in the nav file, the path is required to create an index view. Without the path, a docs category won't be clickable as a link and won't display a view of those docs. Learn more about index views. rootNav no rootNav controls whether a nav file will be displayed or hidden on the docs site home page. It is enabled by default. If you want to hide a category from the home page (as we do for our style guide docs, for example), you would set this to false, as shown below: title: Style guide path: /docs/style-guide Copy children no This is hardly ever used. It indicates a sub-navigation node. Procedures Below are instructions for several common procedures. It may help you to review the terms we use before starting a procedure. Procedures include: Add a new docs category Add a doc to sidebar/nav-file Move docs between folders or categories Move or delete folders Create a \"dummy\" category for docs that don’t live in that area Make a category heading clickable Troubleshoot messed up category views Overview of steps for a large docs site restructure project For some smaller docs site edits, you can sometimes simply edit the nav files and not have to touch the doc files or folders. But for larger projects, you may want to or need to edit and move the docs files and folders themselves. Below is a broad overview of the chunks of work such larger projects generally entail. Plan out what the new nav file structure will look like, and plan out the work of moving docs files or creating new folders. It can help to write down the chunks of work a large project will entail. Move the affected doc files to their new folder locations, making sure to add redirects. For more on that, see Move docs between folders. Delete any empty folders. Edit the nav files to reflect the new desired structure and point to the new doc URLs. If there are category header path URLs that are no longer needed, add those URLs as redirects to specific docs (preferred) or the taxonomy redirects file. For more specific and granular procedures, keep reading. Add a new category We'll explain two procedures: adding a subcategory of docs in an existing nav file, and adding an entirely new nav file. Add a new nav file Adding an entirely new nav file should be rare, and something we only do occasionally during large overhauls of site structure. To add an entirely new nav file: Copy an existing file nav file, or create a new nav file. Customize the new nav file with the categories and docs you want, using the structure of existing nav files as a template. For more on structure, see nav format. Tip You need at least one level of nesting inside the nav file. Without that, doc titles in the auto-generated category views will render as H2 headings. For example, src/content/level-one/level-two/doc will work, but src/content/level-one/doc will produce strange formatting. Add a new category to a nav file To add a new category to a nav file: In an existing nav file, add a new category, represented by its title and path. If you're adding a path for that category (recommended), it must use the URL of an existing folder with at least one mdx file in it. Add the docs you want in that section. Ensure your new content matches the indenting of the surrounding nav file. To learn more about how this works, see: How a doc's sidebar is determined How a doc category view is determined If a category view isn't clickable, see Make category view clickable. Add a doc to sidebar/nav-file Once you create a doc, you need to place it in one or more nav files. To do this: In the nav file location where you want to locate it, add the title (its short title displayed in the sidebar and category views) and the path, which is the doc's URL. Ensure that you've emulated the indenting based on the surrounding nav file content or other nav files. Add doc in multiple sidebar locations To add a doc in more than one sidebar location, simply add that doc (its title and path) wherever you want it to be in the nav file. For more on how the sidebar is determined for docs in multiple nav files, see Sidebar. You can add a doc URL in multiple nav file locations. Move docs to other categories Because the nav file and the actual folder structure aren't connected, there are two different ways to \"move docs\": Move a doc in the nav files: preferred and most common procedure. Move a doc between folders: less frequent, mainly when doing larger projects where we want to do a significant overhaul of the docs structure and want to ensure the folder structure doesn't become too divergent from the nav file structure. Move docs using nav file Move a doc in the nav file when you want to change where it's visible in the sidebar menus. To move a doc from one place to another in the nav file: In the first nav file, copy the two rows representing that doc's entry (the title and path lines) and paste that content into the place you want it to live in the new nav file. In the new nav file section, make sure that new content is aligned properly with the surrounding nav file content. See Nav format for more about nav file structure. Move docs between folders Note that moving docs between the folders should be relatively rare. The main reasons to do this are when the folder structure and nav file structure are becoming very different, which can be bad for a couple reasons: Too much divergence can create issues with category view displays or sidebar actions. Too much divergence can make finding and editing docs harder, so there can be value to keeping things fairly up to date and parallel. When you move a doc between folders or rename a doc, that changes its URL. Similarly, if you rename a folder, that changes the URL of all docs in that area. To move a doc between folders: Get the current URL of the doc you want to move and add that URL to its own list of redirects. Tips: One way to do this in VSCode is to right click the file and click \"Get relative path\". If you are moving many files, ask the team about ways to programmatically add redirects. Remove the trailing slash. Move the doc to the new folder. Update nav files with the new URL. This is easily overlooked but having the correct doc URL in the nav file, and not a redirect, is important. Note that a doc URL may be in more than one nav file so searching the site for that URL can help. Move or delete a folder Sometimes when we are doing a larger restructuring project, we may want to move or delete the actual folders instead of simply editing the nav files. If you are moving an entire folder or multiple folders to another folder, docs and all: Move the folder on your local disk to the new location (in Finder, for example). Next, because that move changes all the URLs of the docs and categories, you'll need to add redirects: For adding redirects for docs, see the procedures for moving a doc between folders. For category redirects: For the section of the nav file affected by your folder editing, gather all the category URLs (path fields) that relate to the moved or deleted folders. We don't need to redirect all folder-related URL paths: we only need to redirect the nav file paths because those represent the paths that we actually link to in the docs (in other words: we aren't using folder-based URLs if they don't have a nav file path). Add those category path URLs as redirects in specific docs or, if that won't work, in the taxonomy-redirects file. We should aim to add category redirects in specific docs and the reason for this is that the taxonomy-redirects file is hard to use and because it's a better customer experience to land on a doc versus a category if possible. In most cases, you'll be able to find a fitting doc to redirect to but if only a category view makes sense, use the taxonomy redirects file. For larger projects, this can be tough work, so you'll want to check out the build and make sure all the sidebar links and category headers are working as expected. For deleting folders, you'll want to essentially follow the same steps as above: either moving or deleting the docs in those folders first, gathering the affected category path URLs and adding them as redirects, adn then deleting the empty folders. Create a \"dummy\" sub-category of docs that don't live in that category Sometimes you want to create a category of docs that is there to help expose a related doc or set of docs. For example, in this view, we have added a category for 'New Relic University' even though that's not a doc that lives in that section; in this case, it's not even a doc on our site. In the example above, this 'New Relic University' category header is in regular text and not a link, and that's because it doesn't have a path set for it in the nav file. This also means that in the sidebar, this category header is not a clickable link and simply functions as a collapser/expander. This is acceptable if you don't mind it but below we explain how you can get a clickable category if you need it. To create a so-called \"dummy\" category: Add the category structure you want in the nav file. If you're okay not having a clickable category header, your new category doesn't require a path. If you want a clickable category header, you will need to use or create a folder that matches the new category path and that has at least one mdx file in it (details). In the nav file, add the title and path information for the docs you want in that new category. Test your new category to ensure it is working correctly. Make a sidebar category heading clickable If there's a sidebar category that's only acting as an expander/collapser and doesn't have a link, that's because it either a) doesn't have a path set in the nav file, or b) that path goes to a folder that doesn't have a doc in it. For more on this, see the instructions regarding clickable headers in the \"dummy\" category section. Troubleshoot category views not working correctly If a docs category view is not working correctly, review how category views are formed. If this does happen, get another opinion from another tech writer to make sure you're not missing something, as we should rarely have problems. One reason that a category view might not work is specifically for path URLs that are also landing pages. In this case, if that path is used in more than one location in the same nav file, the docs site can be confused about which category view to use. We may fix this with a coding fix but in meantime: consider pointing to other URLs and not that path, so that there's only one use of that path per nav file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.85525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;link-your-applications-kubernetes - title: <em>App</em> <em>naming</em> pages: - title: <em>Name</em> your application path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>app</em>-<em>naming</em>&#x2F;<em>name</em>-your-application - title: Use multiple names for an <em>app</em> path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>app</em>-<em>naming</em>&#x2F;use-multiple-names-<em>app</em> Copy"
      },
      "id": "612eff27e7b9d25b16b6f24c"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.64101,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Automatic <em>application</em> <em>naming</em>",
        "sections": "Automatic <em>application</em> <em>naming</em>",
        "tags": "<em>Agents</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s Java <em>agent</em> reports all transactions and other metrics in a single JVM to the application <em>name</em> specified in newrelic.yml under the setting <em>app_name</em> (for more information about application <em>naming</em>"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/configuration/add-rename-remove-hosts": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "sections": [
        "High security mode",
        "Requirements",
        "Account level",
        "Enable high security mode (version 2)",
        "Caution",
        "Results of enabling high security mode (version 2)",
        "Results of enabling high security mode v1 (deprecated)",
        "Migrate from version 1 to version 2"
      ],
      "title": "High security mode",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "460ad5339fa585b7fcf6db77644b85ddf015c7d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/high-security-mode/",
      "published_at": "2021-12-05T06:33:24Z",
      "updated_at": "2021-11-15T11:26:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's default APM agent settings provide a high level of security. However, you may need to guarantee that even if the default APM agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on APM's high security mode (also known as enterprise security mode). For more information about our security measures, see our security and privacy documentation, or visit the New Relic security website. Requirements Customers on our New Relic One pricing model require Enterprise edition. Customers on our original pricing model have access depending on their subscription level. Account level If you choose to turn on high security, you must enable high security for all applications reporting to the account. High security must be set on each individual account. For organizations that have a parent/child account structure, child accounts don't automatically inherit the high security setting when enabled on the parent account. Currently there are two versions of high security mode. Version 1 is deprecated and is only available if you already have it. If you are enabling high security mode for the first time, the only option is version 2 (v2). Agent Version 2 support C SDK n/a Go All versions Java 3.7 or higher (enabled by default) .NET 3.3 or higher Node.js 1.7.0 or higher PHP 4.9 or higher Python 2.22.0.0 or higher Ruby 3.9.1 or higher Enable high security mode (version 2) To enable high security, you must update both the local configuration on your server and the remote configuration in the UI. Caution Once you enable high security for an account, high security cannot be turned off without assistance from New Relic Support. Setting location Description Set in UI To set high security in the UI: Go to one.newrelic.com, click the account dropdown and select Account settings. On that page, select High security mode. If you are on our original pricing model, only the account owner can view this option. If the agent is configured for high security via the UI but not locally, then the agent connections will be rejected, and the agent will shut down. However, this won't shut down your application. Local, via agent Enable high security mode in your agent configuration file. High security mode is disabled by default, and the exact procedure to enable it varies by agent: C SDK: n/a Go Java .NET Node.js PHP Python Ruby If the agent is configured for high security locally but not via the UI, then the agent connections will be rejected, and the agent will shut down. This will not shut down your application. Results of enabling high security mode (version 2) Once enabled, high security mode (v2) ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires a secure (HTTPS) connection. Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure all data in transit per the latest industry standards. Prevents HTTP param capture High security mode does not allow HTTP params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send HTTP params locally or through server-side configuration, high security mode will override the configuration to never capture HTTP params. Prevents message queue param capture High security mode does not allow message queue params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send message queue params locally or through server-side configuration, then high security mode will override the configuration to never capture message queue params. Prevents raw query statement capture High security mode does not allow raw database query statements, which may contain sensitive customer data, to be captured. If the agent is configured to capture raw queries locally or through server-side configuration, then high security mode will override the configuration to never capture raw queries. Prevents user attribute capture High security mode does not allow attributes set using each agent's API to be captured, as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.addCustomParameter(String key, String value) Copy NewRelic.addCustomParameter(String key, Number value) Copy NewRelic.setUserName(String name) Copy NewRelic.setAccountName(String name) Copy NewRelic.setProductName(String name) Copy Prevents noticeError attribute capture High security mode does not allow attributes set using each agent's noticeError API call to be captured as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.noticeError(String message, Map<String, String> params) Copy NewRelic.noticeError(Throwable throwable, Map<String, String> params) Copy Prevents custom events High security mode does not allow custom events to be created using the agent API, as these may contain sensitive customer data. For example, in the .NET agent, the API call RecordCustomEvent will be blocked. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Results of enabling high security mode v1 (deprecated) High security mode version 1 is deprecated and only available if you enabled it prior to version 2 being available. High security mode version 1 ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure that all data in transit is encrypted as per the latest industry standards. Prevents HTTP param capture Agents configured to capture HTTP params, which may contain sensitive customer data, are not allowed to connect to New Relic. If the local configuration is set to capture request parameters, then New Relic's collector will reject the connection, and the agent will shut down. Prevents raw query statement capture Agents configured to capture raw database query statements, which may contain sensitive customer data, are not allowed to connect to New Relic. If the agent is configured to capture raw queries locally or through server-side configuration, New Relic's collector will reject the connection and the agent will shut down. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Migrate from version 1 to version 2 These are the main differences between the two versions of high security: In order to make high security even more secure, high security must be enabled in the New Relic user interface and in the local New Relic configuration file. High security v1 only required high security to be set in the New Relic UI. User attributes, noticeError attributes, and message queue parameters are turned off with high security in version 2, but not in version 1. To update from v1 to v2, add high_security: true to your local agent configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.5015,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic <em>agents</em> support HTTPS. If the <em>configuration</em> is not set appropriately, the <em>agent</em> will override the property to ensure that all data in transit is encrypted as per the latest"
      },
      "id": "617e646328ccbc8b5a7ff3ac"
    },
    {
      "sections": [
        "Enable configurable security policies",
        "Tip",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "e0027e4ca72d231ea54847b3b7cf7cf8be0c7df6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-12-05T06:08:24Z",
      "updated_at": "2021-10-31T09:38:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tip APM's configurable security policies is available in limited release for approved New Relic accounts. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.80763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " security website. Compatibility and requirements <em>APM</em> <em>agent</em> versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security"
      },
      "id": "617e6431e7b9d23689c05c1f"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/configuration/enable-configurable-security-policies": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "sections": [
        "High security mode",
        "Requirements",
        "Account level",
        "Enable high security mode (version 2)",
        "Caution",
        "Results of enabling high security mode (version 2)",
        "Results of enabling high security mode v1 (deprecated)",
        "Migrate from version 1 to version 2"
      ],
      "title": "High security mode",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "460ad5339fa585b7fcf6db77644b85ddf015c7d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/high-security-mode/",
      "published_at": "2021-12-05T06:33:24Z",
      "updated_at": "2021-11-15T11:26:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's default APM agent settings provide a high level of security. However, you may need to guarantee that even if the default APM agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on APM's high security mode (also known as enterprise security mode). For more information about our security measures, see our security and privacy documentation, or visit the New Relic security website. Requirements Customers on our New Relic One pricing model require Enterprise edition. Customers on our original pricing model have access depending on their subscription level. Account level If you choose to turn on high security, you must enable high security for all applications reporting to the account. High security must be set on each individual account. For organizations that have a parent/child account structure, child accounts don't automatically inherit the high security setting when enabled on the parent account. Currently there are two versions of high security mode. Version 1 is deprecated and is only available if you already have it. If you are enabling high security mode for the first time, the only option is version 2 (v2). Agent Version 2 support C SDK n/a Go All versions Java 3.7 or higher (enabled by default) .NET 3.3 or higher Node.js 1.7.0 or higher PHP 4.9 or higher Python 2.22.0.0 or higher Ruby 3.9.1 or higher Enable high security mode (version 2) To enable high security, you must update both the local configuration on your server and the remote configuration in the UI. Caution Once you enable high security for an account, high security cannot be turned off without assistance from New Relic Support. Setting location Description Set in UI To set high security in the UI: Go to one.newrelic.com, click the account dropdown and select Account settings. On that page, select High security mode. If you are on our original pricing model, only the account owner can view this option. If the agent is configured for high security via the UI but not locally, then the agent connections will be rejected, and the agent will shut down. However, this won't shut down your application. Local, via agent Enable high security mode in your agent configuration file. High security mode is disabled by default, and the exact procedure to enable it varies by agent: C SDK: n/a Go Java .NET Node.js PHP Python Ruby If the agent is configured for high security locally but not via the UI, then the agent connections will be rejected, and the agent will shut down. This will not shut down your application. Results of enabling high security mode (version 2) Once enabled, high security mode (v2) ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires a secure (HTTPS) connection. Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure all data in transit per the latest industry standards. Prevents HTTP param capture High security mode does not allow HTTP params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send HTTP params locally or through server-side configuration, high security mode will override the configuration to never capture HTTP params. Prevents message queue param capture High security mode does not allow message queue params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send message queue params locally or through server-side configuration, then high security mode will override the configuration to never capture message queue params. Prevents raw query statement capture High security mode does not allow raw database query statements, which may contain sensitive customer data, to be captured. If the agent is configured to capture raw queries locally or through server-side configuration, then high security mode will override the configuration to never capture raw queries. Prevents user attribute capture High security mode does not allow attributes set using each agent's API to be captured, as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.addCustomParameter(String key, String value) Copy NewRelic.addCustomParameter(String key, Number value) Copy NewRelic.setUserName(String name) Copy NewRelic.setAccountName(String name) Copy NewRelic.setProductName(String name) Copy Prevents noticeError attribute capture High security mode does not allow attributes set using each agent's noticeError API call to be captured as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.noticeError(String message, Map<String, String> params) Copy NewRelic.noticeError(Throwable throwable, Map<String, String> params) Copy Prevents custom events High security mode does not allow custom events to be created using the agent API, as these may contain sensitive customer data. For example, in the .NET agent, the API call RecordCustomEvent will be blocked. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Results of enabling high security mode v1 (deprecated) High security mode version 1 is deprecated and only available if you enabled it prior to version 2 being available. High security mode version 1 ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure that all data in transit is encrypted as per the latest industry standards. Prevents HTTP param capture Agents configured to capture HTTP params, which may contain sensitive customer data, are not allowed to connect to New Relic. If the local configuration is set to capture request parameters, then New Relic's collector will reject the connection, and the agent will shut down. Prevents raw query statement capture Agents configured to capture raw database query statements, which may contain sensitive customer data, are not allowed to connect to New Relic. If the agent is configured to capture raw queries locally or through server-side configuration, New Relic's collector will reject the connection and the agent will shut down. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Migrate from version 1 to version 2 These are the main differences between the two versions of high security: In order to make high security even more secure, high security must be enabled in the New Relic user interface and in the local New Relic configuration file. High security v1 only required high security to be set in the New Relic UI. User attributes, noticeError attributes, and message queue parameters are turned off with high security in version 2, but not in version 1. To update from v1 to v2, add high_security: true to your local agent configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.50148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic <em>agents</em> support HTTPS. If the <em>configuration</em> is not set appropriately, the <em>agent</em> will override the property to ensure that all data in transit is encrypted as per the latest"
      },
      "id": "617e646328ccbc8b5a7ff3ac"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "34c443ebbf3a304d6aeb3e3f012b4ddd11b06765",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-12-05T05:49:02Z",
      "updated_at": "2021-10-23T19:48:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.60484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available <em>configuration</em>"
      },
      "id": "617e649c196a67df22f7bb1c"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/configuration/high-security-mode": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "sections": [
        "Enable configurable security policies",
        "Tip",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "e0027e4ca72d231ea54847b3b7cf7cf8be0c7df6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-12-05T06:08:24Z",
      "updated_at": "2021-10-31T09:38:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tip APM's configurable security policies is available in limited release for approved New Relic accounts. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.80763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " security website. Compatibility and requirements <em>APM</em> <em>agent</em> versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security"
      },
      "id": "617e6431e7b9d23689c05c1f"
    },
    {
      "sections": [
        "Server-side agent configuration",
        "Centralization and security",
        "Server-side configuration precedence",
        "Enable server-side configuration",
        "View or change server-side configuration settings",
        "Disable server-side configuration"
      ],
      "title": "Server-side agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "34c443ebbf3a304d6aeb3e3f012b4ddd11b06765",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/server-side-agent-configuration/",
      "published_at": "2021-12-05T05:49:02Z",
      "updated_at": "2021-10-23T19:48:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Server-side configuration transitions some core settings from your language agent's configuration file to the New Relic collector. Depending on the language agent, available settings may include: Transaction tracing SQL recording and logging SQL query plans Error collection Thread profiling Distributed tracing Cross application tracing Centralization and security Server-side configuration provides an easy way to manage the available settings from the New Relic UI. Centralized configuration settings can also help you ensure standards compliance and security management for your settings. Any change automatically applies to all APM agents, even if they run across multiple hosts. The agent still follows the local configurations for any settings not available from the UI. Server-side configuration precedence This feature provides the convenience of managing the available configuration settings directly within the New Relic UI, without the need for deployments or restarts. Available options to change settings, and the order of precedence they take when you utilize environment variables or other configuration options, will depend on the language agent used. For more information about the hierarchy of settings, see the illustration for the specific agent: C SDK configuration: A hierarchy is not applicable, because configuration values come from API calls. Also, server-side configuration is not supported. However, you can change the app name from the UI or from the C SDK configuration settings. Go hierarchy Java hierarchy .NET hierarchy Node.js hierarchy PHP hierarchy (server-side configuration not supported) Python hierarchy Ruby hierarchy Enable server-side configuration The C SDK and PHP agent do not support server-side configuration. To enable server-side configuration settings for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. After you enable server-side configuration, you can view and change the available settings through the UI. View or change server-side configuration settings If you use server-side configuration, you must still include your license_key and app_name in the local config file. These settings are required for the agent to communicate with the New Relic collector. The C SDK and PHP agent do not support server-side configuration. To view or change the available server-side configuration settings through the UI for apps that use other New Relic agents: Go to one.newrelic.com and click APM. Click on your app. Then click Settings > Application > Server-side agent configuration. Once you set any of these options from the UI, they will override any conflicting options in the agent's configuration file. Disable server-side configuration Once you enable server-side configuration for an account, server-side configuration cannot be turned off without assistance from New Relic Support. This helps mitigate issues that could arise from conflicts with configuration settings if you need to transition back to a local configuration setup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.60484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Server-side <em>agent</em> <em>configuration</em>",
        "sections": "Server-side <em>agent</em> <em>configuration</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " change automatically applies to all <em>APM</em> <em>agents</em>, even if they run across multiple hosts. The <em>agent</em> still follows the local configurations for any settings not available from the UI. Server-side <em>configuration</em> precedence This feature provides the convenience of managing the available <em>configuration</em>"
      },
      "id": "617e649c196a67df22f7bb1c"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/configuration/server-side-agent-configuration": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99261,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "sections": [
        "High security mode",
        "Requirements",
        "Account level",
        "Enable high security mode (version 2)",
        "Caution",
        "Results of enabling high security mode (version 2)",
        "Results of enabling high security mode v1 (deprecated)",
        "Migrate from version 1 to version 2"
      ],
      "title": "High security mode",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "460ad5339fa585b7fcf6db77644b85ddf015c7d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/high-security-mode/",
      "published_at": "2021-12-05T06:33:24Z",
      "updated_at": "2021-11-15T11:26:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's default APM agent settings provide a high level of security. However, you may need to guarantee that even if the default APM agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on APM's high security mode (also known as enterprise security mode). For more information about our security measures, see our security and privacy documentation, or visit the New Relic security website. Requirements Customers on our New Relic One pricing model require Enterprise edition. Customers on our original pricing model have access depending on their subscription level. Account level If you choose to turn on high security, you must enable high security for all applications reporting to the account. High security must be set on each individual account. For organizations that have a parent/child account structure, child accounts don't automatically inherit the high security setting when enabled on the parent account. Currently there are two versions of high security mode. Version 1 is deprecated and is only available if you already have it. If you are enabling high security mode for the first time, the only option is version 2 (v2). Agent Version 2 support C SDK n/a Go All versions Java 3.7 or higher (enabled by default) .NET 3.3 or higher Node.js 1.7.0 or higher PHP 4.9 or higher Python 2.22.0.0 or higher Ruby 3.9.1 or higher Enable high security mode (version 2) To enable high security, you must update both the local configuration on your server and the remote configuration in the UI. Caution Once you enable high security for an account, high security cannot be turned off without assistance from New Relic Support. Setting location Description Set in UI To set high security in the UI: Go to one.newrelic.com, click the account dropdown and select Account settings. On that page, select High security mode. If you are on our original pricing model, only the account owner can view this option. If the agent is configured for high security via the UI but not locally, then the agent connections will be rejected, and the agent will shut down. However, this won't shut down your application. Local, via agent Enable high security mode in your agent configuration file. High security mode is disabled by default, and the exact procedure to enable it varies by agent: C SDK: n/a Go Java .NET Node.js PHP Python Ruby If the agent is configured for high security locally but not via the UI, then the agent connections will be rejected, and the agent will shut down. This will not shut down your application. Results of enabling high security mode (version 2) Once enabled, high security mode (v2) ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires a secure (HTTPS) connection. Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure all data in transit per the latest industry standards. Prevents HTTP param capture High security mode does not allow HTTP params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send HTTP params locally or through server-side configuration, high security mode will override the configuration to never capture HTTP params. Prevents message queue param capture High security mode does not allow message queue params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send message queue params locally or through server-side configuration, then high security mode will override the configuration to never capture message queue params. Prevents raw query statement capture High security mode does not allow raw database query statements, which may contain sensitive customer data, to be captured. If the agent is configured to capture raw queries locally or through server-side configuration, then high security mode will override the configuration to never capture raw queries. Prevents user attribute capture High security mode does not allow attributes set using each agent's API to be captured, as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.addCustomParameter(String key, String value) Copy NewRelic.addCustomParameter(String key, Number value) Copy NewRelic.setUserName(String name) Copy NewRelic.setAccountName(String name) Copy NewRelic.setProductName(String name) Copy Prevents noticeError attribute capture High security mode does not allow attributes set using each agent's noticeError API call to be captured as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.noticeError(String message, Map<String, String> params) Copy NewRelic.noticeError(Throwable throwable, Map<String, String> params) Copy Prevents custom events High security mode does not allow custom events to be created using the agent API, as these may contain sensitive customer data. For example, in the .NET agent, the API call RecordCustomEvent will be blocked. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Results of enabling high security mode v1 (deprecated) High security mode version 1 is deprecated and only available if you enabled it prior to version 2 being available. High security mode version 1 ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure that all data in transit is encrypted as per the latest industry standards. Prevents HTTP param capture Agents configured to capture HTTP params, which may contain sensitive customer data, are not allowed to connect to New Relic. If the local configuration is set to capture request parameters, then New Relic's collector will reject the connection, and the agent will shut down. Prevents raw query statement capture Agents configured to capture raw database query statements, which may contain sensitive customer data, are not allowed to connect to New Relic. If the agent is configured to capture raw queries locally or through server-side configuration, New Relic's collector will reject the connection and the agent will shut down. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Migrate from version 1 to version 2 These are the main differences between the two versions of high security: In order to make high security even more secure, high security must be enabled in the New Relic user interface and in the local New Relic configuration file. High security v1 only required high security to be set in the New Relic UI. User attributes, noticeError attributes, and message queue parameters are turned off with high security in version 2, but not in version 1. To update from v1 to v2, add high_security: true to your local agent configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.50146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic <em>agents</em> support HTTPS. If the <em>configuration</em> is not set appropriately, the <em>agent</em> will override the property to ensure that all data in transit is encrypted as per the latest"
      },
      "id": "617e646328ccbc8b5a7ff3ac"
    },
    {
      "sections": [
        "Enable configurable security policies",
        "Tip",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "e0027e4ca72d231ea54847b3b7cf7cf8be0c7df6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-12-05T06:08:24Z",
      "updated_at": "2021-10-31T09:38:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tip APM's configurable security policies is available in limited release for approved New Relic accounts. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.80762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " security website. Compatibility and requirements <em>APM</em> <em>agent</em> versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security"
      },
      "id": "617e6431e7b9d23689c05c1f"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/configuration/support-arm-graviton-x86-64": [
    {
      "sections": [
        "Custom SSL certificates (Ruby)",
        "Use a custom CA bundle",
        "Installing SSL Certificates"
      ],
      "title": "Custom SSL certificates (Ruby)",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Configuration"
      ],
      "external_id": "4988704d9e8125f52d5f2a1a0335f205a320d8db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/ruby-agent/configuration/custom-ssl-certificates-ruby/",
      "published_at": "2021-12-05T09:17:20Z",
      "updated_at": "2021-12-05T09:17:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic requires HTTPS for all traffic to APM and the New Relic REST API. The Ruby agent connects to New Relic collector servers over SSL by default, and uses a system/host installed set of SSL certificate to validate the identity of the collector servers when connecting. In most cases, this default set of certificates is sufficient. In certain configurations, you may need to use a custom CA bundle. For example, you may use an HTTP proxy to intercept and decrypt SSL traffic from the agent, which then establishes a separate SSL connection to New Relic. Custom CA bundles are available in versions 3.9.4 or higher of the Ruby agent. Use a custom CA bundle To configure the agent to use a custom CA bundle when validating the SSL certificate presented by a proxy, set the ca_bundle_path configuration setting in your newrelic.yml file or via the NEW_RELIC_CA_BUNDLE_PATH environment variable: common: &default_settings ca_bundle_path: certificates/mycert.pem # ... other settings ... Copy Specify a path to a .pem file containing each certificate you want the agent to use when validating the identity of the proxy or server. You can concatenate multiple certificates into a single .pem file. Relative path: If you specify a relative path, the agent will assign a path relative to the working directory of your app server process at runtime. Absolute path: If your working directory is / rather than the root of your application, be sure to specify an absolute path. Installing SSL Certificates If you're deploying a Ruby application and agent to a container or server that does not have CA certificates installed, you need to ensure they're now installed for 7.0 or highter releases of the agent to make successful HTTPS connections to New Relic servers. These CA certificates may be installed in various ways, depending on your host. The following external links are helpful guidiance for testing the readiness of your host and installing CA certificates: Troubleshooting SSL Certificate Errors Automated SSL Check Installing CA Certificates How to handle Certificates in Docker",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.75827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": " in versions 3.9.4 or higher of the Ruby <em>agent</em>. Use a custom CA bundle To configure the <em>agent</em> to use a custom CA bundle when validating the SSL certificate presented by a proxy, set the ca_bundle_path <em>configuration</em> setting in your newrelic.yml file or via the NEW_RELIC_CA_BUNDLE_PATH environment variable"
      },
      "id": "617e9526e7b9d244dbc05e66"
    },
    {
      "sections": [
        "Automatic application naming",
        "Important",
        "Caution",
        "Application name sources",
        "Request attribute",
        "Tip",
        "Servlet init parameter",
        "Filter init parameter",
        "Context parameter",
        "Display name",
        "Context path"
      ],
      "title": "Automatic application naming",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Configuration"
      ],
      "external_id": "b8d38d3fe920d7d399bd1eb05d53ba438c01790d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/configuration/automatic-application-naming/",
      "published_at": "2021-12-05T04:44:39Z",
      "updated_at": "2021-12-05T04:44:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic's Java agent reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming, see Name your Java application). By changing enable_auto_app_naming in newrelic.yml to true, applications will be named for their context, filter, servlet, or request attribute. This setting allows you to run several web applications in a single JVM while reporting transactions, errors, and metrics to other appropriate applications in the New Relic user interface. Background tasks will still use the default application name from the newrelic.yml. Important These configuration changes require a JVM restart to take effect. This configuration does NOT work with Infinite Tracing enabled. Caution Enabling auto app naming will increase the amount of data ingested by the agent. There are various methods to alert on and monitor data ingest. Application name sources When you set enable_auto_app_naming to true, New Relic uses the following sources of information to name your applications: App type Naming source Background tasks The default application name from newrelic.yml Web transactions In order by priority: Request attribute (highest priority) Servlet init parameter Filter init parameter Web app context parameter Web app context name (display-name) Web app context path (lowest priority) Request attribute The APPLICATION_NAME request attribute takes precedence over any settings in the XML. Set this attribute as early as possible in the web transaction. If called multiple times, the last invocation determines the application name. Tip APPLICATION_NAME only works with ServletRequests. To use the request attribute for fine-grained application naming based on the request URI: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... String requestUri = httpServletRequest.getRequestURI(); if (requestUri.startsWith(\"/my-special-request/\")) { request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MySpecialWebApp\"); } ... Copy Servlet init parameter To set the application name for individual servlets in web.xml using init parameters: <servlet> <servlet-name>SqlServlet</servlet-name> <servlet-class>test.SqlServlet</servlet-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyServletApp</param-value> </init-param> </servlet> Copy The agent obtains the value of the init-param by calling javax.servlet.ServletConfig#getInitParameter(String) Copy with the argument com.newrelic.agent.APPLICATION_NAME. If a web request calls multiple servlets, the init-param of the first servlet to finish has precedence. A servlet that does not have an init-param uses the default application name for the web app. Besides declaring the application name in XML, you can also set it in your application code by storing an attribute in the javax.servlet.ServletRequest: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ... request.setAttribute(\"com.newrelic.agent.APPLICATION_NAME\", \"MyWebApp\"); ... Copy Filter init parameter If your web app does not have servlets, you can use an init parameter for a filter: <filter> <filter-name>SqlFilter</filter-name> <filter-class>test.SqlFilter</filter-class> <init-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyFilterApp</param-value> </init-param> </filter> Copy The agent obtains the value of the init-param by calling javax.servlet.FilterConfig#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. Servlets takes precedence over filters for application naming, so the init parameter for a filter is used only if no servlets were invoked. The init-param of the first filter to finish has precedence. Context parameter To use a context parameter to set the application name: <context-param> <param-name>com.newrelic.agent.APPLICATION_NAME</param-name> <param-value>MyWebApp</param-value> </context-param> Copy The agent obtains the value of the context parameter is by calling javax.servlet.ServletContext#getInitParameter(String) with the argument com.newrelic.agent.APPLICATION_NAME. The context parameter takes precedence over the display-name element. Display name To determine the application name by using the display-name element in the web.xml: <display-name>MyWebApp</display-name> Copy The agent obtains the value of the display-name element by calling javax.servlet.ServletContext#getServletContextName(). Context path If there is no display-name element, and none of the other higher hierarchy methods are used to set the app name, the application name comes from the context path of the web app. The agent obtains the context path by calling javax.servlet.ServletContext#getContextPath(). The context path is the portion of the request URI that is used to select the context of the request. The context path always comes first in a request URI. For example: Consider the following URL: http://example.com/newrelic-axis2-ws/getWeather Copy In this URL: The request URI is /newrelic-axis2-ws/getWeather. The context path is /newrelic-axis2-ws. The application is named newrelic-axis2-ws.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.50412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Agents</em>",
        "body": "The names you give to your applications can help organize your New Relic performance metrics. New Relic&#x27;s Java <em>agent</em> reports all transactions and other metrics in a single JVM to the application name specified in newrelic.yml under the setting app_name (for more information about application naming"
      },
      "id": "617e7063e7b9d2b171c05f6d"
    },
    {
      "sections": [
        "Ruby agent configuration",
        "Configuration methods and precedence",
        "View and edit config file options",
        "Update the config file",
        "Important",
        "General",
        "license_key",
        "agent_enabled",
        "app_name",
        "monitor_mode",
        "log_level",
        "high_security",
        "security_policies_token",
        "proxy_host",
        "proxy_port",
        "proxy_user",
        "proxy_pass",
        "capture_params",
        "Caution",
        "config_path",
        "apdex_t",
        "sync_startup",
        "send_data_on_exit",
        "timeout",
        "force_install_exit_handler",
        "log_file_name",
        "log_file_path",
        "prepend_active_record_instrumentation",
        "capture_memcache_keys",
        "message_tracer.segment_parameters.enabled",
        "marshaller",
        "backport_fast_active_record_connection_lookup",
        "labels",
        "ca_bundle_path",
        "datastore_tracer.instance_reporting.enabled",
        "datastore_tracer.database_name_reporting.enabled",
        "clear_transaction_state_after_fork",
        "exclude_newrelic_header",
        "infinite_tracing.trace_observer.host",
        "infinite_tracing.trace_observer.port",
        "Transaction Tracer",
        "transaction_tracer.enabled",
        "transaction_tracer.transaction_threshold",
        "transaction_tracer.record_sql",
        "transaction_tracer.record_redis_arguments",
        "transaction_tracer.capture_attributes",
        "transaction_tracer.explain_threshold",
        "transaction_tracer.explain_enabled",
        "transaction_tracer.stack_trace_threshold",
        "transaction_tracer.limit_segments",
        "Error Collector",
        "error_collector.enabled",
        "error_collector.capture_attributes",
        "error_collector.ignore_errors",
        "error_collector.ignore_classes",
        "error_collector.ignore_messages",
        "error_collector.ignore_status_codes",
        "error_collector.expected_classes",
        "error_collector.expected_messages",
        "error_collector.expected_status_codes",
        "error_collector.max_backtrace_frames",
        "error_collector.capture_events",
        "error_collector.max_event_samples_stored",
        "Browser Monitoring",
        "browser_monitoring.auto_instrument",
        "browser_monitoring.capture_attributes",
        "Analytics Events",
        "analytics_events.enabled",
        "analytics_events.max_samples_stored",
        "analytics_events.capture_attributes",
        "Attributes",
        "attributes.enabled",
        "transaction_tracer.attributes.enabled",
        "transaction_events.attributes.enabled",
        "error_collector.attributes.enabled",
        "browser_monitoring.attributes.enabled",
        "span_events.attributes.enabled",
        "transaction_segments.attributes.enabled",
        "attributes.exclude",
        "transaction_tracer.attributes.exclude",
        "transaction_events.attributes.exclude",
        "error_collector.attributes.exclude",
        "browser_monitoring.attributes.exclude",
        "span_events.attributes.exclude",
        "transaction_segments.attributes.exclude",
        "attributes.include",
        "transaction_tracer.attributes.include",
        "transaction_events.attributes.include",
        "error_collector.attributes.include",
        "browser_monitoring.attributes.include",
        "span_events.attributes.include",
        "transaction_segments.attributes.include",
        "Audit Log",
        "audit_log.enabled",
        "audit_log.path",
        "audit_log.endpoints",
        "Autostart",
        "autostart.denylisted_constants",
        "autostart.denylisted_executables",
        "autostart.denylisted_rake_tasks",
        "Cross Application Tracer",
        "cross_application_tracer.enabled",
        "Custom Attributes",
        "custom_attributes.enabled",
        "Custom Insights Events",
        "custom_insights_events.enabled",
        "custom_insights_events.max_samples_stored",
        "Disabling",
        "disable_rake",
        "disable_samplers",
        "disable_resque",
        "disable_sidekiq",
        "disable_dj",
        "disable_sinatra",
        "disable_sinatra_auto_middleware",
        "disable_view_instrumentation",
        "disable_activerecord_instrumentation",
        "disable_data_mapper",
        "disable_activejob",
        "disable_action_cable_instrumentation",
        "disable_active_storage",
        "disable_memcached",
        "disable_memcache_client",
        "disable_dalli",
        "disable_dalli_cas_client",
        "disable_memcache_instrumentation",
        "disable_gc_profiler",
        "disable_sequel_instrumentation",
        "disable_database_instrumentation",
        "disable_mongo",
        "disable_redis",
        "disable_vm_sampler",
        "disable_memory_sampler",
        "disable_cpu_sampler",
        "disable_delayed_job_sampler",
        "disable_active_record_notifications",
        "disable_bunny",
        "disable_curb",
        "disable_excon",
        "disable_httpclient",
        "disable_net_http",
        "disable_rack",
        "disable_rack_urlmap",
        "disable_puma_rack",
        "disable_puma_rack_urlmap",
        "disable_typhoeus",
        "disable_httprb",
        "disable_middleware_instrumentation",
        "disable_grape",
        "Distributed Tracing",
        "distributed_tracing.enabled",
        "Heroku",
        "heroku.use_dyno_names",
        "heroku.dyno_name_prefixes_to_shorten",
        "Instrumentation",
        "instrumentation.net_http",
        "instrumentation.typhoeus",
        "instrumentation.bunny",
        "instrumentation.httprb",
        "instrumentation.resque",
        "instrumentation.redis",
        "instrumentation.rake",
        "instrumentation.mongo",
        "instrumentation.delayed_job",
        "instrumentation.httpclient",
        "instrumentation.curb",
        "instrumentation.sinatra",
        "instrumentation.rack",
        "instrumentation.rack_urlmap",
        "instrumentation.puma_rack",
        "instrumentation.puma_rack_urlmap",
        "instrumentation.memcached",
        "instrumentation.memcache_client",
        "instrumentation.memcache",
        "instrumentation.logger",
        "instrumentation.tilt",
        "instrumentation.excon",
        "instrumentation.grape",
        "Mongo",
        "mongo.capture_queries",
        "mongo.obfuscate_queries",
        "Process Host",
        "process_host.display_name",
        "Rake",
        "rake.tasks",
        "rake.connect_timeout",
        "Resque",
        "resque.capture_params",
        "Rules",
        "rules.ignore_url_regexes",
        "Sidekiq",
        "sidekiq.capture_params",
        "Slow SQL",
        "slow_sql.enabled",
        "slow_sql.explain_threshold",
        "slow_sql.explain_enabled",
        "slow_sql.record_sql",
        "slow_sql.use_longer_sql_id",
        "Span Events",
        "span_events.enabled",
        "span_events.queue_size",
        "span_events.max_samples_stored",
        "Strip Exception Messages",
        "strip_exception_messages.enabled",
        "strip_exception_messages.allowed_classes",
        "Thread Profiler",
        "thread_profiler.enabled",
        "Utilization",
        "utilization.detect_aws",
        "utilization.detect_azure",
        "utilization.detect_gcp",
        "utilization.detect_pcf",
        "utilization.detect_docker",
        "utilization.detect_kubernetes"
      ],
      "title": "Ruby agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Configuration"
      ],
      "external_id": "a001df310d2cda388988d8947dd0a6cd160a4ad8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/ruby-agent/configuration/ruby-agent-configuration/",
      "published_at": "2021-12-04T22:19:44Z",
      "updated_at": "2021-12-04T22:19:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can configure the New Relic Ruby agent with settings in a configuration file, environment variables, or programmatically with server-side configuration. This document summarizes the configuration options available for the Ruby agent. If the default value for a configuration option is (Dynamic), this means the Ruby agent calculates the default at runtime. The value for the config setting defaults to the value of another setting as appropriate. Configuration methods and precedence The primary (default) method to configure the Ruby agent is via the configuration file (newrelic.yml) in the config subdirectory. To set configuration values using environment variables: Add the prefix NEW_RELIC_ to the setting's name. Replace any periods . with underscores _. You can also configure a few values in the UI via server-side configuration. The Ruby agent follows this order of precedence for configuration: Environment variables Server-side configuration Configuration file (newrelic.yml) Default configuration settings In other words, environment variables override all other configuration settings and info, server-side configuration overrides the configuration file and default config settings, and so on. View and edit config file options The Ruby agent's newrelic.yml is a standard YAML configuration file. It typically includes a Defaults section at the top, plus sections below for each application environment; for example, Development, Testing, and Production. The Ruby agent determines which section of the newrelic.yml config file to read from by looking at certain environment variables to derive the application's environment. This can be useful, for example, when you want to use info for the log_level config setting in your production environment, and you want more verbose log_level config settings (such as debug in your development environment. Here is an example newrelic.yml config file: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'My Application Name' production: <<: *default_settings log_level: info development: <<: *default_settings log_level: debug Copy For non-Rails apps, the Ruby agent looks for the following environment variables, in this order, to determine the application environment: NEW_RELIC_ENV RUBY_ENV RAILS_ENV APP_ENV RACK_ENV If the Ruby agent does not detect values for any of those environment variables, it will default the application environment to development and read from the development section of the newrelic.yml config file. When running the Ruby agent in a Rails app, the agent first looks for the NEW_RELIC_ENV environment variable to determine the application environment and which section of the newrelic.yml to use. If NEW_RELIC_ENV is not present, the agent uses the Rails environment (RAILS_ENV or RAILS.env, depending on the version of Rails) . When you edit the config file, be sure to: Indent only with two spaces. Indent only where relevant, in stanzas such as error_collector. If you do not indent correctly, the agent may throw an Unable to parse configuration file error on startup. To view the most current list of available Ruby agent configuration options, use the rake newrelic:config:docs command. This document describes the most common options. Update the config file This documentation applies to the Ruby agent's latest release. For details on earlier versions, refer to the comments in newrelic.yml itself. To update newrelic.yml file after a new release, use the template in the base directory of the agent gem. When you update to new gem versions, examine or diff config/newrelic.yml and newrelic.yml in the installation directory to take advantage of new configuration options. Important Updating the gem does not automatically update config/newrelic.yml. General These settings are available for agent configuration. Some settings depend on your New Relic subscription level. license_key Type String Default \"\" Environ variable NEW_RELIC_LICENSE_KEY Your New Relic license key. agent_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_AGENT_ENABLED If true, allows the Ruby agent to run. app_name Type String Default (Dynamic) Environ variable NEW_RELIC_APP_NAME Specify the application name used to aggregate data in the New Relic UI. To report data to multiple apps at the same time, specify a list of names separated by a semicolon ;. For example, MyApp or MyStagingApp;Instance1. monitor_mode Type Boolean Default (Dynamic) Environ variable NEW_RELIC_MONITOR_MODE When true, the agent transmits data about your app to the New Relic collector. log_level Type String Default \"info\" Environ variable NEW_RELIC_LOG_LEVEL Sets the level of detail of log messages. Possible log levels, in increasing verbosity, are: error, warn, info or debug. high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY If true, enables high security mode. Ensure you understand the implications of high security mode before enabling this setting. security_policies_token Type String Default \"\" Environ variable NEW_RELIC_SECURITY_POLICIES_TOKEN Applies Language Agent Security Policy settings. proxy_host Type String Default nil Environ variable NEW_RELIC_PROXY_HOST Defines a host for communicating with the New Relic collector via a proxy server. proxy_port Type Integer Default 8080 Environ variable NEW_RELIC_PROXY_PORT Defines a port for communicating with the New Relic collector via a proxy server. proxy_user Type String Default nil Environ variable NEW_RELIC_PROXY_USER Defines a user for communicating with the New Relic collector via a proxy server. proxy_pass Type String Default nil Environ variable NEW_RELIC_PROXY_PASS Defines a password for communicating with the New Relic collector via a proxy server. capture_params Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_PARAMS When true, the agent captures HTTP request parameters and attaches them to transaction traces, traced errors, and TransactionError events. Caution When using the capture_params setting, the Ruby agent will not attempt to filter secret information. Recommendation: To filter secret information from request parameters, use the attributes.include setting instead. For more information, see the Ruby attribute examples. config_path Type String Default (Dynamic) Environ variable NEW_RELIC_CONFIG_PATH Path to newrelic.yml. If undefined, the agent checks the following directories (in order): config/newrelic.yml, newrelic.yml, $HOME/.newrelic/newrelic.yml and $HOME/newrelic.yml. apdex_t Type Float Default 0.5 Environ variable NEW_RELIC_APDEX_T DEPRECATED For agent versions 3.5.0 or higher, set your Apdex T via the New Relic UI. sync_startup Type Boolean Default false Environ variable NEW_RELIC_SYNC_STARTUP When set to true, forces a synchronous connection to the New Relic collector during application startup. For very short-lived processes, this helps ensure the New Relic agent has time to report. send_data_on_exit Type Boolean Default true Environ variable NEW_RELIC_SEND_DATA_ON_EXIT If true, enables the exit handler that sends data to the New Relic collector before shutting down. timeout Type Integer Default 120 Environ variable NEW_RELIC_TIMEOUT Defines the maximum number of seconds the agent should spend attempting to connect to the collector. force_install_exit_handler Type Boolean Default false Environ variable NEW_RELIC_FORCE_INSTALL_EXIT_HANDLER Forces the exit handler that sends all cached data to collector before shutting down to be installed regardless of detecting scenarios where it generally should not be. Known use-case for this option is where Sinatra is running as an embedded service within another framework and the agent is detecting the Sinatra app and skipping the at_exit handler as a result. Sinatra classically runs the entire application in an at_exit block and would otherwise misbehave if the Agent's at_exit handler was also installed in those circumstances. Note: send_data_on_exit should also be set to true in tandem with this setting. log_file_name Type String Default \"newrelic_agent.log\" Environ variable NEW_RELIC_LOG_FILE_NAME Defines a name for the log file. log_file_path Type String Default \"log/\" Environ variable NEW_RELIC_LOG_FILE_PATH Defines a path to the agent log file, excluding the filename. prepend_active_record_instrumentation Type Boolean Default false Environ variable NEW_RELIC_PREPEND_ACTIVE_RECORD_INSTRUMENTATION If true, uses Module#prepend rather than alias_method for ActiveRecord instrumentation. capture_memcache_keys Type Boolean Default false Environ variable NEW_RELIC_CAPTURE_MEMCACHE_KEYS Enable or disable the capture of memcache keys from transaction traces. message_tracer.segment_parameters.enabled Type Boolean Default true Environ variable NEW_RELIC_MESSAGE_TRACER_SEGMENT_PARAMETERS_ENABLED If true, the agent will collect metadata about messages and attach them as segment parameters. marshaller Type String Default \"json\" Environ variable NEW_RELIC_MARSHALLER Specifies a marshaller for transmitting data to the New Relic collector. Currently json is the only valid value for this setting. backport_fast_active_record_connection_lookup Type Boolean Default false Environ variable NEW_RELIC_BACKPORT_FAST_ACTIVE_RECORD_CONNECTION_LOOKUP Backports the faster ActiveRecord connection lookup introduced in Rails 6, which improves agent performance when instrumenting ActiveRecord. Note that this setting may not be compatible with other gems that patch ActiveRecord. labels Type String Default \"\" Environ variable NEW_RELIC_LABELS A dictionary of label names and values that will be applied to the data sent from this agent. May also be expressed as a semicolon-delimited ; string of colon-separated : pairs. For example, <var>Server</var>:<var>One</var>;<var>Data Center</var>:<var>Primary</var>. ca_bundle_path Type String Default nil Environ variable NEW_RELIC_CA_BUNDLE_PATH Manual override for the path to your local CA bundle. This CA bundle will be used to validate the SSL certificate presented by New Relic's data collection service. datastore_tracer.instance_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_INSTANCE_REPORTING_ENABLED If false, the agent will not report datastore instance metrics, nor add host or port_path_or_id parameters to transaction or slow SQL traces. datastore_tracer.database_name_reporting.enabled Type Boolean Default true Environ variable NEW_RELIC_DATASTORE_TRACER_DATABASE_NAME_REPORTING_ENABLED If false, the agent will not add database_name parameter to transaction or slow sql traces. clear_transaction_state_after_fork Type Boolean Default false Environ variable NEW_RELIC_CLEAR_TRANSACTION_STATE_AFTER_FORK If true, the agent will clear Tracer::State in Agent.drop_buffered_data. exclude_newrelic_header Type Boolean Default false Environ variable NEW_RELIC_EXCLUDE_NEWRELIC_HEADER Allows newrelic distributed tracing headers to be suppressed on outbound requests. infinite_tracing.trace_observer.host Type String Default \"\" Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST Configures the hostname for the Trace Observer Host. When configured, enables tail-based sampling by sending all recorded spans to a Trace Observer for further sampling decisions, irrespective of any usual agent sampling decision. infinite_tracing.trace_observer.port Type Integer Default 443 Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_PORT Configures the TCP/IP port for the Trace Observer Host Transaction Tracer The transaction traces feature collects detailed information from a selection of transactions, including a summary of the calling sequence, a breakdown of time spent, and a list of SQL queries and their query plans (on mysql and postgresql). Available features depend on your New Relic subscription level. transaction_tracer.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ENABLED If true, enables collection of transaction traces. transaction_tracer.transaction_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_TRANSACTION_THRESHOLD Specify a threshold in seconds. Transactions with a duration longer than this threshold are eligible for transaction traces. Specify a float value or the string apdex_f. transaction_tracer.record_sql Type String Default \"obfuscated\" Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_SQL Obfuscation level for SQL queries reported in transaction trace nodes. By default, this is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to none. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. transaction_tracer.record_redis_arguments Type Boolean Default false Environ variable NEW_RELIC_TRANSACTION_TRACER_RECORD_REDIS_ARGUMENTS If true, the agent records Redis command arguments in transaction traces. transaction_tracer.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_tracer.attributes.enabled instead. transaction_tracer.explain_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_THRESHOLD Threshold (in seconds) above which the agent will collect explain plans. Relevant only when explain_enabled is true. transaction_tracer.explain_enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_EXPLAIN_ENABLED If true, enables the collection of explain plans in transaction traces. This setting will also apply to explain plans in slow SQL traces if slow_sql.explain_enabled is not set separately. transaction_tracer.stack_trace_threshold Type Float Default 0.5 Environ variable NEW_RELIC_TRANSACTION_TRACER_STACK_TRACE_THRESHOLD Specify a threshold in seconds. The agent includes stack traces in transaction trace nodes when the stack trace duration exceeds this threshold. transaction_tracer.limit_segments Type Integer Default 4000 Environ variable NEW_RELIC_TRANSACTION_TRACER_LIMIT_SEGMENTS Maximum number of transaction trace nodes to record in a single transaction trace. Error Collector The agent collects and reports all uncaught exceptions by default. These configuration options allow you to customize the error collection. For information on ignored and expected errors, see this page on Error Analytics in APM. To set expected errors via the NewRelic::Agent.notice_error Ruby method, consult the Ruby Agent API. error_collector.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED If true, the agent captures traced errors and error count metrics. error_collector.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_ATTRIBUTES DEPRECATED Use error_collector.attributes.enabled instead. error_collector.ignore_errors Type String Default \"ActionController::RoutingError,Sinatra::NotFound\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS DEPRECATED Use error_collector.ignore_classes instead. Specify a comma-delimited list of error classes that the agent should ignore. Caution Server side configuration takes precedence for this setting over all environment configurations. This differs from all other configuration settings where environment variable take precedence over server side configuration. error_collector.ignore_classes Type Array Default [] Environ variable None A list of error classes that the agent should ignore. Caution This option can't be set via environment variable. error_collector.ignore_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be ignored. Caution This option can't be set via environment variable. error_collector.ignore_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be ignored. error_collector.expected_classes Type Array Default [] Environ variable None A list of error classes that the agent should treat as expected. Caution This option can't be set via environment variable. error_collector.expected_messages Type Hash Default {} Environ variable None A map of error classes to a list of messages. When an error of one of the classes specified here occurs, if its error message contains one of the strings corresponding to it here, that error will be treated as expected. Caution This option can't be set via environment variable. error_collector.expected_status_codes Type String Default \"\" Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_STATUS_CODES A comma separated list of status codes, possibly including ranges. Errors associated with these status codes, where applicable, will be treated as expected. error_collector.max_backtrace_frames Type Integer Default 50 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_BACKTRACE_FRAMES Defines the maximum number of frames in an error backtrace. Backtraces over this amount are truncated at the beginning and end. error_collector.capture_events Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_CAPTURE_EVENTS If true, the agent collects TransactionError events. error_collector.max_event_samples_stored Type Integer Default 100 Environ variable NEW_RELIC_ERROR_COLLECTOR_MAX_EVENT_SAMPLES_STORED Defines the maximum number of TransactionError events sent to Insights per harvest cycle. Browser Monitoring The browser monitoring page load timing feature (sometimes referred to as real user monitoring or RUM) gives you insight into the performance real users are experiencing with your website. This is accomplished by measuring the time it takes for your users' browsers to download and render your web pages by injecting a small amount of JavaScript code into the header and footer of each page. browser_monitoring.auto_instrument Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_AUTO_INSTRUMENT If true, enables auto-injection of the JavaScript header for page load timing (sometimes referred to as real user monitoring or RUM). browser_monitoring.capture_attributes Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_CAPTURE_ATTRIBUTES DEPRECATED Use browser_monitoring.attributes.enabled instead. Analytics Events New Relic dashboards is a resource to gather and visualize data about your software and what it says about your business. With it you can quickly and easily create real-time dashboards to get immediate answers about end-user experiences, clickstreams, mobile activities, and server transactions. analytics_events.enabled Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_ENABLED If true, enables analytics event sampling. analytics_events.max_samples_stored Type Integer Default 1200 Environ variable NEW_RELIC_ANALYTICS_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of request events reported from a single harvest. analytics_events.capture_attributes Type Boolean Default true Environ variable NEW_RELIC_ANALYTICS_EVENTS_CAPTURE_ATTRIBUTES DEPRECATED Use transaction_events.attributes.enabled instead. Attributes Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. transaction_tracer.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. transaction_events.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. error_collector.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. browser_monitoring.attributes.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent captures attributes from browser monitoring. span_events.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on span events. transaction_segments.attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes on transaction segments. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. transaction_tracer.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. transaction_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. error_collector.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. browser_monitoring.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. span_events.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from span events. Allows * as wildcard at end. transaction_segments.attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction segments. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include in all destinations. Allows * as wildcard at end. transaction_tracer.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. transaction_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. error_collector.attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. browser_monitoring.attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. span_events.attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on span events. Allows * as wildcard at end. transaction_segments.attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_SEGMENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include on transaction segments. Allows * as wildcard at end. Audit Log audit_log.enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED If true, enables an audit log which logs communications with the New Relic collector. audit_log.path Type String Default (Dynamic) Environ variable NEW_RELIC_AUDIT_LOG_PATH Specifies a path to the audit log file (including the filename). audit_log.endpoints Type Array Default [\".*\"] Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS List of allowed endpoints to include in audit log Autostart autostart.denylisted_constants Type String Default \"Rails::Console\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_CONSTANTS Specify a list of constants that should prevent the agent from starting automatically. Separate individual constants with a comma ,. For example, Rails::Console,UninstrumentedBackgroundJob. autostart.denylisted_executables Type String Default \"irb,rspec\" Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_EXECUTABLES Defines a comma-delimited list of executables that the agent should not instrument. For example, rake,my_ruby_script.rb. autostart.denylisted_rake_tasks Type String Default Copy Environ variable NEW_RELIC_AUTOSTART_DENYLISTED_RAKE_TASKS Defines a comma-delimited list of Rake tasks that the agent should not instrument. For example, assets:precompile,db:migrate. Cross Application Tracer cross_application_tracer.enabled Type Boolean Default false Environ variable NEW_RELIC_CROSS_APPLICATION_TRACER_ENABLED DEPRECATED Please see: distributed_tracing-enabled. If true, enables cross-application tracing when distributed_tracing.enabled is set to false. Custom Attributes custom_attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_ATTRIBUTES_ENABLED If false, custom attributes will not be sent on Insights events. Custom Insights Events custom_insights_events.enabled Type Boolean Default true Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_ENABLED If true, the agent captures New Relic Insights custom events. custom_insights_events.max_samples_stored Type Integer Default 1000 Environ variable NEW_RELIC_CUSTOM_INSIGHTS_EVENTS_MAX_SAMPLES_STORED Specify a maximum number of custom Insights events to buffer in memory at a time. Disabling Use these settings to toggle instrumentation types during agent startup. disable_rake Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RAKE DEPRECATED Please see: instrumentation.rake. If true, disables Rake instrumentation. disable_samplers Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SAMPLERS If true, disables the collection of sampler metrics. Sampler metrics are metrics that are not event-based (such as CPU time or memory usage). disable_resque Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RESQUE DEPRECATED Please see: instrumentation.resque. If true, disables Resque instrumentation. disable_sidekiq Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SIDEKIQ If true, disables Sidekiq instrumentation. disable_dj Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DJ DEPRECATED Please see: instrumentation.delayed_job. If true, disables Delayed::Job instrumentation. disable_sinatra Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA DEPRECATED Please see: instrumentation.sinatra. If true , disables Sinatra instrumentation. disable_sinatra_auto_middleware Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SINATRA_AUTO_MIDDLEWARE If true, disables agent middleware for Sinatra. This middleware is responsible for advanced feature support such as cross application tracing, page load timing, and error collection. Important Cross application tracing is deprecated in favor of distributed tracing. Distributed tracing is on by default for Ruby agent versions 8.0.0 and above. Middlewares are not required to support distributed tracing. To continue using cross application tracing, update the following options in your newrelic.yml configuration file: # newrelic.yml cross_application_tracer: enabled: true distributed_tracing: enabled: false Copy disable_view_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VIEW_INSTRUMENTATION If true, disables view instrumentation. disable_activerecord_instrumentation Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_ACTIVERECORD_INSTRUMENTATION If true, disables active record instrumentation. disable_data_mapper Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATA_MAPPER If true, disables DataMapper instrumentation. disable_activejob Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVEJOB If true, disables ActiveJob instrumentation. disable_action_cable_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTION_CABLE_INSTRUMENTATION If true, disables Action Cable instrumentation. disable_active_storage Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_STORAGE If true, disables ActiveStorage instrumentation. disable_memcached Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHED DEPRECATED Please see: instrumentation.memcached. If true, disables instrumentation for the memcached gem. disable_memcache_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_MEMCACHE_CLIENT DEPRECATED Please see: instrumentation.memcache-client. If true, disables instrumentation for the memcache-client gem. disable_dalli Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem. disable_dalli_cas_client Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_DALLI_CAS_CLIENT DEPRECATED Please see: instrumentation.memcache. If true, disables instrumentation for the dalli gem's additional CAS client support. disable_memcache_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMCACHE_INSTRUMENTATION DEPRECATED Please see: instrumentation.memcache. If true, disables memcache instrumentation. disable_gc_profiler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GC_PROFILER If true, disables the use of GC::Profiler to measure time spent in garbage collection disable_sequel_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_SEQUEL_INSTRUMENTATION If true, disables Sequel instrumentation. disable_database_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DATABASE_INSTRUMENTATION DEPRECATED Use disable_sequel_instrumentation instead. disable_mongo Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MONGO DEPRECATED Please see: instrumentation.mongo. If true, the agent won't install instrumentation for the Mongo gem. disable_redis Type Boolean Default false Environ variable NEW_RELIC_DISABLE_REDIS DEPRECATED Please see: instrumentation.redis. If true, the agent won't install instrumentation for Redis. disable_vm_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_VM_SAMPLER If true, the agent won't sample performance measurements from the Ruby VM. disable_memory_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MEMORY_SAMPLER If true, the agent won't sample the memory usage of the host process. disable_cpu_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CPU_SAMPLER If true, the agent won't sample the CPU usage of the host process. disable_delayed_job_sampler Type Boolean Default false Environ variable NEW_RELIC_DISABLE_DELAYED_JOB_SAMPLER If true, the agent won't measure the depth of Delayed Job queues. disable_active_record_notifications Type Boolean Default false Environ variable NEW_RELIC_DISABLE_ACTIVE_RECORD_NOTIFICATIONS If true, disables instrumentation for ActiveRecord 4, 5, and 6. disable_bunny Type Boolean Default false Environ variable NEW_RELIC_DISABLE_BUNNY DEPRECATED Please see: instrumentation.bunny. If true, disables instrumentation for the bunny gem. disable_curb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_CURB DEPRECATED Please see: instrumentation.curb. If true, disables instrumentation for the curb gem. disable_excon Type Boolean Default false Environ variable NEW_RELIC_DISABLE_EXCON DEPRECATED Please see: instrumentation.excon. If true, disables instrumentation for the excon gem. disable_httpclient Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPCLIENT DEPRECATED Please see: instrumentation.httpclient. If true, disables instrumentation for the httpclient gem. disable_net_http Type Boolean Default false Environ variable NEW_RELIC_DISABLE_NET_HTTP DEPRECATED Please see: instrumentation.net_http. If true, disables instrumentation for Net::HTTP. disable_rack Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK DEPRECATED Please see: instrumentation.rack. If true, prevents the agent from hooking into the to_app method in Rack::Builder to find gems to instrument during application startup. disable_rack_urlmap Type Boolean Default false Environ variable NEW_RELIC_DISABLE_RACK_URLMAP DEPRECATED Please see: instrumentation.rack_urlmap. If true, prevents the agent from hooking into Rack::URLMap to install middleware tracing. disable_puma_rack Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK DEPRECATED Please see: instrumentation.puma_rack. If true, prevents the agent from hooking into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. disable_puma_rack_urlmap Type Boolean Default (Dynamic) Environ variable NEW_RELIC_DISABLE_PUMA_RACK_URLMAP DEPRECATED Please see: instrumentation.puma_rack_urlmap. If true, prevents the agent from hooking into Puma::Rack::URLMap to install middleware tracing. disable_typhoeus Type Boolean Default false Environ variable NEW_RELIC_DISABLE_TYPHOEUS DEPRECATED Please see: instrumentation.typhoeus. If true, the agent won't install instrumentation for the typhoeus gem. disable_httprb Type Boolean Default false Environ variable NEW_RELIC_DISABLE_HTTPRB DEPRECATED Please see: instrumentation.httprb. If true, the agent won't install instrumentation for the http.rb gem. disable_middleware_instrumentation Type Boolean Default false Environ variable NEW_RELIC_DISABLE_MIDDLEWARE_INSTRUMENTATION If true, the agent won't wrap third-party middlewares in instrumentation (regardless of whether they are installed via Rack::Builder or Rails). disable_grape Type Boolean Default false Environ variable NEW_RELIC_DISABLE_GRAPE DEPRECATED Please see: instrumentation.grape. If true, the agent won't install Grape instrumentation. Distributed Tracing distributed_tracing.enabled Type Boolean Default true Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Distributed tracing lets you see the path that a request takes through your distributed system. Enabling distributed tracing changes the behavior of some New Relic features, so carefully consult the transition guide before you enable this feature. Heroku heroku.use_dyno_names Type Boolean Default true Environ variable NEW_RELIC_HEROKU_USE_DYNO_NAMES If true, the agent uses Heroku dyno names as the hostname. heroku.dyno_name_prefixes_to_shorten Type Array Default [\"scheduler\", \"run\"] Environ variable NEW_RELIC_HEROKU_DYNO_NAME_PREFIXES_TO_SHORTEN Ordinarily the agent reports dyno names with a trailing dot and process ID (for example, worker.3). You can remove this trailing data by specifying the prefixes you want to report without trailing data (for example, worker). Instrumentation instrumentation.net_http Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_NET_HTTP Controls auto-instrumentation of Net::HTTP at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.typhoeus Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_TYPHOEUS Controls auto-instrumentation of Typhoeus at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.bunny Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_BUNNY Controls auto-instrumentation of bunny at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httprb Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_HTTPRB Controls auto-instrumentation of http.rb gem at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.resque Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_RESQUE Controls auto-instrumentation of resque at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.redis Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_REDIS Controls auto-instrumentation of Redis at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rake Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_RAKE Controls auto-instrumentation of rake at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.mongo Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_MONGO Controls auto-instrumentation of Mongo at start up. May be one of [enabled|disabled] . instrumentation.delayed_job Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_DELAYED_JOB Controls auto-instrumentation of Delayed Job at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.httpclient Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_HTTPCLIENT Controls auto-instrumentation of HTTPClient at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.curb Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_CURB Controls auto-instrumentation of Curb at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.sinatra Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_SINATRA Controls auto-instrumentation of Sinatra at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.rack Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_RACK Controls auto-instrumentation of Rack. When enabled, the agent hooks into the to_app method in Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.rack_urlmap Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_RACK_URLMAP Controls auto-instrumentation of Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK Controls auto-instrumentation of Puma::Rack. When enabled, the agent hooks into the to_app method in Puma::Rack::Builder to find gems to instrument during application startup. May be one of [auto|prepend|chain|disabled] . instrumentation.puma_rack_urlmap Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_PUMA_RACK_URLMAP Controls auto-instrumentation of Puma::Rack::URLMap at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcached Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHED Controls auto-instrumentation of memcached gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache_client Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE_CLIENT Controls auto-instrumentation of memcache-client gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.memcache Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_MEMCACHE Controls auto-instrumentation of dalli gem for Memcache at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.logger Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_LOGGER Controls auto-instrumentation of Ruby standard library Logger at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.tilt Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_TILT Controls auto-instrumentation of the Tilt template rendering library at start up. May be one of [auto|prepend|chain|disabled] . instrumentation.excon Type String Default (Dynamic) Environ variable NEW_RELIC_INSTRUMENTATION_EXCON Controls auto-instrumentation of Excon at start up. May be one of [enabled|disabled] . instrumentation.grape Type String Default \"auto\" Environ variable NEW_RELIC_INSTRUMENTATION_GRAPE Controls auto-instrumentation of Grape at start up. May be one of [auto|prepend|chain|disabled] . Mongo mongo.capture_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_CAPTURE_QUERIES If true, the agent captures Mongo queries in transaction traces. mongo.obfuscate_queries Type Boolean Default true Environ variable NEW_RELIC_MONGO_OBFUSCATE_QUERIES If true, the agent obfuscates Mongo queries in transaction traces. Process Host process_host.display_name Type String Default (Dynamic) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom host name for display in the New Relic UI. Rake rake.tasks Type Array Default [] Environ variable NEW_RELIC_RAKE_TASKS Specify an array of Rake tasks to automatically instrument. rake.connect_timeout Type Integer Default 10 Environ variable NEW_RELIC_RAKE_CONNECT_TIMEOUT Timeout for waiting on connect to complete before a rake task Resque resque.capture_params Type Boolean Default false Environ variable NEW_RELIC_RESQUE_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Resque. Rules rules.ignore_url_regexes Type Array Default [] Environ variable NEW_RELIC_RULES_IGNORE_URL_REGEXES Define transactions you want the agent to ignore, by specifying a list of patterns matching the URI you want to ignore. See documentation on (ignoring specific transactions) [https://docs.newrelic.com/docs/agents/ruby-agent/api-guides/ignoring-specific-transactions/#config-ignoring] for more details. Sidekiq sidekiq.capture_params Type Boolean Default false Environ variable NEW_RELIC_SIDEKIQ_CAPTURE_PARAMS DEPRECATED If true, enables the capture of job arguments for transaction traces and traced errors in Sidekiq. Slow SQL slow_sql.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_ENABLED If true, the agent collects slow SQL queries. slow_sql.explain_threshold Type Float Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_THRESHOLD Specify a threshold in seconds. The agent collects slow SQL queries and explain plans that exceed this threshold. slow_sql.explain_enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_EXPLAIN_ENABLED If true, the agent collects explain plans in slow SQL queries. If this setting is omitted, the transaction_tracer.explain_enabled setting will be applied as the default setting for explain plans in slow SQL as well. slow_sql.record_sql Type String Default (Dynamic) Environ variable NEW_RELIC_SLOW_SQL_RECORD_SQL Defines an obfuscation level for slow SQL queries. Valid options are obfuscated, raw, or none). slow_sql.use_longer_sql_id Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_USE_LONGER_SQL_ID Generate a longer sql_id for slow SQL traces. sql_id is used for aggregation of similar queries. Span Events span_events.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED If true, enables span event sampling. span_events.queue_size Type Integer Default 10000 Environ variable NEW_RELIC_SPAN_EVENTS_QUEUE_SIZE Sets the maximum number of span events to buffer when streaming to the trace observer. span_events.max_samples_stored Type Integer Default 2000 Environ variable NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED Defines the maximum number of span events reported from a single harvest. Any Integer between 1 and 10000 is valid. Strip Exception Messages strip_exception_messages.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ENABLED If true, the agent strips messages from all exceptions except those in the allowlist. Enabled automatically in high security mode. strip_exception_messages.allowed_classes Type String Default \"\" Environ variable NEW_RELIC_STRIP_EXCEPTION_MESSAGES_ALLOWED_CLASSES Specify a list of exceptions you do not want the agent to strip when strip_exception_messages is true. Separate exceptions with a comma. For example, \"ImportantException,PreserveMessageException\". Thread Profiler thread_profiler.enabled Type Boolean Default (Dynamic) Environ variable NEW_RELIC_THREAD_PROFILER_ENABLED If true, enables use of the thread profiler. Utilization utilization.detect_aws Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AWS If true, the agent automatically detects that it is running in an AWS environment. utilization.detect_azure Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_AZURE If true, the agent automatically detects that it is running in an Azure environment. utilization.detect_gcp Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_GCP If true, the agent automatically detects that it is running in an Google Cloud Platform environment. utilization.detect_pcf Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_PCF If true, the agent automatically detects that it is running in a Pivotal Cloud Foundry environment. utilization.detect_docker Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_DOCKER If true, the agent automatically detects that it is running in Docker. utilization.detect_kubernetes Type Boolean Default true Environ variable NEW_RELIC_UTILIZATION_DETECT_KUBERNETES If true, the agent automatically detects that it is running in Kubernetes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.23638,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>configuration</em>",
        "sections": "Ruby <em>agent</em> <em>configuration</em>",
        "tags": "<em>Agents</em>",
        "body": "You can configure the New Relic Ruby <em>agent</em> with settings in a <em>configuration</em> file, environment variables, or programmatically with server-side <em>configuration</em>. This document summarizes the <em>configuration</em> options available for the Ruby <em>agent</em>. If the default value for a <em>configuration</em> option is (Dynamic"
      },
      "id": "617dc153196a678548f7c17e"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/configuration/view-config-values-your-app": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.99258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "sections": [
        "High security mode",
        "Requirements",
        "Account level",
        "Enable high security mode (version 2)",
        "Caution",
        "Results of enabling high security mode (version 2)",
        "Results of enabling high security mode v1 (deprecated)",
        "Migrate from version 1 to version 2"
      ],
      "title": "High security mode",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "460ad5339fa585b7fcf6db77644b85ddf015c7d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/high-security-mode/",
      "published_at": "2021-12-05T06:33:24Z",
      "updated_at": "2021-11-15T11:26:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's default APM agent settings provide a high level of security. However, you may need to guarantee that even if the default APM agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on APM's high security mode (also known as enterprise security mode). For more information about our security measures, see our security and privacy documentation, or visit the New Relic security website. Requirements Customers on our New Relic One pricing model require Enterprise edition. Customers on our original pricing model have access depending on their subscription level. Account level If you choose to turn on high security, you must enable high security for all applications reporting to the account. High security must be set on each individual account. For organizations that have a parent/child account structure, child accounts don't automatically inherit the high security setting when enabled on the parent account. Currently there are two versions of high security mode. Version 1 is deprecated and is only available if you already have it. If you are enabling high security mode for the first time, the only option is version 2 (v2). Agent Version 2 support C SDK n/a Go All versions Java 3.7 or higher (enabled by default) .NET 3.3 or higher Node.js 1.7.0 or higher PHP 4.9 or higher Python 2.22.0.0 or higher Ruby 3.9.1 or higher Enable high security mode (version 2) To enable high security, you must update both the local configuration on your server and the remote configuration in the UI. Caution Once you enable high security for an account, high security cannot be turned off without assistance from New Relic Support. Setting location Description Set in UI To set high security in the UI: Go to one.newrelic.com, click the account dropdown and select Account settings. On that page, select High security mode. If you are on our original pricing model, only the account owner can view this option. If the agent is configured for high security via the UI but not locally, then the agent connections will be rejected, and the agent will shut down. However, this won't shut down your application. Local, via agent Enable high security mode in your agent configuration file. High security mode is disabled by default, and the exact procedure to enable it varies by agent: C SDK: n/a Go Java .NET Node.js PHP Python Ruby If the agent is configured for high security locally but not via the UI, then the agent connections will be rejected, and the agent will shut down. This will not shut down your application. Results of enabling high security mode (version 2) Once enabled, high security mode (v2) ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires a secure (HTTPS) connection. Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure all data in transit per the latest industry standards. Prevents HTTP param capture High security mode does not allow HTTP params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send HTTP params locally or through server-side configuration, high security mode will override the configuration to never capture HTTP params. Prevents message queue param capture High security mode does not allow message queue params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send message queue params locally or through server-side configuration, then high security mode will override the configuration to never capture message queue params. Prevents raw query statement capture High security mode does not allow raw database query statements, which may contain sensitive customer data, to be captured. If the agent is configured to capture raw queries locally or through server-side configuration, then high security mode will override the configuration to never capture raw queries. Prevents user attribute capture High security mode does not allow attributes set using each agent's API to be captured, as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.addCustomParameter(String key, String value) Copy NewRelic.addCustomParameter(String key, Number value) Copy NewRelic.setUserName(String name) Copy NewRelic.setAccountName(String name) Copy NewRelic.setProductName(String name) Copy Prevents noticeError attribute capture High security mode does not allow attributes set using each agent's noticeError API call to be captured as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.noticeError(String message, Map<String, String> params) Copy NewRelic.noticeError(Throwable throwable, Map<String, String> params) Copy Prevents custom events High security mode does not allow custom events to be created using the agent API, as these may contain sensitive customer data. For example, in the .NET agent, the API call RecordCustomEvent will be blocked. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Results of enabling high security mode v1 (deprecated) High security mode version 1 is deprecated and only available if you enabled it prior to version 2 being available. High security mode version 1 ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure that all data in transit is encrypted as per the latest industry standards. Prevents HTTP param capture Agents configured to capture HTTP params, which may contain sensitive customer data, are not allowed to connect to New Relic. If the local configuration is set to capture request parameters, then New Relic's collector will reject the connection, and the agent will shut down. Prevents raw query statement capture Agents configured to capture raw database query statements, which may contain sensitive customer data, are not allowed to connect to New Relic. If the agent is configured to capture raw queries locally or through server-side configuration, New Relic's collector will reject the connection and the agent will shut down. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Migrate from version 1 to version 2 These are the main differences between the two versions of high security: In order to make high security even more secure, high security must be enabled in the New Relic user interface and in the local New Relic configuration file. High security v1 only required high security to be set in the New Relic UI. User attributes, noticeError attributes, and message queue parameters are turned off with high security in version 2, but not in version 1. To update from v1 to v2, add high_security: true to your local agent configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.50143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic <em>agents</em> support HTTPS. If the <em>configuration</em> is not set appropriately, the <em>agent</em> will override the property to ensure that all data in transit is encrypted as per the latest"
      },
      "id": "617e646328ccbc8b5a7ff3ac"
    },
    {
      "sections": [
        "Enable configurable security policies",
        "Tip",
        "Compatibility and requirements",
        "Caution",
        "Example configuration",
        "Java agent: YAML example",
        ".NET agent: XML example",
        "Ruby agent: YAML example",
        "Available policy options"
      ],
      "title": "Enable configurable security policies",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "e0027e4ca72d231ea54847b3b7cf7cf8be0c7df6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/enable-configurable-security-policies/",
      "published_at": "2021-12-05T06:08:24Z",
      "updated_at": "2021-10-31T09:38:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Tip APM's configurable security policies is available in limited release for approved New Relic accounts. If you are a New Relic customer and interested in the limited release of configurable security policies, contact your New Relic sales rep. APM's configurable security policies gives you granular control over configuration options related to your account's data security. This document explains how to enable account-wide security policies and the options available. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Compatibility and requirements APM agent versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security policies Caution Security policies apply account-wide. Once enabled, they can only be edited or disabled with the help of New Relic support. If high security mode is enabled for the account(s), do not disable it. Account-level high security mode differs from your APM agent's high security mode, which is set in the configuration file. High security mode and configurable security policies do not apply to Lambda monitoring or use of the New Relic Event API. For the limited release, there is no UI component. If you are participating in the limited release, follow this procedure to set up your accounts: Choose the accounts on which to enable configurable security policies. Choose the configurable security policies options that you want for those accounts. Inform your New Relic sales rep of the options that you have chosen. Ensure your agent versions support this feature. Update agents if necessary. When you receive the security token based on the security policies options that you chose, insert the security token into the agent configuration file(s). See examples. Delete the high security mode enabled flag from your config file(s). High security mode (HSM) at the agent level is different than high security mode at the account level. Be sure to disable HSM in the agent's config file, as explained in this procedure. Having both the security token and the HSM flag will result in the agent disconnecting. Example configuration Here are some example configuration examples for enabling the configurable security policies: Java agent: YAML example The Java agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy .NET agent: XML example The .NET agent uses a XML file for configuration. Here is an example snippet enabling security policies: ... <configuration agentenabled=\"true\" xmlns=\"urn:newrelic-config\"> <service licensekey=\"YOUR_LICENSE_KEY\"> <application> <name>YOUR_APPLICATION_NAME</name> </application> <securityPoliciesToken>YOUR_TOKEN</securityPoliciesToken> <log level=\"info\"> </log></service></configuration> ... Copy If you prefer to use an environment variable, it would look like this: NEW_RELIC_SECURITY_POLICIES_TOKEN=YOUR_TOKEN Copy Ruby agent: YAML example The Ruby agent uses a YAML file for configuration. Here is an example snippet enabling security policies: common: &default_settings license_key: 'YOUR_LICENSE_KEY' app_name: 'YOUR_APPLICATION_NAME' security_policies_token: 'YOUR_TOKEN' production: <<: *default_settings log_level: info Copy Available policy options Here are the settings you can choose when creating your policies. Some of these options will not be available for some agents. Setting Effect Database query collection Options: Enabled: Collects obfuscated database query data. Obfuscated queries generally appear along with slow query details in the APM or New Relic One UI. Disabled: Prevents the collection of obfuscated database query data. Raw query data is not collected once configurable security policies is enabled. attributes.include list Go, Java, .NET, Node.js, Ruby only Options: Enabled: attributes.include list functions normally; attribute keys found in the attributes.include list are recorded. Disabled: Ignores the list of allowed attributes listed in the attributes.include property in agent configuration; no intrinsic request parameter attributes will be collected. Whitelisting attributes at the account level is not supported. Raw exception messages Options: Enabled: Allows recording of all raw exception messages. Disabled: Prevents recording of all raw exception messages. The messages may be either obfuscated or completely removed, depending on the agent. Custom events Options: Enabled: Allows the recording of custom events that are created and sent up via an agent API. Disabled: Prevents recording of any custom events collect by an agent API. Custom attributes Options: Enabled: Allows for the collection of custom attributes passed in by the New Relic agent. Disabled: Prevents collection of custom attributes that are collected by the New Relic agent. Custom instrumentation editor Java only Options: Enabled: Allows custom instrumentation of the agent, using the custom instrumentation editor. Disabled: Prevents custom instrumentation of the agent using the custom instrumentation editor. Instrumentation previously done via the editor is also disabled. Access to the custom instrumentation editor is only available to New Relic account Owners and Admins. Message parameters Java and Ruby only Options: Enabled: Allows the collection of message parameters (message.parameters.*). Disabled: Prevents collection of message parameters. Job arguments Ruby only Options: Enabled: Allows the collection of job arguments (job.(type).args.*). Disabled: Prevents the collection of job arguments.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.80762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable <em>configurable</em> security policies",
        "sections": "Enable <em>configurable</em> security policies",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " security website. Compatibility and requirements <em>APM</em> <em>agent</em> versions that support this feature include: C SDK: not available Go: 2.1 or higher Java: 4.1 or higher .NET: 8.1 or higher Node.js: 4.1 or higher PHP: 8.1 or higher Python: not available Ruby: 5.2 or higher Enable configurable security"
      },
      "id": "617e6431e7b9d23689c05c1f"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/troubleshooting/agent-nrintegrationerrors-appear-insights": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.81866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "sections": [
        "Get environment data about your APM app",
        "Problem",
        "Solution"
      ],
      "title": "Get environment data about your APM app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Troubleshooting"
      ],
      "external_id": "07870669016a0c24b9cd50fcf67966ea55ef9b49",
      "image": "https://docs.newrelic.com/static/1a6d2627ddd9082d34cdd5b81cc29035/c1b63/troubleshooting-apm-environment.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/troubleshooting/get-environment-data-about-your-apm-app/",
      "published_at": "2021-12-05T06:03:03Z",
      "updated_at": "2021-10-23T19:51:07Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You need an easy way to get information about your application's environment, such as: What services a particular agent version is using What apps have outdated agent versions What hosts use which agents What values apply to specific agent settings Solution To see which services and settings apply to an agent, or to see which agent uses a specific service or setting, go to one.newrelic.com. Click on your app in the list, then click Settings > Environment > Environment snapshot. The Environment snapshot page helps you connect payloads from agents that include environment data, so you have a sense of what monitoring data is recorded. This also helps you more easily identify discrepancies across your services, and determine what might need to be updated. In the following example, the user mouses over the second agent on the list. Most of the settings for this agent are consistent with others, but it's easy to see specific host settings for logical processors, physical cores, and Ruby patch levels. Also notice that this agent is using an earlier Ruby version. one.newrelic.com > APM > Settings > Environment > Environment snapshot: To see specific settings that apply to an agent and its services, or to see which of a setting's values apply to specific agents, mouse over any agent or value. Information on the Environment snapshot page depends on the APM agent you use. For example, apps using the Ruby agent show settings for gems, while apps using the Java agent show settings for jars.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.98535,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get environment data about your <em>APM</em> app",
        "sections": "Get environment data about your <em>APM</em> app",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " and its services, or to see which of a setting&#x27;s values apply to specific <em>agents</em>, mouse over any <em>agent</em> or value. Information on the Environment snapshot page depends on the <em>APM</em> <em>agent</em> you use. For example, apps using the Ruby <em>agent</em> show settings for gems, while apps using the Java <em>agent</em> show settings for jars."
      },
      "id": "617e649c28ccbc8b5a7ff459"
    },
    {
      "sections": [
        "High security mode",
        "Requirements",
        "Account level",
        "Enable high security mode (version 2)",
        "Caution",
        "Results of enabling high security mode (version 2)",
        "Results of enabling high security mode v1 (deprecated)",
        "Migrate from version 1 to version 2"
      ],
      "title": "High security mode",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "460ad5339fa585b7fcf6db77644b85ddf015c7d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/high-security-mode/",
      "published_at": "2021-12-05T06:33:24Z",
      "updated_at": "2021-11-15T11:26:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's default APM agent settings provide a high level of security. However, you may need to guarantee that even if the default APM agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on APM's high security mode (also known as enterprise security mode). For more information about our security measures, see our security and privacy documentation, or visit the New Relic security website. Requirements Customers on our New Relic One pricing model require Enterprise edition. Customers on our original pricing model have access depending on their subscription level. Account level If you choose to turn on high security, you must enable high security for all applications reporting to the account. High security must be set on each individual account. For organizations that have a parent/child account structure, child accounts don't automatically inherit the high security setting when enabled on the parent account. Currently there are two versions of high security mode. Version 1 is deprecated and is only available if you already have it. If you are enabling high security mode for the first time, the only option is version 2 (v2). Agent Version 2 support C SDK n/a Go All versions Java 3.7 or higher (enabled by default) .NET 3.3 or higher Node.js 1.7.0 or higher PHP 4.9 or higher Python 2.22.0.0 or higher Ruby 3.9.1 or higher Enable high security mode (version 2) To enable high security, you must update both the local configuration on your server and the remote configuration in the UI. Caution Once you enable high security for an account, high security cannot be turned off without assistance from New Relic Support. Setting location Description Set in UI To set high security in the UI: Go to one.newrelic.com, click the account dropdown and select Account settings. On that page, select High security mode. If you are on our original pricing model, only the account owner can view this option. If the agent is configured for high security via the UI but not locally, then the agent connections will be rejected, and the agent will shut down. However, this won't shut down your application. Local, via agent Enable high security mode in your agent configuration file. High security mode is disabled by default, and the exact procedure to enable it varies by agent: C SDK: n/a Go Java .NET Node.js PHP Python Ruby If the agent is configured for high security locally but not via the UI, then the agent connections will be rejected, and the agent will shut down. This will not shut down your application. Results of enabling high security mode (version 2) Once enabled, high security mode (v2) ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires a secure (HTTPS) connection. Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure all data in transit per the latest industry standards. Prevents HTTP param capture High security mode does not allow HTTP params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send HTTP params locally or through server-side configuration, high security mode will override the configuration to never capture HTTP params. Prevents message queue param capture High security mode does not allow message queue params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send message queue params locally or through server-side configuration, then high security mode will override the configuration to never capture message queue params. Prevents raw query statement capture High security mode does not allow raw database query statements, which may contain sensitive customer data, to be captured. If the agent is configured to capture raw queries locally or through server-side configuration, then high security mode will override the configuration to never capture raw queries. Prevents user attribute capture High security mode does not allow attributes set using each agent's API to be captured, as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.addCustomParameter(String key, String value) Copy NewRelic.addCustomParameter(String key, Number value) Copy NewRelic.setUserName(String name) Copy NewRelic.setAccountName(String name) Copy NewRelic.setProductName(String name) Copy Prevents noticeError attribute capture High security mode does not allow attributes set using each agent's noticeError API call to be captured as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.noticeError(String message, Map<String, String> params) Copy NewRelic.noticeError(Throwable throwable, Map<String, String> params) Copy Prevents custom events High security mode does not allow custom events to be created using the agent API, as these may contain sensitive customer data. For example, in the .NET agent, the API call RecordCustomEvent will be blocked. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Results of enabling high security mode v1 (deprecated) High security mode version 1 is deprecated and only available if you enabled it prior to version 2 being available. High security mode version 1 ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure that all data in transit is encrypted as per the latest industry standards. Prevents HTTP param capture Agents configured to capture HTTP params, which may contain sensitive customer data, are not allowed to connect to New Relic. If the local configuration is set to capture request parameters, then New Relic's collector will reject the connection, and the agent will shut down. Prevents raw query statement capture Agents configured to capture raw database query statements, which may contain sensitive customer data, are not allowed to connect to New Relic. If the agent is configured to capture raw queries locally or through server-side configuration, New Relic's collector will reject the connection and the agent will shut down. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Migrate from version 1 to version 2 These are the main differences between the two versions of high security: In order to make high security even more secure, high security must be enabled in the New Relic user interface and in the local New Relic configuration file. High security v1 only required high security to be set in the New Relic UI. User attributes, noticeError attributes, and message queue parameters are turned off with high security in version 2, but not in version 1. To update from v1 to v2, add high_security: true to your local agent configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.74852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "New Relic&#x27;s default <em>APM</em> <em>agent</em> settings provide a high level of security. However, you may need to guarantee that even if the default <em>APM</em> <em>agent</em> settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on <em>APM</em>"
      },
      "id": "617e646328ccbc8b5a7ff3ac"
    }
  ],
  "/docs/apm/agents/manage-apm-agents/troubleshooting/get-environment-data-about-your-apm-app": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "487aff56ffce5c35d019e9871fbbf58d5f74b855",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-12-05T05:31:31Z",
      "updated_at": "2021-11-25T11:58:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with tags. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.81863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single New Relic-monitored app. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work with each"
      },
      "id": "617e63f3196a6757faf7c315"
    },
    {
      "sections": [
        "APM agent NRIntegrationError config mismatch issue",
        "Problem",
        "Solution",
        "Go",
        "Tip",
        "Java",
        ".NET",
        "Node.js",
        "Python",
        "Ruby"
      ],
      "title": "APM agent NRIntegrationError config mismatch issue",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Troubleshooting"
      ],
      "external_id": "32e59fa3b63faa8465002f68055ba92dce9f838b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/troubleshooting/agent-nrintegrationerrors-appear-insights/",
      "published_at": "2021-12-05T05:36:31Z",
      "updated_at": "2021-10-23T19:52:29Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem An NrIntegrationError event is generated that has the following message: Configuration mismatch: Agent configured harvest limit for EVENT TYPE exceeds maximum limit; limit adjusted to LIMIT Copy Solution This is caused by a configuration mismatch with the agent. See the relevant agent solution to resolve your configuration mismatch: Go In your newrelic.Config: For transaction events, adjust the value of TransactionEvents.MaxSamplesStored. Tip The Go Agent currently does not support adjusting this value for custom events. Java In your newrelic.yml: For transaction events, adjust the value of transaction_events.max_samples_stored. For custom events, adjust the value of custom_events.max_samples_stored. .NET In your newrelic.config: For transaction events, adjust the value of the maximumSamplesStored attribute under the transactionEvents element. For custom events, adjust the value of the maximumSamplesStored attribute under the customEvents element. Node.js For transaction events, in the transaction_events: { section of your app's newrelic.js, adjust the value of max_samples_per_minute. For custom events, in the custom_insights_events: { section of your app's newrelic.js, adjust the value of max_samples_stored. Python In your newrelic.ini: For transaction events, adjust the value of event_harvest_config. harvest_limits.analytic_event_data. For custom events, adjust the value of event_harvest_config.harvest_limits.custom_event_data. For error events, adjust the value of event_harvest_config.harvest_limits.error_event_data. For span events, adjust the value of event_harvest_config.harvest_limits.span_event_data. Ruby In your newrelic.yml: For transaction events, adjust the value of analytics_events.max_samples_stored. For custom events, adjust the value of custom_events.max_samples_stored. For error events, adjust the value of error_collector.max_event_samples_stored. Tip This error does not apply to the C SDK or PHP agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.59955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>APM</em> <em>agent</em> NRIntegrationError config mismatch issue",
        "sections": "<em>APM</em> <em>agent</em> NRIntegrationError config mismatch issue",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "Problem An NrIntegrationError event is generated that has the following message: Configuration mismatch: <em>Agent</em> configured harvest limit for EVENT TYPE exceeds maximum limit; limit adjusted to LIMIT Copy Solution This is caused by a configuration mismatch with the <em>agent</em>. See the relevant <em>agent</em>"
      },
      "id": "617e521e196a675a64f7e648"
    },
    {
      "sections": [
        "High security mode",
        "Requirements",
        "Account level",
        "Enable high security mode (version 2)",
        "Caution",
        "Results of enabling high security mode (version 2)",
        "Results of enabling high security mode v1 (deprecated)",
        "Migrate from version 1 to version 2"
      ],
      "title": "High security mode",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "460ad5339fa585b7fcf6db77644b85ddf015c7d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/manage-apm-agents/configuration/high-security-mode/",
      "published_at": "2021-12-05T06:33:24Z",
      "updated_at": "2021-11-15T11:26:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's default APM agent settings provide a high level of security. However, you may need to guarantee that even if the default APM agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on APM's high security mode (also known as enterprise security mode). For more information about our security measures, see our security and privacy documentation, or visit the New Relic security website. Requirements Customers on our New Relic One pricing model require Enterprise edition. Customers on our original pricing model have access depending on their subscription level. Account level If you choose to turn on high security, you must enable high security for all applications reporting to the account. High security must be set on each individual account. For organizations that have a parent/child account structure, child accounts don't automatically inherit the high security setting when enabled on the parent account. Currently there are two versions of high security mode. Version 1 is deprecated and is only available if you already have it. If you are enabling high security mode for the first time, the only option is version 2 (v2). Agent Version 2 support C SDK n/a Go All versions Java 3.7 or higher (enabled by default) .NET 3.3 or higher Node.js 1.7.0 or higher PHP 4.9 or higher Python 2.22.0.0 or higher Ruby 3.9.1 or higher Enable high security mode (version 2) To enable high security, you must update both the local configuration on your server and the remote configuration in the UI. Caution Once you enable high security for an account, high security cannot be turned off without assistance from New Relic Support. Setting location Description Set in UI To set high security in the UI: Go to one.newrelic.com, click the account dropdown and select Account settings. On that page, select High security mode. If you are on our original pricing model, only the account owner can view this option. If the agent is configured for high security via the UI but not locally, then the agent connections will be rejected, and the agent will shut down. However, this won't shut down your application. Local, via agent Enable high security mode in your agent configuration file. High security mode is disabled by default, and the exact procedure to enable it varies by agent: C SDK: n/a Go Java .NET Node.js PHP Python Ruby If the agent is configured for high security locally but not via the UI, then the agent connections will be rejected, and the agent will shut down. This will not shut down your application. Results of enabling high security mode (version 2) Once enabled, high security mode (v2) ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires a secure (HTTPS) connection. Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure all data in transit per the latest industry standards. Prevents HTTP param capture High security mode does not allow HTTP params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send HTTP params locally or through server-side configuration, high security mode will override the configuration to never capture HTTP params. Prevents message queue param capture High security mode does not allow message queue params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send message queue params locally or through server-side configuration, then high security mode will override the configuration to never capture message queue params. Prevents raw query statement capture High security mode does not allow raw database query statements, which may contain sensitive customer data, to be captured. If the agent is configured to capture raw queries locally or through server-side configuration, then high security mode will override the configuration to never capture raw queries. Prevents user attribute capture High security mode does not allow attributes set using each agent's API to be captured, as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.addCustomParameter(String key, String value) Copy NewRelic.addCustomParameter(String key, Number value) Copy NewRelic.setUserName(String name) Copy NewRelic.setAccountName(String name) Copy NewRelic.setProductName(String name) Copy Prevents noticeError attribute capture High security mode does not allow attributes set using each agent's noticeError API call to be captured as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.noticeError(String message, Map<String, String> params) Copy NewRelic.noticeError(Throwable throwable, Map<String, String> params) Copy Prevents custom events High security mode does not allow custom events to be created using the agent API, as these may contain sensitive customer data. For example, in the .NET agent, the API call RecordCustomEvent will be blocked. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Results of enabling high security mode v1 (deprecated) High security mode version 1 is deprecated and only available if you enabled it prior to version 2 being available. High security mode version 1 ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure that all data in transit is encrypted as per the latest industry standards. Prevents HTTP param capture Agents configured to capture HTTP params, which may contain sensitive customer data, are not allowed to connect to New Relic. If the local configuration is set to capture request parameters, then New Relic's collector will reject the connection, and the agent will shut down. Prevents raw query statement capture Agents configured to capture raw database query statements, which may contain sensitive customer data, are not allowed to connect to New Relic. If the agent is configured to capture raw queries locally or through server-side configuration, New Relic's collector will reject the connection and the agent will shut down. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Migrate from version 1 to version 2 These are the main differences between the two versions of high security: In order to make high security even more secure, high security must be enabled in the New Relic user interface and in the local New Relic configuration file. High security v1 only required high security to be set in the New Relic UI. User attributes, noticeError attributes, and message queue parameters are turned off with high security in version 2, but not in version 1. To update from v1 to v2, add high_security: true to your local agent configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.74851,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "New Relic&#x27;s default <em>APM</em> <em>agent</em> settings provide a high level of security. However, you may need to guarantee that even if the default <em>APM</em> <em>agent</em> settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on <em>APM</em>"
      },
      "id": "617e646328ccbc8b5a7ff3ac"
    }
  ],
  "/docs/apm/agents/net-agent/attributes/custom-attributes-net": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.61922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ". See .<em>NET</em> <em>agent</em> <em>attributes</em> and Enable and disable <em>attributes</em>. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring <em>agent</em> Usually the browser <em>agent</em> is added automatically to your pages or deployed by copy"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.387054,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (obsolete)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "maxStackTrace",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Capture HTTP Request Headers",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "fd9643d4551ea4fd76f3275edc05251e6dc52f5c",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-12-05T06:31:05Z",
      "updated_at": "2021-11-26T00:57:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You'll be able to configure our .NET agent to suit your environnment after you create a New Relic account (it's free, forever) and install the .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED=2000 NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\a\\directory (not configurable via config file) NEWRELIC_LOG_DIRECTORY=path\\to\\a\\directory (Insert a directory where you want to put the agent and profiler logs. You can't set this directory for both agent and profiler logs in the configuration file.) NEWRELIC_LOG_LEVEL=off|error|warn|info|debug|finest|all Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown while the agent initiates a final harvest cycle and sends all data to New Relic. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Alternatively, set the NEWRELIC_LOG_LEVEL environment variable in the application's environment. Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomAttribute. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events Capture HTTP Request Headers App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. Important expectedClasses, expectedMessages, and expectedStatusCodes configuration settings require .NET agent version 8.31.0.0 or higher. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (obsolete) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable the high security property in the New Relic user interface. Enabling high security turns SSL on; request parameters, custom parameters and HTTP request headers are not collected; strip exception messages is enabled; and queries can't be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for browser monitoring. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. maxStackTrace Type Integer Default 0 By default maxStackTrace is set to 0, which disables stack traces as part of a transaction trace. If this value is set greater than 0, then stack traces will be captured for transaction traces. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Int Default 2000 The maximum number of samples to store in memory at a time. This may be configured using the NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED environment variable as well. Important This configuration option is only available in the .NET Agent v9.0 or higher. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Capture HTTP Request Headers The allowAllHeaders element is a child of the configuration element. Set this to true to allow the .NET Agent to capture all HTTP request headers as request.headers.{http-header-name} attributes. Set this to false to only allow the .NET agent to collect the following HTTP request headers: request.headers.referer request.headers.accept request.headers.content-length request.headers.host request.headers.user-agent Copy enabled Type Boolean Default false Enable or disable HTTP request headers capture. Example: <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> </attributes> Copy Important The allowAllHeaders setting is only available in the .NET Agent version 8.40.0+. When using allowAllHeaders to capture attributes, the captured request header attributes are still being controlled by the root level and destination level attributes settings. Without setting the request.header.* in the include list under the attributes element (see the following), the .NET Agent still filters out all header attributes. The default newrelic.config is set to include the request.header.*. <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> ... </attributes> Copy The default newrelic.config is also set to explicitly exclude the following HTTP request headers to prevent the .NET Agent collecting unwanted data. <attributes enabled=\"true\"> <exclude>request.headers.cookie</exclude> <exclude>request.headers.authorization</exclude> <exclude>request.headers.proxy-authorization</exclude> <exclude>request.headers.x-*</exclude> </attributes> Copy Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.988754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain <em>attributes</em>, and enabling distributed tracing. The .<em>NET</em> <em>agent</em> gets its configuration from"
      },
      "id": "617e9587196a67924df7e55e"
    }
  ],
  "/docs/apm/agents/net-agent/attributes/enable-disable-attributes-net": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.61919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ". See .<em>NET</em> <em>agent</em> <em>attributes</em> and Enable and disable <em>attributes</em>. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring <em>agent</em> Usually the browser <em>agent</em> is added automatically to your pages or deployed by copy"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (obsolete)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "maxStackTrace",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Capture HTTP Request Headers",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "fd9643d4551ea4fd76f3275edc05251e6dc52f5c",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-12-05T06:31:05Z",
      "updated_at": "2021-11-26T00:57:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You'll be able to configure our .NET agent to suit your environnment after you create a New Relic account (it's free, forever) and install the .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED=2000 NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\a\\directory (not configurable via config file) NEWRELIC_LOG_DIRECTORY=path\\to\\a\\directory (Insert a directory where you want to put the agent and profiler logs. You can't set this directory for both agent and profiler logs in the configuration file.) NEWRELIC_LOG_LEVEL=off|error|warn|info|debug|finest|all Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown while the agent initiates a final harvest cycle and sends all data to New Relic. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Alternatively, set the NEWRELIC_LOG_LEVEL environment variable in the application's environment. Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomAttribute. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events Capture HTTP Request Headers App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. Important expectedClasses, expectedMessages, and expectedStatusCodes configuration settings require .NET agent version 8.31.0.0 or higher. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (obsolete) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable the high security property in the New Relic user interface. Enabling high security turns SSL on; request parameters, custom parameters and HTTP request headers are not collected; strip exception messages is enabled; and queries can't be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for browser monitoring. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. maxStackTrace Type Integer Default 0 By default maxStackTrace is set to 0, which disables stack traces as part of a transaction trace. If this value is set greater than 0, then stack traces will be captured for transaction traces. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Int Default 2000 The maximum number of samples to store in memory at a time. This may be configured using the NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED environment variable as well. Important This configuration option is only available in the .NET Agent v9.0 or higher. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Capture HTTP Request Headers The allowAllHeaders element is a child of the configuration element. Set this to true to allow the .NET Agent to capture all HTTP request headers as request.headers.{http-header-name} attributes. Set this to false to only allow the .NET agent to collect the following HTTP request headers: request.headers.referer request.headers.accept request.headers.content-length request.headers.host request.headers.user-agent Copy enabled Type Boolean Default false Enable or disable HTTP request headers capture. Example: <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> </attributes> Copy Important The allowAllHeaders setting is only available in the .NET Agent version 8.40.0+. When using allowAllHeaders to capture attributes, the captured request header attributes are still being controlled by the root level and destination level attributes settings. Without setting the request.header.* in the include list under the attributes element (see the following), the .NET Agent still filters out all header attributes. The default newrelic.config is set to include the request.header.*. <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> ... </attributes> Copy The default newrelic.config is also set to explicitly exclude the following HTTP request headers to prevent the .NET Agent collecting unwanted data. <attributes enabled=\"true\"> <exclude>request.headers.cookie</exclude> <exclude>request.headers.authorization</exclude> <exclude>request.headers.proxy-authorization</exclude> <exclude>request.headers.x-*</exclude> </attributes> Copy Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.98872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain <em>attributes</em>, and enabling distributed tracing. The .<em>NET</em> <em>agent</em> gets its configuration from"
      },
      "id": "617e9587196a67924df7e55e"
    }
  ],
  "/docs/apm/agents/net-agent/attributes/net-attribute-examples": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.619156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ". See .<em>NET</em> <em>agent</em> <em>attributes</em> and Enable and disable <em>attributes</em>. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring <em>agent</em> Usually the browser <em>agent</em> is added automatically to your pages or deployed by copy"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (obsolete)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "maxStackTrace",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Capture HTTP Request Headers",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "fd9643d4551ea4fd76f3275edc05251e6dc52f5c",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-12-05T06:31:05Z",
      "updated_at": "2021-11-26T00:57:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You'll be able to configure our .NET agent to suit your environnment after you create a New Relic account (it's free, forever) and install the .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED=2000 NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\a\\directory (not configurable via config file) NEWRELIC_LOG_DIRECTORY=path\\to\\a\\directory (Insert a directory where you want to put the agent and profiler logs. You can't set this directory for both agent and profiler logs in the configuration file.) NEWRELIC_LOG_LEVEL=off|error|warn|info|debug|finest|all Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown while the agent initiates a final harvest cycle and sends all data to New Relic. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Alternatively, set the NEWRELIC_LOG_LEVEL environment variable in the application's environment. Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomAttribute. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events Capture HTTP Request Headers App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. Important expectedClasses, expectedMessages, and expectedStatusCodes configuration settings require .NET agent version 8.31.0.0 or higher. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (obsolete) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable the high security property in the New Relic user interface. Enabling high security turns SSL on; request parameters, custom parameters and HTTP request headers are not collected; strip exception messages is enabled; and queries can't be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for browser monitoring. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. maxStackTrace Type Integer Default 0 By default maxStackTrace is set to 0, which disables stack traces as part of a transaction trace. If this value is set greater than 0, then stack traces will be captured for transaction traces. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Int Default 2000 The maximum number of samples to store in memory at a time. This may be configured using the NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED environment variable as well. Important This configuration option is only available in the .NET Agent v9.0 or higher. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Capture HTTP Request Headers The allowAllHeaders element is a child of the configuration element. Set this to true to allow the .NET Agent to capture all HTTP request headers as request.headers.{http-header-name} attributes. Set this to false to only allow the .NET agent to collect the following HTTP request headers: request.headers.referer request.headers.accept request.headers.content-length request.headers.host request.headers.user-agent Copy enabled Type Boolean Default false Enable or disable HTTP request headers capture. Example: <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> </attributes> Copy Important The allowAllHeaders setting is only available in the .NET Agent version 8.40.0+. When using allowAllHeaders to capture attributes, the captured request header attributes are still being controlled by the root level and destination level attributes settings. Without setting the request.header.* in the include list under the attributes element (see the following), the .NET Agent still filters out all header attributes. The default newrelic.config is set to include the request.header.*. <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> ... </attributes> Copy The default newrelic.config is also set to explicitly exclude the following HTTP request headers to prevent the .NET Agent collecting unwanted data. <attributes enabled=\"true\"> <exclude>request.headers.cookie</exclude> <exclude>request.headers.authorization</exclude> <exclude>request.headers.proxy-authorization</exclude> <exclude>request.headers.x-*</exclude> </attributes> Copy Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.98869,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain <em>attributes</em>, and enabling distributed tracing. The .<em>NET</em> <em>agent</em> gets its configuration from"
      },
      "id": "617e9587196a67924df7e55e"
    }
  ],
  "/docs/apm/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38687,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "4d29407927b8e103f97458ec4db3f7b67e9b446a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-12-05T05:55:26Z",
      "updated_at": "2021-10-23T19:55:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.63012,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "617e59b164441f1faffbd8a6"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension (Windows Only)",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "701aa47e19eed94c9281fecc6da194a29af7e479",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-12-05T05:36:32Z",
      "updated_at": "2021-10-23T19:56:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most reliable option is to use the publicly maintained Azure site extension. Note: Azure Site Extensions are only currently available for Windows App Service Resources. Install using the Azure Site Extension For developer teams, or anyone needing to deploy the agent on a Linux App Service Resource, installing via nuget is the best option: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension (Windows Only) To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file (Note: If Visual Studio prevents you from editing the newrelic.config file that was added to your project by NuGet then you will need to make a local copy of this in your application): Log file configuration for Windows <log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"></log> Copy Log file configuration for Linux <log directory=\"/home/LogFiles/NewRelic\" level=\"info\"></log> Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic NEWRELIC_PROFILER_LOG_DIRECTORY /home/LogFiles/NewRelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.55901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": " <em>installation</em> overview. <em>Installation</em> options Use any of the following methods to add the New Relic .<em>NET</em> <em>agent</em> to your <em>Azure</em>-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most"
      },
      "id": "617e9f86e7b9d2de47c04aec"
    }
  ],
  "/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "98e8f038d2e302e37bb01a6e7f38ac07d6f5aa62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-12-05T06:03:25Z",
      "updated_at": "2021-10-23T19:55:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.55849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "617e59ef28ccbc30227ffee8"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension (Windows Only)",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "701aa47e19eed94c9281fecc6da194a29af7e479",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-12-05T05:36:32Z",
      "updated_at": "2021-10-23T19:56:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most reliable option is to use the publicly maintained Azure site extension. Note: Azure Site Extensions are only currently available for Windows App Service Resources. Install using the Azure Site Extension For developer teams, or anyone needing to deploy the agent on a Linux App Service Resource, installing via nuget is the best option: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension (Windows Only) To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) The NuGet installation method packages the New Relic Agent with your application so that it is available to the Azure Web App Host. New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file (Note: If Visual Studio prevents you from editing the newrelic.config file that was added to your project by NuGet then you will need to make a local copy of this in your application): Log file configuration for Windows <log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"></log> Copy Log file configuration for Linux <log directory=\"/home/LogFiles/NewRelic\" level=\"info\"></log> Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic NEWRELIC_PROFILER_LOG_DIRECTORY /home/LogFiles/NewRelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.55901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": " <em>installation</em> overview. <em>Installation</em> options Use any of the following methods to add the New Relic .<em>NET</em> <em>agent</em> to your <em>Azure</em>-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, the easiest and most"
      },
      "id": "617e9f86e7b9d2de47c04aec"
    }
  ],
  "/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "98e8f038d2e302e37bb01a6e7f38ac07d6f5aa62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-12-05T06:03:25Z",
      "updated_at": "2021-10-23T19:55:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.55849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "617e59ef28ccbc30227ffee8"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "4d29407927b8e103f97458ec4db3f7b67e9b446a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-12-05T05:55:26Z",
      "updated_at": "2021-10-23T19:55:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.63011,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "617e59b164441f1faffbd8a6"
    }
  ],
  "/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-web-apps": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "98e8f038d2e302e37bb01a6e7f38ac07d6f5aa62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-12-05T06:03:25Z",
      "updated_at": "2021-10-23T19:55:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.55849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "617e59ef28ccbc30227ffee8"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "4d29407927b8e103f97458ec4db3f7b67e9b446a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-12-05T05:55:26Z",
      "updated_at": "2021-10-23T19:55:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.63011,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "617e59b164441f1faffbd8a6"
    }
  ],
  "/docs/apm/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d428aa4ed9ebda700fc9e5abda0a5800f12b971a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-12-05T06:09:54Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.990875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "617e9f5764441f10a6fbf04f"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "3b98c5edf5af1541d2a111708a6267f5ec9e2619",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-12-05T05:55:25Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.083244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "617e5a5564441faa2bfbda11"
    }
  ],
  "/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d428aa4ed9ebda700fc9e5abda0a5800f12b971a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-12-05T06:09:54Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.990875,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "617e9f5764441f10a6fbf04f"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "552beae09bbb95650dd5f9cb1a8a36777f403aba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-12-05T05:37:18Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.11403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "617e5a0528ccbc4354800476"
    }
  ],
  "/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-unable-open-log-file": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d428aa4ed9ebda700fc9e5abda0a5800f12b971a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-12-05T06:09:54Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.99087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "617e9f5764441f10a6fbf04f"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "552beae09bbb95650dd5f9cb1a8a36777f403aba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-12-05T05:37:18Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.11403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "617e5a0528ccbc4354800476"
    }
  ],
  "/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "552beae09bbb95650dd5f9cb1a8a36777f403aba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-12-05T05:37:18Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.11403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "617e5a0528ccbc4354800476"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "3b98c5edf5af1541d2a111708a6267f5ec9e2619",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-12-05T05:55:25Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.08324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "617e5a5564441faa2bfbda11"
    }
  ],
  "/docs/apm/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38649,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d428aa4ed9ebda700fc9e5abda0a5800f12b971a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-12-05T06:09:54Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.99086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "617e9f5764441f10a6fbf04f"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "552beae09bbb95650dd5f9cb1a8a36777f403aba",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-12-05T05:37:18Z",
      "updated_at": "2021-10-23T17:44:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.11402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "617e5a0528ccbc4354800476"
    }
  ],
  "/docs/apm/agents/net-agent/configuration/name-your-net-application": [
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (obsolete)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "maxStackTrace",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Capture HTTP Request Headers",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "fd9643d4551ea4fd76f3275edc05251e6dc52f5c",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-12-05T06:31:05Z",
      "updated_at": "2021-11-26T00:57:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You'll be able to configure our .NET agent to suit your environnment after you create a New Relic account (it's free, forever) and install the .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED=2000 NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\a\\directory (not configurable via config file) NEWRELIC_LOG_DIRECTORY=path\\to\\a\\directory (Insert a directory where you want to put the agent and profiler logs. You can't set this directory for both agent and profiler logs in the configuration file.) NEWRELIC_LOG_LEVEL=off|error|warn|info|debug|finest|all Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown while the agent initiates a final harvest cycle and sends all data to New Relic. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Alternatively, set the NEWRELIC_LOG_LEVEL environment variable in the application's environment. Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomAttribute. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events Capture HTTP Request Headers App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. Important expectedClasses, expectedMessages, and expectedStatusCodes configuration settings require .NET agent version 8.31.0.0 or higher. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (obsolete) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable the high security property in the New Relic user interface. Enabling high security turns SSL on; request parameters, custom parameters and HTTP request headers are not collected; strip exception messages is enabled; and queries can't be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for browser monitoring. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. maxStackTrace Type Integer Default 0 By default maxStackTrace is set to 0, which disables stack traces as part of a transaction trace. If this value is set greater than 0, then stack traces will be captured for transaction traces. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Int Default 2000 The maximum number of samples to store in memory at a time. This may be configured using the NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED environment variable as well. Important This configuration option is only available in the .NET Agent v9.0 or higher. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Capture HTTP Request Headers The allowAllHeaders element is a child of the configuration element. Set this to true to allow the .NET Agent to capture all HTTP request headers as request.headers.{http-header-name} attributes. Set this to false to only allow the .NET agent to collect the following HTTP request headers: request.headers.referer request.headers.accept request.headers.content-length request.headers.host request.headers.user-agent Copy enabled Type Boolean Default false Enable or disable HTTP request headers capture. Example: <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> </attributes> Copy Important The allowAllHeaders setting is only available in the .NET Agent version 8.40.0+. When using allowAllHeaders to capture attributes, the captured request header attributes are still being controlled by the root level and destination level attributes settings. Without setting the request.header.* in the include list under the attributes element (see the following), the .NET Agent still filters out all header attributes. The default newrelic.config is set to include the request.header.*. <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> ... </attributes> Copy The default newrelic.config is also set to explicitly exclude the following HTTP request headers to prevent the .NET Agent collecting unwanted data. <attributes enabled=\"true\"> <exclude>request.headers.cookie</exclude> <exclude>request.headers.authorization</exclude> <exclude>request.headers.proxy-authorization</exclude> <exclude>request.headers.x-*</exclude> </attributes> Copy Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.77829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>configuration</em>",
        "sections": ".<em>NET</em> <em>agent</em> <em>configuration</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "You&#x27;ll be able to configure our .<em>NET</em> <em>agent</em> to suit your environnment after you create a New Relic account (it&#x27;s free, forever) and install the .<em>NET</em> <em>agent</em>. <em>Configuration</em> overview APM <em>agent</em> <em>configuration</em> options allow you to control some aspects of how the <em>agent</em> behaves. Some of these config options"
      },
      "id": "617e9587196a67924df7e55e"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.094086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    }
  ],
  "/docs/apm/agents/net-agent/configuration/net-agent-configuration": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.093994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.57762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " the .<em>NET</em> <em>agent</em> does not report automatically Use NoticeError(). Capture errors or prevent the .<em>NET</em> <em>agent</em> from reporting an error at all Use your .<em>NET</em> <em>agent</em> <em>configuration</em> file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/custom-instrumentation/add-detail-transactions-xml-net": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.70299,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "sections": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> provides several options for <em>custom</em> <em>instrumentation</em>. <em>Custom</em> <em>instrumentation</em> allows you to <em>instrument</em> parts of your app that are not instrumented automatically. This document describes how to <em>instrument</em> your app by decorating the methods in your app code with attributes. Use"
      },
      "id": "617e9fc0196a672142f7d03b"
    },
    {
      "sections": [
        "Introduction to .NET custom instrumentation",
        "Important",
        "Choose a method of custom instrumentation",
        "Creating transactions vs. adding detail",
        "Classify as \"web\" or \"non-web\" (attribute method only)"
      ],
      "title": "Introduction to .NET custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "e891d81d053b6b7c9fb4376e0e263da67b9a19cc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation/",
      "published_at": "2021-12-05T05:38:49Z",
      "updated_at": "2021-10-23T17:57:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For fully supported frameworks (.NET Framework | .NET Core), the New Relic .NET agent automatically collects and reports information on web transactions and browser tasks. However, if you are using an application framework that isn't automatically instrumented (or not using a framework) you may see large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use custom instrumentation to add transactions and detail. This document describes how to instrument activity that is not instrumented by the .NET agent by default. For other ways of configuring your app's instrumentation, see Guide to using the .NET agent API. Important For both of the agent's supported frameworks (.NET Framework and .NET Core), custom instrumentation is done the same way, unless otherwise stated. Choose a method of custom instrumentation The .NET agent supports two methods of custom instrumentation: Method Description Attribute custom instrumentation Instrument your code by decorating your methods with an attribute. Attribute instrumentation is simpler to implement than XML instrumentation because you only need to add a single decorator, in the same place in your code as the method you want to instrument. For instructions, see Custom instrumentation via attributes. XML custom instrumentation Instrument your code by listing the target methods in an XML file. XML instrumentation is more complex than attribute instrumentation, and it will fail if you change the name of the assembly, class, or method you want to instrument. However, XML instrumentation does not require you to modify your source code. For instructions, see Create transactions via XML and Add detail to transactions via XML. Creating transactions vs. adding detail When you add custom instrumentation via either method, you need to choose between creating a new transaction and adding instrumentation to an existing transaction: Situation Recommendation The method you want to instrument does not appear in the New Relic UI at all Create a new transaction. For details, see: Custom instrumentation via attributes Create transactions via XML The transaction appears in the New Relic UI but contains sections of uninstrumented time Add detail to an existing transaction. For details, see: Custom instrumentation via attributes Add detail to transactions via XML Classify as \"web\" or \"non-web\" (attribute method only) APM separates transactions into web transactions and non-web transactions in the UI. When you add detail to an existing transaction, its category is determined by the category of the parent transaction. When you create a transaction via custom instrumentation using the attribute method, you must categorize it as web or non-web. (This is not possible with XML instrumentation; all XML-created transactions are classified as non-web.) Category When to use Web Use web for web requests. You can only mark new transactions as web transactions with custom instrumentation using attributes, not by using XML. Non-web Use non-web for other types of background requests, such as console apps and services. All transactions created using XML are classified as non-web. Transactions created using attributes can be classified either as web or non-web.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.49279,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use <em>custom</em> <em>instrumentation</em> to add transactions and detail. This document describes how to <em>instrument</em> activity that is not instrumented by the .<em>NET</em> <em>agent</em> by default. For other ways"
      },
      "id": "617e9f8628ccbc53447ff12c"
    },
    {
      "sections": [
        "Create transactions via XML (.NET)",
        "Create transactions using XML",
        "For the .NET Framework or Core agent on Windows",
        "Important",
        "For the .NET Core agent on Linux",
        "For Azure App Services",
        "Tip",
        "View transactions in the UI",
        "Example: Instrument three methods",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Example: Instrument a console app",
        "Example app"
      ],
      "title": "Create transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "10ae0b4efb80fb527b16a10f567f4e645b032411",
      "image": "https://docs.newrelic.com/static/0ed431b536aef47896991b59af94f453/c1b63/custom_transactions.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/create-transactions-xml-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-10-23T18:01:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic instruments supported frameworks automatically. However, you may also have other frameworks for which some transactions are not being created automatically or additional methods that you would like to instrument. You can add custom instrumentation to these methods by creating transactions. Transactions created via XML are classified as non-web in the New Relic UI. This document describes how to create transactions with an XML file. You can also: Add details to existing transactions using XML Create transactions and add detail to existing transactions with the .NET agent API. If you have a non-IIS application, XML instrumentation requires enabling the Instrument all option during the .NET agent installation. Create transactions using XML Custom transactions (transactions not instrumented automatically) are defined in a custom instrumentation XML file. You define a method that triggers the creation of a transaction. You can also instrument additional methods called by the trigger method. Some important rules to know before you create a custom transaction: Database and external calls do not require custom instrumentation because they're automatically instrumented. Ensure your XML file is in the correct path. To define its instrumentation set, the .NET agent reads every XML file in the Extensions directory. If a method you attempt to instrument is already part of an existing transaction, it will be added as a segment to that transaction. No new transaction will be created. This will occur even if the parent method is instrumented using custom instrumentation. Avoid instrumenting things like Main() as this method won't end until the application ends and data may not be sent to New Relic. To create a custom instrumentation file: Create a new .xml file in the Extensions directory within your .NET Agent directory. The location of this directory depends on your OS: For the .NET Framework or Core agent on Windows C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Use the ProgramData directory, not the Program Files directory. For the .NET Core agent on Linux PATH_TO_AGENT_DIRECTORY/Extensions Copy PATH_TO_AGENT_DIRECTORY will be the default /usr/local/newrelic-netcore20-agent or the directory chosen at installation. For Azure App Services .NET Framework agent: D:\\home\\site\\wwwroot\\newrelic\\extensions Copy .NET Core agent: D:\\home\\site\\wwwroot\\newrelic_core\\extensions Copy Copy this template into the file you created. This template defines two separate class and methods as transactions but more can be added: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy In the file you created, customize the attribute values Name, AssemblyName, NameSpace.ClassName, and MethodName. Customize these values for both the trigger method and for any methods called by the trigger method. Tip These values are case sensitive. Name: Defines the transaction name. The metricName attribute is optional. If omitted, the transaction name will be NameSpace.ClassName/MethodName. The transaction category will be \"Custom\". The resulting full metric name will be \"OtherTransaction/Custom/Name . If you wish to change the transaction category from \"Custom\", use the SetTransactionName api call. The New Relic UI groups transactions under categories in the transaction type field. AssemblyName: The assembly that contains the trigger method. NameSpace.ClassName: The fully-qualified class name that contains the trigger method. MethodName: The exact name of the trigger method. Adding additional methods must include the \"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" attribute to be defined as a transaction. Tags without this attribute will add detail to existing transactions only. Optional: To check if the XML file is formatted correctly, you can check it against the XSD (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) using any XSD validator. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. View transactions in the UI The custom transaction starts when the method specified by methodName is invoked in the assembly specified by assemblyName. The transaction ends when the method returns or throws an exception. You can view these metrics in the Transactions page and in transaction traces. To view the transaction: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > Type > (select a type). The type is defined by Category/Name. one.newrelic.com > APM > (select an app) > Monitoring > Transactions > Type > (selected type): Use the Type menu to view your custom transactions. Example: Instrument three methods This example presents a simple implementation of creating transactions. Example custom instrumentation file This custom instrumentation file defines the three methods to instrument. Only two are defined as transactions. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Bars\"> <match assemblyName=\"Foo\" className=\"Foo.Bar\"> <exactMethodMatcher methodName=\"Bar1\" /> <exactMethodMatcher methodName=\"Bar2\" /> </match> </tracerFactory> <!-- Instrument 0 or more methods called by the trigger method. These methods appear in the transaction breakdown table and in transaction traces. --> <tracerFactory> <match assemblyName=\"Foo\" className=\"Foo.Bar\"> <exactMethodMatcher methodName=\"Bar3\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods, with comments explaining when each one will be instrumented by the agent: var bar = new Bar(); bar.Bar1(); // Creates a transaction named Bars in the Custom category. bar.Bar2(); // Creates a transaction named Bars in the Custom category. bar.Bar3(); // Won't create a new transaction. See `If Bar3 is called directly`, below. namespace Foo { public class Bar { // The agent creates a transaction that includes an external service request in its transaction traces. public void Bar1() { new WebClient().DownloadString(\"http://www.google.com/\"); } // Creates a transaction containing one segment. public void Bar2() { // The Bar3 segment will contain your SQL query inside of it and possibly an execution plan. Bar3(); } // If Bar3 is called directly, the agent will not create a transaction. // However, if Bar3 is called from Bar1 or Bar2, Bar3 will appear as a segment containing its SQL query. private void Bar3() { using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } } } Copy Example: Instrument a console app This simple console app demonstrates creating transactions. After running the application a few times, you see the transactions you created in the Transactions page (at one.newrelic.com > APM > (select an app) > Transactions > Type). The Dummy segment will be visible in the transactions breakdown table and in any transaction traces. Example custom instrumentation file This custom instrumentation file defines two methods to instrument: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"CustomTransaction\"> <match assemblyName=\"ConsoleApplication1\" className=\"ConsoleApplication1.CustomTransaction\"> <exactMethodMatcher methodName=\"StartTransaction\" /> </match> </tracerFactory> <!-- Instrument 0 or more methods called by the trigger method. These methods appear in the transaction breakdown table and in transaction traces. --> <tracerFactory> <match assemblyName=\"ConsoleApplication1\" className=\"ConsoleApplication1.CustomTransaction\"> <exactMethodMatcher methodName=\"Dummy\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example app This code contains the two methods specified by the custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { Console.WriteLine(\"Custom Transactions\"); var t = new CustomTransaction(); while (true) t.StartTransaction(); } } class CustomTransaction { public void StartTransaction() { Console.WriteLine(\"StartTransaction\"); Dummy(); } void Dummy() { System.Threading.Thread.Sleep(5000); } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19559,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create transactions via XML (.<em>NET</em>)",
        "sections": "For the .<em>NET</em> Framework or Core <em>agent</em> on Windows",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " have a non-IIS application, XML <em>instrumentation</em> requires enabling the <em>Instrument</em> all option during the .<em>NET</em> <em>agent</em> installation. Create transactions using XML <em>Custom</em> transactions (transactions not instrumented automatically) are defined in a <em>custom</em> <em>instrumentation</em> XML file. You define a method"
      },
      "id": "617e9aeb28ccbc08957feebd"
    }
  ],
  "/docs/apm/agents/net-agent/custom-instrumentation/create-transactions-xml-net": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.70294,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "sections": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> provides several options for <em>custom</em> <em>instrumentation</em>. <em>Custom</em> <em>instrumentation</em> allows you to <em>instrument</em> parts of your app that are not instrumented automatically. This document describes how to <em>instrument</em> your app by decorating the methods in your app code with attributes. Use"
      },
      "id": "617e9fc0196a672142f7d03b"
    },
    {
      "sections": [
        "Add detail to transactions via XML (.NET)",
        "Add detail with custom instrumentation",
        "Important",
        "Tip",
        "Ignore a transaction",
        "Track async work in a separate transaction",
        "Example method definitions",
        "Example method invocations",
        "Example MyInstrumentation.xml",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Name metrics",
        "Name transactions",
        "XSD validation",
        "Troubleshooting"
      ],
      "title": "Add detail to transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "8220ccbb945751144b8f1fff165dd9250be651ed",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/add-detail-transactions-xml-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:17:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web browser transactions and non-web transactions (background tasks). Normally the .NET agent produces complete information automatically, without any need for you to modify your application code. However, if New Relic does not support your framework, you may need to add custom instrumentation. New Relic uses method tracers to implement custom instrumentation. A method tracer is a software probe that you can put on a method of any class. The .NET agent loads the instrumentation directives that define which methods should be traced from all XML files in the extensions directory. This document describes instrumenting work when the agent is already collecting transactions, but you want to add more detail to those transactions. To instrument work when the agent isn't creating transactions automatically, see Create transactions via XML. You can also add detail and create transactions by decorating your code with attributes. Add detail with custom instrumentation Extension files define a number of tracer factories in an instrumentation element. Each tracer factory contains match elements that define the assembly, fully qualified class name, and method name to match. To define a new custom instrumentation XML file: Create a new .xml file in the extensions directory used by the .NET agent to read every XML file and define its instrumentation set. For the .NET Framework agent, use the following location: C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Do not put the .xml file in the C:\\Program Files\\New Relic\\.NET agent\\Extensions directory. The file must be in the ProgramData file location for custom instrumentation to work. Do not modify the distributed xml files. These files are overwritten whenever the agent is upgraded. Copy this template into the file you created use the sample as an example. This instruments two methods but you can add methods to your instrumentation file. Tip The values AssemblyName, NameSpace.ClassName, and MethodName are case sensitive. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- These methods appear in the transactions breakdown table and in transaction traces --> <tracerFactory metricName=\"Category/Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <tracerFactory metricName=\"Category/Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Validate the .xml instrumentation file against extension.xsd. Non-IIS apps (such as a console app or background process): You must also create transactions via XML to contain the methods you instrument. Custom methods instrumented outside of a transaction will not be reported to New Relic. Important If your .NET agent version is 7.0 or higher, this is the end of the procedure. If your .NET agent version is lower than 7.0, continue to the next steps. If your app is IIS-hosted, restart IIS. For non-IIS applications, restart your application's host process or the application itself. Important If some of your methods still don't show up in traces after adding XML custom instrumentation, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Ignore a transaction You can stop a transaction from being reported by using a custom instrumentation file. Whenever an ignored method is called, the .NET agent ignores the entire parent transaction. This is the same as calling IgnoreTransaction(). To ignore a transaction: Add custom instrumentation. Add a tracerFactory whose name is NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory: <tracerFactory name=\" NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory \"> <match assemblyName=\"System.Web.Extensions\" className=\"System.Web.Handlers.ScriptResourceHandler\"> <exactMethodMatcher methodName=\"Throw404\" /> </match> </tracerFactory> Copy Track async work in a separate transaction In some cases, asynchronous work can be tracked as a separate transaction by applying the AsyncForceNewTransactionWrapper instrumentation: <tracerFactory name=\" AsyncForceNewTransactionWrapper \"> <match assemblyName=\"AssemblyName\" className=\"Namespace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> Copy Async usage considerations Comments Instrumented method The instrumented method must be invoked using Task.Run, Task.Factory.StartNew, or new Thread(). It cannot be invoked using the await keyword. Return type The instrumented method is not required to be async. However, if it is async, it must have a return type of Task or Task<T>. It cannot have a void return type. Attribute instrumentation The instrumented method cannot have attribute instrumentation applied to it. It cannot be decorated with the [Transaction] or [Trace] attributes. Example method definitions The following methods can be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private void SyncMethod() { } private async Task AsyncMethod_Task() { } private async Task<string> AsyncMethod_TypedTask() { return \"ok\"; } Copy The following methods cannot be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private async void AsyncMethod_Void() { } [Transaction] private void TransactionAttributedMethod() { } [Trace] private void TracedAttributedMethod() { } Copy Example method invocations The following method calls can be used with AsyncForceNewTransactionWrapper instrumentation: Task.Run(SyncMethod); Task.Factory.StartNew(AsyncMethod_Task); var newThread = new Thread(new ThreadStart(SyncMethod)); newThread.Start(); Copy The following method calls cannot be used with AsyncForceNewTransactionWrapper instrumentation: SyncMethod(); //This is not an asynchronous call await AsyncMethod_Task(); //Not started with Task.Run, Task.Factor.StartNew, or new Thread() AsyncMethod_Void(); //Async Void is not supported Copy Example MyInstrumentation.xml This example instruments two methods and ignores another method: Instrument: CustomInstrumentDemo.Controllers.FirstController.FirstExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.SecondExample() Ignore: CustomInstrumentDemo.Controllers.SecondController.ThirdExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.FourthExample(int id, string name) To implement this custom instrumentation scheme, use the following example file and instrumented methods: Example custom instrumentation file The following is an example custom instrumentation file named MyInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- instrument CustomInstrumentDemo.Controllers.FirstController.FirstExample and creates metric named Custom/Foo1 --> <tracerFactory metricName=\"Custom/Foo1\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.FirstController\"> <exactMethodMatcher methodName=\"FirstExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.SecondExample --> <tracerFactory> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"SecondExample\" /> </match> </tracerFactory> <!-- ignore CustomInstrumentDemo.Controllers.SecondController.ThirdExample --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"ThirdExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.FourthExample and creates metric named Custom/{value}, where {value} is the value of the first string parameter of the instrumented method (in this case, the first string parameter is \"name\"). --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.CustomSegmentTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"FourthExample\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods specified by the example custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Mvc; using System.Threading; namespace CustomInstrumentDemo.Controllers { public class FirstController : Controller { public ActionResult Foo1() { ViewBag.Message = \"Your Sample Page\"; FirstExample(); return View(); } public void FirstExample() { int firstVar = 1; for (int i = 0; i <= 500; i++) { firstVar *= 5; Thread.Sleep(50); } } } public class SecondController : Controller { public ActionResult Foo2() { ViewBag.Message = \"This view will include detailed information on the SecondExample method\"; SecondExample(); return view; } public ActionResult Foo3() { ViewBag.Message = \"This view will be ignored because of the inclusion of the ThirdExample method\"; ThirdExample(); } public void SecondExample() { int secondVar = 2; using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } public void ThirdExample() { try { var ImNotABool = \"43\"; bool.Parse(ImNotABool); } catch (Exception ex) { NewRelic.Api.Agent.NewRelic.NoticeError(ex); } } public void FourthExample(int id, string name) { Console.WriteLine(\"The ID passed in was \" + id + \" and the name passed in was \" + name); } } } Copy Name metrics Metrics created from tracers will be named using the class name and method name of the matched method. You can override this name with the metricName attribute. Begin metricName with Custom/ (for example, metricName=\"Custom/OrderSubmissions\"). <!-- instruments MyCompany.Order.Submit() and creates a metric named Custom/OrderSubmissions --> <tracerFactory metricName=\"Custom/OrderSubmissions\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.Order\"> <exactMethodMatcher methodName=\"Submit\" /> </match </tracerFactory> Copy Name transactions The agent names transactions using the tracer in the transaction with the highest naming priority. Web transactions may be named using the HTTP handler, ASP name, MVC controller name, or web service name, depending on the tracers invoked in the transaction's execution. Background transactions with no tracer that explicitly names the transaction are rolled up into a single transaction name. Use the transactionNamingPriority attribute to tell the agent to give a tracer transaction naming priority. Valid values are 1 to 7, where 7 takes precedence over 1 to 6. Also, the metricName attribute must begin with Custom/ (for example, metricName=\"Custom/instance\"). <!-- instructs the agent to create a metric for MyControllerBase.Execute and to name the transaction using this tracer's metric name --> <tracerFactory metricName=\"Custom/instance\" transactionNamingPriority=\"7\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.MyControllerBase\"> <exactMethodMatcher methodName=\"Execute\" /> </match> </tracerFactory> Copy XSD validation The XML instrumentation file can be checked against the XSD file (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) with any XSD validator. Troubleshooting The .NET agent will write a log message to NewRelic.Profiler.####.log (where #### is the PID of the instrumented process) as it rewrites methods. This helps to verify that custom instrumentation is being read and that the proper methods are being instrumented. Tip Avoid using the name attribute of the tracerFactory element in custom instrumentation. For more information, review the extension.xsd schema file in the agent directory.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.01262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add detail to transactions via XML (.<em>NET</em>)",
        "sections": "Add detail with <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ", you may need to add <em>custom</em> <em>instrumentation</em>. New Relic uses method tracers to implement <em>custom</em> <em>instrumentation</em>. A method tracer is a software probe that you can put on a method of any class. The .<em>NET</em> <em>agent</em> loads the <em>instrumentation</em> directives that define which methods should be traced from all XML"
      },
      "id": "617e9aece7b9d2a2b1c04e45"
    },
    {
      "sections": [
        "Introduction to .NET custom instrumentation",
        "Important",
        "Choose a method of custom instrumentation",
        "Creating transactions vs. adding detail",
        "Classify as \"web\" or \"non-web\" (attribute method only)"
      ],
      "title": "Introduction to .NET custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "e891d81d053b6b7c9fb4376e0e263da67b9a19cc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation/",
      "published_at": "2021-12-05T05:38:49Z",
      "updated_at": "2021-10-23T17:57:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For fully supported frameworks (.NET Framework | .NET Core), the New Relic .NET agent automatically collects and reports information on web transactions and browser tasks. However, if you are using an application framework that isn't automatically instrumented (or not using a framework) you may see large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use custom instrumentation to add transactions and detail. This document describes how to instrument activity that is not instrumented by the .NET agent by default. For other ways of configuring your app's instrumentation, see Guide to using the .NET agent API. Important For both of the agent's supported frameworks (.NET Framework and .NET Core), custom instrumentation is done the same way, unless otherwise stated. Choose a method of custom instrumentation The .NET agent supports two methods of custom instrumentation: Method Description Attribute custom instrumentation Instrument your code by decorating your methods with an attribute. Attribute instrumentation is simpler to implement than XML instrumentation because you only need to add a single decorator, in the same place in your code as the method you want to instrument. For instructions, see Custom instrumentation via attributes. XML custom instrumentation Instrument your code by listing the target methods in an XML file. XML instrumentation is more complex than attribute instrumentation, and it will fail if you change the name of the assembly, class, or method you want to instrument. However, XML instrumentation does not require you to modify your source code. For instructions, see Create transactions via XML and Add detail to transactions via XML. Creating transactions vs. adding detail When you add custom instrumentation via either method, you need to choose between creating a new transaction and adding instrumentation to an existing transaction: Situation Recommendation The method you want to instrument does not appear in the New Relic UI at all Create a new transaction. For details, see: Custom instrumentation via attributes Create transactions via XML The transaction appears in the New Relic UI but contains sections of uninstrumented time Add detail to an existing transaction. For details, see: Custom instrumentation via attributes Add detail to transactions via XML Classify as \"web\" or \"non-web\" (attribute method only) APM separates transactions into web transactions and non-web transactions in the UI. When you add detail to an existing transaction, its category is determined by the category of the parent transaction. When you create a transaction via custom instrumentation using the attribute method, you must categorize it as web or non-web. (This is not possible with XML instrumentation; all XML-created transactions are classified as non-web.) Category When to use Web Use web for web requests. You can only mark new transactions as web transactions with custom instrumentation using attributes, not by using XML. Non-web Use non-web for other types of background requests, such as console apps and services. All transactions created using XML are classified as non-web. Transactions created using attributes can be classified either as web or non-web.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.49278,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use <em>custom</em> <em>instrumentation</em> to add transactions and detail. This document describes how to <em>instrument</em> activity that is not instrumented by the .<em>NET</em> <em>agent</em> by default. For other ways"
      },
      "id": "617e9f8628ccbc53447ff12c"
    }
  ],
  "/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net": [
    {
      "sections": [
        "Add detail to transactions via XML (.NET)",
        "Add detail with custom instrumentation",
        "Important",
        "Tip",
        "Ignore a transaction",
        "Track async work in a separate transaction",
        "Example method definitions",
        "Example method invocations",
        "Example MyInstrumentation.xml",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Name metrics",
        "Name transactions",
        "XSD validation",
        "Troubleshooting"
      ],
      "title": "Add detail to transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "8220ccbb945751144b8f1fff165dd9250be651ed",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/add-detail-transactions-xml-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:17:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web browser transactions and non-web transactions (background tasks). Normally the .NET agent produces complete information automatically, without any need for you to modify your application code. However, if New Relic does not support your framework, you may need to add custom instrumentation. New Relic uses method tracers to implement custom instrumentation. A method tracer is a software probe that you can put on a method of any class. The .NET agent loads the instrumentation directives that define which methods should be traced from all XML files in the extensions directory. This document describes instrumenting work when the agent is already collecting transactions, but you want to add more detail to those transactions. To instrument work when the agent isn't creating transactions automatically, see Create transactions via XML. You can also add detail and create transactions by decorating your code with attributes. Add detail with custom instrumentation Extension files define a number of tracer factories in an instrumentation element. Each tracer factory contains match elements that define the assembly, fully qualified class name, and method name to match. To define a new custom instrumentation XML file: Create a new .xml file in the extensions directory used by the .NET agent to read every XML file and define its instrumentation set. For the .NET Framework agent, use the following location: C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Do not put the .xml file in the C:\\Program Files\\New Relic\\.NET agent\\Extensions directory. The file must be in the ProgramData file location for custom instrumentation to work. Do not modify the distributed xml files. These files are overwritten whenever the agent is upgraded. Copy this template into the file you created use the sample as an example. This instruments two methods but you can add methods to your instrumentation file. Tip The values AssemblyName, NameSpace.ClassName, and MethodName are case sensitive. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- These methods appear in the transactions breakdown table and in transaction traces --> <tracerFactory metricName=\"Category/Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <tracerFactory metricName=\"Category/Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Validate the .xml instrumentation file against extension.xsd. Non-IIS apps (such as a console app or background process): You must also create transactions via XML to contain the methods you instrument. Custom methods instrumented outside of a transaction will not be reported to New Relic. Important If your .NET agent version is 7.0 or higher, this is the end of the procedure. If your .NET agent version is lower than 7.0, continue to the next steps. If your app is IIS-hosted, restart IIS. For non-IIS applications, restart your application's host process or the application itself. Important If some of your methods still don't show up in traces after adding XML custom instrumentation, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Ignore a transaction You can stop a transaction from being reported by using a custom instrumentation file. Whenever an ignored method is called, the .NET agent ignores the entire parent transaction. This is the same as calling IgnoreTransaction(). To ignore a transaction: Add custom instrumentation. Add a tracerFactory whose name is NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory: <tracerFactory name=\" NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory \"> <match assemblyName=\"System.Web.Extensions\" className=\"System.Web.Handlers.ScriptResourceHandler\"> <exactMethodMatcher methodName=\"Throw404\" /> </match> </tracerFactory> Copy Track async work in a separate transaction In some cases, asynchronous work can be tracked as a separate transaction by applying the AsyncForceNewTransactionWrapper instrumentation: <tracerFactory name=\" AsyncForceNewTransactionWrapper \"> <match assemblyName=\"AssemblyName\" className=\"Namespace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> Copy Async usage considerations Comments Instrumented method The instrumented method must be invoked using Task.Run, Task.Factory.StartNew, or new Thread(). It cannot be invoked using the await keyword. Return type The instrumented method is not required to be async. However, if it is async, it must have a return type of Task or Task<T>. It cannot have a void return type. Attribute instrumentation The instrumented method cannot have attribute instrumentation applied to it. It cannot be decorated with the [Transaction] or [Trace] attributes. Example method definitions The following methods can be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private void SyncMethod() { } private async Task AsyncMethod_Task() { } private async Task<string> AsyncMethod_TypedTask() { return \"ok\"; } Copy The following methods cannot be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private async void AsyncMethod_Void() { } [Transaction] private void TransactionAttributedMethod() { } [Trace] private void TracedAttributedMethod() { } Copy Example method invocations The following method calls can be used with AsyncForceNewTransactionWrapper instrumentation: Task.Run(SyncMethod); Task.Factory.StartNew(AsyncMethod_Task); var newThread = new Thread(new ThreadStart(SyncMethod)); newThread.Start(); Copy The following method calls cannot be used with AsyncForceNewTransactionWrapper instrumentation: SyncMethod(); //This is not an asynchronous call await AsyncMethod_Task(); //Not started with Task.Run, Task.Factor.StartNew, or new Thread() AsyncMethod_Void(); //Async Void is not supported Copy Example MyInstrumentation.xml This example instruments two methods and ignores another method: Instrument: CustomInstrumentDemo.Controllers.FirstController.FirstExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.SecondExample() Ignore: CustomInstrumentDemo.Controllers.SecondController.ThirdExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.FourthExample(int id, string name) To implement this custom instrumentation scheme, use the following example file and instrumented methods: Example custom instrumentation file The following is an example custom instrumentation file named MyInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- instrument CustomInstrumentDemo.Controllers.FirstController.FirstExample and creates metric named Custom/Foo1 --> <tracerFactory metricName=\"Custom/Foo1\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.FirstController\"> <exactMethodMatcher methodName=\"FirstExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.SecondExample --> <tracerFactory> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"SecondExample\" /> </match> </tracerFactory> <!-- ignore CustomInstrumentDemo.Controllers.SecondController.ThirdExample --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"ThirdExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.FourthExample and creates metric named Custom/{value}, where {value} is the value of the first string parameter of the instrumented method (in this case, the first string parameter is \"name\"). --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.CustomSegmentTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"FourthExample\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods specified by the example custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Mvc; using System.Threading; namespace CustomInstrumentDemo.Controllers { public class FirstController : Controller { public ActionResult Foo1() { ViewBag.Message = \"Your Sample Page\"; FirstExample(); return View(); } public void FirstExample() { int firstVar = 1; for (int i = 0; i <= 500; i++) { firstVar *= 5; Thread.Sleep(50); } } } public class SecondController : Controller { public ActionResult Foo2() { ViewBag.Message = \"This view will include detailed information on the SecondExample method\"; SecondExample(); return view; } public ActionResult Foo3() { ViewBag.Message = \"This view will be ignored because of the inclusion of the ThirdExample method\"; ThirdExample(); } public void SecondExample() { int secondVar = 2; using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } public void ThirdExample() { try { var ImNotABool = \"43\"; bool.Parse(ImNotABool); } catch (Exception ex) { NewRelic.Api.Agent.NewRelic.NoticeError(ex); } } public void FourthExample(int id, string name) { Console.WriteLine(\"The ID passed in was \" + id + \" and the name passed in was \" + name); } } } Copy Name metrics Metrics created from tracers will be named using the class name and method name of the matched method. You can override this name with the metricName attribute. Begin metricName with Custom/ (for example, metricName=\"Custom/OrderSubmissions\"). <!-- instruments MyCompany.Order.Submit() and creates a metric named Custom/OrderSubmissions --> <tracerFactory metricName=\"Custom/OrderSubmissions\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.Order\"> <exactMethodMatcher methodName=\"Submit\" /> </match </tracerFactory> Copy Name transactions The agent names transactions using the tracer in the transaction with the highest naming priority. Web transactions may be named using the HTTP handler, ASP name, MVC controller name, or web service name, depending on the tracers invoked in the transaction's execution. Background transactions with no tracer that explicitly names the transaction are rolled up into a single transaction name. Use the transactionNamingPriority attribute to tell the agent to give a tracer transaction naming priority. Valid values are 1 to 7, where 7 takes precedence over 1 to 6. Also, the metricName attribute must begin with Custom/ (for example, metricName=\"Custom/instance\"). <!-- instructs the agent to create a metric for MyControllerBase.Execute and to name the transaction using this tracer's metric name --> <tracerFactory metricName=\"Custom/instance\" transactionNamingPriority=\"7\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.MyControllerBase\"> <exactMethodMatcher methodName=\"Execute\" /> </match> </tracerFactory> Copy XSD validation The XML instrumentation file can be checked against the XSD file (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) with any XSD validator. Troubleshooting The .NET agent will write a log message to NewRelic.Profiler.####.log (where #### is the PID of the instrumented process) as it rewrites methods. This helps to verify that custom instrumentation is being read and that the proper methods are being instrumented. Tip Avoid using the name attribute of the tracerFactory element in custom instrumentation. For more information, review the extension.xsd schema file in the agent directory.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.01262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add detail to transactions via XML (.<em>NET</em>)",
        "sections": "Add detail with <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ", you may need to add <em>custom</em> <em>instrumentation</em>. New Relic uses method tracers to implement <em>custom</em> <em>instrumentation</em>. A method tracer is a software probe that you can put on a method of any class. The .<em>NET</em> <em>agent</em> loads the <em>instrumentation</em> directives that define which methods should be traced from all XML"
      },
      "id": "617e9aece7b9d2a2b1c04e45"
    },
    {
      "sections": [
        "Introduction to .NET custom instrumentation",
        "Important",
        "Choose a method of custom instrumentation",
        "Creating transactions vs. adding detail",
        "Classify as \"web\" or \"non-web\" (attribute method only)"
      ],
      "title": "Introduction to .NET custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "e891d81d053b6b7c9fb4376e0e263da67b9a19cc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation/",
      "published_at": "2021-12-05T05:38:49Z",
      "updated_at": "2021-10-23T17:57:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For fully supported frameworks (.NET Framework | .NET Core), the New Relic .NET agent automatically collects and reports information on web transactions and browser tasks. However, if you are using an application framework that isn't automatically instrumented (or not using a framework) you may see large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use custom instrumentation to add transactions and detail. This document describes how to instrument activity that is not instrumented by the .NET agent by default. For other ways of configuring your app's instrumentation, see Guide to using the .NET agent API. Important For both of the agent's supported frameworks (.NET Framework and .NET Core), custom instrumentation is done the same way, unless otherwise stated. Choose a method of custom instrumentation The .NET agent supports two methods of custom instrumentation: Method Description Attribute custom instrumentation Instrument your code by decorating your methods with an attribute. Attribute instrumentation is simpler to implement than XML instrumentation because you only need to add a single decorator, in the same place in your code as the method you want to instrument. For instructions, see Custom instrumentation via attributes. XML custom instrumentation Instrument your code by listing the target methods in an XML file. XML instrumentation is more complex than attribute instrumentation, and it will fail if you change the name of the assembly, class, or method you want to instrument. However, XML instrumentation does not require you to modify your source code. For instructions, see Create transactions via XML and Add detail to transactions via XML. Creating transactions vs. adding detail When you add custom instrumentation via either method, you need to choose between creating a new transaction and adding instrumentation to an existing transaction: Situation Recommendation The method you want to instrument does not appear in the New Relic UI at all Create a new transaction. For details, see: Custom instrumentation via attributes Create transactions via XML The transaction appears in the New Relic UI but contains sections of uninstrumented time Add detail to an existing transaction. For details, see: Custom instrumentation via attributes Add detail to transactions via XML Classify as \"web\" or \"non-web\" (attribute method only) APM separates transactions into web transactions and non-web transactions in the UI. When you add detail to an existing transaction, its category is determined by the category of the parent transaction. When you create a transaction via custom instrumentation using the attribute method, you must categorize it as web or non-web. (This is not possible with XML instrumentation; all XML-created transactions are classified as non-web.) Category When to use Web Use web for web requests. You can only mark new transactions as web transactions with custom instrumentation using attributes, not by using XML. Non-web Use non-web for other types of background requests, such as console apps and services. All transactions created using XML are classified as non-web. Transactions created using attributes can be classified either as web or non-web.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.49278,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use <em>custom</em> <em>instrumentation</em> to add transactions and detail. This document describes how to <em>instrument</em> activity that is not instrumented by the .<em>NET</em> <em>agent</em> by default. For other ways"
      },
      "id": "617e9f8628ccbc53447ff12c"
    },
    {
      "sections": [
        "Create transactions via XML (.NET)",
        "Create transactions using XML",
        "For the .NET Framework or Core agent on Windows",
        "Important",
        "For the .NET Core agent on Linux",
        "For Azure App Services",
        "Tip",
        "View transactions in the UI",
        "Example: Instrument three methods",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Example: Instrument a console app",
        "Example app"
      ],
      "title": "Create transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "10ae0b4efb80fb527b16a10f567f4e645b032411",
      "image": "https://docs.newrelic.com/static/0ed431b536aef47896991b59af94f453/c1b63/custom_transactions.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/create-transactions-xml-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-10-23T18:01:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic instruments supported frameworks automatically. However, you may also have other frameworks for which some transactions are not being created automatically or additional methods that you would like to instrument. You can add custom instrumentation to these methods by creating transactions. Transactions created via XML are classified as non-web in the New Relic UI. This document describes how to create transactions with an XML file. You can also: Add details to existing transactions using XML Create transactions and add detail to existing transactions with the .NET agent API. If you have a non-IIS application, XML instrumentation requires enabling the Instrument all option during the .NET agent installation. Create transactions using XML Custom transactions (transactions not instrumented automatically) are defined in a custom instrumentation XML file. You define a method that triggers the creation of a transaction. You can also instrument additional methods called by the trigger method. Some important rules to know before you create a custom transaction: Database and external calls do not require custom instrumentation because they're automatically instrumented. Ensure your XML file is in the correct path. To define its instrumentation set, the .NET agent reads every XML file in the Extensions directory. If a method you attempt to instrument is already part of an existing transaction, it will be added as a segment to that transaction. No new transaction will be created. This will occur even if the parent method is instrumented using custom instrumentation. Avoid instrumenting things like Main() as this method won't end until the application ends and data may not be sent to New Relic. To create a custom instrumentation file: Create a new .xml file in the Extensions directory within your .NET Agent directory. The location of this directory depends on your OS: For the .NET Framework or Core agent on Windows C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Use the ProgramData directory, not the Program Files directory. For the .NET Core agent on Linux PATH_TO_AGENT_DIRECTORY/Extensions Copy PATH_TO_AGENT_DIRECTORY will be the default /usr/local/newrelic-netcore20-agent or the directory chosen at installation. For Azure App Services .NET Framework agent: D:\\home\\site\\wwwroot\\newrelic\\extensions Copy .NET Core agent: D:\\home\\site\\wwwroot\\newrelic_core\\extensions Copy Copy this template into the file you created. This template defines two separate class and methods as transactions but more can be added: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy In the file you created, customize the attribute values Name, AssemblyName, NameSpace.ClassName, and MethodName. Customize these values for both the trigger method and for any methods called by the trigger method. Tip These values are case sensitive. Name: Defines the transaction name. The metricName attribute is optional. If omitted, the transaction name will be NameSpace.ClassName/MethodName. The transaction category will be \"Custom\". The resulting full metric name will be \"OtherTransaction/Custom/Name . If you wish to change the transaction category from \"Custom\", use the SetTransactionName api call. The New Relic UI groups transactions under categories in the transaction type field. AssemblyName: The assembly that contains the trigger method. NameSpace.ClassName: The fully-qualified class name that contains the trigger method. MethodName: The exact name of the trigger method. Adding additional methods must include the \"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" attribute to be defined as a transaction. Tags without this attribute will add detail to existing transactions only. Optional: To check if the XML file is formatted correctly, you can check it against the XSD (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) using any XSD validator. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. View transactions in the UI The custom transaction starts when the method specified by methodName is invoked in the assembly specified by assemblyName. The transaction ends when the method returns or throws an exception. You can view these metrics in the Transactions page and in transaction traces. To view the transaction: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > Type > (select a type). The type is defined by Category/Name. one.newrelic.com > APM > (select an app) > Monitoring > Transactions > Type > (selected type): Use the Type menu to view your custom transactions. Example: Instrument three methods This example presents a simple implementation of creating transactions. Example custom instrumentation file This custom instrumentation file defines the three methods to instrument. Only two are defined as transactions. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Bars\"> <match assemblyName=\"Foo\" className=\"Foo.Bar\"> <exactMethodMatcher methodName=\"Bar1\" /> <exactMethodMatcher methodName=\"Bar2\" /> </match> </tracerFactory> <!-- Instrument 0 or more methods called by the trigger method. These methods appear in the transaction breakdown table and in transaction traces. --> <tracerFactory> <match assemblyName=\"Foo\" className=\"Foo.Bar\"> <exactMethodMatcher methodName=\"Bar3\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods, with comments explaining when each one will be instrumented by the agent: var bar = new Bar(); bar.Bar1(); // Creates a transaction named Bars in the Custom category. bar.Bar2(); // Creates a transaction named Bars in the Custom category. bar.Bar3(); // Won't create a new transaction. See `If Bar3 is called directly`, below. namespace Foo { public class Bar { // The agent creates a transaction that includes an external service request in its transaction traces. public void Bar1() { new WebClient().DownloadString(\"http://www.google.com/\"); } // Creates a transaction containing one segment. public void Bar2() { // The Bar3 segment will contain your SQL query inside of it and possibly an execution plan. Bar3(); } // If Bar3 is called directly, the agent will not create a transaction. // However, if Bar3 is called from Bar1 or Bar2, Bar3 will appear as a segment containing its SQL query. private void Bar3() { using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } } } Copy Example: Instrument a console app This simple console app demonstrates creating transactions. After running the application a few times, you see the transactions you created in the Transactions page (at one.newrelic.com > APM > (select an app) > Transactions > Type). The Dummy segment will be visible in the transactions breakdown table and in any transaction traces. Example custom instrumentation file This custom instrumentation file defines two methods to instrument: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"CustomTransaction\"> <match assemblyName=\"ConsoleApplication1\" className=\"ConsoleApplication1.CustomTransaction\"> <exactMethodMatcher methodName=\"StartTransaction\" /> </match> </tracerFactory> <!-- Instrument 0 or more methods called by the trigger method. These methods appear in the transaction breakdown table and in transaction traces. --> <tracerFactory> <match assemblyName=\"ConsoleApplication1\" className=\"ConsoleApplication1.CustomTransaction\"> <exactMethodMatcher methodName=\"Dummy\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example app This code contains the two methods specified by the custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { Console.WriteLine(\"Custom Transactions\"); var t = new CustomTransaction(); while (true) t.StartTransaction(); } } class CustomTransaction { public void StartTransaction() { Console.WriteLine(\"StartTransaction\"); Dummy(); } void Dummy() { System.Threading.Thread.Sleep(5000); } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create transactions via XML (.<em>NET</em>)",
        "sections": "For the .<em>NET</em> Framework or Core <em>agent</em> on Windows",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " have a non-IIS application, XML <em>instrumentation</em> requires enabling the <em>Instrument</em> all option during the .<em>NET</em> <em>agent</em> installation. Create transactions using XML <em>Custom</em> transactions (transactions not instrumented automatically) are defined in a <em>custom</em> <em>instrumentation</em> XML file. You define a method"
      },
      "id": "617e9aeb28ccbc08957feebd"
    }
  ],
  "/docs/apm/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.70291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "sections": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> provides several options for <em>custom</em> <em>instrumentation</em>. <em>Custom</em> <em>instrumentation</em> allows you to <em>instrument</em> parts of your app that are not instrumented automatically. This document describes how to <em>instrument</em> your app by decorating the methods in your app code with attributes. Use"
      },
      "id": "617e9fc0196a672142f7d03b"
    },
    {
      "sections": [
        "Add detail to transactions via XML (.NET)",
        "Add detail with custom instrumentation",
        "Important",
        "Tip",
        "Ignore a transaction",
        "Track async work in a separate transaction",
        "Example method definitions",
        "Example method invocations",
        "Example MyInstrumentation.xml",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Name metrics",
        "Name transactions",
        "XSD validation",
        "Troubleshooting"
      ],
      "title": "Add detail to transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "8220ccbb945751144b8f1fff165dd9250be651ed",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/add-detail-transactions-xml-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:17:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web browser transactions and non-web transactions (background tasks). Normally the .NET agent produces complete information automatically, without any need for you to modify your application code. However, if New Relic does not support your framework, you may need to add custom instrumentation. New Relic uses method tracers to implement custom instrumentation. A method tracer is a software probe that you can put on a method of any class. The .NET agent loads the instrumentation directives that define which methods should be traced from all XML files in the extensions directory. This document describes instrumenting work when the agent is already collecting transactions, but you want to add more detail to those transactions. To instrument work when the agent isn't creating transactions automatically, see Create transactions via XML. You can also add detail and create transactions by decorating your code with attributes. Add detail with custom instrumentation Extension files define a number of tracer factories in an instrumentation element. Each tracer factory contains match elements that define the assembly, fully qualified class name, and method name to match. To define a new custom instrumentation XML file: Create a new .xml file in the extensions directory used by the .NET agent to read every XML file and define its instrumentation set. For the .NET Framework agent, use the following location: C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Do not put the .xml file in the C:\\Program Files\\New Relic\\.NET agent\\Extensions directory. The file must be in the ProgramData file location for custom instrumentation to work. Do not modify the distributed xml files. These files are overwritten whenever the agent is upgraded. Copy this template into the file you created use the sample as an example. This instruments two methods but you can add methods to your instrumentation file. Tip The values AssemblyName, NameSpace.ClassName, and MethodName are case sensitive. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- These methods appear in the transactions breakdown table and in transaction traces --> <tracerFactory metricName=\"Category/Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <tracerFactory metricName=\"Category/Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Validate the .xml instrumentation file against extension.xsd. Non-IIS apps (such as a console app or background process): You must also create transactions via XML to contain the methods you instrument. Custom methods instrumented outside of a transaction will not be reported to New Relic. Important If your .NET agent version is 7.0 or higher, this is the end of the procedure. If your .NET agent version is lower than 7.0, continue to the next steps. If your app is IIS-hosted, restart IIS. For non-IIS applications, restart your application's host process or the application itself. Important If some of your methods still don't show up in traces after adding XML custom instrumentation, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Ignore a transaction You can stop a transaction from being reported by using a custom instrumentation file. Whenever an ignored method is called, the .NET agent ignores the entire parent transaction. This is the same as calling IgnoreTransaction(). To ignore a transaction: Add custom instrumentation. Add a tracerFactory whose name is NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory: <tracerFactory name=\" NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory \"> <match assemblyName=\"System.Web.Extensions\" className=\"System.Web.Handlers.ScriptResourceHandler\"> <exactMethodMatcher methodName=\"Throw404\" /> </match> </tracerFactory> Copy Track async work in a separate transaction In some cases, asynchronous work can be tracked as a separate transaction by applying the AsyncForceNewTransactionWrapper instrumentation: <tracerFactory name=\" AsyncForceNewTransactionWrapper \"> <match assemblyName=\"AssemblyName\" className=\"Namespace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> Copy Async usage considerations Comments Instrumented method The instrumented method must be invoked using Task.Run, Task.Factory.StartNew, or new Thread(). It cannot be invoked using the await keyword. Return type The instrumented method is not required to be async. However, if it is async, it must have a return type of Task or Task<T>. It cannot have a void return type. Attribute instrumentation The instrumented method cannot have attribute instrumentation applied to it. It cannot be decorated with the [Transaction] or [Trace] attributes. Example method definitions The following methods can be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private void SyncMethod() { } private async Task AsyncMethod_Task() { } private async Task<string> AsyncMethod_TypedTask() { return \"ok\"; } Copy The following methods cannot be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private async void AsyncMethod_Void() { } [Transaction] private void TransactionAttributedMethod() { } [Trace] private void TracedAttributedMethod() { } Copy Example method invocations The following method calls can be used with AsyncForceNewTransactionWrapper instrumentation: Task.Run(SyncMethod); Task.Factory.StartNew(AsyncMethod_Task); var newThread = new Thread(new ThreadStart(SyncMethod)); newThread.Start(); Copy The following method calls cannot be used with AsyncForceNewTransactionWrapper instrumentation: SyncMethod(); //This is not an asynchronous call await AsyncMethod_Task(); //Not started with Task.Run, Task.Factor.StartNew, or new Thread() AsyncMethod_Void(); //Async Void is not supported Copy Example MyInstrumentation.xml This example instruments two methods and ignores another method: Instrument: CustomInstrumentDemo.Controllers.FirstController.FirstExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.SecondExample() Ignore: CustomInstrumentDemo.Controllers.SecondController.ThirdExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.FourthExample(int id, string name) To implement this custom instrumentation scheme, use the following example file and instrumented methods: Example custom instrumentation file The following is an example custom instrumentation file named MyInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- instrument CustomInstrumentDemo.Controllers.FirstController.FirstExample and creates metric named Custom/Foo1 --> <tracerFactory metricName=\"Custom/Foo1\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.FirstController\"> <exactMethodMatcher methodName=\"FirstExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.SecondExample --> <tracerFactory> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"SecondExample\" /> </match> </tracerFactory> <!-- ignore CustomInstrumentDemo.Controllers.SecondController.ThirdExample --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"ThirdExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.FourthExample and creates metric named Custom/{value}, where {value} is the value of the first string parameter of the instrumented method (in this case, the first string parameter is \"name\"). --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.CustomSegmentTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"FourthExample\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods specified by the example custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Mvc; using System.Threading; namespace CustomInstrumentDemo.Controllers { public class FirstController : Controller { public ActionResult Foo1() { ViewBag.Message = \"Your Sample Page\"; FirstExample(); return View(); } public void FirstExample() { int firstVar = 1; for (int i = 0; i <= 500; i++) { firstVar *= 5; Thread.Sleep(50); } } } public class SecondController : Controller { public ActionResult Foo2() { ViewBag.Message = \"This view will include detailed information on the SecondExample method\"; SecondExample(); return view; } public ActionResult Foo3() { ViewBag.Message = \"This view will be ignored because of the inclusion of the ThirdExample method\"; ThirdExample(); } public void SecondExample() { int secondVar = 2; using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } public void ThirdExample() { try { var ImNotABool = \"43\"; bool.Parse(ImNotABool); } catch (Exception ex) { NewRelic.Api.Agent.NewRelic.NoticeError(ex); } } public void FourthExample(int id, string name) { Console.WriteLine(\"The ID passed in was \" + id + \" and the name passed in was \" + name); } } } Copy Name metrics Metrics created from tracers will be named using the class name and method name of the matched method. You can override this name with the metricName attribute. Begin metricName with Custom/ (for example, metricName=\"Custom/OrderSubmissions\"). <!-- instruments MyCompany.Order.Submit() and creates a metric named Custom/OrderSubmissions --> <tracerFactory metricName=\"Custom/OrderSubmissions\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.Order\"> <exactMethodMatcher methodName=\"Submit\" /> </match </tracerFactory> Copy Name transactions The agent names transactions using the tracer in the transaction with the highest naming priority. Web transactions may be named using the HTTP handler, ASP name, MVC controller name, or web service name, depending on the tracers invoked in the transaction's execution. Background transactions with no tracer that explicitly names the transaction are rolled up into a single transaction name. Use the transactionNamingPriority attribute to tell the agent to give a tracer transaction naming priority. Valid values are 1 to 7, where 7 takes precedence over 1 to 6. Also, the metricName attribute must begin with Custom/ (for example, metricName=\"Custom/instance\"). <!-- instructs the agent to create a metric for MyControllerBase.Execute and to name the transaction using this tracer's metric name --> <tracerFactory metricName=\"Custom/instance\" transactionNamingPriority=\"7\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.MyControllerBase\"> <exactMethodMatcher methodName=\"Execute\" /> </match> </tracerFactory> Copy XSD validation The XML instrumentation file can be checked against the XSD file (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) with any XSD validator. Troubleshooting The .NET agent will write a log message to NewRelic.Profiler.####.log (where #### is the PID of the instrumented process) as it rewrites methods. This helps to verify that custom instrumentation is being read and that the proper methods are being instrumented. Tip Avoid using the name attribute of the tracerFactory element in custom instrumentation. For more information, review the extension.xsd schema file in the agent directory.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.01257,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add detail to transactions via XML (.<em>NET</em>)",
        "sections": "Add detail with <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ", you may need to add <em>custom</em> <em>instrumentation</em>. New Relic uses method tracers to implement <em>custom</em> <em>instrumentation</em>. A method tracer is a software probe that you can put on a method of any class. The .<em>NET</em> <em>agent</em> loads the <em>instrumentation</em> directives that define which methods should be traced from all XML"
      },
      "id": "617e9aece7b9d2a2b1c04e45"
    },
    {
      "sections": [
        "Create transactions via XML (.NET)",
        "Create transactions using XML",
        "For the .NET Framework or Core agent on Windows",
        "Important",
        "For the .NET Core agent on Linux",
        "For Azure App Services",
        "Tip",
        "View transactions in the UI",
        "Example: Instrument three methods",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Example: Instrument a console app",
        "Example app"
      ],
      "title": "Create transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "10ae0b4efb80fb527b16a10f567f4e645b032411",
      "image": "https://docs.newrelic.com/static/0ed431b536aef47896991b59af94f453/c1b63/custom_transactions.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/create-transactions-xml-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-10-23T18:01:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic instruments supported frameworks automatically. However, you may also have other frameworks for which some transactions are not being created automatically or additional methods that you would like to instrument. You can add custom instrumentation to these methods by creating transactions. Transactions created via XML are classified as non-web in the New Relic UI. This document describes how to create transactions with an XML file. You can also: Add details to existing transactions using XML Create transactions and add detail to existing transactions with the .NET agent API. If you have a non-IIS application, XML instrumentation requires enabling the Instrument all option during the .NET agent installation. Create transactions using XML Custom transactions (transactions not instrumented automatically) are defined in a custom instrumentation XML file. You define a method that triggers the creation of a transaction. You can also instrument additional methods called by the trigger method. Some important rules to know before you create a custom transaction: Database and external calls do not require custom instrumentation because they're automatically instrumented. Ensure your XML file is in the correct path. To define its instrumentation set, the .NET agent reads every XML file in the Extensions directory. If a method you attempt to instrument is already part of an existing transaction, it will be added as a segment to that transaction. No new transaction will be created. This will occur even if the parent method is instrumented using custom instrumentation. Avoid instrumenting things like Main() as this method won't end until the application ends and data may not be sent to New Relic. To create a custom instrumentation file: Create a new .xml file in the Extensions directory within your .NET Agent directory. The location of this directory depends on your OS: For the .NET Framework or Core agent on Windows C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Use the ProgramData directory, not the Program Files directory. For the .NET Core agent on Linux PATH_TO_AGENT_DIRECTORY/Extensions Copy PATH_TO_AGENT_DIRECTORY will be the default /usr/local/newrelic-netcore20-agent or the directory chosen at installation. For Azure App Services .NET Framework agent: D:\\home\\site\\wwwroot\\newrelic\\extensions Copy .NET Core agent: D:\\home\\site\\wwwroot\\newrelic_core\\extensions Copy Copy this template into the file you created. This template defines two separate class and methods as transactions but more can be added: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy In the file you created, customize the attribute values Name, AssemblyName, NameSpace.ClassName, and MethodName. Customize these values for both the trigger method and for any methods called by the trigger method. Tip These values are case sensitive. Name: Defines the transaction name. The metricName attribute is optional. If omitted, the transaction name will be NameSpace.ClassName/MethodName. The transaction category will be \"Custom\". The resulting full metric name will be \"OtherTransaction/Custom/Name . If you wish to change the transaction category from \"Custom\", use the SetTransactionName api call. The New Relic UI groups transactions under categories in the transaction type field. AssemblyName: The assembly that contains the trigger method. NameSpace.ClassName: The fully-qualified class name that contains the trigger method. MethodName: The exact name of the trigger method. Adding additional methods must include the \"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" attribute to be defined as a transaction. Tags without this attribute will add detail to existing transactions only. Optional: To check if the XML file is formatted correctly, you can check it against the XSD (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) using any XSD validator. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. View transactions in the UI The custom transaction starts when the method specified by methodName is invoked in the assembly specified by assemblyName. The transaction ends when the method returns or throws an exception. You can view these metrics in the Transactions page and in transaction traces. To view the transaction: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > Type > (select a type). The type is defined by Category/Name. one.newrelic.com > APM > (select an app) > Monitoring > Transactions > Type > (selected type): Use the Type menu to view your custom transactions. Example: Instrument three methods This example presents a simple implementation of creating transactions. Example custom instrumentation file This custom instrumentation file defines the three methods to instrument. Only two are defined as transactions. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Bars\"> <match assemblyName=\"Foo\" className=\"Foo.Bar\"> <exactMethodMatcher methodName=\"Bar1\" /> <exactMethodMatcher methodName=\"Bar2\" /> </match> </tracerFactory> <!-- Instrument 0 or more methods called by the trigger method. These methods appear in the transaction breakdown table and in transaction traces. --> <tracerFactory> <match assemblyName=\"Foo\" className=\"Foo.Bar\"> <exactMethodMatcher methodName=\"Bar3\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods, with comments explaining when each one will be instrumented by the agent: var bar = new Bar(); bar.Bar1(); // Creates a transaction named Bars in the Custom category. bar.Bar2(); // Creates a transaction named Bars in the Custom category. bar.Bar3(); // Won't create a new transaction. See `If Bar3 is called directly`, below. namespace Foo { public class Bar { // The agent creates a transaction that includes an external service request in its transaction traces. public void Bar1() { new WebClient().DownloadString(\"http://www.google.com/\"); } // Creates a transaction containing one segment. public void Bar2() { // The Bar3 segment will contain your SQL query inside of it and possibly an execution plan. Bar3(); } // If Bar3 is called directly, the agent will not create a transaction. // However, if Bar3 is called from Bar1 or Bar2, Bar3 will appear as a segment containing its SQL query. private void Bar3() { using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } } } Copy Example: Instrument a console app This simple console app demonstrates creating transactions. After running the application a few times, you see the transactions you created in the Transactions page (at one.newrelic.com > APM > (select an app) > Transactions > Type). The Dummy segment will be visible in the transactions breakdown table and in any transaction traces. Example custom instrumentation file This custom instrumentation file defines two methods to instrument: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- Define the method which triggers the creation of a transaction. --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"CustomTransaction\"> <match assemblyName=\"ConsoleApplication1\" className=\"ConsoleApplication1.CustomTransaction\"> <exactMethodMatcher methodName=\"StartTransaction\" /> </match> </tracerFactory> <!-- Instrument 0 or more methods called by the trigger method. These methods appear in the transaction breakdown table and in transaction traces. --> <tracerFactory> <match assemblyName=\"ConsoleApplication1\" className=\"ConsoleApplication1.CustomTransaction\"> <exactMethodMatcher methodName=\"Dummy\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example app This code contains the two methods specified by the custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace ConsoleApplication1 { class Program { static void Main(string[] args) { Console.WriteLine(\"Custom Transactions\"); var t = new CustomTransaction(); while (true) t.StartTransaction(); } } class CustomTransaction { public void StartTransaction() { Console.WriteLine(\"StartTransaction\"); Dummy(); } void Dummy() { System.Threading.Thread.Sleep(5000); } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.19557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create transactions via XML (.<em>NET</em>)",
        "sections": "For the .<em>NET</em> Framework or Core <em>agent</em> on Windows",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " have a non-IIS application, XML <em>instrumentation</em> requires enabling the <em>Instrument</em> all option during the .<em>NET</em> <em>agent</em> installation. Create transactions using XML <em>Custom</em> transactions (transactions not instrumented automatically) are defined in a <em>custom</em> <em>instrumentation</em> XML file. You define a method"
      },
      "id": "617e9aeb28ccbc08957feebd"
    }
  ],
  "/docs/apm/agents/net-agent/getting-started/8x-to-9x-agent-migration-guide": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.3862,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.52672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.61621,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .<em>NET</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view a list of hosts"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    }
  ],
  "/docs/apm/agents/net-agent/getting-started/apm-agent-security-net": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.09872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, <em>get</em> support at support.newrelic.com. External call libraries The .<em>NET</em> <em>agent</em> automatically instruments these external call libraries : Libraries Supported methods"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Framework",
        "Requirements",
        ".NET Framework version",
        "App/web servers",
        "CLRs",
        "Operating system",
        "Use of other monitoring software",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Code Access Security",
        "Network requirements",
        "Application lifespan",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "Messaging",
        "CMS",
        "External call libraries",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Framework",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "51297ecb512364b29064565ce18f4f503d9dd415",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework/",
      "published_at": "2021-12-05T06:09:54Z",
      "updated_at": "2021-11-25T12:01:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent supports both .NET Framework and .NET Core. Here we describe the compatibility and support for .NET Framework applications. For .NET Core, see Compatibility and requirements for .NET Core. The agent includes built-in instrumentation for some of the most popular parts of the .NET Framework ecosystem, including frameworks, databases, and message queuing systems. After you download and install the agent, it runs within the monitored process. The agent does not create a separate process or service. For frameworks and libraries that are not automatically instrumented, you can extend the agent with .NET custom instrumentation. Want to try out New Relic's .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install New Relic's .NET agent, make sure your system meets these requirements: .NET Framework version .NET Framework 4.5 or higher .NET Framework 4.5 or higher requires the New Relic .NET agent version 7.0 or higher. .NET Framework 4.0 or lower To instrument applications running on .NET Framework version 4.0 and lower, you must run a version of the New Relic .NET agent earlier than 7.0. For more information and download procedures, see Technical support for .NET frameworks 4.0 or earlier. Here are additional details about .NET Framework versions 4.0 and lower: .NET Framework version Notes .NET Framework 2.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.5 Fully supported by .NET agent versions below 7.0. .NET Framework 4.0 Fully supported by .NET agent versions below 7.0. If you use .NET Framework 1.1 for any app on your target system, you must disable instrumentation of that app with applicationPool set to instrument=\"false\". The .NET agent can cause crashes in .NET 1.1 apps. App/web servers You must use one of these app/web servers: IIS Self-hosted OWIN Self-hosted WCF Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 The agent automatically creates transactions for apps hosted in IIS. If you self-host with WCF and OWIN version 3 or higher, the agent also automatically creates transactions. For other self-hosted services, you will need to create transactions via custom instrumentation. CLRs The agent requires CLR version 4.0. Legacy applications running on CLR 2.0 can be instrumented with agent versions earlier than 7.0. Operating system The agent requires one of these operating systems: Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 Windows Server 2019 Windows 10 Windows Azure (OS Family 1, 2, and 3) Windows containers running on Windows 2016 (NanoServer based images are not supported) Use of other monitoring software The .NET Common Language Runtime (CLR) only allows one profiler to access the profiling API of a process at any given time. Running our .NET agent alongside other monitoring software will result in a profiler conflict. For more information, see Errors while using other APM software. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both a 32-bit and 64-bit version. On 64-bit systems, the 64-bit agent can instrument both 32-bit and 64-bit applications. Permissions Installation requires elevated privileges (Administrator). For example, you can: Be logged in as an administrator user. Be a member of the Administrators group. On newer operating systems, provide elevation credentials when prompted. The monitored process must have read/write access to the directory in which the agent is installed. The agent runs as a part of the monitored process and relies on those permissions to function. Recommendation: Restrict permissions for the newrelic.config file and give read/write access only to the owner of the monitored process. Review permissions for the logs created by the agent to minimize the number of users with access and their privileges. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Code Access Security The use of Code Access Security is compatible with the .NET agent only when Full Trust is provided. The agent is not compatible with more restrictive trust levels. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Application lifespan The .NET agent uploads data at the end of each harvest cycle (once per minute). If your .NET app doesn't run that long, you can set the service element's sendDataOnExit attribute to true in the newrelic.config file. Automatic instrumentation If your application is hosted in ASP.NET or another fully supported framework, the .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. The .NET agent does not directly monitor datastore processes. Also, by default the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collection of the SQL query parameters can be enabled in the agent configuration. App frameworks The agent automatically instruments some application frameworks; we refer to these frameworks as fully supported. Compatibility status .NET app frameworks Fully supported These frameworks are fully supported: ASP.NET MVC 2 ASP.NET MVC 3 ASP.NET MVC 4 ASP.NET MVC 5 ASP.NET Web API v2 ASP.NET Core MVC 2.0 ASP.NET Core 2.1 ASP.NET Core 2.2 ASP.NET Web Forms Castle MonoRail v2 (not the same as Mono) OWIN-hosted web API applications on .NET framework using: Microsoft.Owin.Host.HttpListener v2.x Microsoft.Owin.Host.HttpListener v3.x Microsoft.Owin.Host.HttpListener v4.x SOAP-based web services WCF Hosting Models IIS Hosted (with and without ASP Compatibility) Self Hosted Binding Types (both client and service) WCF Instrumentation has been tested for the following common binding types. Varying levels of support are available for distributed tracing (DT) and cross application tracing (CAT): Binding Distributed Tracing (DT) Support Cross Application Tracing (CAT) Support BasicHTTP supported supported WebHTTP supported supported WSHTTP supported supported NetTCP supported supported NetNamedPipe not supported * not supported * NetMSMQ not supported * not supported * * Distributed tracing may be manually implemented using these Distributed Tracing API methods. Invocation Methods (both client and service) Synchronous Asynchronous Processing Model (APM) Begin/End Task Asynchronous Processing (TAP) Event-based Asynchronous Processing (EAP) Client support only. Not fully supported These frameworks are not fully supported: ASP.NET Web API v1: See the troubleshooting information about using ASP.NET Web API v1 with New Relic's .NET agent 5.0 or higher for apps targeting .NET Framework 4.0. (This does not affect .NET Framework 4.5 or higher.) Mono: New Relic does not support Mono, an open-source .NET framework that runs on Linux. This is because there is no Profiler API to inject into the .NET agent as a profiler into Mono-based .NET applications. The Profiler API is a Component Object Model (COM)-based interface and is not supported on Linux. Not supported Classic ASP is not supported, because the agent can only instrument .NET Framework-based apps. Sharepoint is not supported. Datastores Collecting instance details for supported datastores requires .NET agent version 6.5.29.0 or higher and is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. In order to automatically instrument the performance of .NET Framework application calls to these datastores, make sure you have the .NET agent version 8.14 or higher: Datastore Instance details Other notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Couchbase SDK version 2.x.x (2.4.0 or higher is not supported). With Couchbase, the following are not instrumented by default in favor of their multi-document counterparts: Get(string key) GetDocument(string key) Remove(string key) Remove(string key, ulong cas) Upsert<T>(string key, T value) IBM DB2 Microsoft SQL Server MongoDB We support both the modern and legacy MongoDB drivers. Legacy - mongocsharpdriver Driver versions 1.10.0 or earlier: Instance details are not available in these driver versions. Modern - MongoDB.Driver Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector Oracle PostgreSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. ServiceStack.Redis StackExchange.Redis Messaging The agent automatically instruments these message systems: MSMQ: Puts and takes on messages NServiceBus 5.0 (6.0 or higher not supported): Puts and takes on messages and cross application tracing RabbitMQ 3.5 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver CMS The agent automatically instruments the EPiServer content management system. External call libraries The agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestSharp The agent instruments these RestSharp methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync Execute ExecuteAsGet ExecuteAsPost DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: GetResponse Connect the agent to other New Relic products In addition to APM, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET applications, the .NET agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the .NET agent. Automatic browser injection is not supported for ASP.NET core applications. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.78998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Framework",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Framework",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " from datastores not currently listed, <em>get</em> support at support.newrelic.com. In order to automatically instrument the performance of .<em>NET</em> Framework application calls to these datastores, make sure you have the .<em>NET</em> <em>agent</em> version 8.14 or higher: Datastore Instance details Other notes Cosmos DB The .<em>NET</em>"
      },
      "id": "617e9ff028ccbc90f37ff8ae"
    },
    {
      "sections": [
        "Introduction to New Relic for .NET",
        "Support for both .NET Framework and .NET Core",
        "Install the agent on Windows with our guided install",
        "Install the agent",
        "Tip",
        "Configure the agent",
        "Extend your instrumentation",
        "View logs for your APM and infrastructure data",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "a19f931fc6b91fa9a3ff3e1b73886901259ca8a9",
      "image": "https://docs.newrelic.com/static/23d1cfe6da584e6ebb01f6a40080b06e/c1b63/net_overview.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/introduction-new-relic-net/",
      "published_at": "2021-12-05T06:09:53Z",
      "updated_at": "2021-11-15T06:12:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our .NET agent for application performance monitoring, you can: Use APM to get a high-level overview of your app, to see code-level details like transaction traces, database queries, and errors, and to track activity across a large distributed system. Get proactive notifications from alerts to ensure your app is up and running smoothly. Use the query builder to query your data and create custom dashboards with that data. Install infrastructure monitoring to view the performance of your app's host environment. Support for both .NET Framework and .NET Core New Relic's .NET agent supports both .NET Framework and .NET Core, and it works with all .NET compatible languages, such as VB.NET, C#, and CLI. The agent's support for .NET Core takes advantage of the compatibility, speed, expanded API features, and cross-platform capabilities of Microsoft's .NET Core. The agent does not support Microsoft .NET Core versions earlier than 2.0. With New Relic's support for .NET, you can monitor your apps in dynamic or distributed environments, such as: Cloud-managed server VM images On-host VM servers Microsoft Azure App Services Self-hosted Windows and Linux systems Amazon AWS EC2 VMs Install the agent on Windows with our guided install Our guided install creates a customized CLI command for your environment that downloads and installs the .NET agent for Windows IIS applications. Ready to get started? Click the Guided install button. If your account reports data through our EU datacenter, click EU Guided install. Guided install EU Guided install In addition to the .NET agent, you can use this to install our infrastructure agent to discover other applications, infrastructure, and log sources running in your environment and recommend which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Install the agent Before you install the .NET agent, create your New Relic account. Then, review the requirements for .NET Framework or the requirements for .NET Core. When you are ready to install, use our launcher, or see the install instructions appropriate for your operating system: Windows or Linux. Add .NET data Tip To stay up-to-date with new features and bug fixes, see the .NET agent release notes. After you install the agent and wait a few minutes for your app to generate traffic, data will appear in the APM Summary page. If no data appears, or if you encounter other problems, see New Relic's .NET agent troubleshooting procedures. one.newrelic.com > APM > (select an app) > Summary: After installing the .NET agent, you will see a summary of your app's performance on the Summary page. Configure the agent The most important part of agent configuration is to give your app a descriptive name. New Relic uses this app name to aggregate metrics when you have multiple apps or hosts. The agent also includes a variety of configuration options to further customize your installation. Extend your instrumentation After installing the .NET agent, extend the agent's instrumentation with one or more of these methods: Instrumentation options Details Browser instrumentation Integrate the .NET agent with browser monitoring to gain visibility into end-user activity. ASP.NET apps (.NET Framework only): Use any of the available options to install the browser agent. ASP.NET Core apps (targeting .NET Core or .NET Framework): Use either the API method or the copy/paste method to inject the browser agent into your webpages. Custom instrumentation Instrument transactions not captured as part of New Relic's automatic framework instrumentation. Agent API See the .NET agent API guide to learn how to customize the agent's behavior. For example, you can collect custom metrics, flag an error, or ignore a particular transaction entirely. Custom attributes Customize the attributes attached to transactions. Customizing attributes allows you to avoid sending sensitive attributes, or to collect additional attributes for deeper visibility into your transactions. Distributed tracing Enable distributed tracing to understand activity across a complex, distributed system that uses many services and microservices. Open source telemetry Explore these tools: OpenTelemetry exporter and .NET Telemetry SDK. View logs for your APM and infrastructure data You can also bring your logs and application's data together to make troubleshooting easier and faster. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. No need to switch to another UI page in New Relic One. Check the source code The .NET agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.99356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic for .<em>NET</em>",
        "sections": "Introduction to New Relic for .<em>NET</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " the <em>agent</em> on Windows with our guided install Our guided install creates a customized CLI command for your environment that downloads and installs the .<em>NET</em> <em>agent</em> for Windows IIS applications. Ready to <em>get</em> <em>started</em>? Click the Guided install button. If your account reports data through our EU datacenter"
      },
      "id": "61744d37e7b9d2d02813ddf8"
    }
  ],
  "/docs/apm/agents/net-agent/getting-started/introduction-new-relic-net": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.09872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, <em>get</em> support at support.newrelic.com. External call libraries The .<em>NET</em> <em>agent</em> automatically instruments these external call libraries : Libraries Supported methods"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Framework",
        "Requirements",
        ".NET Framework version",
        "App/web servers",
        "CLRs",
        "Operating system",
        "Use of other monitoring software",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Code Access Security",
        "Network requirements",
        "Application lifespan",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "Messaging",
        "CMS",
        "External call libraries",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Framework",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "51297ecb512364b29064565ce18f4f503d9dd415",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework/",
      "published_at": "2021-12-05T06:09:54Z",
      "updated_at": "2021-11-25T12:01:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent supports both .NET Framework and .NET Core. Here we describe the compatibility and support for .NET Framework applications. For .NET Core, see Compatibility and requirements for .NET Core. The agent includes built-in instrumentation for some of the most popular parts of the .NET Framework ecosystem, including frameworks, databases, and message queuing systems. After you download and install the agent, it runs within the monitored process. The agent does not create a separate process or service. For frameworks and libraries that are not automatically instrumented, you can extend the agent with .NET custom instrumentation. Want to try out New Relic's .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install New Relic's .NET agent, make sure your system meets these requirements: .NET Framework version .NET Framework 4.5 or higher .NET Framework 4.5 or higher requires the New Relic .NET agent version 7.0 or higher. .NET Framework 4.0 or lower To instrument applications running on .NET Framework version 4.0 and lower, you must run a version of the New Relic .NET agent earlier than 7.0. For more information and download procedures, see Technical support for .NET frameworks 4.0 or earlier. Here are additional details about .NET Framework versions 4.0 and lower: .NET Framework version Notes .NET Framework 2.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.5 Fully supported by .NET agent versions below 7.0. .NET Framework 4.0 Fully supported by .NET agent versions below 7.0. If you use .NET Framework 1.1 for any app on your target system, you must disable instrumentation of that app with applicationPool set to instrument=\"false\". The .NET agent can cause crashes in .NET 1.1 apps. App/web servers You must use one of these app/web servers: IIS Self-hosted OWIN Self-hosted WCF Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 The agent automatically creates transactions for apps hosted in IIS. If you self-host with WCF and OWIN version 3 or higher, the agent also automatically creates transactions. For other self-hosted services, you will need to create transactions via custom instrumentation. CLRs The agent requires CLR version 4.0. Legacy applications running on CLR 2.0 can be instrumented with agent versions earlier than 7.0. Operating system The agent requires one of these operating systems: Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 Windows Server 2019 Windows 10 Windows Azure (OS Family 1, 2, and 3) Windows containers running on Windows 2016 (NanoServer based images are not supported) Use of other monitoring software The .NET Common Language Runtime (CLR) only allows one profiler to access the profiling API of a process at any given time. Running our .NET agent alongside other monitoring software will result in a profiler conflict. For more information, see Errors while using other APM software. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both a 32-bit and 64-bit version. On 64-bit systems, the 64-bit agent can instrument both 32-bit and 64-bit applications. Permissions Installation requires elevated privileges (Administrator). For example, you can: Be logged in as an administrator user. Be a member of the Administrators group. On newer operating systems, provide elevation credentials when prompted. The monitored process must have read/write access to the directory in which the agent is installed. The agent runs as a part of the monitored process and relies on those permissions to function. Recommendation: Restrict permissions for the newrelic.config file and give read/write access only to the owner of the monitored process. Review permissions for the logs created by the agent to minimize the number of users with access and their privileges. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Code Access Security The use of Code Access Security is compatible with the .NET agent only when Full Trust is provided. The agent is not compatible with more restrictive trust levels. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Application lifespan The .NET agent uploads data at the end of each harvest cycle (once per minute). If your .NET app doesn't run that long, you can set the service element's sendDataOnExit attribute to true in the newrelic.config file. Automatic instrumentation If your application is hosted in ASP.NET or another fully supported framework, the .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. The .NET agent does not directly monitor datastore processes. Also, by default the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collection of the SQL query parameters can be enabled in the agent configuration. App frameworks The agent automatically instruments some application frameworks; we refer to these frameworks as fully supported. Compatibility status .NET app frameworks Fully supported These frameworks are fully supported: ASP.NET MVC 2 ASP.NET MVC 3 ASP.NET MVC 4 ASP.NET MVC 5 ASP.NET Web API v2 ASP.NET Core MVC 2.0 ASP.NET Core 2.1 ASP.NET Core 2.2 ASP.NET Web Forms Castle MonoRail v2 (not the same as Mono) OWIN-hosted web API applications on .NET framework using: Microsoft.Owin.Host.HttpListener v2.x Microsoft.Owin.Host.HttpListener v3.x Microsoft.Owin.Host.HttpListener v4.x SOAP-based web services WCF Hosting Models IIS Hosted (with and without ASP Compatibility) Self Hosted Binding Types (both client and service) WCF Instrumentation has been tested for the following common binding types. Varying levels of support are available for distributed tracing (DT) and cross application tracing (CAT): Binding Distributed Tracing (DT) Support Cross Application Tracing (CAT) Support BasicHTTP supported supported WebHTTP supported supported WSHTTP supported supported NetTCP supported supported NetNamedPipe not supported * not supported * NetMSMQ not supported * not supported * * Distributed tracing may be manually implemented using these Distributed Tracing API methods. Invocation Methods (both client and service) Synchronous Asynchronous Processing Model (APM) Begin/End Task Asynchronous Processing (TAP) Event-based Asynchronous Processing (EAP) Client support only. Not fully supported These frameworks are not fully supported: ASP.NET Web API v1: See the troubleshooting information about using ASP.NET Web API v1 with New Relic's .NET agent 5.0 or higher for apps targeting .NET Framework 4.0. (This does not affect .NET Framework 4.5 or higher.) Mono: New Relic does not support Mono, an open-source .NET framework that runs on Linux. This is because there is no Profiler API to inject into the .NET agent as a profiler into Mono-based .NET applications. The Profiler API is a Component Object Model (COM)-based interface and is not supported on Linux. Not supported Classic ASP is not supported, because the agent can only instrument .NET Framework-based apps. Sharepoint is not supported. Datastores Collecting instance details for supported datastores requires .NET agent version 6.5.29.0 or higher and is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. In order to automatically instrument the performance of .NET Framework application calls to these datastores, make sure you have the .NET agent version 8.14 or higher: Datastore Instance details Other notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Couchbase SDK version 2.x.x (2.4.0 or higher is not supported). With Couchbase, the following are not instrumented by default in favor of their multi-document counterparts: Get(string key) GetDocument(string key) Remove(string key) Remove(string key, ulong cas) Upsert<T>(string key, T value) IBM DB2 Microsoft SQL Server MongoDB We support both the modern and legacy MongoDB drivers. Legacy - mongocsharpdriver Driver versions 1.10.0 or earlier: Instance details are not available in these driver versions. Modern - MongoDB.Driver Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector Oracle PostgreSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. ServiceStack.Redis StackExchange.Redis Messaging The agent automatically instruments these message systems: MSMQ: Puts and takes on messages NServiceBus 5.0 (6.0 or higher not supported): Puts and takes on messages and cross application tracing RabbitMQ 3.5 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver CMS The agent automatically instruments the EPiServer content management system. External call libraries The agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestSharp The agent instruments these RestSharp methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync Execute ExecuteAsGet ExecuteAsPost DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: GetResponse Connect the agent to other New Relic products In addition to APM, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET applications, the .NET agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the .NET agent. Automatic browser injection is not supported for ASP.NET core applications. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.78998,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Framework",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Framework",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " from datastores not currently listed, <em>get</em> support at support.newrelic.com. In order to automatically instrument the performance of .<em>NET</em> Framework application calls to these datastores, make sure you have the .<em>NET</em> <em>agent</em> version 8.14 or higher: Datastore Instance details Other notes Cosmos DB The .<em>NET</em>"
      },
      "id": "617e9ff028ccbc90f37ff8ae"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " installer RUN [<em>Net</em>.ServicePointManager]::SecurityProtocol = [<em>Net</em>.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest &quot;https:&#x2F;&#x2F;download.newrelic.com&#x2F;dot_<em>net_agent</em>&#x2F;latest_release&#x2F;NewRelicDot<em>NetAgent</em>_x64.msi&quot;\\ -UseBasicParsing -OutFile &quot;NewRelicDot<em>NetAgent</em>_x64.msi&quot; # Install the New Relic .<em>NET</em> <em>agent</em> RUN <em>Start</em>"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    }
  ],
  "/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Framework",
        "Requirements",
        ".NET Framework version",
        "App/web servers",
        "CLRs",
        "Operating system",
        "Use of other monitoring software",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Code Access Security",
        "Network requirements",
        "Application lifespan",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "Messaging",
        "CMS",
        "External call libraries",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Framework",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "51297ecb512364b29064565ce18f4f503d9dd415",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework/",
      "published_at": "2021-12-05T06:09:54Z",
      "updated_at": "2021-11-25T12:01:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent supports both .NET Framework and .NET Core. Here we describe the compatibility and support for .NET Framework applications. For .NET Core, see Compatibility and requirements for .NET Core. The agent includes built-in instrumentation for some of the most popular parts of the .NET Framework ecosystem, including frameworks, databases, and message queuing systems. After you download and install the agent, it runs within the monitored process. The agent does not create a separate process or service. For frameworks and libraries that are not automatically instrumented, you can extend the agent with .NET custom instrumentation. Want to try out New Relic's .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install New Relic's .NET agent, make sure your system meets these requirements: .NET Framework version .NET Framework 4.5 or higher .NET Framework 4.5 or higher requires the New Relic .NET agent version 7.0 or higher. .NET Framework 4.0 or lower To instrument applications running on .NET Framework version 4.0 and lower, you must run a version of the New Relic .NET agent earlier than 7.0. For more information and download procedures, see Technical support for .NET frameworks 4.0 or earlier. Here are additional details about .NET Framework versions 4.0 and lower: .NET Framework version Notes .NET Framework 2.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.5 Fully supported by .NET agent versions below 7.0. .NET Framework 4.0 Fully supported by .NET agent versions below 7.0. If you use .NET Framework 1.1 for any app on your target system, you must disable instrumentation of that app with applicationPool set to instrument=\"false\". The .NET agent can cause crashes in .NET 1.1 apps. App/web servers You must use one of these app/web servers: IIS Self-hosted OWIN Self-hosted WCF Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 The agent automatically creates transactions for apps hosted in IIS. If you self-host with WCF and OWIN version 3 or higher, the agent also automatically creates transactions. For other self-hosted services, you will need to create transactions via custom instrumentation. CLRs The agent requires CLR version 4.0. Legacy applications running on CLR 2.0 can be instrumented with agent versions earlier than 7.0. Operating system The agent requires one of these operating systems: Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 Windows Server 2019 Windows 10 Windows Azure (OS Family 1, 2, and 3) Windows containers running on Windows 2016 (NanoServer based images are not supported) Use of other monitoring software The .NET Common Language Runtime (CLR) only allows one profiler to access the profiling API of a process at any given time. Running our .NET agent alongside other monitoring software will result in a profiler conflict. For more information, see Errors while using other APM software. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both a 32-bit and 64-bit version. On 64-bit systems, the 64-bit agent can instrument both 32-bit and 64-bit applications. Permissions Installation requires elevated privileges (Administrator). For example, you can: Be logged in as an administrator user. Be a member of the Administrators group. On newer operating systems, provide elevation credentials when prompted. The monitored process must have read/write access to the directory in which the agent is installed. The agent runs as a part of the monitored process and relies on those permissions to function. Recommendation: Restrict permissions for the newrelic.config file and give read/write access only to the owner of the monitored process. Review permissions for the logs created by the agent to minimize the number of users with access and their privileges. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Code Access Security The use of Code Access Security is compatible with the .NET agent only when Full Trust is provided. The agent is not compatible with more restrictive trust levels. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Application lifespan The .NET agent uploads data at the end of each harvest cycle (once per minute). If your .NET app doesn't run that long, you can set the service element's sendDataOnExit attribute to true in the newrelic.config file. Automatic instrumentation If your application is hosted in ASP.NET or another fully supported framework, the .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. The .NET agent does not directly monitor datastore processes. Also, by default the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collection of the SQL query parameters can be enabled in the agent configuration. App frameworks The agent automatically instruments some application frameworks; we refer to these frameworks as fully supported. Compatibility status .NET app frameworks Fully supported These frameworks are fully supported: ASP.NET MVC 2 ASP.NET MVC 3 ASP.NET MVC 4 ASP.NET MVC 5 ASP.NET Web API v2 ASP.NET Core MVC 2.0 ASP.NET Core 2.1 ASP.NET Core 2.2 ASP.NET Web Forms Castle MonoRail v2 (not the same as Mono) OWIN-hosted web API applications on .NET framework using: Microsoft.Owin.Host.HttpListener v2.x Microsoft.Owin.Host.HttpListener v3.x Microsoft.Owin.Host.HttpListener v4.x SOAP-based web services WCF Hosting Models IIS Hosted (with and without ASP Compatibility) Self Hosted Binding Types (both client and service) WCF Instrumentation has been tested for the following common binding types. Varying levels of support are available for distributed tracing (DT) and cross application tracing (CAT): Binding Distributed Tracing (DT) Support Cross Application Tracing (CAT) Support BasicHTTP supported supported WebHTTP supported supported WSHTTP supported supported NetTCP supported supported NetNamedPipe not supported * not supported * NetMSMQ not supported * not supported * * Distributed tracing may be manually implemented using these Distributed Tracing API methods. Invocation Methods (both client and service) Synchronous Asynchronous Processing Model (APM) Begin/End Task Asynchronous Processing (TAP) Event-based Asynchronous Processing (EAP) Client support only. Not fully supported These frameworks are not fully supported: ASP.NET Web API v1: See the troubleshooting information about using ASP.NET Web API v1 with New Relic's .NET agent 5.0 or higher for apps targeting .NET Framework 4.0. (This does not affect .NET Framework 4.5 or higher.) Mono: New Relic does not support Mono, an open-source .NET framework that runs on Linux. This is because there is no Profiler API to inject into the .NET agent as a profiler into Mono-based .NET applications. The Profiler API is a Component Object Model (COM)-based interface and is not supported on Linux. Not supported Classic ASP is not supported, because the agent can only instrument .NET Framework-based apps. Sharepoint is not supported. Datastores Collecting instance details for supported datastores requires .NET agent version 6.5.29.0 or higher and is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. In order to automatically instrument the performance of .NET Framework application calls to these datastores, make sure you have the .NET agent version 8.14 or higher: Datastore Instance details Other notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Couchbase SDK version 2.x.x (2.4.0 or higher is not supported). With Couchbase, the following are not instrumented by default in favor of their multi-document counterparts: Get(string key) GetDocument(string key) Remove(string key) Remove(string key, ulong cas) Upsert<T>(string key, T value) IBM DB2 Microsoft SQL Server MongoDB We support both the modern and legacy MongoDB drivers. Legacy - mongocsharpdriver Driver versions 1.10.0 or earlier: Instance details are not available in these driver versions. Modern - MongoDB.Driver Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector Oracle PostgreSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. ServiceStack.Redis StackExchange.Redis Messaging The agent automatically instruments these message systems: MSMQ: Puts and takes on messages NServiceBus 5.0 (6.0 or higher not supported): Puts and takes on messages and cross application tracing RabbitMQ 3.5 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver CMS The agent automatically instruments the EPiServer content management system. External call libraries The agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestSharp The agent instruments these RestSharp methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync Execute ExecuteAsGet ExecuteAsPost DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: GetResponse Connect the agent to other New Relic products In addition to APM, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET applications, the .NET agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the .NET agent. Automatic browser injection is not supported for ASP.NET core applications. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.78993,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Framework",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Framework",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " from datastores not currently listed, <em>get</em> support at support.newrelic.com. In order to automatically instrument the performance of .<em>NET</em> Framework application calls to these datastores, make sure you have the .<em>NET</em> <em>agent</em> version 8.14 or higher: Datastore Instance details Other notes Cosmos DB The .<em>NET</em>"
      },
      "id": "617e9ff028ccbc90f37ff8ae"
    },
    {
      "sections": [
        "Introduction to New Relic for .NET",
        "Support for both .NET Framework and .NET Core",
        "Install the agent on Windows with our guided install",
        "Install the agent",
        "Tip",
        "Configure the agent",
        "Extend your instrumentation",
        "View logs for your APM and infrastructure data",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "a19f931fc6b91fa9a3ff3e1b73886901259ca8a9",
      "image": "https://docs.newrelic.com/static/23d1cfe6da584e6ebb01f6a40080b06e/c1b63/net_overview.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/introduction-new-relic-net/",
      "published_at": "2021-12-05T06:09:53Z",
      "updated_at": "2021-11-15T06:12:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our .NET agent for application performance monitoring, you can: Use APM to get a high-level overview of your app, to see code-level details like transaction traces, database queries, and errors, and to track activity across a large distributed system. Get proactive notifications from alerts to ensure your app is up and running smoothly. Use the query builder to query your data and create custom dashboards with that data. Install infrastructure monitoring to view the performance of your app's host environment. Support for both .NET Framework and .NET Core New Relic's .NET agent supports both .NET Framework and .NET Core, and it works with all .NET compatible languages, such as VB.NET, C#, and CLI. The agent's support for .NET Core takes advantage of the compatibility, speed, expanded API features, and cross-platform capabilities of Microsoft's .NET Core. The agent does not support Microsoft .NET Core versions earlier than 2.0. With New Relic's support for .NET, you can monitor your apps in dynamic or distributed environments, such as: Cloud-managed server VM images On-host VM servers Microsoft Azure App Services Self-hosted Windows and Linux systems Amazon AWS EC2 VMs Install the agent on Windows with our guided install Our guided install creates a customized CLI command for your environment that downloads and installs the .NET agent for Windows IIS applications. Ready to get started? Click the Guided install button. If your account reports data through our EU datacenter, click EU Guided install. Guided install EU Guided install In addition to the .NET agent, you can use this to install our infrastructure agent to discover other applications, infrastructure, and log sources running in your environment and recommend which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Install the agent Before you install the .NET agent, create your New Relic account. Then, review the requirements for .NET Framework or the requirements for .NET Core. When you are ready to install, use our launcher, or see the install instructions appropriate for your operating system: Windows or Linux. Add .NET data Tip To stay up-to-date with new features and bug fixes, see the .NET agent release notes. After you install the agent and wait a few minutes for your app to generate traffic, data will appear in the APM Summary page. If no data appears, or if you encounter other problems, see New Relic's .NET agent troubleshooting procedures. one.newrelic.com > APM > (select an app) > Summary: After installing the .NET agent, you will see a summary of your app's performance on the Summary page. Configure the agent The most important part of agent configuration is to give your app a descriptive name. New Relic uses this app name to aggregate metrics when you have multiple apps or hosts. The agent also includes a variety of configuration options to further customize your installation. Extend your instrumentation After installing the .NET agent, extend the agent's instrumentation with one or more of these methods: Instrumentation options Details Browser instrumentation Integrate the .NET agent with browser monitoring to gain visibility into end-user activity. ASP.NET apps (.NET Framework only): Use any of the available options to install the browser agent. ASP.NET Core apps (targeting .NET Core or .NET Framework): Use either the API method or the copy/paste method to inject the browser agent into your webpages. Custom instrumentation Instrument transactions not captured as part of New Relic's automatic framework instrumentation. Agent API See the .NET agent API guide to learn how to customize the agent's behavior. For example, you can collect custom metrics, flag an error, or ignore a particular transaction entirely. Custom attributes Customize the attributes attached to transactions. Customizing attributes allows you to avoid sending sensitive attributes, or to collect additional attributes for deeper visibility into your transactions. Distributed tracing Enable distributed tracing to understand activity across a complex, distributed system that uses many services and microservices. Open source telemetry Explore these tools: OpenTelemetry exporter and .NET Telemetry SDK. View logs for your APM and infrastructure data You can also bring your logs and application's data together to make troubleshooting easier and faster. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. No need to switch to another UI page in New Relic One. Check the source code The .NET agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.993546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic for .<em>NET</em>",
        "sections": "Introduction to New Relic for .<em>NET</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " the <em>agent</em> on Windows with our guided install Our guided install creates a customized CLI command for your environment that downloads and installs the .<em>NET</em> <em>agent</em> for Windows IIS applications. Ready to <em>get</em> <em>started</em>? Click the Guided install button. If your account reports data through our EU datacenter"
      },
      "id": "61744d37e7b9d2d02813ddf8"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " installer RUN [<em>Net</em>.ServicePointManager]::SecurityProtocol = [<em>Net</em>.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest &quot;https:&#x2F;&#x2F;download.newrelic.com&#x2F;dot_<em>net_agent</em>&#x2F;latest_release&#x2F;NewRelicDot<em>NetAgent</em>_x64.msi&quot;\\ -UseBasicParsing -OutFile &quot;NewRelicDot<em>NetAgent</em>_x64.msi&quot; # Install the New Relic .<em>NET</em> <em>agent</em> RUN <em>Start</em>"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    }
  ],
  "/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.09868,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, <em>get</em> support at support.newrelic.com. External call libraries The .<em>NET</em> <em>agent</em> automatically instruments these external call libraries : Libraries Supported methods"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    },
    {
      "sections": [
        "Introduction to New Relic for .NET",
        "Support for both .NET Framework and .NET Core",
        "Install the agent on Windows with our guided install",
        "Install the agent",
        "Tip",
        "Configure the agent",
        "Extend your instrumentation",
        "View logs for your APM and infrastructure data",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "a19f931fc6b91fa9a3ff3e1b73886901259ca8a9",
      "image": "https://docs.newrelic.com/static/23d1cfe6da584e6ebb01f6a40080b06e/c1b63/net_overview.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/introduction-new-relic-net/",
      "published_at": "2021-12-05T06:09:53Z",
      "updated_at": "2021-11-15T06:12:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our .NET agent for application performance monitoring, you can: Use APM to get a high-level overview of your app, to see code-level details like transaction traces, database queries, and errors, and to track activity across a large distributed system. Get proactive notifications from alerts to ensure your app is up and running smoothly. Use the query builder to query your data and create custom dashboards with that data. Install infrastructure monitoring to view the performance of your app's host environment. Support for both .NET Framework and .NET Core New Relic's .NET agent supports both .NET Framework and .NET Core, and it works with all .NET compatible languages, such as VB.NET, C#, and CLI. The agent's support for .NET Core takes advantage of the compatibility, speed, expanded API features, and cross-platform capabilities of Microsoft's .NET Core. The agent does not support Microsoft .NET Core versions earlier than 2.0. With New Relic's support for .NET, you can monitor your apps in dynamic or distributed environments, such as: Cloud-managed server VM images On-host VM servers Microsoft Azure App Services Self-hosted Windows and Linux systems Amazon AWS EC2 VMs Install the agent on Windows with our guided install Our guided install creates a customized CLI command for your environment that downloads and installs the .NET agent for Windows IIS applications. Ready to get started? Click the Guided install button. If your account reports data through our EU datacenter, click EU Guided install. Guided install EU Guided install In addition to the .NET agent, you can use this to install our infrastructure agent to discover other applications, infrastructure, and log sources running in your environment and recommend which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Install the agent Before you install the .NET agent, create your New Relic account. Then, review the requirements for .NET Framework or the requirements for .NET Core. When you are ready to install, use our launcher, or see the install instructions appropriate for your operating system: Windows or Linux. Add .NET data Tip To stay up-to-date with new features and bug fixes, see the .NET agent release notes. After you install the agent and wait a few minutes for your app to generate traffic, data will appear in the APM Summary page. If no data appears, or if you encounter other problems, see New Relic's .NET agent troubleshooting procedures. one.newrelic.com > APM > (select an app) > Summary: After installing the .NET agent, you will see a summary of your app's performance on the Summary page. Configure the agent The most important part of agent configuration is to give your app a descriptive name. New Relic uses this app name to aggregate metrics when you have multiple apps or hosts. The agent also includes a variety of configuration options to further customize your installation. Extend your instrumentation After installing the .NET agent, extend the agent's instrumentation with one or more of these methods: Instrumentation options Details Browser instrumentation Integrate the .NET agent with browser monitoring to gain visibility into end-user activity. ASP.NET apps (.NET Framework only): Use any of the available options to install the browser agent. ASP.NET Core apps (targeting .NET Core or .NET Framework): Use either the API method or the copy/paste method to inject the browser agent into your webpages. Custom instrumentation Instrument transactions not captured as part of New Relic's automatic framework instrumentation. Agent API See the .NET agent API guide to learn how to customize the agent's behavior. For example, you can collect custom metrics, flag an error, or ignore a particular transaction entirely. Custom attributes Customize the attributes attached to transactions. Customizing attributes allows you to avoid sending sensitive attributes, or to collect additional attributes for deeper visibility into your transactions. Distributed tracing Enable distributed tracing to understand activity across a complex, distributed system that uses many services and microservices. Open source telemetry Explore these tools: OpenTelemetry exporter and .NET Telemetry SDK. View logs for your APM and infrastructure data You can also bring your logs and application's data together to make troubleshooting easier and faster. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. No need to switch to another UI page in New Relic One. Check the source code The .NET agent is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.993546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic for .<em>NET</em>",
        "sections": "Introduction to New Relic for .<em>NET</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " the <em>agent</em> on Windows with our guided install Our guided install creates a customized CLI command for your environment that downloads and installs the .<em>NET</em> <em>agent</em> for Windows IIS applications. Ready to <em>get</em> <em>started</em>? Click the Guided install button. If your account reports data through our EU datacenter"
      },
      "id": "61744d37e7b9d2d02813ddf8"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " installer RUN [<em>Net</em>.ServicePointManager]::SecurityProtocol = [<em>Net</em>.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest &quot;https:&#x2F;&#x2F;download.newrelic.com&#x2F;dot_<em>net_agent</em>&#x2F;latest_release&#x2F;NewRelicDot<em>NetAgent</em>_x64.msi&quot;\\ -UseBasicParsing -OutFile &quot;NewRelicDot<em>NetAgent</em>_x64.msi&quot; # Install the New Relic .<em>NET</em> <em>agent</em> RUN <em>Start</em>"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    }
  ],
  "/docs/apm/agents/net-agent/index": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19512,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.093506,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (obsolete)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "maxStackTrace",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Capture HTTP Request Headers",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "fd9643d4551ea4fd76f3275edc05251e6dc52f5c",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-12-05T06:31:05Z",
      "updated_at": "2021-11-26T00:57:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You'll be able to configure our .NET agent to suit your environnment after you create a New Relic account (it's free, forever) and install the .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED=2000 NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\a\\directory (not configurable via config file) NEWRELIC_LOG_DIRECTORY=path\\to\\a\\directory (Insert a directory where you want to put the agent and profiler logs. You can't set this directory for both agent and profiler logs in the configuration file.) NEWRELIC_LOG_LEVEL=off|error|warn|info|debug|finest|all Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown while the agent initiates a final harvest cycle and sends all data to New Relic. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Alternatively, set the NEWRELIC_LOG_LEVEL environment variable in the application's environment. Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomAttribute. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events Capture HTTP Request Headers App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. Important expectedClasses, expectedMessages, and expectedStatusCodes configuration settings require .NET agent version 8.31.0.0 or higher. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (obsolete) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable the high security property in the New Relic user interface. Enabling high security turns SSL on; request parameters, custom parameters and HTTP request headers are not collected; strip exception messages is enabled; and queries can't be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for browser monitoring. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. maxStackTrace Type Integer Default 0 By default maxStackTrace is set to 0, which disables stack traces as part of a transaction trace. If this value is set greater than 0, then stack traces will be captured for transaction traces. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Int Default 2000 The maximum number of samples to store in memory at a time. This may be configured using the NEW_RELIC_SPAN_EVENTS_MAX_SAMPLES_STORED environment variable as well. Important This configuration option is only available in the .NET Agent v9.0 or higher. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Capture HTTP Request Headers The allowAllHeaders element is a child of the configuration element. Set this to true to allow the .NET Agent to capture all HTTP request headers as request.headers.{http-header-name} attributes. Set this to false to only allow the .NET agent to collect the following HTTP request headers: request.headers.referer request.headers.accept request.headers.content-length request.headers.host request.headers.user-agent Copy enabled Type Boolean Default false Enable or disable HTTP request headers capture. Example: <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> </attributes> Copy Important The allowAllHeaders setting is only available in the .NET Agent version 8.40.0+. When using allowAllHeaders to capture attributes, the captured request header attributes are still being controlled by the root level and destination level attributes settings. Without setting the request.header.* in the include list under the attributes element (see the following), the .NET Agent still filters out all header attributes. The default newrelic.config is set to include the request.header.*. <allowAllHeaders enabled=\"true\" /> <attributes enabled=\"true\"> <include>request.headers.*</include> ... </attributes> Copy The default newrelic.config is also set to explicitly exclude the following HTTP request headers to prevent the .NET Agent collecting unwanted data. <attributes enabled=\"true\"> <exclude>request.headers.cookie</exclude> <exclude>request.headers.authorization</exclude> <exclude>request.headers.proxy-authorization</exclude> <exclude>request.headers.x-*</exclude> </attributes> Copy Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.846596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " environment variables. If your system has previously used monitoring services (non-New Relic), you may have a &quot;profiler conflict&quot; when trying to install and use the New Relic <em>agent</em>. More details: Profiler conflict explanation New Relic’s .<em>NET</em> <em>agents</em> rely on environment variables to tell the .<em>NET</em> Common"
      },
      "id": "617e9587196a67924df7e55e"
    }
  ],
  "/docs/apm/agents/net-agent/install-guides/install-net-agent-using-nuget": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.70776,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "e6ca5edfb8dde1f3d12cb84098b545577579ad65",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/net-agent-install-resources/",
      "published_at": "2021-12-05T06:48:35Z",
      "updated_at": "2021-11-15T08:30:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (such as the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.36296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "617ea23428ccbc5e0a800718"
    },
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "37eab8e6c4fc69ebf2a61fba1b0475d586459a52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-12-05T06:48:34Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.56815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "617ea1fc64441f6ccafbefe5"
    }
  ],
  "/docs/apm/agents/net-agent/install-guides/install-overview": [
    {
      "sections": [
        "New Relic guided install overview",
        "Why it matters",
        "Some technical detail",
        "Important",
        "On-host integration (OHI) recipes",
        "Troubleshoot common problems",
        "MySQL: Incorrect user permissions",
        "NGINX: No status URL"
      ],
      "title": "New Relic guided install overview",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started"
      ],
      "external_id": "d2fb3ba0450a0810bb52db550fb261275c7d17f0",
      "image": "https://docs.newrelic.com/static/6bf45ccf002250f7ebaa69cbe3ff706c/c1b63/guided-install-cli.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/new-relic-guided-install-overview/",
      "published_at": "2021-12-05T01:46:48Z",
      "updated_at": "2021-11-25T19:33:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you haven't already, sign up for a free New Relic account so you can instrument your systems and send telemetry data to New Relic. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click the Guided install button. Or, if your account reports data through our EU data center, click EU Guided install. Guided install EU Guided install Our infrastructure agent discovers the applications and infrastructure and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Why it matters With our guided install, you can instrument your applications and infrastructure and start seeing your data in New Relic in minutes. The guided install uses our command line interface (CLI), the infrastructure agent for your host environment, and a library of installation recipes to instrument your applications and infrastructure for you. That means less toil for you. Because our instrumentation recipes are open source, you can modify existing recipes, or build new ones, to suit your needs. Some technical detail The New Relic guided install uses open source installation recipes to instrument on-host integrations. These recipes include installation and setup commands, information about logs, and metadata related to what’s being installed. They're collected in a YAML file for each type of system and have all of the installation details necessary to install the infrastructure agent for a specific integration. Important On Windows, our guided install only supports Microsoft SQL Server, logs, and the infrastructure agent. All other integrations are only supported on Linux. On-host integration (OHI) recipes The guided install automates the discovery, configuration, and installation of OHIs. However, there may be times when you want to instrument them one-by-one using the CLI install command. To install any individual on-host integration, run this command: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=API_KEY NEW_RELIC_ACCOUNT_ID=ACCOUNT_ID /usr/local/bin/newrelic install -n INTEGRATION-FLAG Copy For example: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=<API_KEY> NEW_RELIC_ACCOUNT_ID=<ACCOUNT_ID> /usr/local/bin/newrelic install -n apache-open-source-integration Copy The table lists the integrations supported by the guided install CLI command. The specific on-host integration commands are provided for your reference. Our open source integrations send performance metrics and inventory data from your servers and applications to the New Relic platform. You can view pre-built dashboards of your metric data, create alert policies, and create your own custom queries and charts. Integration Command Apache newrelic install -n apache-open-source-integration Cassandra newrelic install -n cassandra-open-source-integration Couchbase newrelic install -n couchbase-open-source-integration ElasticSearch newrelic install -n elasticsearch-open-source-integration HAProxy newrelic install -n haproxy-open-source-integration HashiCorp Consul newrelic install -n hashicorp-consul-open-source-integration Memcached newrelic install -n memcached-open-source-integration Microsoft SQL Server (Windows only) newrelic install -n mssql-server-integration-installer MongoDB newrelic install -n mongodb-open-source-integration MySQL newrelic install -n mysql-open-source-integration Nagios newrelic install -n nagios-open-source-integration Nginx newrelic install -n nginx-open-source-integration PostgreSQL newrelic install -n postgres-open-source-integration RabbitMQ newrelic install -n rabbitmq-open-source-integration Redis newrelic install -n redis-open-source-integration Varnish Cache newrelic install -n varnish-cache-open-source-integration Troubleshoot common problems As we identify areas where the guided install fails, we'll document them here and provide some troubleshooting guidance. MySQL: Incorrect user permissions To monitor MySQL health data, you need a valid username and password with specific permissions. These commands will create a user and grant the required permissions: Create a user newrelic@localhost with a specific password. sudo mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'YOUR_SELECTED_PASSWORD';\" Copy Give replication privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Give select privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Once done, your next guided install attempt should work. NGINX: No status URL To monitor your NGINX server, you'll need to configure a valid status URL. status_url: The URL set up to provide the metrics using the status module. If the default value of 127.0.0.1 is incorrect, substitute the address/FQDN/URL for your system. Example: status_url: http://127.0.0.1/status You can read more about the status_url in these NGINX docs: For NGINX Open Source: HTTP stub status module For NGINX Plus: HTTP status module and HTTP API module There are different ways to set status_url, depending on how NGINX was installed: If enabled via Kubernetes: See Monitor services running on Kubernetes. If enabled via Amazon ECS: See Monitor services running on ECS. If installed on-host: Edit the config in the integration's YAML config file, nginx-config.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 293.1271,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic guided <em>install</em> <em>overview</em>",
        "sections": "New Relic guided <em>install</em> <em>overview</em>",
        "body": "If you haven&#x27;t already, sign up for a free New Relic account so you can instrument your systems and send telemetry data to New Relic. Our guided <em>install</em> creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get"
      },
      "id": "61743c2ce7b9d294a513c7c7"
    },
    {
      "sections": [
        "PHP agent installation overview",
        "PHP components",
        "Install the agent",
        "Tip",
        "RedHat or CentOS",
        "Ubuntu or Debian",
        "Tar archive",
        "View logs for your APM and infrastructure data",
        "Install PHP with partnership accounts"
      ],
      "title": "PHP agent installation overview",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Installation"
      ],
      "external_id": "09b58ebc9092c835d89eebc9cf97ca5cb95a2571",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/php-agent/installation/php-agent-installation-overview/",
      "published_at": "2021-12-05T06:29:00Z",
      "updated_at": "2021-11-15T18:40:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our PHP agent auto-instruments your code so you can start monitoring applications. You can use our guided installation for an automated install, or follow the instructions in this document to complete a basic PHP agent installation. Either way, you need a New Relic account. (It's free, forever.) Get an account Start guided install EU guided install PHP components Our PHP agent consists of two basic components: A PHP extension, which collects data from your application A local proxy daemon, which transmits the data to New Relic Your system's configuration components, including the web server, operating system, system permissions, PHP installation itself, package manager, etc., are all important factors during installation and configuration, because the agent is a part of that. For more information about supported PHP releases, frameworks, and other system requirements, see PHP compatibility and requirements. Install the agent Follow this general process to install the agent on your system. The agent installation package or tar archive includes the interactive newrelic-install script, which automates some installation tasks. Tip If your application is frequently inactive, we recommend you generate some data by interacting with the application or site. This will help ensure the agent initially connects. If you haven't already, create a New Relic account. It's free, forever. Ensure your system meets the agent's requirements, including appropriate system permissions. From your Account settings, copy your license key information. Install the agent package or tar archive on your system. RedHat or CentOS The most common way to install the agent on RedHat or CentOS is with the installation package (.rpm) and the package manager. You can tell the package manager to get it from the New Relic repository, or you can download the .rpm file directly from the New Relic website. Install the package with your preferred package manager (yum or rpm) and then run the newrelic-install script. Ubuntu or Debian Install the package either with apt-get or with dpkg commands. Typically, running the newrelic-install script is not required. Tar archive The .tar archive method is the most generic method you can use on all supported operating systems. Download the compressed tar archive for your system if any of these situations apply to you: Your operating system is not listed here. You are not using a package manager. Other methods are unsuccessful. Install the tar archive of the agent on any supported platform. Change the default application name to a meaningful name. Optional: Change other agent configuration settings to further customize your installation. Restart your web server (Apache, Nginx, PHP-FPM, etc.). Recommendation: To help ensure the PHP agent is initiated, especially if your application has infrequent activity, generate some data by using the app for a few seconds. Wait a few minutes for your application to send data to New Relic. Then, check your app's performance in the New Relic UI. View logs for your APM and infrastructure data You can also bring your logs and application's data together to make troubleshooting easier and faster. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. No need to switch to another UI page in New Relic One. Install PHP with partnership accounts Installation procedures may be different for admins who install the PHP agent through a New Relic partnership. For more information, see: AWS Heroku Magento Shared hosting providers Other partnership installation procedures Not all partners support PHP agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.52533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP agent <em>installation</em> <em>overview</em>",
        "sections": "PHP agent <em>installation</em> <em>overview</em>",
        "tags": "<em>Installation</em>",
        "body": "Our PHP agent auto-instruments your code so you can start monitoring applications. You can use our guided installation for an automated <em>install</em>, or follow the instructions in this document to complete a basic PHP agent installation. Either way, you need a New Relic account. (It&#x27;s free, forever"
      },
      "id": "617e9d27e7b9d29455c04c8b"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 284.9118,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .NET agent on Docker container",
        "sections": "<em>Overview</em> for <em>install</em> of .NET agent on Docker",
        "tags": "Other <em>installation</em>",
        "body": " for either Windows or Linux. It&#x27;s just a matter of configuring your Dockerfile to perform the procedure. <em>Overview</em> for <em>install</em> of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. <em>Install</em> the agent with one of the standard <em>install</em> procedures"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    }
  ],
  "/docs/apm/agents/net-agent/installation/install-net-agent-linux": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.11603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.093414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.1541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " of the most popular parts of the .<em>NET</em> Core ecosystem, including frameworks, databases, and message queuing systems. After <em>installation</em>, the <em>agent</em> runs within the monitored process; there is not a separate process or service created by the <em>agent</em>. For frameworks and libraries that are not automatically"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    }
  ],
  "/docs/apm/agents/net-agent/installation/install-net-agent-windows": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.11589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.15407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " of the most popular parts of the .<em>NET</em> Core ecosystem, including frameworks, databases, and message queuing systems. After <em>installation</em>, the <em>agent</em> runs within the monitored process; there is not a separate process or service created by the <em>agent</em>. For frameworks and libraries that are not automatically"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    }
  ],
  "/docs/apm/agents/net-agent/installation/introduction-net-agent-install": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.11589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.15407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " of the most popular parts of the .<em>NET</em> Core ecosystem, including frameworks, databases, and message queuing systems. After <em>installation</em>, the <em>agent</em> runs within the monitored process; there is not a separate process or service created by the <em>agent</em>. For frameworks and libraries that are not automatically"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    }
  ],
  "/docs/apm/agents/net-agent/installation/uninstall-net-agent": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.11574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.154045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " of the most popular parts of the .<em>NET</em> Core ecosystem, including frameworks, databases, and message queuing systems. After <em>installation</em>, the <em>agent</em> runs within the monitored process; there is not a separate process or service created by the <em>agent</em>. For frameworks and libraries that are not automatically"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    }
  ],
  "/docs/apm/agents/net-agent/installation/update-net-agent": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.11574,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Important",
        "Target framework version",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "d0fa683a97252cb5ea0460070b0ff94ea107cb18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-12-05T06:03:51Z",
      "updated_at": "2021-11-25T12:00:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. Table of minimum agent versions required per .NET Core version .NET Core version Minimum required .NET agent version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 .NET 6.0 > = 9.2.0 Important On Linux ARM64 platforms, the .NET agent only supports versions of .NET 5.0 or later. The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0 and 6.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy <TargetFramework>net6.0</TargetFramework> Copy Important On Linux ARM64 platforms, the .NET agent only supports target frameworks of net5.0 or later. Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Linux (ARM64/aarch64 architectures) All ARM64 Linux distributions supported by the .NET 5+ runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as both 64-bit (x64) and ARM64 (aarch64) versions on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, 5.0 and 6.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Cosmos DB The .NET agent v9.2.0 or later automatically instruments Microsoft.Azure.Cosmos library v3.17.0 or later (v3.23.0 is the latest tested version). Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.154045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "sections": ".<em>NET</em> <em>agent</em>: compatibility and requirements for .<em>NET</em> Core",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " of the most popular parts of the .<em>NET</em> Core ecosystem, including frameworks, databases, and message queuing systems. After <em>installation</em>, the <em>agent</em> runs within the monitored process; there is not a separate process or service created by the <em>agent</em>. For frameworks and libraries that are not automatically"
      },
      "id": "617e9ff0e7b9d2ab0dc04da1"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/disablebrowsermonitoring-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/getagent": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.029,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/getbrowsertimingheader-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/getlinkingmetadata-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19759,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.385345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.52603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "See related logs",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "0c7cdbb53a4bf3107cc95f3260e6848b558238b0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-12-05T04:46:29Z",
      "updated_at": "2021-11-26T09:30:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: getTraceMetadata getLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Learn about the type-specific headers of an inbound or outbound message. Headers Copy For a provided implementation of Headers use ConcurrentHashMapHeaders. See an example of W3C trace context headers implementation in DT API usage with Kafka. Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Understand a utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage Important Cross application tracing has been deprecated as of agent version 7.4.0 and will be removed in a future agent version. Instead of using cross application tracing, we recommend our distributed tracing features. Distributed tracing is an improvement on the cross application tracing feature and is recommended for large, distributed systems. To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.25462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic Java <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM Java <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "617e5b6fe7b9d248b3c06014"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/iagent": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197556,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.02897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05168,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/ignore-apdex": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197556,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.02897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05168,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/ignore-transaction": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.02896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/incrementcounter-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197525,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.02896,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/index": [
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 722.99695,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 632.5456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    },
    {
      "sections": [
        "TraceMetadata (.NET agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Properties",
        "Examples"
      ],
      "title": "TraceMetadata (.NET agent API)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "029c89628718a98d79fcc6b1a83b9e4b2a8a3b2a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/tracemetadata-net-agent-api-0/",
      "published_at": "2021-12-05T06:46:34Z",
      "updated_at": "2021-10-23T18:14:05Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax NewRelic.Api.Agent.NewRelic.TraceMetadata; Copy Returns properties in the current execution environment used to support tracing. Requirements Agent version 8.19 or higher. Compatible with all app types. Distributed tracing must be enabled to get meaningful values. Description Provides access to the following properties: Properties Name Description TraceId Returns a string representing the currently executing trace. If the trace ID is not available, or distributed tracing is disabled, the value will be string.Empty. SpanId Returns a string representing the currently executing span. If the span ID is not available, or distributed tracing is disabled, the value will be string.Empty. IsSampled Returns true if the current trace is sampled for inclusion, false if it is sampled out. Examples NewRelic.Api.Agent.IAgent Agent = NewRelic.Api.Agent.NewRelic.GetAgent(); var traceMetadata = Agent.TraceMetadata; var traceId = traceMetadata.TraceId; var spanId = traceMetadata.SpanId; var isSampled = traceMetadata.IsSampled; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 631.9523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "TraceMetadata (.<em>NET</em> <em>agent</em> <em>API</em>)",
        "sections": "TraceMetadata (.<em>NET</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax NewRelic.<em>Api.Agent</em>.NewRelic.TraceMetadata; Copy Returns properties in the current execution environment used to support tracing. Requirements <em>Agent</em> version 8.19 or higher. Compatible with all app types. Distributed tracing must be enabled to get meaningful values. Description Provides access"
      },
      "id": "617ea156e7b9d295d9c0636b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/ispan": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05162,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/itransaction": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.38507,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/noticeerror-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.02893,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/recordcustomevent-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028915,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/recordmetric-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197426,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028915,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/recordresponsetimemetric-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19739,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.0289,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05152,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/set-application-name": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19739,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.0289,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05152,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/set-transaction-uri": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05149,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/set-user-parameters": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05149,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/settransactionname-net-agent-api": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.02887,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/start-agent": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.19733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.02887,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/net-agent-api/tracemetadata-net-agent-api-0": [
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.197296,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> <em>API</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an <em>API</em> that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> <em>API</em> for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    },
    {
      "sections": [
        "ITransaction",
        "Syntax",
        "Description",
        "AcceptDistributedTraceHeaders",
        "Parameters",
        "Usage considerations",
        "Example",
        "InsertDistributedTraceHeaders",
        "AcceptDistributedTracePayload",
        "Caution",
        "CreateDistributedTracePayload (obsolete)",
        "Returns",
        "AddCustomAttribute",
        "CurrentSpan",
        "Examples"
      ],
      "title": "ITransaction",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "NET agent API"
      ],
      "external_id": "afbff8863ddc33bcc38a4c5c4ddc654d679d4d4c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/itransaction/",
      "published_at": "2021-12-05T06:44:31Z",
      "updated_at": "2021-11-15T08:16:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic API. Description Provides access to transaction-specific methods in the New Relic .NET agent API. To obtain a reference to ITransaction, use the current transaction method available on IAgent. This section contains descriptions and parameters of three ITransaction methods: Name Description AcceptDistributedTraceHeaders Accepts incoming trace context headers from another service. InsertDistributedTraceHeaders Adds trace context headers to an outgoing request. AcceptDistributedTracePayload (obsolete) Accepts an incoming distributed trace payload from another service. CreateDistributedTracePayload (obsolete) Creates a distributed trace payload for inclusion in an outgoing request. AddCustomAttribute Add contextual information from your application to the current transaction in form of attributes. CurrentSpan Provides access to the currently executing span, which provides access to span-specific methods in the New Relic API. AcceptDistributedTraceHeaders ITransaction.AcceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by InsertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated AcceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. Syntax void AcceptDistributedHeaders(carrier, getter, transportType) Copy Parameters Name Description carrier < T> Required. Source of incoming Trace Context headers. getter Func < T, string, IEnumerable < string>> Required. Caller-defined function to extract header data from the carrier. transportType TransportType enum Required. Describes the transport of the incoming payload (for example TransportType.HTTP). Usage considerations Distributed tracing must be enabled. AcceptDistributedTraceHeaders will be ignored if InsertDistributedTraceHeaders or AcceptDistributedTraceHeaders has already been called for this transaction. Example HttpContext httpContext = HttpContext.Current;IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;currentTransaction.AcceptDistributedTraceHeaders(httpContext, Getter, TransportType.HTTP);IEnumerable<string> Getter(HttpContext carrier, string key) { string value = carrier.Request.Headers[key]; return value == null ? null : new string[] { value }; } Copy InsertDistributedTraceHeaders ITransaction.InsertDistributedTraceHeaders is used to implement distributed tracing. It modifies the carrier object that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with <distributedTracing excludeNewrelicHeader=\"true\" /> in the config. This method replaces the deprecated CreateDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Syntax void InsertDistributedTraceHeaders(carrier, setter) Copy Parameters Name Description carrier < T> Required. Container where Trace Context headers are inserted.. setter Action < T, string, string> Required. Caller-defined Action to insert header data into the carrier. Usage considerations Distributed tracing must be enabled. Example HttpWebRequest requestMessage = (HttpWebRequest)WebRequest.Create(\"https://remote-address\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent();ITransaction currentTransaction = agent.CurrentTransaction;var setter = new Action<HttpWebRequest, string, string>((carrier, key, value) => { carrier.Headers?.Set(key, value); });currentTransaction.InsertDistributedTraceHeaders(requestMessage, setter); Copy AcceptDistributedTracePayload Caution This API is not available in the .NET agent v9.0 or higher. Please use AcceptDistributedTraceHeaders instead. Accepts an incoming distributed trace payload from an upstream service. Calling this method links the transaction from the upstream service to this transaction. Syntax void AcceptDistributedPayload(payload, transportType) Copy Parameters Name Description payload string Required. A string representation of the incoming distributed trace payload. transportType TransportType enum Recommended. Describes the transport of the incoming payload (for example, http). Default TransportType.Unknown. Usage considerations Distributed tracing must be enabled. The payload can be a Base64-encoded or plain text string. AcceptDistributedTracePayload will be ignored if CreateDistributedTracePayload has already been called for this transaction. Example //Obtain the information from the request object from the upstream caller.//The method by which this information is obtain is specific to the transport //type being used. For example, in an HttpRequest, this information is//contained in the header.KeyValuePair<string, string> metadata = GetMetaDataFromRequest(\"requestPayload\");IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction.AcceptDistributedTracePayload(metadata.Value, TransportType.Queue); Copy CreateDistributedTracePayload (obsolete) Caution This API is not available in the .NET agent v9.0 or higher. Please use InsertDistributedTraceHeaders instead. Creates a distributed trace payload for inclusion in an outgoing request to a downstream system. Syntax IDistributedTracePayload CreateDistributedTracePayload() Copy Returns An object that implements IDistributedTracePayload which provides access to the distributed trace payload that was created. Usage considerations Distributed tracing must be enabled. CreateDistributedTracePayload will be ignored if AcceptDistributedTracePayload has already been called for this transaction. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; IDistributedTracePayload payload = transaction.CreateDistributedTracePayload(); Copy AddCustomAttribute Adds contextual information about your application to the current transaction in the form of attributes. This method requires .NET agent version and .NET agent API version 8.24.244.0 or higher. It replaced the deprecated AddCustomParameter. Syntax ITransaction AddCustomAttribute(string key, object value) Copy Parameters Parameter Description key string Identifies the information being reported. Also known as the name. Empty keys are not supported. Keys are limited to 255-bytes. Attributes with keys larger than 255-bytes will be ignored. value object The value being reported. Returns A reference to the current transaction. Usage considerations For details about supported data types, see the Custom Attributes Guide. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"customerName\",\"Bob Smith\") .AddCustomAttribute(\"currentAge\",31) .AddCustomAttribute(\"birthday\", new DateTime(2000, 02, 14)) .AddCustomAttribute(\"waitTime\", TimeSpan.FromMilliseconds(93842)); Copy CurrentSpan Provides access to the currently executing span, making span-specific methods available within the New Relic API. Example IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; ISpan = currentSpan = transaction.CurrentSpan; Copy Examples See Parameters section.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.028854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>NET</em> <em>agent</em> <em>API</em>",
        "body": "Syntax public interface ITransaction Copy Provides access to transaction-specific methods in the New Relic <em>API</em>. Description Provides access to transaction-specific methods in the New Relic .<em>NET</em> <em>agent</em> <em>API</em>. To obtain a reference to ITransaction, use the current transaction method available on IAgent"
      },
      "id": "617e9ba328ccbc6a037ff538"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Important",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "3f09412e78afeaa0f470445a1c433ac77d0f680d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-12-05T05:38:04Z",
      "updated_at": "2021-11-25T14:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Important If some of your methods still don't show up in traces after adding the [Trace] attribute, disable method inlining for those methods with [MethodImpl(MethodImplOptions.NoInlining)]. Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "617e9fc0196a672142f7d03b"
    }
  ],
  "/docs/apm/agents/net-agent/other-features/async-support-net": [
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 238.1649,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Browser monitoring and the .NET agent",
        "Auto-instrumentation",
        "Important",
        "Manual instrumentation via agent API",
        ".NET Web Forms view engine",
        "Other view engines such as Razor",
        ".NET MVC",
        "Disable instrumentation",
        "Disable auto-instrumentation",
        "Disable auto-instrumentation on a particular view",
        "Disable both automatic and manual instrumentation on a particular view",
        "Troubleshooting"
      ],
      "title": "Browser monitoring and the .NET agent",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "071338482f7140fed1cf42574e3803e37e58aed4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/browser-monitoring-net-agent/",
      "published_at": "2021-12-05T06:47:55Z",
      "updated_at": "2021-10-23T18:20:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the .NET agent, you can add browser monitoring instrumentation to your webpages. Before you use browser with your .NET agent, refer to the .NET agent release notes, and make sure you have the installed the latest .NET agent release. Follow the .NET agent requirements to install browser monitoring. Then follow the procedures in this document to manually instrument the .NET agent. Auto-instrumentation Important This feature is not available for asp.net core applications whether they are monitored by the .NET Framework or Core agent. Browser auto-instrumentation is enabled by default. With browser auto-instrumentation, the .NET Framework agent automatically injects the browser JavaScript header into any page that has a content-type of text/html and also has <head> tag within the page. The <head> tag search starts at the beginning of the DOM. The .NET agent injects the JavaScript header through the addition of an HttpModule that modifies the page using HTTP response filters before streaming the content to the user. The first time you enable auto-instrumentation, you may need to clean your asp.net cache directory so that aspx pages are recompiled. Use the following command: flush_dotnet_temp.cmd Copy With this injection, previously functioning pages may stop working if a content-type is not set correctly. To correct, review and update the content-types in your app or disable auto-instrumentation. Manual instrumentation via agent API If you cannot enable auto-instrumentation, you can still include the browser agent manually by using the New Relic .NET agent API and including appropriate code in your pages. To download the NewRelic.Api.agent.dll, re-run the installation and reference the .dll: From the New Relic .NET agent directory, select the New Relic.Net agent section, then select API Assembly. NuGet: Install and reference the .dll by running Install-package NewRelic.Agent.Api. To set up your web application to call the New Relic .NET agent API, add a reference to NewRelic.Api.Agent.dll to your project. Optional: If you are modifying the deployed application directory on the web server, copy NewRelic.Api.Agent.dll into the application's bin directory. Call the API in your <head> tag. If a meta-tag with the X-UA-COMPATIBLE http-equiv attribute exists, set it after that meta tag. .NET Web Forms view engine When using .NET Web Forms view engine, be sure to use = and not :. That way the view engine will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. If you are using .NET ASP Web Forms with master pages, add the header manually by calling GetBrowserTimingHeader() in your master page under the <head> tag: <%= NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader() %> Copy Import the namespace with: <%@ Import Namespace=\"NewRelic.Api.Agent\" %> Copy Other view engines such as Razor For other view engines such as Razor, you can use the GetBrowserTimingHeader() method to generate the header string. Here is a Razor-based view example: <!DOCTYPE html> <html lang=\"en\"> <head> @Html.Raw(NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader()) ... </head> </html> Copy .NET MVC When using .NET MVC, call the Html.Raw helper. That way, .NET MVC will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. Disable instrumentation To disable instrumentation: Disable auto-instrumentation To fully disable auto-instrumentation, edit newrelic.config and set the autoInstrument flag to false: <!-- disable auto instrumentation --> <browserMonitoring autoInstrument=\"false\"/> Copy Important If you change the flag or uninstall the .NET agent, be sure to flush your cache again so that references to the agent are removed from compiled files. Disable auto-instrumentation on a particular view To disable only auto-instrumentation on a particular view, use the agent API call DisableBrowserMonitoring(). Add this call in any view where browser scripts are not needed or wanted. Put this API call as close as possible to the top of the view where you want it disabled. Disable both automatic and manual instrumentation on a particular view To disable both auto-instrumentation and manual instrumentation for individual webpages, use the agent API call DisableBrowserMonitoring(true). Troubleshooting Follow the troubleshooting procedures if you are unable to view any browser timing data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.72047,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "sections": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "With the .<em>NET</em> <em>agent</em>, you can add browser monitoring instrumentation to your webpages. Before you use browser with your .<em>NET</em> <em>agent</em>, refer to the .<em>NET</em> <em>agent</em> release notes, and make sure you have the installed the latest .<em>NET</em> <em>agent</em> release. Follow the .<em>NET</em> <em>agent</em> requirements to install browser"
      },
      "id": "617ea18f64441f8ce6fbcecd"
    },
    {
      "sections": [
        "Limit log disk space with log rolling"
      ],
      "title": "Limit log disk space with log rolling",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d3f7c3c6d5f7fc5b93d7aadf281fd111f4a6aec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/limit-log-disk-space-log-rolling/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-10-23T18:21:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To balance the need for logs while considering disk usage, each .NET agent will limit disk usage to 250MB using log rolling. The agent will first log to the file newrelic_agent_UNIQUENAME.log and create the file if it doesn't exist. Once that file reaches 50MB in size, the agent will: Create a new log file. Roll each existing log file to a new, sequentially numbered name (up to four archived files). Delete the fourth archive. To roll the log files, the old newrelic_agent_UNIQUENAME.log becomes the new newrelic_agent_UNIQUENAME.log(1). Then, the old newrelic_agent_UNIQUENAME.log(1) becomes the new newrelic_agent_UNIQUENAME.log(2), and so on. The old newrelic_agent_UNIQUENAME.log(4) is deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.55096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Other</em> <em>features</em>",
        "body": "To balance the need for logs while considering disk usage, each .<em>NET</em> <em>agent</em> will limit disk usage to 250MB using log rolling. The <em>agent</em> will first log to the file newrelic_<em>agent</em>_UNIQUENAME.log and create the file if it doesn&#x27;t exist. Once that file reaches 50MB in size, the <em>agent</em> will: Create a new"
      },
      "id": "617ea1fb28ccbc93a1800c19"
    }
  ],
  "/docs/apm/agents/net-agent/other-features/browser-monitoring-net-agent": [
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 238.16472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Async support in .NET",
        "Features supporting async instrumentation",
        "HttpClient async methods",
        "RestClient async methods",
        "SqlCommand async methods",
        "SqlDataReader async methods",
        "NpgsqlCommand async methods (Postgres)",
        "Custom instrumentation",
        "Known limitations",
        "Requires updated ASP pipeline",
        "Instrumented async methods must have return type of Task or Task<T>, not void",
        "No instrumentation for begin* and end* style",
        "No capture of scoped metrics/segments in manually created threads",
        "For instrumented async methods, use await, not Task.Result()",
        "ContinueWith({}) block may affect timing measurements",
        "Problem with nesting in IIS-hosted WCF apps",
        "Segments don't auto-create stack traces"
      ],
      "title": "Async support in .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "9cfd34cd4a8e91fe9fd2ddbca4a774694b1e5a50",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/async-support-net/",
      "published_at": "2021-12-05T06:46:34Z",
      "updated_at": "2021-10-23T18:20:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent automatically includes asynchronous framework instrumentation as of agent version 6.0. With the standard async-await pattern, introduced in .NET 4.5, calls to async methods can return even though the work being done in the called method is still in progress. The .NET agent observes this in-progress asynchronous work and waits for it to complete before recording timings. Features supporting async instrumentation With the addition of async support, new features are available in New Relic's .NET agent. However, as part of this enhancement, a small number of features previously provided by the agent currently are not available. Except as noted, the agent does not instrument async methods for any of the other supported frameworks for the .NET agent. HttpClient async methods The agent instruments these HttpClient async methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestClient async methods The agent instruments these RestClient async methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync SqlCommand async methods The agent instruments these SqlCommand async methods: ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync ExecuteXmlReaderAsync SqlDataReader async methods The agent instruments these SqlDataReader async methods: NextResultAsync ReadAsync NpgsqlCommand async methods (Postgres) The agent instruments these NpgsqlCommand async methods (Postgres): ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync Custom instrumentation The .NET agent supports custom instrumentation of your own async methods. Known limitations Here is a summary of known limitations for async instrumentation with New Relic's .NET agent. Requires updated ASP pipeline The .NET agent will not instrument async methods if the legacy ASP pipeline is present. Since Microsoft replaced the legacy ASP pipeline well before async methods were introduced, this issue typically only affects applications created under .NET Framework 4.0 or lower, then migrated to .NET Framework 4.5 or higher. To see if this issue affects your application, and how to resolve it if it does, review the troubleshooting procedures. Instrumented async methods must have return type of Task or Task<T>, not void The .NET agent does not support instrumentation of async methods that have return type of anything other than Task or Task<T>. The agent does not support async void methods. For more information, refer to the Microsoft documentation about async return types: Task < TResult> return type Async void and generalized async return types No instrumentation for begin* and end* style The .NET agent does not instrument any .NET methods that use the begin* and end* style, except for WCF applications. Outside of this exception, if your application calls these types of methods, the agent will not create segments for them. However, the rest of your transactions and segments will be created correctly. No capture of scoped metrics/segments in manually created threads The .NET agent does not capture scoped metrics or segments within threads that are manually created by your application. For instrumented async methods, use await, not Task.Result() If your application calls instrumented async methods, use await rather than Task related methods like Task.Result() to wait for the results. Otherwise, instrumentation may not work properly. In general, avoid using Task.Result() when calling async methods. It can lead to deadlocks. ContinueWith({}) block may affect timing measurements If you add your own ContinueWith({}) block to the promise returned by an instrumented async method, it may affect timing measurements reported by the instrumentation. For example, the time may include the time your ContinueWith takes to execute. Problem with nesting in IIS-hosted WCF apps IIS-hosted WCF services do not properly nest the WCF segment under the ExecuteRequestHandler segment. The two segments will appear to be siblings within a transaction trace, even though their reported total time will be accurate. Segments don't auto-create stack traces Segments in a transaction trace will not generate stack traces automatically, even if they run longer than transaction_tracer.stack_trace_threshold.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.58199,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Async support in .<em>NET</em>",
        "sections": "<em>Features</em> supporting async instrumentation",
        "tags": "<em>Other</em> <em>features</em>",
        "body": " observes this in-progress asynchronous work and waits for it to complete before recording timings. <em>Features</em> supporting async instrumentation With the addition of async support, new <em>features</em> are available in New Relic&#x27;s .<em>NET</em> <em>agent</em>. However, as part of this enhancement, a small number of <em>features</em>"
      },
      "id": "617e97d4e7b9d2b164c04ac4"
    },
    {
      "sections": [
        "Limit log disk space with log rolling"
      ],
      "title": "Limit log disk space with log rolling",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d3f7c3c6d5f7fc5b93d7aadf281fd111f4a6aec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/limit-log-disk-space-log-rolling/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-10-23T18:21:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To balance the need for logs while considering disk usage, each .NET agent will limit disk usage to 250MB using log rolling. The agent will first log to the file newrelic_agent_UNIQUENAME.log and create the file if it doesn't exist. Once that file reaches 50MB in size, the agent will: Create a new log file. Roll each existing log file to a new, sequentially numbered name (up to four archived files). Delete the fourth archive. To roll the log files, the old newrelic_agent_UNIQUENAME.log becomes the new newrelic_agent_UNIQUENAME.log(1). Then, the old newrelic_agent_UNIQUENAME.log(1) becomes the new newrelic_agent_UNIQUENAME.log(2), and so on. The old newrelic_agent_UNIQUENAME.log(4) is deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.55095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Other</em> <em>features</em>",
        "body": "To balance the need for logs while considering disk usage, each .<em>NET</em> <em>agent</em> will limit disk usage to 250MB using log rolling. The <em>agent</em> will first log to the file newrelic_<em>agent</em>_UNIQUENAME.log and create the file if it doesn&#x27;t exist. Once that file reaches 50MB in size, the <em>agent</em> will: Create a new"
      },
      "id": "617ea1fb28ccbc93a1800c19"
    }
  ],
  "/docs/apm/agents/net-agent/other-features/limit-log-disk-space-log-rolling": [
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 238.16472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Browser monitoring and the .NET agent",
        "Auto-instrumentation",
        "Important",
        "Manual instrumentation via agent API",
        ".NET Web Forms view engine",
        "Other view engines such as Razor",
        ".NET MVC",
        "Disable instrumentation",
        "Disable auto-instrumentation",
        "Disable auto-instrumentation on a particular view",
        "Disable both automatic and manual instrumentation on a particular view",
        "Troubleshooting"
      ],
      "title": "Browser monitoring and the .NET agent",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "071338482f7140fed1cf42574e3803e37e58aed4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/browser-monitoring-net-agent/",
      "published_at": "2021-12-05T06:47:55Z",
      "updated_at": "2021-10-23T18:20:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the .NET agent, you can add browser monitoring instrumentation to your webpages. Before you use browser with your .NET agent, refer to the .NET agent release notes, and make sure you have the installed the latest .NET agent release. Follow the .NET agent requirements to install browser monitoring. Then follow the procedures in this document to manually instrument the .NET agent. Auto-instrumentation Important This feature is not available for asp.net core applications whether they are monitored by the .NET Framework or Core agent. Browser auto-instrumentation is enabled by default. With browser auto-instrumentation, the .NET Framework agent automatically injects the browser JavaScript header into any page that has a content-type of text/html and also has <head> tag within the page. The <head> tag search starts at the beginning of the DOM. The .NET agent injects the JavaScript header through the addition of an HttpModule that modifies the page using HTTP response filters before streaming the content to the user. The first time you enable auto-instrumentation, you may need to clean your asp.net cache directory so that aspx pages are recompiled. Use the following command: flush_dotnet_temp.cmd Copy With this injection, previously functioning pages may stop working if a content-type is not set correctly. To correct, review and update the content-types in your app or disable auto-instrumentation. Manual instrumentation via agent API If you cannot enable auto-instrumentation, you can still include the browser agent manually by using the New Relic .NET agent API and including appropriate code in your pages. To download the NewRelic.Api.agent.dll, re-run the installation and reference the .dll: From the New Relic .NET agent directory, select the New Relic.Net agent section, then select API Assembly. NuGet: Install and reference the .dll by running Install-package NewRelic.Agent.Api. To set up your web application to call the New Relic .NET agent API, add a reference to NewRelic.Api.Agent.dll to your project. Optional: If you are modifying the deployed application directory on the web server, copy NewRelic.Api.Agent.dll into the application's bin directory. Call the API in your <head> tag. If a meta-tag with the X-UA-COMPATIBLE http-equiv attribute exists, set it after that meta tag. .NET Web Forms view engine When using .NET Web Forms view engine, be sure to use = and not :. That way the view engine will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. If you are using .NET ASP Web Forms with master pages, add the header manually by calling GetBrowserTimingHeader() in your master page under the <head> tag: <%= NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader() %> Copy Import the namespace with: <%@ Import Namespace=\"NewRelic.Api.Agent\" %> Copy Other view engines such as Razor For other view engines such as Razor, you can use the GetBrowserTimingHeader() method to generate the header string. Here is a Razor-based view example: <!DOCTYPE html> <html lang=\"en\"> <head> @Html.Raw(NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader()) ... </head> </html> Copy .NET MVC When using .NET MVC, call the Html.Raw helper. That way, .NET MVC will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. Disable instrumentation To disable instrumentation: Disable auto-instrumentation To fully disable auto-instrumentation, edit newrelic.config and set the autoInstrument flag to false: <!-- disable auto instrumentation --> <browserMonitoring autoInstrument=\"false\"/> Copy Important If you change the flag or uninstall the .NET agent, be sure to flush your cache again so that references to the agent are removed from compiled files. Disable auto-instrumentation on a particular view To disable only auto-instrumentation on a particular view, use the agent API call DisableBrowserMonitoring(). Add this call in any view where browser scripts are not needed or wanted. Put this API call as close as possible to the top of the view where you want it disabled. Disable both automatic and manual instrumentation on a particular view To disable both auto-instrumentation and manual instrumentation for individual webpages, use the agent API call DisableBrowserMonitoring(true). Troubleshooting Follow the troubleshooting procedures if you are unable to view any browser timing data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.72046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "sections": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "With the .<em>NET</em> <em>agent</em>, you can add browser monitoring instrumentation to your webpages. Before you use browser with your .<em>NET</em> <em>agent</em>, refer to the .<em>NET</em> <em>agent</em> release notes, and make sure you have the installed the latest .<em>NET</em> <em>agent</em> release. Follow the .<em>NET</em> <em>agent</em> requirements to install browser"
      },
      "id": "617ea18f64441f8ce6fbcecd"
    },
    {
      "sections": [
        "Async support in .NET",
        "Features supporting async instrumentation",
        "HttpClient async methods",
        "RestClient async methods",
        "SqlCommand async methods",
        "SqlDataReader async methods",
        "NpgsqlCommand async methods (Postgres)",
        "Custom instrumentation",
        "Known limitations",
        "Requires updated ASP pipeline",
        "Instrumented async methods must have return type of Task or Task<T>, not void",
        "No instrumentation for begin* and end* style",
        "No capture of scoped metrics/segments in manually created threads",
        "For instrumented async methods, use await, not Task.Result()",
        "ContinueWith({}) block may affect timing measurements",
        "Problem with nesting in IIS-hosted WCF apps",
        "Segments don't auto-create stack traces"
      ],
      "title": "Async support in .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "9cfd34cd4a8e91fe9fd2ddbca4a774694b1e5a50",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/async-support-net/",
      "published_at": "2021-12-05T06:46:34Z",
      "updated_at": "2021-10-23T18:20:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent automatically includes asynchronous framework instrumentation as of agent version 6.0. With the standard async-await pattern, introduced in .NET 4.5, calls to async methods can return even though the work being done in the called method is still in progress. The .NET agent observes this in-progress asynchronous work and waits for it to complete before recording timings. Features supporting async instrumentation With the addition of async support, new features are available in New Relic's .NET agent. However, as part of this enhancement, a small number of features previously provided by the agent currently are not available. Except as noted, the agent does not instrument async methods for any of the other supported frameworks for the .NET agent. HttpClient async methods The agent instruments these HttpClient async methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestClient async methods The agent instruments these RestClient async methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync SqlCommand async methods The agent instruments these SqlCommand async methods: ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync ExecuteXmlReaderAsync SqlDataReader async methods The agent instruments these SqlDataReader async methods: NextResultAsync ReadAsync NpgsqlCommand async methods (Postgres) The agent instruments these NpgsqlCommand async methods (Postgres): ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync Custom instrumentation The .NET agent supports custom instrumentation of your own async methods. Known limitations Here is a summary of known limitations for async instrumentation with New Relic's .NET agent. Requires updated ASP pipeline The .NET agent will not instrument async methods if the legacy ASP pipeline is present. Since Microsoft replaced the legacy ASP pipeline well before async methods were introduced, this issue typically only affects applications created under .NET Framework 4.0 or lower, then migrated to .NET Framework 4.5 or higher. To see if this issue affects your application, and how to resolve it if it does, review the troubleshooting procedures. Instrumented async methods must have return type of Task or Task<T>, not void The .NET agent does not support instrumentation of async methods that have return type of anything other than Task or Task<T>. The agent does not support async void methods. For more information, refer to the Microsoft documentation about async return types: Task < TResult> return type Async void and generalized async return types No instrumentation for begin* and end* style The .NET agent does not instrument any .NET methods that use the begin* and end* style, except for WCF applications. Outside of this exception, if your application calls these types of methods, the agent will not create segments for them. However, the rest of your transactions and segments will be created correctly. No capture of scoped metrics/segments in manually created threads The .NET agent does not capture scoped metrics or segments within threads that are manually created by your application. For instrumented async methods, use await, not Task.Result() If your application calls instrumented async methods, use await rather than Task related methods like Task.Result() to wait for the results. Otherwise, instrumentation may not work properly. In general, avoid using Task.Result() when calling async methods. It can lead to deadlocks. ContinueWith({}) block may affect timing measurements If you add your own ContinueWith({}) block to the promise returned by an instrumented async method, it may affect timing measurements reported by the instrumentation. For example, the time may include the time your ContinueWith takes to execute. Problem with nesting in IIS-hosted WCF apps IIS-hosted WCF services do not properly nest the WCF segment under the ExecuteRequestHandler segment. The two segments will appear to be siblings within a transaction trace, even though their reported total time will be accurate. Segments don't auto-create stack traces Segments in a transaction trace will not generate stack traces automatically, even if they run longer than transaction_tracer.stack_trace_threshold.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.58199,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Async support in .<em>NET</em>",
        "sections": "<em>Features</em> supporting async instrumentation",
        "tags": "<em>Other</em> <em>features</em>",
        "body": " observes this in-progress asynchronous work and waits for it to complete before recording timings. <em>Features</em> supporting async instrumentation With the addition of async support, new <em>features</em> are available in New Relic&#x27;s .<em>NET</em> <em>agent</em>. However, as part of this enhancement, a small number of <em>features</em>"
      },
      "id": "617e97d4e7b9d2b164c04ac4"
    }
  ],
  "/docs/apm/agents/net-agent/other-features/net-performance-metrics": [
    {
      "sections": [
        "Browser monitoring and the .NET agent",
        "Auto-instrumentation",
        "Important",
        "Manual instrumentation via agent API",
        ".NET Web Forms view engine",
        "Other view engines such as Razor",
        ".NET MVC",
        "Disable instrumentation",
        "Disable auto-instrumentation",
        "Disable auto-instrumentation on a particular view",
        "Disable both automatic and manual instrumentation on a particular view",
        "Troubleshooting"
      ],
      "title": "Browser monitoring and the .NET agent",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "071338482f7140fed1cf42574e3803e37e58aed4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/browser-monitoring-net-agent/",
      "published_at": "2021-12-05T06:47:55Z",
      "updated_at": "2021-10-23T18:20:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the .NET agent, you can add browser monitoring instrumentation to your webpages. Before you use browser with your .NET agent, refer to the .NET agent release notes, and make sure you have the installed the latest .NET agent release. Follow the .NET agent requirements to install browser monitoring. Then follow the procedures in this document to manually instrument the .NET agent. Auto-instrumentation Important This feature is not available for asp.net core applications whether they are monitored by the .NET Framework or Core agent. Browser auto-instrumentation is enabled by default. With browser auto-instrumentation, the .NET Framework agent automatically injects the browser JavaScript header into any page that has a content-type of text/html and also has <head> tag within the page. The <head> tag search starts at the beginning of the DOM. The .NET agent injects the JavaScript header through the addition of an HttpModule that modifies the page using HTTP response filters before streaming the content to the user. The first time you enable auto-instrumentation, you may need to clean your asp.net cache directory so that aspx pages are recompiled. Use the following command: flush_dotnet_temp.cmd Copy With this injection, previously functioning pages may stop working if a content-type is not set correctly. To correct, review and update the content-types in your app or disable auto-instrumentation. Manual instrumentation via agent API If you cannot enable auto-instrumentation, you can still include the browser agent manually by using the New Relic .NET agent API and including appropriate code in your pages. To download the NewRelic.Api.agent.dll, re-run the installation and reference the .dll: From the New Relic .NET agent directory, select the New Relic.Net agent section, then select API Assembly. NuGet: Install and reference the .dll by running Install-package NewRelic.Agent.Api. To set up your web application to call the New Relic .NET agent API, add a reference to NewRelic.Api.Agent.dll to your project. Optional: If you are modifying the deployed application directory on the web server, copy NewRelic.Api.Agent.dll into the application's bin directory. Call the API in your <head> tag. If a meta-tag with the X-UA-COMPATIBLE http-equiv attribute exists, set it after that meta tag. .NET Web Forms view engine When using .NET Web Forms view engine, be sure to use = and not :. That way the view engine will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. If you are using .NET ASP Web Forms with master pages, add the header manually by calling GetBrowserTimingHeader() in your master page under the <head> tag: <%= NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader() %> Copy Import the namespace with: <%@ Import Namespace=\"NewRelic.Api.Agent\" %> Copy Other view engines such as Razor For other view engines such as Razor, you can use the GetBrowserTimingHeader() method to generate the header string. Here is a Razor-based view example: <!DOCTYPE html> <html lang=\"en\"> <head> @Html.Raw(NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader()) ... </head> </html> Copy .NET MVC When using .NET MVC, call the Html.Raw helper. That way, .NET MVC will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. Disable instrumentation To disable instrumentation: Disable auto-instrumentation To fully disable auto-instrumentation, edit newrelic.config and set the autoInstrument flag to false: <!-- disable auto instrumentation --> <browserMonitoring autoInstrument=\"false\"/> Copy Important If you change the flag or uninstall the .NET agent, be sure to flush your cache again so that references to the agent are removed from compiled files. Disable auto-instrumentation on a particular view To disable only auto-instrumentation on a particular view, use the agent API call DisableBrowserMonitoring(). Add this call in any view where browser scripts are not needed or wanted. Put this API call as close as possible to the top of the view where you want it disabled. Disable both automatic and manual instrumentation on a particular view To disable both auto-instrumentation and manual instrumentation for individual webpages, use the agent API call DisableBrowserMonitoring(true). Troubleshooting Follow the troubleshooting procedures if you are unable to view any browser timing data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.72046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "sections": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "With the .<em>NET</em> <em>agent</em>, you can add browser monitoring instrumentation to your webpages. Before you use browser with your .<em>NET</em> <em>agent</em>, refer to the .<em>NET</em> <em>agent</em> release notes, and make sure you have the installed the latest .<em>NET</em> <em>agent</em> release. Follow the .<em>NET</em> <em>agent</em> requirements to install browser"
      },
      "id": "617ea18f64441f8ce6fbcecd"
    },
    {
      "sections": [
        "Async support in .NET",
        "Features supporting async instrumentation",
        "HttpClient async methods",
        "RestClient async methods",
        "SqlCommand async methods",
        "SqlDataReader async methods",
        "NpgsqlCommand async methods (Postgres)",
        "Custom instrumentation",
        "Known limitations",
        "Requires updated ASP pipeline",
        "Instrumented async methods must have return type of Task or Task<T>, not void",
        "No instrumentation for begin* and end* style",
        "No capture of scoped metrics/segments in manually created threads",
        "For instrumented async methods, use await, not Task.Result()",
        "ContinueWith({}) block may affect timing measurements",
        "Problem with nesting in IIS-hosted WCF apps",
        "Segments don't auto-create stack traces"
      ],
      "title": "Async support in .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "9cfd34cd4a8e91fe9fd2ddbca4a774694b1e5a50",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/async-support-net/",
      "published_at": "2021-12-05T06:46:34Z",
      "updated_at": "2021-10-23T18:20:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent automatically includes asynchronous framework instrumentation as of agent version 6.0. With the standard async-await pattern, introduced in .NET 4.5, calls to async methods can return even though the work being done in the called method is still in progress. The .NET agent observes this in-progress asynchronous work and waits for it to complete before recording timings. Features supporting async instrumentation With the addition of async support, new features are available in New Relic's .NET agent. However, as part of this enhancement, a small number of features previously provided by the agent currently are not available. Except as noted, the agent does not instrument async methods for any of the other supported frameworks for the .NET agent. HttpClient async methods The agent instruments these HttpClient async methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestClient async methods The agent instruments these RestClient async methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync SqlCommand async methods The agent instruments these SqlCommand async methods: ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync ExecuteXmlReaderAsync SqlDataReader async methods The agent instruments these SqlDataReader async methods: NextResultAsync ReadAsync NpgsqlCommand async methods (Postgres) The agent instruments these NpgsqlCommand async methods (Postgres): ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync Custom instrumentation The .NET agent supports custom instrumentation of your own async methods. Known limitations Here is a summary of known limitations for async instrumentation with New Relic's .NET agent. Requires updated ASP pipeline The .NET agent will not instrument async methods if the legacy ASP pipeline is present. Since Microsoft replaced the legacy ASP pipeline well before async methods were introduced, this issue typically only affects applications created under .NET Framework 4.0 or lower, then migrated to .NET Framework 4.5 or higher. To see if this issue affects your application, and how to resolve it if it does, review the troubleshooting procedures. Instrumented async methods must have return type of Task or Task<T>, not void The .NET agent does not support instrumentation of async methods that have return type of anything other than Task or Task<T>. The agent does not support async void methods. For more information, refer to the Microsoft documentation about async return types: Task < TResult> return type Async void and generalized async return types No instrumentation for begin* and end* style The .NET agent does not instrument any .NET methods that use the begin* and end* style, except for WCF applications. Outside of this exception, if your application calls these types of methods, the agent will not create segments for them. However, the rest of your transactions and segments will be created correctly. No capture of scoped metrics/segments in manually created threads The .NET agent does not capture scoped metrics or segments within threads that are manually created by your application. For instrumented async methods, use await, not Task.Result() If your application calls instrumented async methods, use await rather than Task related methods like Task.Result() to wait for the results. Otherwise, instrumentation may not work properly. In general, avoid using Task.Result() when calling async methods. It can lead to deadlocks. ContinueWith({}) block may affect timing measurements If you add your own ContinueWith({}) block to the promise returned by an instrumented async method, it may affect timing measurements reported by the instrumentation. For example, the time may include the time your ContinueWith takes to execute. Problem with nesting in IIS-hosted WCF apps IIS-hosted WCF services do not properly nest the WCF segment under the ExecuteRequestHandler segment. The two segments will appear to be siblings within a transaction trace, even though their reported total time will be accurate. Segments don't auto-create stack traces Segments in a transaction trace will not generate stack traces automatically, even if they run longer than transaction_tracer.stack_trace_threshold.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.58197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Async support in .<em>NET</em>",
        "sections": "<em>Features</em> supporting async instrumentation",
        "tags": "<em>Other</em> <em>features</em>",
        "body": " observes this in-progress asynchronous work and waits for it to complete before recording timings. <em>Features</em> supporting async instrumentation With the addition of async support, new <em>features</em> are available in New Relic&#x27;s .<em>NET</em> <em>agent</em>. However, as part of this enhancement, a small number of <em>features</em>"
      },
      "id": "617e97d4e7b9d2b164c04ac4"
    },
    {
      "sections": [
        "Limit log disk space with log rolling"
      ],
      "title": "Limit log disk space with log rolling",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d3f7c3c6d5f7fc5b93d7aadf281fd111f4a6aec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/limit-log-disk-space-log-rolling/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-10-23T18:21:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To balance the need for logs while considering disk usage, each .NET agent will limit disk usage to 250MB using log rolling. The agent will first log to the file newrelic_agent_UNIQUENAME.log and create the file if it doesn't exist. Once that file reaches 50MB in size, the agent will: Create a new log file. Roll each existing log file to a new, sequentially numbered name (up to four archived files). Delete the fourth archive. To roll the log files, the old newrelic_agent_UNIQUENAME.log becomes the new newrelic_agent_UNIQUENAME.log(1). Then, the old newrelic_agent_UNIQUENAME.log(1) becomes the new newrelic_agent_UNIQUENAME.log(2), and so on. The old newrelic_agent_UNIQUENAME.log(4) is deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.55095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Other</em> <em>features</em>",
        "body": "To balance the need for logs while considering disk usage, each .<em>NET</em> <em>agent</em> will limit disk usage to 250MB using log rolling. The <em>agent</em> will first log to the file newrelic_<em>agent</em>_UNIQUENAME.log and create the file if it doesn&#x27;t exist. Once that file reaches 50MB in size, the <em>agent</em> will: Create a new"
      },
      "id": "617ea1fb28ccbc93a1800c19"
    }
  ],
  "/docs/apm/agents/net-agent/other-installation/how-verify-checksum-net-agent-downloads": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.70422,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "e6ca5edfb8dde1f3d12cb84098b545577579ad65",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/net-agent-install-resources/",
      "published_at": "2021-12-05T06:48:35Z",
      "updated_at": "2021-11-15T08:30:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (such as the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.36269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "617ea23428ccbc5e0a800718"
    },
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "37eab8e6c4fc69ebf2a61fba1b0475d586459a52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-12-05T06:48:34Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.56805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "617ea1fc64441f6ccafbefe5"
    }
  ],
  "/docs/apm/agents/net-agent/other-installation/install-net-agent-aspnet-core": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.70422,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "e6ca5edfb8dde1f3d12cb84098b545577579ad65",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/net-agent-install-resources/",
      "published_at": "2021-12-05T06:48:35Z",
      "updated_at": "2021-11-15T08:30:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (such as the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.36269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "617ea23428ccbc5e0a800718"
    },
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "37eab8e6c4fc69ebf2a61fba1b0475d586459a52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-12-05T06:48:34Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.56805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "617ea1fc64441f6ccafbefe5"
    }
  ],
  "/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container": [
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "e6ca5edfb8dde1f3d12cb84098b545577579ad65",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/net-agent-install-resources/",
      "published_at": "2021-12-05T06:48:35Z",
      "updated_at": "2021-11-15T08:30:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (such as the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.36267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "617ea23428ccbc5e0a800718"
    },
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "37eab8e6c4fc69ebf2a61fba1b0475d586459a52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-12-05T06:48:34Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.56805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "617ea1fc64441f6ccafbefe5"
    },
    {
      "sections": [
        "How to verify the checksum of .NET Agent downloads",
        "Windows",
        "CertUtil",
        "Powershell: Get-FileHash",
        "Linux",
        "sha256sum"
      ],
      "title": "How to verify the checksum of .NET Agent downloads",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "9b1395de5ffbd062440508aa9a1d11d84a7818d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/how-verify-checksum-net-agent-downloads/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read about how to confirm the checksum for New Relic's .NET agent installers. If you need the hashes for our current releases, download their SHA256 hashes from our download site. Windows On Windows, we recommended using either CertUtil or Get-FileHash to compute a file hash. CertUtil This utility is available as part of Certificate Services and can be used to compute the hash of a file. This utility can be run from the Command Prompt or Powershell. To compute the hash, run: CertUtil -hashfile YOUR_FILENAME SHA256 If successful, you'll get this response: SHA256 hash of YOUR_FILENAME: 5092fd52e40132a41ac06c320296cd9d63196d6de0fa6ce9b74fc4de1b3f9502 CertUtil: -hashfile command completed successfully. Copy Powershell: Get-FileHash The Get-FileHash cmdlet is included with Powershell version 5.1+ and can be used to compute the hash of a file. To compute the hash, run: Get-FileHash YOUR_FILENAME Algorithm SHA256 | Format-List If successful, you'll get this response: Algorithm : SHA256 Hash : 5092FD52E40132A41AC06C320296CD9D63196D6DE0FA6CE9B74FC4DE1B3F9502 Path : C:\\Path\\To\\YOUR_FILENAME Copy Linux On Linux, we recommend using sha256sum Copy to compute a file hash. sha256sum To compute the hash, run: sha256sum YOUR_FILENAME If successful, you'll get this response: 5092fd52e40132a41ac06c320296cd9d63196d6de0fa6ce9b74fc4de1b3f9502 YOUR_FILENAME Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.47115,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to verify the checksum of .<em>NET</em> <em>Agent</em> downloads",
        "sections": "How to verify the checksum of .<em>NET</em> <em>Agent</em> downloads",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "Read about how to confirm the checksum for New Relic&#x27;s .<em>NET</em> <em>agent</em> installers. If you need the hashes for our current releases, download their SHA256 hashes from our download site. Windows On Windows, we recommended using either CertUtil or Get-FileHash to compute a file hash. CertUtil This utility"
      },
      "id": "617ea1c7e7b9d213edc05b33"
    }
  ],
  "/docs/apm/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.70377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "e6ca5edfb8dde1f3d12cb84098b545577579ad65",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/net-agent-install-resources/",
      "published_at": "2021-12-05T06:48:35Z",
      "updated_at": "2021-11-15T08:30:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (such as the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.36264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "617ea23428ccbc5e0a800718"
    },
    {
      "sections": [
        "How to verify the checksum of .NET Agent downloads",
        "Windows",
        "CertUtil",
        "Powershell: Get-FileHash",
        "Linux",
        "sha256sum"
      ],
      "title": "How to verify the checksum of .NET Agent downloads",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "9b1395de5ffbd062440508aa9a1d11d84a7818d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/how-verify-checksum-net-agent-downloads/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read about how to confirm the checksum for New Relic's .NET agent installers. If you need the hashes for our current releases, download their SHA256 hashes from our download site. Windows On Windows, we recommended using either CertUtil or Get-FileHash to compute a file hash. CertUtil This utility is available as part of Certificate Services and can be used to compute the hash of a file. This utility can be run from the Command Prompt or Powershell. To compute the hash, run: CertUtil -hashfile YOUR_FILENAME SHA256 If successful, you'll get this response: SHA256 hash of YOUR_FILENAME: 5092fd52e40132a41ac06c320296cd9d63196d6de0fa6ce9b74fc4de1b3f9502 CertUtil: -hashfile command completed successfully. Copy Powershell: Get-FileHash The Get-FileHash cmdlet is included with Powershell version 5.1+ and can be used to compute the hash of a file. To compute the hash, run: Get-FileHash YOUR_FILENAME Algorithm SHA256 | Format-List If successful, you'll get this response: Algorithm : SHA256 Hash : 5092FD52E40132A41AC06C320296CD9D63196D6DE0FA6CE9B74FC4DE1B3F9502 Path : C:\\Path\\To\\YOUR_FILENAME Copy Linux On Linux, we recommend using sha256sum Copy to compute a file hash. sha256sum To compute the hash, run: sha256sum YOUR_FILENAME If successful, you'll get this response: 5092fd52e40132a41ac06c320296cd9d63196d6de0fa6ce9b74fc4de1b3f9502 YOUR_FILENAME Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.47113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to verify the checksum of .<em>NET</em> <em>Agent</em> downloads",
        "sections": "How to verify the checksum of .<em>NET</em> <em>Agent</em> downloads",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "Read about how to confirm the checksum for New Relic&#x27;s .<em>NET</em> <em>agent</em> installers. If you need the hashes for our current releases, download their SHA256 hashes from our download site. Windows On Windows, we recommended using either CertUtil or Get-FileHash to compute a file hash. CertUtil This utility"
      },
      "id": "617ea1c7e7b9d213edc05b33"
    }
  ],
  "/docs/apm/agents/net-agent/other-installation/net-agent-install-resources": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 262.70377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "37eab8e6c4fc69ebf2a61fba1b0475d586459a52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-12-05T06:48:34Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.56805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "617ea1fc64441f6ccafbefe5"
    },
    {
      "sections": [
        "How to verify the checksum of .NET Agent downloads",
        "Windows",
        "CertUtil",
        "Powershell: Get-FileHash",
        "Linux",
        "sha256sum"
      ],
      "title": "How to verify the checksum of .NET Agent downloads",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "9b1395de5ffbd062440508aa9a1d11d84a7818d5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/how-verify-checksum-net-agent-downloads/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-10-23T18:05:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read about how to confirm the checksum for New Relic's .NET agent installers. If you need the hashes for our current releases, download their SHA256 hashes from our download site. Windows On Windows, we recommended using either CertUtil or Get-FileHash to compute a file hash. CertUtil This utility is available as part of Certificate Services and can be used to compute the hash of a file. This utility can be run from the Command Prompt or Powershell. To compute the hash, run: CertUtil -hashfile YOUR_FILENAME SHA256 If successful, you'll get this response: SHA256 hash of YOUR_FILENAME: 5092fd52e40132a41ac06c320296cd9d63196d6de0fa6ce9b74fc4de1b3f9502 CertUtil: -hashfile command completed successfully. Copy Powershell: Get-FileHash The Get-FileHash cmdlet is included with Powershell version 5.1+ and can be used to compute the hash of a file. To compute the hash, run: Get-FileHash YOUR_FILENAME Algorithm SHA256 | Format-List If successful, you'll get this response: Algorithm : SHA256 Hash : 5092FD52E40132A41AC06C320296CD9D63196D6DE0FA6CE9B74FC4DE1B3F9502 Path : C:\\Path\\To\\YOUR_FILENAME Copy Linux On Linux, we recommend using sha256sum Copy to compute a file hash. sha256sum To compute the hash, run: sha256sum YOUR_FILENAME If successful, you'll get this response: 5092fd52e40132a41ac06c320296cd9d63196d6de0fa6ce9b74fc4de1b3f9502 YOUR_FILENAME Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.47113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How to verify the checksum of .<em>NET</em> <em>Agent</em> downloads",
        "sections": "How to verify the checksum of .<em>NET</em> <em>Agent</em> downloads",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "Read about how to confirm the checksum for New Relic&#x27;s .<em>NET</em> <em>agent</em> installers. If you need the hashes for our current releases, download their SHA256 hashes from our download site. Windows On Windows, we recommended using either CertUtil or Get-FileHash to compute a file hash. CertUtil This utility"
      },
      "id": "617ea1c7e7b9d213edc05b33"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/agent-changes-content-type-header-wcf-apps-net": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19319,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.0918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.611465,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/azure-pipelines-wipes-out-newrelicazurewebsitesextension-directories": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.193085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09169,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.611435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/browser-injection-health-check-conflict": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.193085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09169,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.611435,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/cocreate-errors-no-event-log": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19298,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.0916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.611404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/cocreateinstance-errors-no-profiler-log": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19298,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.0916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.611404,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/debugging-net-core-agent-linux": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19287,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09151,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.611374,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.192764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.091415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.61134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/high-memory-usage-net": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.192764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.091415,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.61134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/missing-couchbase-metrics-net": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.61131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/missing-net-async-metrics": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.61131,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ],
  "/docs/apm/agents/net-agent/troubleshooting/monitor-short-lived-net-processes": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "0e75eec7071fa9b7626de140bc5537159da8d826",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-12-05T09:03:16Z",
      "updated_at": "2021-12-05T09:03:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile # Use the correct tagged version for your application's targeted runtime. See https://hub.docker.com/_/microsoft-dotnet-aspnet/ FROM mcr.microsoft.com/dotnet/aspnet:6.0 # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent \\ && rm -rf /var/lib/apt/lists/* # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile # This example uses .NET 6.0. For other versions, see https://hub.docker.com/_/microsoft-dotnet-sdk/ FROM mcr.microsoft.com/dotnet/sdk:6.0 AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet publish -c Release -o /app ./YOUR_APP_NAME # The runtime tag version should match the SDK tag version FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM mcr.microsoft.com/dotnet/framework/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Download the New Relic .NET agent installer RUN [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Download the New Relic .NET agent installer RUN powershell.exe [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12;\\ Invoke-WebRequest \"https://download.newrelic.com/dot_net_agent/latest_release/NewRelicDotNetAgent_x64.msi\"\\ -UseBasicParsing -OutFile \"NewRelicDotNetAgent_x64.msi\" # Install the New Relic .NET agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"NewRelicDotNetAgent_x64.msi\", /qn,\\ NR_LICENSE_KEY=YOUR_LICENSE_KEY # Remove the New Relic .NET agent installer RUN powershell.exe Remove-Item \"NewRelicDotNetAgent_x64.msi\" # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windows/servercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.19254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "Install .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .<em>NET</em> <em>agent</em>. Examples are included for both Windows and Linux containers. Installing the .<em>NET</em> <em>agent</em> in a Docker container can be performed using the same procedures as a standard .<em>NET</em> <em>agent</em> install"
      },
      "id": "617ea1c8e7b9d28b99c04bdb"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "6d4cb5f679b1c0c5cb468b07d6135e99479a1bfb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-12-05T06:47:16Z",
      "updated_at": "2021-12-05T06:47:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. Alternatively, you may use the Metric explorer under one.newrelic.com > APM > (select an app) > More views. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.09122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "617ea18e196a67eaf9f7cb46"
    },
    {
      "sections": [
        "Guide to using the .NET agent API",
        "Requirements",
        "Important",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "See related logs",
        "Instrument asynchronous work",
        "View calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser monitoring agent"
      ],
      "title": "Guide to using the .NET agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "API guides"
      ],
      "external_id": "03f79d963725d4c950219143dedb6efa443be9f1",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/net-agent/net-agent-api/guide-using-net-agent-api/",
      "published_at": "2021-12-05T06:04:13Z",
      "updated_at": "2021-11-26T07:39:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent includes an API that allows you to extend the agent's standard functionality. For example, you can use the .NET agent API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .NET agent's default behavior by adjusting configuration settings or using custom instrumentation. Requirements Important As of September 2021, a small subset of APIs, configuration options, and installation options for .NET will be replaced by new methods. For more details, including how you can easily prepare for this transition, see our Explorers Hub post. To use the .NET agent API: Make sure you have the latest .NET agent release. Add a reference to the agent in your project: Add a reference to NewRelic.Api.Agent.dll to your project. OR View and download the API package from the NuGet Package Library. Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Prevent a transaction from reporting to New Relic Use IgnoreTransaction() or an XML file to ignore the transaction. Create a transaction where none exists Use attributes or an XML file to create a new transaction. Time specific methods using segments If a transaction is already visible in the New Relic UI, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. When you want to instrument a method within an existing transaction, see Custom instrumentation via attributes or Add detail to transactions via XML. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in the New Relic UI, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them in dashboards. Use these methods when you want to change how New Relic instruments a transaction that's already visible in the New Relic UI: If you want to... Do this... Change the name of a transaction Use SetTransactionName() or an XML file. Prevent a transaction from affecting your Apdex score Use IgnoreApdex(). Add metadata (such as your customer's account name or subscription level) to your transactions Use custom attributes. See AddCustomAttribute(). See related logs To see logs directly within the context of your application's errors and traces, use these API calls to annotate your logs: TraceMetadata GetLinkingMetadata For more information about correlating log data with other telemetry data, see our logs in context documentation. Instrument asynchronous work For supported frameworks, the .NET agent usually detects async work and instruments it correctly. However, if your app uses another framework, or the default async instrumentation is inaccurate, you can explicitly connect async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. Trace an async method that New Relic is not instrumenting Use an XML file to instrument async methods in IIS apps. Also see the New Relic's troubleshooting tips for missing async metrics. View calls to external services For .NET agent version 8.9 or higher, you can use the following distributed tracing payload APIs to manually pass distributed tracing context between New Relic-monitored services that don't automatically connect to one another in a distributed trace. If you want to... Do this... Instrument an outgoing request to an external application or database Create a distributed trace payload to attach to an outgoing request using CreateDistributedTracePayload(). Connect incoming requests with the originator of the request to complete a span of the trace Receive a payload on an incoming request using AcceptDistributedTracePayload(). For .NET agent versions lower than 8.9, use cross application tracing. Collect or ignore errors Usually the .NET agent detects errors automatically. However, you can manually mark an error with the agent. You can also ignore errors . If you want to... Do this... Report an error the .NET agent does not report automatically Use NoticeError(). Capture errors or prevent the .NET agent from reporting an error at all Use your .NET agent configuration file. Send custom event and metric data from your app APM includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in dashboards Create a custom event. See RecordCustomEvent(). Tag your events with metadata to filter and facet them in dashboards or error analytics Add custom attributes. See .NET agent attributes and Enable and disable attributes. Report custom performance data Use RecordMetric() to create a custom metric. To view the data, use the query builder. Control the browser monitoring agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add apps to browser monitoring. However, you can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.61128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "sections": "Guide to using the .<em>NET</em> <em>agent</em> API",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> includes an API that allows you to extend the <em>agent</em>&#x27;s standard functionality. For example, you can use the .<em>NET</em> <em>agent</em> API for: Customizing your app name Creating custom transaction parameters Reporting custom errors and metrics You can also customize some of the .<em>NET</em> <em>agent</em>"
      },
      "id": "61a08f1564441fd10c9840d0"
    }
  ]
}