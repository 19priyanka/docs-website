{
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.44514,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> notification channels",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your <em>alert</em> notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting <em>started</em> with NerdGraph API explorer. <em>Get</em> notification channels"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.20386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "Create a condition from a chart",
        "Caution",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-07-02T09:46:09Z",
      "updated_at": "2021-07-02T09:46:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. Create a condition from a chart You can use a chart to create a NRQL alert condition. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Caution A small number of our older charts don't include the option to create an alert condition. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for outlier threshold types. It's optional for static and baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions Include an optional FACET clause in your NRQL syntax depending on the threshold type: static or baseline. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static and baseline conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported You can't use a nested query containing the WITH METRIC_FORMAT in the inner query to create NRQL alert conditions. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Newly opened lost signal violations will close immediately when new data is evaluated. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.19812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create NRQL <em>alert</em> conditions",
        "sections": "<em>Alert</em> conditions <em>and</em> query order of operations",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " a NRQL <em>alert</em> condition for a policy: On one.newrelic.com, in the header click <em>Alerts</em> &amp; AI, then in the left sidebar click Policies. Select an existing policy or click <em>New</em> <em>alert</em> policy to create a <em>new</em> policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define"
      },
      "id": "603ef04864441fbc114e8883"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.44514,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ": { password: &quot;t0t4lly-s3cr3t-p455w0rd&quot;, username: &quot;webhook-user&quot; }, customHttpHeaders: [ {name: &quot;X-<em>Api</em>-Key&quot;, value: &quot;100%-real-<em>api</em>-key&quot;}, {name: &quot;X-Calling-Service&quot;, value: &quot;<em>New</em> <em>Relic</em> <em>Alerts</em>&quot;} ], customPayloadBody: &quot;{ \\&quot;account_id\\&quot;: \\&quot;$ACCOUNT_ID\\&quot;, \\&quot;account_name\\&quot;: \\&quot;$ACCOUNT_NAME"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.20386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "Create a condition from a chart",
        "Caution",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-07-02T09:46:09Z",
      "updated_at": "2021-07-02T09:46:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. Create a condition from a chart You can use a chart to create a NRQL alert condition. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Caution A small number of our older charts don't include the option to create an alert condition. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for outlier threshold types. It's optional for static and baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions Include an optional FACET clause in your NRQL syntax depending on the threshold type: static or baseline. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static and baseline conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported You can't use a nested query containing the WITH METRIC_FORMAT in the inner query to create NRQL alert conditions. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Newly opened lost signal violations will close immediately when new data is evaluated. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.19812,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create NRQL <em>alert</em> conditions",
        "sections": "<em>Alert</em> conditions <em>and</em> query order of operations",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " a NRQL <em>alert</em> condition for a policy: On one.newrelic.com, in the header click <em>Alerts</em> &amp; AI, then in the left sidebar click Policies. Select an existing policy or click <em>New</em> <em>alert</em> policy to create a <em>new</em> policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define"
      },
      "id": "603ef04864441fbc114e8883"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/disable-enable-alerts-conditions-using-api": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.44514,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ": { password: &quot;t0t4lly-s3cr3t-p455w0rd&quot;, username: &quot;webhook-user&quot; }, customHttpHeaders: [ {name: &quot;X-<em>Api</em>-Key&quot;, value: &quot;100%-real-<em>api</em>-key&quot;}, {name: &quot;X-Calling-Service&quot;, value: &quot;<em>New</em> <em>Relic</em> <em>Alerts</em>&quot;} ], customPayloadBody: &quot;{ \\&quot;account_id\\&quot;: \\&quot;$ACCOUNT_ID\\&quot;, \\&quot;account_name\\&quot;: \\&quot;$ACCOUNT_NAME"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "Alerts conditions API field names",
        "Required and optional fields",
        "Field definitions",
        "aggregation_window",
        "close_violations_on_expiration",
        "condition_scope",
        "enabled",
        "entities",
        "evaluation_offset",
        "expected_groups",
        "expiration_duration",
        "external_service_url",
        "fill_option",
        "fill_value",
        "ignore_overlap",
        "metric",
        "Alerts plugin conditions",
        "Alerts conditions",
        "Alerts external service conditions",
        "metric_description",
        "monitor_id",
        "name",
        "nrql[query]",
        "nrql[since_value]",
        "open_violation_on_expiration",
        "plugin[guid]",
        "plugin[id]",
        "runbook_url",
        "terms[duration]",
        "terms[operator]",
        "terms[priority]",
        "terms[threshold]",
        "terms[time_function]",
        "type",
        "user_defined[metric] (optional)",
        "user_defined[value_function] (optional)",
        "value_function",
        "violation_time_limit_seconds",
        "violation_close_timer"
      ],
      "title": "Alerts conditions API field names",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "5b098758aa368fade60befbff92ce025f8022f51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names/",
      "published_at": "2021-07-02T09:23:48Z",
      "updated_at": "2021-05-11T06:48:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The REST API endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The API includes four types of New Relic Alerts conditions: APM External services Synthetic monitoring Plugins All of the fields used with a specific condition type are required except for these optional fields: enabled (defaults to false) runbook_url user_defined Field definitions Not every field listed in this glossary is required for every condition type. The condition type for which a field must be used is listed in each description. aggregation_window Streaming alerts gathers data together into specific amounts of time before running the function in the NRQL query. These windows of time are customizable. The default is 1 minute. The maximum is 15 minutes. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. In the UI, under Advanced signal settings, this is the Aggregation window field. close_violations_on_expiration When true, this closes all currently open violations when no signal is heard within the expiration_duration time. The default is False. condition_scope This field allows you to scope a condition to either a JVM instance or to a whole application. This may be one of the strings: instance application Used for: Conditions Entity conditions For instance-based and JVM health metrics, see also violation_close_timer. enabled This is the status of your alert condition and is optional. The default is false. This field may be used to enable or disable a condition for maintenance or testing periods. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions entities This is an array of entity IDs identifying the objects which will be monitored with your condition. These may be application IDs, browser IDs, plugin IDs, key transaction IDs, external service IDs, etc. These are entered as a series of comma separated integers if there is more than one. Used for: Conditions External service conditions Plugin conditions evaluation_offset The offset is how long we wait for late data before evaluating each aggregation window. Waiting longer gives a more accurate signal but increases latency. The default is 3 minutes. In the UI, under Advanced signal settings, this is the Offset evaluation by field. expected_groups This is the number of groups you expect to see at any given time. It is used in combination with the ignore_overlap option. Used for: NRQL outlier conditions expiration_duration How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives and not on data timestamps. The default is null. Add a value to enable loss of signal detection. external_service_url This is the URL of the external service to be monitored. This string must not include the protocol. For example, use example.com, not https://example.com. Used for: External service conditions fill_option For sporadic data, you can avoid false alerts by filling the gaps (empty windows) with synthetic data. none: (Default) Use this if you don’t want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won’t be in violation. static: Use this if you’d like to insert a custom static value into the empty aggregation windows before they’re evaluated. This option has an additional, required parameter of fillValue that specifies what static value should be used. This defaults to 0. last_value: Use this to insert the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. In the UI, under Advanced signal settings, this is the Fill data gaps with field. fill_value This is the value used by the fill_option custom value. The default is 0. ignore_overlap If disabled, this looks for a convergence (or overlapping) of groups. If the condition is looking for two or more groups, and the returned values can't be separated into that number of distinct groups, then that will also produce a violation. This type of overlap event is represented on a chart by group bands touching. Used for: NRQL outlier conditions metric The metric field is used for three alert categories. The exact parameters available for use depend on the setting in the type field. These are listed below according to their alert type field. Alerts plugin conditions For Plugin conditions this is the metric, which has been defined in a plugin, that will be used to trigger a notification. Alerts conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_app_metric apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_kt_metric apdex error_percentage error_count response_time throughput browser_metric end_user_apdex total_page_load page_rendering web_application network dom_processing request_queuing ajax_response_time page_views_with_js_errors page_view_throughput ajax_throughput user_defined browser_metric_baseline page_view_throughput average_response_time ajax_response_time ajax_application_time mobile_metric database images json, network view_loading network_error_percentage status_error_percentage user_defined Alerts external service conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_external_service apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_app_metric_baseline external_service_transaction_time error_count database_transaction_time throughput_web response_time_web non_web_transaction_time web_transaction_database_time non_web_transaction_database_time mobile_external_service response_time_average response_time_minimum response_time_maximum throughput network_failure_percentage http_status_error_percentage metric_description This is a title for the metric which is displayed in notifications. Make this descriptive and unique so the reader will understand the nature of plugin metric being used to trigger an alert. Used for: Plugin conditions monitor_id This is the GUID of the Synthetic monitoring to alert on. Used for: Synthetic monitoring conditions name This condition title will allow to you identify it in the UI. Follow the guidelines for making this descriptive but short. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions nrql[query] This is the NRQL query that alerts monitors as part of a NRQL condition. Used for: NRQL conditions nrql[since_value] This is the timeframe (in minutes) in which to evaluate the specified NRQL query. since_value must be between 1 and 20. Used for: NRQL conditions open_violation_on_expiration When true, this opens a loss of signal violation when no signal within the expiration_duration time. The default is False. plugin[guid] This is the GUID of the plugin for which the trigger is being defined. Used for: Plugin conditions plugin[id] This is the ID of the plugin for which the trigger is being defined. Used for: Plugin conditions runbook_url The runbook URL to display in notifications. This field is optional. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions terms[duration] This is the time (in minutes) for the condition to persist before triggering an event. It corresponds to the duration set when adding a threshold in the UI. Used for: Conditions terms[operator] This determines what comparison will be used between the value_function and the terms [ threshold] value to trigger an event. It corresponds to the operation selected when adding a threshold in the UI. It must be one of the following strings: above below equal Used for: Conditions External service conditions Plugin conditions terms[priority] This corresponds to the severity level selected when setting the threshold values for the condition in the UI. This must be one of the following strings: critical warning Used for: Conditions External service conditions Plugin conditions terms[threshold] This is the threshold that the value_function must be compared to using the terms [ operator] for an event to be triggered. It corresponds to the numeric value specified in the UI when adding the threshold values. This is a numeric value and must be 0 (zero) or greater. Used for: Conditions External service conditions Plugin conditions terms[time_function] This corresponds to the settings made in the UI when adding the threshold values. The choices are: all (corresponding to for at least in the UI) any (corresponding to at least once in in the UI) Used for: Conditions External service conditions Plugin conditions type This defines the type of metric that will be used for the alert. Allowable content for the metric field depends on the type value chosen. There are two product categories : Alerts conditions For this category, type is set to one of the following strings indicating the type of alerts condition. type Use apm_app_metric APM application metric will trigger an alert. apm_app_metric_baseline APM application metric will trigger an alert (using a baseline threshold). apm_kt_metric APM key transaction metric will trigger an alert. browser_metric Browser metric will trigger an alert. browser_metric_baseline Browser metric will trigger an alert (using a baseline threshold). mobile_metric Mobile metric will trigger an alert. Used for: Conditions Alerts external service conditions For this category, type is set to one of the following strings indicating the type of external service condition. type Use apm_external_service APM external metric will trigger an alert. mobile_external_service Mobile external metric will trigger an alert. Used for: External service conditions user_defined[metric] (optional) This is the name of a user defined custom metric to be used to determine if an event should be triggered. The user_defined [ value_function] associated with the metric is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions user_defined[value_function] (optional) This is the numeric value obtained from the custom metric specified by user_defined [ metric]. It is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. One of these value functions must be specified: average min max total sample_size Used for: Conditions value_function This is the value function used from the plugin metric. This may be one of the strings: min max average sample_size total percent Used for: Plugin conditions When used for a NRQL condition, the options are: single_value (condition is evaluated based on each query's returned value) sum (condition is evaluated based on the sum of each query's returned values over the specified duration) violation_time_limit_seconds Use to automatically close instance-based violations after the number of seconds specified. Must be one of these values: 3600 7200 14400 28800 43200 86400 Used for: Location conditions NRQL conditions violation_close_timer Use to automatically close instance-based violations, including JVM health metric violations, after the number of hours specified. Must be one of these values: 1 2 4 8 12 24 Used for: apm_app_metric (with condition_scope set to instance) apm_jvm_metric",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.3445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> conditions <em>API</em> field names",
        "sections": "<em>Alerts</em> conditions <em>API</em> field names",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "The <em>REST</em> <em>API</em> endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The <em>API</em> includes four types of <em>New</em> <em>Relic</em> <em>Alerts</em> conditions: APM External"
      },
      "id": "604428f5e7b9d22c3a579a05"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.20386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/manage-entities-alerts-conditions": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.44495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ": { password: &quot;t0t4lly-s3cr3t-p455w0rd&quot;, username: &quot;webhook-user&quot; }, customHttpHeaders: [ {name: &quot;X-<em>Api</em>-Key&quot;, value: &quot;100%-real-<em>api</em>-key&quot;}, {name: &quot;X-Calling-Service&quot;, value: &quot;<em>New</em> <em>Relic</em> <em>Alerts</em>&quot;} ], customPayloadBody: &quot;{ \\&quot;account_id\\&quot;: \\&quot;$ACCOUNT_ID\\&quot;, \\&quot;account_name\\&quot;: \\&quot;$ACCOUNT_NAME"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "Alerts conditions API field names",
        "Required and optional fields",
        "Field definitions",
        "aggregation_window",
        "close_violations_on_expiration",
        "condition_scope",
        "enabled",
        "entities",
        "evaluation_offset",
        "expected_groups",
        "expiration_duration",
        "external_service_url",
        "fill_option",
        "fill_value",
        "ignore_overlap",
        "metric",
        "Alerts plugin conditions",
        "Alerts conditions",
        "Alerts external service conditions",
        "metric_description",
        "monitor_id",
        "name",
        "nrql[query]",
        "nrql[since_value]",
        "open_violation_on_expiration",
        "plugin[guid]",
        "plugin[id]",
        "runbook_url",
        "terms[duration]",
        "terms[operator]",
        "terms[priority]",
        "terms[threshold]",
        "terms[time_function]",
        "type",
        "user_defined[metric] (optional)",
        "user_defined[value_function] (optional)",
        "value_function",
        "violation_time_limit_seconds",
        "violation_close_timer"
      ],
      "title": "Alerts conditions API field names",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "5b098758aa368fade60befbff92ce025f8022f51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names/",
      "published_at": "2021-07-02T09:23:48Z",
      "updated_at": "2021-05-11T06:48:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The REST API endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The API includes four types of New Relic Alerts conditions: APM External services Synthetic monitoring Plugins All of the fields used with a specific condition type are required except for these optional fields: enabled (defaults to false) runbook_url user_defined Field definitions Not every field listed in this glossary is required for every condition type. The condition type for which a field must be used is listed in each description. aggregation_window Streaming alerts gathers data together into specific amounts of time before running the function in the NRQL query. These windows of time are customizable. The default is 1 minute. The maximum is 15 minutes. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. In the UI, under Advanced signal settings, this is the Aggregation window field. close_violations_on_expiration When true, this closes all currently open violations when no signal is heard within the expiration_duration time. The default is False. condition_scope This field allows you to scope a condition to either a JVM instance or to a whole application. This may be one of the strings: instance application Used for: Conditions Entity conditions For instance-based and JVM health metrics, see also violation_close_timer. enabled This is the status of your alert condition and is optional. The default is false. This field may be used to enable or disable a condition for maintenance or testing periods. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions entities This is an array of entity IDs identifying the objects which will be monitored with your condition. These may be application IDs, browser IDs, plugin IDs, key transaction IDs, external service IDs, etc. These are entered as a series of comma separated integers if there is more than one. Used for: Conditions External service conditions Plugin conditions evaluation_offset The offset is how long we wait for late data before evaluating each aggregation window. Waiting longer gives a more accurate signal but increases latency. The default is 3 minutes. In the UI, under Advanced signal settings, this is the Offset evaluation by field. expected_groups This is the number of groups you expect to see at any given time. It is used in combination with the ignore_overlap option. Used for: NRQL outlier conditions expiration_duration How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives and not on data timestamps. The default is null. Add a value to enable loss of signal detection. external_service_url This is the URL of the external service to be monitored. This string must not include the protocol. For example, use example.com, not https://example.com. Used for: External service conditions fill_option For sporadic data, you can avoid false alerts by filling the gaps (empty windows) with synthetic data. none: (Default) Use this if you don’t want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won’t be in violation. static: Use this if you’d like to insert a custom static value into the empty aggregation windows before they’re evaluated. This option has an additional, required parameter of fillValue that specifies what static value should be used. This defaults to 0. last_value: Use this to insert the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. In the UI, under Advanced signal settings, this is the Fill data gaps with field. fill_value This is the value used by the fill_option custom value. The default is 0. ignore_overlap If disabled, this looks for a convergence (or overlapping) of groups. If the condition is looking for two or more groups, and the returned values can't be separated into that number of distinct groups, then that will also produce a violation. This type of overlap event is represented on a chart by group bands touching. Used for: NRQL outlier conditions metric The metric field is used for three alert categories. The exact parameters available for use depend on the setting in the type field. These are listed below according to their alert type field. Alerts plugin conditions For Plugin conditions this is the metric, which has been defined in a plugin, that will be used to trigger a notification. Alerts conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_app_metric apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_kt_metric apdex error_percentage error_count response_time throughput browser_metric end_user_apdex total_page_load page_rendering web_application network dom_processing request_queuing ajax_response_time page_views_with_js_errors page_view_throughput ajax_throughput user_defined browser_metric_baseline page_view_throughput average_response_time ajax_response_time ajax_application_time mobile_metric database images json, network view_loading network_error_percentage status_error_percentage user_defined Alerts external service conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_external_service apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_app_metric_baseline external_service_transaction_time error_count database_transaction_time throughput_web response_time_web non_web_transaction_time web_transaction_database_time non_web_transaction_database_time mobile_external_service response_time_average response_time_minimum response_time_maximum throughput network_failure_percentage http_status_error_percentage metric_description This is a title for the metric which is displayed in notifications. Make this descriptive and unique so the reader will understand the nature of plugin metric being used to trigger an alert. Used for: Plugin conditions monitor_id This is the GUID of the Synthetic monitoring to alert on. Used for: Synthetic monitoring conditions name This condition title will allow to you identify it in the UI. Follow the guidelines for making this descriptive but short. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions nrql[query] This is the NRQL query that alerts monitors as part of a NRQL condition. Used for: NRQL conditions nrql[since_value] This is the timeframe (in minutes) in which to evaluate the specified NRQL query. since_value must be between 1 and 20. Used for: NRQL conditions open_violation_on_expiration When true, this opens a loss of signal violation when no signal within the expiration_duration time. The default is False. plugin[guid] This is the GUID of the plugin for which the trigger is being defined. Used for: Plugin conditions plugin[id] This is the ID of the plugin for which the trigger is being defined. Used for: Plugin conditions runbook_url The runbook URL to display in notifications. This field is optional. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions terms[duration] This is the time (in minutes) for the condition to persist before triggering an event. It corresponds to the duration set when adding a threshold in the UI. Used for: Conditions terms[operator] This determines what comparison will be used between the value_function and the terms [ threshold] value to trigger an event. It corresponds to the operation selected when adding a threshold in the UI. It must be one of the following strings: above below equal Used for: Conditions External service conditions Plugin conditions terms[priority] This corresponds to the severity level selected when setting the threshold values for the condition in the UI. This must be one of the following strings: critical warning Used for: Conditions External service conditions Plugin conditions terms[threshold] This is the threshold that the value_function must be compared to using the terms [ operator] for an event to be triggered. It corresponds to the numeric value specified in the UI when adding the threshold values. This is a numeric value and must be 0 (zero) or greater. Used for: Conditions External service conditions Plugin conditions terms[time_function] This corresponds to the settings made in the UI when adding the threshold values. The choices are: all (corresponding to for at least in the UI) any (corresponding to at least once in in the UI) Used for: Conditions External service conditions Plugin conditions type This defines the type of metric that will be used for the alert. Allowable content for the metric field depends on the type value chosen. There are two product categories : Alerts conditions For this category, type is set to one of the following strings indicating the type of alerts condition. type Use apm_app_metric APM application metric will trigger an alert. apm_app_metric_baseline APM application metric will trigger an alert (using a baseline threshold). apm_kt_metric APM key transaction metric will trigger an alert. browser_metric Browser metric will trigger an alert. browser_metric_baseline Browser metric will trigger an alert (using a baseline threshold). mobile_metric Mobile metric will trigger an alert. Used for: Conditions Alerts external service conditions For this category, type is set to one of the following strings indicating the type of external service condition. type Use apm_external_service APM external metric will trigger an alert. mobile_external_service Mobile external metric will trigger an alert. Used for: External service conditions user_defined[metric] (optional) This is the name of a user defined custom metric to be used to determine if an event should be triggered. The user_defined [ value_function] associated with the metric is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions user_defined[value_function] (optional) This is the numeric value obtained from the custom metric specified by user_defined [ metric]. It is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. One of these value functions must be specified: average min max total sample_size Used for: Conditions value_function This is the value function used from the plugin metric. This may be one of the strings: min max average sample_size total percent Used for: Plugin conditions When used for a NRQL condition, the options are: single_value (condition is evaluated based on each query's returned value) sum (condition is evaluated based on the sum of each query's returned values over the specified duration) violation_time_limit_seconds Use to automatically close instance-based violations after the number of seconds specified. Must be one of these values: 3600 7200 14400 28800 43200 86400 Used for: Location conditions NRQL conditions violation_close_timer Use to automatically close instance-based violations, including JVM health metric violations, after the number of hours specified. Must be one of these values: 1 2 4 8 12 24 Used for: apm_app_metric (with condition_scope set to instance) apm_jvm_metric",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.34448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> conditions <em>API</em> field names",
        "sections": "<em>Alerts</em> conditions <em>API</em> field names",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "The <em>REST</em> <em>API</em> endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The <em>API</em> includes four types of <em>New</em> <em>Relic</em> <em>Alerts</em> conditions: APM External"
      },
      "id": "604428f5e7b9d22c3a579a05"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.2038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/rest-api-calls-alerts": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.44495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ": { password: &quot;t0t4lly-s3cr3t-p455w0rd&quot;, username: &quot;webhook-user&quot; }, customHttpHeaders: [ {name: &quot;X-<em>Api</em>-Key&quot;, value: &quot;100%-real-<em>api</em>-key&quot;}, {name: &quot;X-Calling-Service&quot;, value: &quot;<em>New</em> <em>Relic</em> <em>Alerts</em>&quot;} ], customPayloadBody: &quot;{ \\&quot;account_id\\&quot;: \\&quot;$ACCOUNT_ID\\&quot;, \\&quot;account_name\\&quot;: \\&quot;$ACCOUNT_NAME"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "Alerts conditions API field names",
        "Required and optional fields",
        "Field definitions",
        "aggregation_window",
        "close_violations_on_expiration",
        "condition_scope",
        "enabled",
        "entities",
        "evaluation_offset",
        "expected_groups",
        "expiration_duration",
        "external_service_url",
        "fill_option",
        "fill_value",
        "ignore_overlap",
        "metric",
        "Alerts plugin conditions",
        "Alerts conditions",
        "Alerts external service conditions",
        "metric_description",
        "monitor_id",
        "name",
        "nrql[query]",
        "nrql[since_value]",
        "open_violation_on_expiration",
        "plugin[guid]",
        "plugin[id]",
        "runbook_url",
        "terms[duration]",
        "terms[operator]",
        "terms[priority]",
        "terms[threshold]",
        "terms[time_function]",
        "type",
        "user_defined[metric] (optional)",
        "user_defined[value_function] (optional)",
        "value_function",
        "violation_time_limit_seconds",
        "violation_close_timer"
      ],
      "title": "Alerts conditions API field names",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "5b098758aa368fade60befbff92ce025f8022f51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names/",
      "published_at": "2021-07-02T09:23:48Z",
      "updated_at": "2021-05-11T06:48:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The REST API endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The API includes four types of New Relic Alerts conditions: APM External services Synthetic monitoring Plugins All of the fields used with a specific condition type are required except for these optional fields: enabled (defaults to false) runbook_url user_defined Field definitions Not every field listed in this glossary is required for every condition type. The condition type for which a field must be used is listed in each description. aggregation_window Streaming alerts gathers data together into specific amounts of time before running the function in the NRQL query. These windows of time are customizable. The default is 1 minute. The maximum is 15 minutes. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. In the UI, under Advanced signal settings, this is the Aggregation window field. close_violations_on_expiration When true, this closes all currently open violations when no signal is heard within the expiration_duration time. The default is False. condition_scope This field allows you to scope a condition to either a JVM instance or to a whole application. This may be one of the strings: instance application Used for: Conditions Entity conditions For instance-based and JVM health metrics, see also violation_close_timer. enabled This is the status of your alert condition and is optional. The default is false. This field may be used to enable or disable a condition for maintenance or testing periods. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions entities This is an array of entity IDs identifying the objects which will be monitored with your condition. These may be application IDs, browser IDs, plugin IDs, key transaction IDs, external service IDs, etc. These are entered as a series of comma separated integers if there is more than one. Used for: Conditions External service conditions Plugin conditions evaluation_offset The offset is how long we wait for late data before evaluating each aggregation window. Waiting longer gives a more accurate signal but increases latency. The default is 3 minutes. In the UI, under Advanced signal settings, this is the Offset evaluation by field. expected_groups This is the number of groups you expect to see at any given time. It is used in combination with the ignore_overlap option. Used for: NRQL outlier conditions expiration_duration How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives and not on data timestamps. The default is null. Add a value to enable loss of signal detection. external_service_url This is the URL of the external service to be monitored. This string must not include the protocol. For example, use example.com, not https://example.com. Used for: External service conditions fill_option For sporadic data, you can avoid false alerts by filling the gaps (empty windows) with synthetic data. none: (Default) Use this if you don’t want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won’t be in violation. static: Use this if you’d like to insert a custom static value into the empty aggregation windows before they’re evaluated. This option has an additional, required parameter of fillValue that specifies what static value should be used. This defaults to 0. last_value: Use this to insert the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. In the UI, under Advanced signal settings, this is the Fill data gaps with field. fill_value This is the value used by the fill_option custom value. The default is 0. ignore_overlap If disabled, this looks for a convergence (or overlapping) of groups. If the condition is looking for two or more groups, and the returned values can't be separated into that number of distinct groups, then that will also produce a violation. This type of overlap event is represented on a chart by group bands touching. Used for: NRQL outlier conditions metric The metric field is used for three alert categories. The exact parameters available for use depend on the setting in the type field. These are listed below according to their alert type field. Alerts plugin conditions For Plugin conditions this is the metric, which has been defined in a plugin, that will be used to trigger a notification. Alerts conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_app_metric apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_kt_metric apdex error_percentage error_count response_time throughput browser_metric end_user_apdex total_page_load page_rendering web_application network dom_processing request_queuing ajax_response_time page_views_with_js_errors page_view_throughput ajax_throughput user_defined browser_metric_baseline page_view_throughput average_response_time ajax_response_time ajax_application_time mobile_metric database images json, network view_loading network_error_percentage status_error_percentage user_defined Alerts external service conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_external_service apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_app_metric_baseline external_service_transaction_time error_count database_transaction_time throughput_web response_time_web non_web_transaction_time web_transaction_database_time non_web_transaction_database_time mobile_external_service response_time_average response_time_minimum response_time_maximum throughput network_failure_percentage http_status_error_percentage metric_description This is a title for the metric which is displayed in notifications. Make this descriptive and unique so the reader will understand the nature of plugin metric being used to trigger an alert. Used for: Plugin conditions monitor_id This is the GUID of the Synthetic monitoring to alert on. Used for: Synthetic monitoring conditions name This condition title will allow to you identify it in the UI. Follow the guidelines for making this descriptive but short. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions nrql[query] This is the NRQL query that alerts monitors as part of a NRQL condition. Used for: NRQL conditions nrql[since_value] This is the timeframe (in minutes) in which to evaluate the specified NRQL query. since_value must be between 1 and 20. Used for: NRQL conditions open_violation_on_expiration When true, this opens a loss of signal violation when no signal within the expiration_duration time. The default is False. plugin[guid] This is the GUID of the plugin for which the trigger is being defined. Used for: Plugin conditions plugin[id] This is the ID of the plugin for which the trigger is being defined. Used for: Plugin conditions runbook_url The runbook URL to display in notifications. This field is optional. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions terms[duration] This is the time (in minutes) for the condition to persist before triggering an event. It corresponds to the duration set when adding a threshold in the UI. Used for: Conditions terms[operator] This determines what comparison will be used between the value_function and the terms [ threshold] value to trigger an event. It corresponds to the operation selected when adding a threshold in the UI. It must be one of the following strings: above below equal Used for: Conditions External service conditions Plugin conditions terms[priority] This corresponds to the severity level selected when setting the threshold values for the condition in the UI. This must be one of the following strings: critical warning Used for: Conditions External service conditions Plugin conditions terms[threshold] This is the threshold that the value_function must be compared to using the terms [ operator] for an event to be triggered. It corresponds to the numeric value specified in the UI when adding the threshold values. This is a numeric value and must be 0 (zero) or greater. Used for: Conditions External service conditions Plugin conditions terms[time_function] This corresponds to the settings made in the UI when adding the threshold values. The choices are: all (corresponding to for at least in the UI) any (corresponding to at least once in in the UI) Used for: Conditions External service conditions Plugin conditions type This defines the type of metric that will be used for the alert. Allowable content for the metric field depends on the type value chosen. There are two product categories : Alerts conditions For this category, type is set to one of the following strings indicating the type of alerts condition. type Use apm_app_metric APM application metric will trigger an alert. apm_app_metric_baseline APM application metric will trigger an alert (using a baseline threshold). apm_kt_metric APM key transaction metric will trigger an alert. browser_metric Browser metric will trigger an alert. browser_metric_baseline Browser metric will trigger an alert (using a baseline threshold). mobile_metric Mobile metric will trigger an alert. Used for: Conditions Alerts external service conditions For this category, type is set to one of the following strings indicating the type of external service condition. type Use apm_external_service APM external metric will trigger an alert. mobile_external_service Mobile external metric will trigger an alert. Used for: External service conditions user_defined[metric] (optional) This is the name of a user defined custom metric to be used to determine if an event should be triggered. The user_defined [ value_function] associated with the metric is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions user_defined[value_function] (optional) This is the numeric value obtained from the custom metric specified by user_defined [ metric]. It is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. One of these value functions must be specified: average min max total sample_size Used for: Conditions value_function This is the value function used from the plugin metric. This may be one of the strings: min max average sample_size total percent Used for: Plugin conditions When used for a NRQL condition, the options are: single_value (condition is evaluated based on each query's returned value) sum (condition is evaluated based on the sum of each query's returned values over the specified duration) violation_time_limit_seconds Use to automatically close instance-based violations after the number of seconds specified. Must be one of these values: 3600 7200 14400 28800 43200 86400 Used for: Location conditions NRQL conditions violation_close_timer Use to automatically close instance-based violations, including JVM health metric violations, after the number of hours specified. Must be one of these values: 1 2 4 8 12 24 Used for: apm_app_metric (with condition_scope set to instance) apm_jvm_metric",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.34448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> conditions <em>API</em> field names",
        "sections": "<em>Alerts</em> conditions <em>API</em> field names",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "The <em>REST</em> <em>API</em> endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The <em>API</em> includes four types of <em>New</em> <em>Relic</em> <em>Alerts</em> conditions: APM External"
      },
      "id": "604428f5e7b9d22c3a579a05"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.2038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rules-limits-glossary/rules-limits-alerts": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.44495,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ": { password: &quot;t0t4lly-s3cr3t-p455w0rd&quot;, username: &quot;webhook-user&quot; }, customHttpHeaders: [ {name: &quot;X-Api-Key&quot;, value: &quot;100%-real-api-key&quot;}, {name: &quot;X-Calling-Service&quot;, value: &quot;<em>New</em> <em>Relic</em> <em>Alerts</em>&quot;} ], customPayloadBody: &quot;{ \\&quot;account_id\\&quot;: \\&quot;$ACCOUNT_ID\\&quot;, \\&quot;account_name\\&quot;: \\&quot;$ACCOUNT_NAME"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.2038,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "Create a condition from a chart",
        "Caution",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-07-02T09:46:09Z",
      "updated_at": "2021-07-02T09:46:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. Create a condition from a chart You can use a chart to create a NRQL alert condition. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Caution A small number of our older charts don't include the option to create an alert condition. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for outlier threshold types. It's optional for static and baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions Include an optional FACET clause in your NRQL syntax depending on the threshold type: static or baseline. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static and baseline conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported You can't use a nested query containing the WITH METRIC_FORMAT in the inner query to create NRQL alert conditions. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Newly opened lost signal violations will close immediately when new data is evaluated. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.19804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create NRQL <em>alert</em> conditions",
        "sections": "<em>Alert</em> conditions <em>and</em> query order of operations",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " a NRQL <em>alert</em> condition for a policy: On one.newrelic.com, in the header click <em>Alerts</em> &amp; AI, then in the left sidebar click Policies. Select an existing policy or click <em>New</em> <em>alert</em> policy to create a <em>new</em> policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define"
      },
      "id": "603ef04864441fbc114e8883"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/troubleshooting/missing-alert-notifications": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.46133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ": { password: &quot;t0t4lly-s3cr3t-p455w0rd&quot;, username: &quot;webhook-user&quot; }, customHttpHeaders: [ {name: &quot;X-Api-Key&quot;, value: &quot;100%-real-api-key&quot;}, {name: &quot;X-Calling-Service&quot;, value: &quot;<em>New</em> <em>Relic</em> <em>Alerts</em>&quot;} ], customPayloadBody: &quot;{ \\&quot;account_id\\&quot;: \\&quot;$ACCOUNT_ID\\&quot;, \\&quot;account_name\\&quot;: \\&quot;$ACCOUNT_NAME"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "Create a condition from a chart",
        "Caution",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-07-02T09:46:09Z",
      "updated_at": "2021-07-02T09:46:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. Create a condition from a chart You can use a chart to create a NRQL alert condition. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Caution A small number of our older charts don't include the option to create an alert condition. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for outlier threshold types. It's optional for static and baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions Include an optional FACET clause in your NRQL syntax depending on the threshold type: static or baseline. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static and baseline conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported You can't use a nested query containing the WITH METRIC_FORMAT in the inner query to create NRQL alert conditions. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Newly opened lost signal violations will close immediately when new data is evaluated. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.30502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create NRQL <em>alert</em> conditions",
        "sections": "<em>Alert</em> conditions <em>and</em> query order of operations",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " a NRQL <em>alert</em> condition for a policy: On one.newrelic.com, in the header click <em>Alerts</em> &amp; AI, then in the left sidebar click Policies. Select an existing policy or click <em>New</em> <em>alert</em> policy to create a <em>new</em> policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define"
      },
      "id": "603ef04864441fbc114e8883"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.52884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/troubleshooting/tag-information-not-showing-entity-infra-alert-condition": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 244.46133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ": { password: &quot;t0t4lly-s3cr3t-p455w0rd&quot;, username: &quot;webhook-user&quot; }, customHttpHeaders: [ {name: &quot;X-Api-Key&quot;, value: &quot;100%-real-api-key&quot;}, {name: &quot;X-Calling-Service&quot;, value: &quot;<em>New</em> <em>Relic</em> <em>Alerts</em>&quot;} ], customPayloadBody: &quot;{ \\&quot;account_id\\&quot;: \\&quot;$ACCOUNT_ID\\&quot;, \\&quot;account_name\\&quot;: \\&quot;$ACCOUNT_NAME"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "Create a condition from a chart",
        "Caution",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-07-02T09:46:09Z",
      "updated_at": "2021-07-02T09:46:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. Create a condition from a chart You can use a chart to create a NRQL alert condition. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Caution A small number of our older charts don't include the option to create an alert condition. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for outlier threshold types. It's optional for static and baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions Include an optional FACET clause in your NRQL syntax depending on the threshold type: static or baseline. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static and baseline conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. Nested queries containing 'WITH METRIC_FORMAT' in the inner query are not currently supported You can't use a nested query containing the WITH METRIC_FORMAT in the inner query to create NRQL alert conditions. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Newly opened lost signal violations will close immediately when new data is evaluated. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.30502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create NRQL <em>alert</em> conditions",
        "sections": "<em>Alert</em> conditions <em>and</em> query order of operations",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " a NRQL <em>alert</em> condition for a policy: On one.newrelic.com, in the header click <em>Alerts</em> &amp; AI, then in the left sidebar click Policies. Select an existing policy or click <em>New</em> <em>alert</em> policy to create a <em>new</em> policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define"
      },
      "id": "603ef04864441fbc114e8883"
    },
    {
      "sections": [
        "View or update user email channels",
        "View account email channels",
        "Add or update user channels"
      ],
      "title": "View or update user email channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "e8cf8c9003d35a35ced0c4e55fa3127cda811757",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels/",
      "published_at": "2021-07-02T09:47:32Z",
      "updated_at": "2021-07-02T09:47:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search the list of user names and emails: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. In the search field, search for 'user'. Add or update user channels Users can't unsubscribe from alerts email notifications. The account Owner or Admin must remove them from the policy's notification channel. To add or update account users as notification channels for a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, and then choose the policy you want to change. Optional: You can update notification channels for specific users. On the Notification channels page, select a user, select any policy subscription already associated with the user as applicable to view policy details. Click Notification channels, then follow standard procedures to add notification channels. Click Update policy.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.52884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Alerts</em> automatically includes the email addresses for all users in the selected account as individual notification channels. If the account is a child account, the list shows only the users on the child account, not the users in the parent account. View account email channels To view or search"
      },
      "id": "6043fc8064441f080f378ef6"
    }
  ],
  "/docs/apis/index": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-07T01:39:51Z",
      "title": "Collect data",
      "updated_at": "2021-07-05T01:38:40Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.82804,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Through our opensource agents or <em>APIs</em>, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/",
      "sections": [
        "Welcome to New Relic",
        "Create a free account",
        "Start collecting data",
        "Set up alerts",
        "Telemetry Data Platform",
        "Introduction to Telemetry Data Platform",
        "Data explorer",
        "Dashboards",
        "Log management",
        "APIs",
        "Manage data",
        "Build on New Relic One",
        "Full-Stack Observability",
        "Introduction to Full-Stack Observability",
        "APM",
        "Browser",
        "Distributed Tracing",
        "Infrastructure",
        "Logs in context",
        "Mobile",
        "Serverless",
        "Synthetics",
        "Workloads",
        "Alerts and Applied Intelligence (AI)",
        "Introduction to Alerts",
        "Introduction to Applied Intelligence",
        "Incident Intelligence",
        "Incident Workflows",
        "Proactive Detection",
        "New Relic integrations",
        "Back-end, front-end, and mobile applications",
        "Infrastructure and cloud platforms",
        "Open-source monitoring systems",
        "Security, privacy, and legal information",
        "Data privacy",
        "Security compliance",
        "Security bulletins",
        "Licenses"
      ],
      "published_at": "2021-07-07T01:38:36Z",
      "title": "New Relic Documentation",
      "updated_at": "2021-07-07T01:38:36Z",
      "type": "docs",
      "external_id": "807276d5fdd805ba0247a1ce1016af986fb31995",
      "popularity": 1,
      "body": "Welcome to New Relic If you're new, follow these three steps to create an account and get going. (It's free!) Scroll on for more about our Telemetry Data Platform, Full-Stack Observability, and Applied Intelligence. Or, to get a wider view of our platform's capabilities, read the Intro to New Relic, and use our solutions and best practices guides. Create a free account No credit card required. Start collecting data Our UI guides you through setup and install. Set up alerts Get notified quickly about changes in your system. Telemetry Data Platform Ingest, visualize, and alert on all your telemetry data in one place. Introduction to Telemetry Data Platform How to manage all your monitoring in one place. Data explorer Query and build charts with NRQL, our PromQL-style syntax, or our visual chart builder. Dashboards Combine data from anywhere in our platform into customized dashboards. Log management Get logs alongside your telemetry data with our fast, scalable log management. APIs Find APIs to send data in, get data out, or manage the New Relic platform. Manage data Monitor and control your data usage. Build on New Relic One Learn how to build custom apps on our platform at developer.newrelic.com Full-Stack Observability Analyze and troubleshoot problems easily across your entire software stack. Introduction to Full-Stack Observability Get deep insight into everything from infrastructure to server code to end-user apps. APM Get real-time and trending data about your app's performance and stability. Browser Measure website performance, track errors, and see how users interact with your site. Distributed Tracing Track requests through your distributed system to find trends and anomalies. Infrastructure Monitor your infrastructure—hosts, cloud providers, container services, backend services, orchestrators, and more. Logs in context Link your log data to APM agent data so you can pinpoint where things are going wrong. Mobile Understand user journeys in your Android and iOS apps and troubleshoot crashes. Serverless Monitor AWS Lambda, Azure Functions, and Google Cloud Functions. Synthetics Simulate user activity to detect outages and fix poor website performance. Workloads Group or monitor entities across your entire stack based on a team or a set of responsibilities. Alerts and Applied Intelligence (AI) Automatically detect anomalies, correlate issues, and reduce alert noise. Introduction to Alerts Get notified about important changes in your system based on any data you connect to New Relic. Introduction to Applied Intelligence Recognize issues sooner, resolve problems faster, and reduce noise for better incident management. Incident Intelligence Get an overview of all your incidents. See sources and related events, and find out how they all correlate. Incident Workflows Enrich your incidents with New Relic data before sending them to your notification platform. Proactive Detection Get notified by Slack or webhook of unusual app behavior. New Relic integrations Integrations connect the technologies in your stack to New Relic. Here are a few of our 370+ integrations: Back-end, front-end, and mobile applications Android Browser (JavaScript) C SDK Go iOS Java .NET Node.js PHP Python Ruby Synthetics Infrastructure and cloud platforms Apache AWS Azure Google Cloud Kafka Kubernetes Linux Microsoft SQL MongoDB MySQL NGINX PostgreSQL Redis Windows Open-source monitoring systems Dropwizard Istio JMX Kamon Micrometer OpenCensus OpenTelemetry Prometheus StatsD See all 370+ integrations Security, privacy, and legal information Find out how we ensure security, data privacy, and compliance, and find our terms of service. Data privacy New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. Security compliance Whether your data is in transit to New Relic or at rest in our storage, strong encryption measures can help protect against unauthorized access or theft of valuable data. Security bulletins Security bulletins are a way for us to let you know about security vulnerabilities, remediation strategies, and applicable updates. Licenses All about New Relic's licenses, Usage Plan, and policies. Find out what open source software we use in our products.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.341618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em>",
        "body": " management Get logs alongside your telemetry data with our fast, scalable log management. <em>APIs</em> Find <em>APIs</em> to send data in, get data out, or manage the New Relic platform. Manage data Monitor and control your data usage. Build on New Relic One Learn how to build custom apps on our platform"
      },
      "id": "5be4e5d38e9c0f3585d72edf"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "Tip",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-07-02T08:51:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. Tip To use our APIs, or the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.689644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic NerdGraph, our GraphQL <em>API</em>",
        "sections": "Introduction to New Relic NerdGraph, our GraphQL <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": "NerdGraph is our GraphQL-format <em>API</em> that lets you query New Relic data and configure some New Relic features. Tip To use our <em>APIs</em>, or the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data"
      },
      "id": "6043ff97196a67d0a0960f55"
    }
  ],
  "/docs/apis/insights-apis/insights-dashboard-api": [
    {
      "sections": [
        "Insights query API",
        "Tip",
        "Requirements and recommendations",
        "1. Register an API key",
        "2. Create the API query request",
        "Linux",
        "Microsoft Windows",
        "3. Process the returned JSON",
        "Example",
        "Query, query API request, returned data",
        "Rate limiting guidelines"
      ],
      "title": "Insights query API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "fa0e72f1345a7adde2418c08dc8950c970140a74",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/query-insights-event-data-api/",
      "published_at": "2021-07-01T18:22:32Z",
      "updated_at": "2021-05-15T10:03:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Insights query API is a REST API for making NRQL queries. Tip This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. Requirements and recommendations This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. Use of this API may be restricted by role-related user permissions. To add custom data to New Relic, you'd use our data ingest APIs. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. 1. Register an API key To use the Insights query API, you need a query key. You can have multiple query keys, and any query key can be used to initiate any Insights API query. If you have multiple systems querying Insights or different data destinations, New Relic recommends you use multiple query keys to enhance data security. For security reasons, query keys cannot be altered or read using the API. To change or read a query key, use the New Relic UI. Tip This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. To create a new query key: Go to insights.newrelic.com > Manage data > API keys. Select the plus icon next to the Query keys heading. Enter a short description of the key. Select Save your notes. 2. Create the API query request When you create or edit a query key, you will see an example curl query that you can use as a template. The example query won't work unless you follow these query rules: The NRQL query string must be URL-encoded. The query string must be less than 4000 bytes. The URL must contain a valid account ID. The X-Query-Key must contain a valid query key. The Content-Type must be application/json. Linux Here is a curl example: curl -H \"Accept: application/json\" -H \"X-Query-Key: YOUR_QUERY_KEY\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=YOUR_URL_ENCODED_QUERY\" Copy Microsoft Windows You can use Powershell to query events via API: Invoke-WebRequest -Uri https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=YOUR_URL_ENCODED_QUERY -Headers @{\"X-Query-Key\"=\"YOUR_QUERY_KEY\"} -ContentType \"application/json\" -Method GET Copy 3. Process the returned JSON The query API returns results in JSON format. There is a limit of 2,000 results per request. The structure of the JSON data depends on the NRQL that you used in the request: Different combinations of SELECT statements, clauses, and functions each return an appropriate response. When writing your code to process the JSON, you should do a test run of your query and examine the resulting JSON. Example The Insights query API returns JSON data. Here's an example of a query, its query request format, and its returned data: Query, query API request, returned data Original NRQL query: SELECT count(appName) FROM PageView SINCE '2014-08-04 00:00:00+0500' Copy Query cURL request (with URL-encoded NRQL query): curl -H \"Accept: application/json\" -H \"X-Query-Key: YOUR_QUERY_KEY\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=SELECT+count%28appName%29+FROM+PageView+SINCE+%272014-08-04+00%3A00%3A00%2B0500%27\" Copy Returned JSON data: { \"results\": [ { \"count\": 80275388 } ], \"metadata\": { \"eventTypes\": [ \"PageView\" ], \"eventType\": \"PageView\", \"openEnded\": true, \"beginTime\": \"2014-08-03T19:00:00Z\", \"endTime\": \"2017-01-18T23:18:41Z\", \"beginTimeMillis=\": 1407092400000, \"endTimeMillis\": 1484781521198, \"rawSince\": \"'2014-08-04 00:00:00+0500'\", \"rawUntil\": \"`now`\", \"rawCompareWith\": \"\", \"clippedTimeWindows\": { \"Browser\": { \"beginTimeMillis\": 1483571921198, \"endTimeMillis\": 1484781521198, \"retentionMillis\": 1209600000 } }, \"messages\": [], \"contents\": [ { \"function\": \"count\", \"attribute\": \"appName\", \"simple\": true } ] } } Copy Rate limiting guidelines We have querying limits. You likely won't encounter these limits, especially if you follow these general guidelines: Limit the amount of requests with complex queries (for example, queries with FACET or TIMESERIES clauses, or queries of over a million events) run at the same time. Limit the amount of requests run concurrently over extended periods of time to a maximum of 5, especially if they include complex queries. If New Relic applies rate limits on your account, the query API returns a 503 error. Charts may display timeout error messages.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.00288,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Insights</em> query <em>API</em>",
        "sections": "<em>Insights</em> query <em>API</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "-Key: YOUR_QUERY_KEY&quot; &quot;https:&#x2F;&#x2F;<em>insights</em>-<em>api</em>.newrelic.com&#x2F;v1&#x2F;accounts&#x2F;YOUR_ACCOUNT_ID&#x2F;query?nrql=SELECT+count%28appName%29+FROM+PageView+SINCE+%272014-08-04+00%3A00%3A00%2B0500%27&quot; Copy Returned JSON <em>data</em>: { &quot;results&quot;: [ { &quot;count&quot;: 80275388 } ], &quot;metadata&quot;: { &quot;<em>event</em>Types&quot;: [ &quot;PageView&quot; ], &quot;<em>event</em>"
      },
      "id": "609f9c86196a67e93722b170"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute Browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-07-02T21:25:53Z",
      "updated_at": "2021-06-15T00:49:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Subscription level This feature requires a Browser Pro subscription. The instrumentation level setting for an application does not affect the availability of JavaScript API functions. Agent version Your New Relic Browser agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the Browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default Browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute Browser API call To add a custom attribute to the PageView event via the Browser agent, use the setCustomAttribute Browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual Browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.23444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring custom <em>events</em> and attributes",
        "sections": "Report browser monitoring custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser <em>API</em>&#x27;s addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-07-02T02:52:24Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.40663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report custom <em>events</em> and attributes",
        "sections": "APM: Report custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_<em>insights</em>_events.enabled: false to newrelic.js. PHP Custom <em>event</em> collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant <em>API</em>"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/apis/insights-apis/query-insights-event-data-api": [
    {
      "sections": [
        "Insights Dashboard API",
        "Important",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2021-07-01T18:31:51Z",
      "updated_at": "2021-07-01T18:31:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Insights Dashboard API allows you to create and manage dashboards. Important Note that this API will be permanently deprecated between July 28 - August 30, 2021. Firstly, on July 28 the list and show endpoints and then on August 30 the rest of endpoints. We have a migration guide to help you transition to using the new dashboards API. For instructions on using the UI, see Dashboards. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. For detailed examples and use cases, see this New Relic blog post. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 326.70953,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Insights</em> Dashboard <em>API</em>",
        "sections": "<em>Insights</em> Dashboard <em>API</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " transition to using the new dashboards <em>API</em>. For instructions on using the UI, see Dashboards. Requirements If your account hosts <em>data</em> in the EU <em>data</em> center, ensure you&#x27;re using the proper <em>API</em> endpoints for EU region accounts. Overview The <em>Insights</em> Dashboard <em>API</em> allows you to list, create, read, update"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute Browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "1b83d1fc94a08bad364d1e1d03156279e535104d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2021-07-02T21:25:53Z",
      "updated_at": "2021-06-15T00:49:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Subscription level This feature requires a Browser Pro subscription. The instrumentation level setting for an application does not affect the availability of JavaScript API functions. Agent version Your New Relic Browser agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the Browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default Browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute Browser API call To add a custom attribute to the PageView event via the Browser agent, use the setCustomAttribute Browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual Browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.23444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring custom <em>events</em> and attributes",
        "sections": "Report browser monitoring custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the Browser <em>API</em>&#x27;s addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an <em>event</em> named PageAction"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    },
    {
      "sections": [
        "APM: Report custom events and attributes",
        "Data considerations",
        "Tip",
        "Record custom events and attributes",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words"
      ],
      "title": "APM: Report custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "bbb007a010108780f8c1131e08389b8ac26c4009",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/apm-report-custom-events-attributes/",
      "published_at": "2021-07-02T02:52:24Z",
      "updated_at": "2021-05-15T10:44:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have APM, you can report custom event data. You can then query and visualize your data in New Relic. Data considerations New Relic agents send event data to New Relic as part of the normal harvest cycle every five seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 833 custom events every 5 seconds. Additionally, posts greater than 1MB (10^6 bytes) in size will not be recorded, regardless of the custom event limit. You can also send custom events using the Event API (without need for APM). However, be aware that custom events sent with the agent APIs are not compatible with high security mode. Tip For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record custom events and attributes You can add your own custom APM events and attributes, which you can then use for querying and charting. This is one of several ways to report custom data. To record a custom event, follow the procedures for your New Relic language agent. To add custom attributes to APM events, you must first enable them for your New Relic APM agent, and then make an API call to record the attribute. Follow the agent-specific custom attribute procedures. When creating your own custom events and attributes, follow data requirements for: Size limits Attribute types Reserved words C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. You can then add custom attributes for your C SDK app. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. You can then add custom attributes for your Go app. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); Copy The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 Copy To disable custom events entirely, add the following to your newrelic.yml: custom_insights_events: enabled: false Copy You can then add custom attributes for your Java app. For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 Copy .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); Copy The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your .NET app. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); Copy The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. You can then add custom attributes for your PHP app. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) Copy The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see our documentation about limits and restricted characters and reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. You can then add custom attributes for your Python app. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) Copy The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see our documentation about limits and restricted characters and NRQL reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 Copy You can then add custom attributes for your Ruby app. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.40663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report custom <em>events</em> and attributes",
        "sections": "APM: Report custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " words. You can then add custom attributes for your Node.js app. To disable custom events entirely, add custom_<em>insights</em>_events.enabled: false to newrelic.js. PHP Custom <em>event</em> collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant <em>API</em>"
      },
      "id": "609fa629e7b9d2fa8dc3eb04"
    }
  ],
  "/docs/apis/intro-apis/introduction-new-relic-apis": [
    {
      "sections": [
        "New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "Important",
        "User key",
        "Create a user key",
        "Edit a user key",
        "Delete a user key",
        "Tip",
        "License key",
        "Create a license key",
        "Edit a license key",
        "Delete a license API key",
        "Browser key",
        "Create a browser key",
        "Edit a browser key",
        "Delete a browser key",
        "REST API key",
        "Activate or change REST API key",
        "View REST API keys",
        "Delete REST API key",
        "Insights insert key",
        "Generate an Insights insert key",
        "Edit or delete an Insights insert key",
        "Insights query key",
        "Generate an Insights query key",
        "Edit or delete an Insights query key",
        "Admin key"
      ],
      "title": "New Relic API keys",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "b373cd68cf21daeb5d912ffb4b1ae3f14f500fcc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/",
      "published_at": "2021-07-01T18:41:20Z",
      "updated_at": "2021-06-20T20:48:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Important Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (Also known as a \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (Also known as a \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Tip In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Important You can't manage or delete an original license key that was created when your account was created. For that, contact New Relic support. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Important You can't manage or delete an original browser key that was created when your account was created. For that, contact New Relic support. REST API key Important We highly recommend using a user key instead, because that key has fewer restrictions. You can use a REST API key with our REST API and the API Explorer. For accounts that have sub-accounts, each sub-account must use its own REST API key. Requirements: Requires admin-level user permissions. If you don't have access to the REST API key or the REST API explorer, it might be due to lack of permissions. Talk to your New Relic account manager, or use a user key instead. Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Important Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don’t need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says “Migrated from an admin user key” in the key table, so you’ll be able to find them easily.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.19174,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>API</em> keys",
        "sections": "New Relic <em>API</em> keys",
        "tags": "<em>Intro</em> <em>to</em> <em>APIs</em>",
        "body": "New Relic has several different <em>APIs</em> that each require their own type of <em>API</em> key to use. This resource describes our <em>API</em> keys, what they&#x27;re used for, and how to access them. Manage <em>API</em> keys in UI Here&#x27;s a direct link to the <em>API</em> keys UI page. To find this from the New Relic UI: From the account"
      },
      "id": "6043fa3464441f1358378f3b"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "Tip",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-07-02T08:51:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. Tip To use our APIs, or the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.26726,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "sections": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s <em>Intro</em> to NerdGraph. Or see the online course on New Relic <em>APIs</em>. Use the GraphiQL explorer To <em>get</em> <em>started</em> using GraphQL, we"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation function",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "child account",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "Full-Stack Observability",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure Monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile Monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "parent account",
        "permalink",
        "pinger",
        "Plugins",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "Telemetry Data Platform",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/035f6a352a6ed56d7d44284f3eee9343/d6a46/account-dropdowns.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-07-02T06:25:02Z",
      "updated_at": "2021-07-02T06:25:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown The account dropdown on the left lets you switch accounts. The account dropdown on the right gets you to your account settings. To access your account settings, in the top right, click your profile icon for all your account-related abilities. In the top left, use the All accounts dropdown menu to switch accounts. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation function You can use NRQL query function, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. child account See parent account. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, with the Browser agent, with the Mobile agent, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure Monitoring By connecting changes in host performance to changes in your configuration, Infrastructure Monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, and the ability to query and chart your New Relic data. These features are now separate and no longer related to Insights. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some contexts. Some examples of this: The API key used for the Event API is still called the Insights insert key. Some APM agents use Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For customers on our original pricing plan, Insights Pro is still the product name governing custom event data ingest and retention. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our Mobile Monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account See parent account. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, Mobile Monitoring, and Browser Monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile Monitoring Mobile Monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile Monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. parent account New Relic organizations can have a parent/child account structure. This structure was much more important for organizations on our original account/user model, but is still used for some features for organizations on the New Relic One account/user model. Learn more about account structure. Parent accounts were previously referred to as \"master accounts\", and child accounts were previously referred to as \"sub-accounts\". permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our Full Stack Observability pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.06062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "agent <em>API</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent <em>API</em> Some New Relic agents have agent <em>APIs</em> that allow you to extend the functionality"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    }
  ],
  "/docs/apis/intro-apis/new-relic-api-keys": [
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-07-01T18:45:24Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 217.92052,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic <em>APIs</em>",
        "sections": "<em>Introduction</em> <em>to</em> New Relic <em>APIs</em>",
        "tags": "<em>Intro</em> <em>to</em> <em>APIs</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred <em>API</em> for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST <em>APIs</em>"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "Tip",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-07-02T08:51:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. Tip To use our APIs, or the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.267204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "sections": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s <em>Intro</em> to NerdGraph. Or see the online course on New Relic <em>APIs</em>. Use the GraphiQL explorer To <em>get</em> <em>started</em> using GraphQL, we"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation function",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "child account",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "Full-Stack Observability",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure Monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile Monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "parent account",
        "permalink",
        "pinger",
        "Plugins",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "Telemetry Data Platform",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/035f6a352a6ed56d7d44284f3eee9343/d6a46/account-dropdowns.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-07-02T06:25:02Z",
      "updated_at": "2021-07-02T06:25:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown The account dropdown on the left lets you switch accounts. The account dropdown on the right gets you to your account settings. To access your account settings, in the top right, click your profile icon for all your account-related abilities. In the top left, use the All accounts dropdown menu to switch accounts. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation function You can use NRQL query function, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. child account See parent account. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, with the Browser agent, with the Mobile agent, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure Monitoring By connecting changes in host performance to changes in your configuration, Infrastructure Monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, and the ability to query and chart your New Relic data. These features are now separate and no longer related to Insights. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some contexts. Some examples of this: The API key used for the Event API is still called the Insights insert key. Some APM agents use Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For customers on our original pricing plan, Insights Pro is still the product name governing custom event data ingest and retention. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our Mobile Monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account See parent account. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, Mobile Monitoring, and Browser Monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile Monitoring Mobile Monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile Monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. parent account New Relic organizations can have a parent/child account structure. This structure was much more important for organizations on our original account/user model, but is still used for some features for organizations on the New Relic One account/user model. Learn more about account structure. Parent accounts were previously referred to as \"master accounts\", and child accounts were previously referred to as \"sub-accounts\". permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our Full Stack Observability pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.06059,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "agent <em>API</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent <em>API</em> Some New Relic agents have agent <em>APIs</em> that allow you to extend the functionality"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    }
  ],
  "/docs/apis/nerdgraph/examples/configure-infinite-tracing-graphql": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.3683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/create-widgets-dashboards-api": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.3683,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/export-dashboards-pdfpng-using-api": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/export-import-dashboards-using-api": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/golden-metrics-entities-nerdgraph-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08954,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.0894,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.8581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-07T01:39:51Z",
      "title": "Collect data",
      "updated_at": "2021-07-05T01:38:40Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.84058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min <em>APIs</em>, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with <em>NerdGraph</em> 25 min Try <em>NerdGraph</em> and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes"
      },
      "id": "6091fa38196a67a932d52a29"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36798,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.8581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-07T01:39:51Z",
      "title": "Collect data",
      "updated_at": "2021-07-05T01:38:40Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.84058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min <em>APIs</em>, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with <em>NerdGraph</em> 25 min Try <em>NerdGraph</em> and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes"
      },
      "id": "6091fa38196a67a932d52a29"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-distributed-trace-data-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.0894,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36798,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.8581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-nrql-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-relationships-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.08923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.0891,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "10b7f830b0ff5c9469d5525ce7a5a400850c1881",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2021-07-07T14:50:40Z",
      "updated_at": "2021-07-07T14:50:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@test.com\"], includeJson: true, name: \"Some Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@test.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@test.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the policy because it might be used by other policies. On the other hand, deleting a channel will cause all associated channels to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 671.4156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> <em>tutorial</em>: Notification channels",
        "sections": "<em>NerdGraph</em> <em>tutorial</em>: Notification channels",
        "tags": "Alerts and <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your alert notification channels using our <em>Graph</em>QL <em>NerdGraph</em> API. Here are some queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. Get notification channels"
      },
      "id": "60e5bf40196a67ac804ea049"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "Tip",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-07-02T08:51:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. Tip To use our APIs, or the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 487.20602,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "sections": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "tags": "<em>NerdGraph</em>",
        "body": " Export dashboards as files Migrate from Insights Dashboard API to <em>NerdGraph</em> Alerts See all alert-related tutorials <em>Applied</em> <em>Intelligence</em> View and configure <em>topology</em> Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "image": "https://docs.newrelic.com/static/7ef874231dae9e4c50130a1ab6571777/c1b63/NRAI_Decisions_Index.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/change-applied-intelligence-correlation-logic-decisions/",
      "sections": [
        "Change Applied Intelligence correlation logic with decisions",
        "Key concepts",
        "Review your active decisions",
        "Correlation statistics",
        "Use suggested decisions",
        "Create custom decisions",
        "Similarity algorithms",
        "Levenshtein distance",
        "Fuzzy score",
        "Fuzzy wuzzy ratio",
        "Fuzzy wuzzy partial ratio",
        "Fuzzy wuzzy token set ratio",
        "Jaro-winkler distance",
        "Cosine distance",
        "Hamming distance",
        "Jaccard distance",
        "Regex operators",
        "Regex in Step 1",
        "Regex in Step 2",
        "About flags",
        "Correlation assistant",
        "Attribute analysis",
        "Tips on using simulation",
        "Topology correlation",
        "Requirements",
        "How does topology correlation work?",
        "Add attributes to incident events",
        "Create or view topology"
      ],
      "published_at": "2021-07-02T12:33:38Z",
      "title": "Change Applied Intelligence correlation logic with decisions",
      "updated_at": "2021-06-08T21:20:29Z",
      "type": "docs",
      "external_id": "8c1e73ea08ed01f85be7af17e6210f63a7a0fc2f",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Incident Intelligence uses logic to correlate your incidents. We call these logic \"decisions.\" We have built-in decisions and you can create and customize your own on the Incident Intelligence Decisions UI page. The more optimally you configure decisions, the better we will group and correlate your incident events, resulting in reduced noise and increased context for on-call teams. one.newrelic.com > Applied Intelligence > Incident intelligence > Decisions: Our UI shows how each decision correlates incidents. Key concepts Here are some key concepts for understanding our decisions logic: What is \"correlation\" and how does it work? For the incident events being sent into Incident Intelligence from your various alerting engines, the most recently created and active incidents are available for correlation. Correlation occurs between two events whenever the criteria in any decision is met. All the events available for correlation are tested against each other in all possible pair combinations and a \"greedy merge\" is performed. This means that if incident A correlates with B into an issue and incident B correlates with incident C into another issue, then AB and BC will also merge together resulting in a single issue including A, B, and C. What types of logic can be used in a decision? At a high level, decisions allow you to define logic based on time (duration between events), frequency (number of events), context (metadata structure & values), and topology (entity relationships). Review your active decisions Decisions determine how Incident Intelligence correlates incidents together. By default, a broad set of global decisions is enabled when you start using Incident Intelligence. To review existing decisions: Go to one.newrelic.com and click Alerts & AI. In the left navigation, under Incident Intelligence, click Decisions. Review the list of active decisions. To see the rule logic that creates correlations between your issues, click the decision. To see examples of incidents the decision correlated, click the Recent correlations tab. Use any of the other options to enable or disable these global decisions. Your decisions will routinely be analyzed for their efficacy as well as other best practices, and recommendations will be attached for review. Correlation statistics Whether you want to use the suggested decisions we provide using our pattern recognition algorithms, or you want to add in your own correlation logic, you'll get insights into your correlation rate, noise reduction improvement, and the number of correlated issues arising, as shown below. From the UI, you can view the underlying NRQL queries and create your own custom charts and dashboards from this data. one.newrelic.com > Applied Intelligence > Incident intelligence > Decisions: Some example statistics from the decisions UI. Some definitions of statistics: Correlation rate: The percentage of the time correlations are occurring versus not. Total correlated issues: Number of issues correlated with another issue. Noise reduction: Total number of issues after correlation divided by the total number of issues before correlation. Correlation reason: Shows which decisions are correlating issues the most. Use suggested decisions Information about the types of suggested decisions: Suggested decisions: The data from your selected sources is continuously inspected for patterns to help reduce noise. Once patterns have been observed in your data, decisions are suggested that would allow these events to correlate in the future. Accelerated suggested decisions: If you have been using New Relic Alerts for a while, when you add alert policies to sources, we're able to use that historical data to accelerate the pattern recognition step and suggest decisions up to 30% faster. To get started, click on a suggested decision, located under the statistics block on the Decisions UI page. You'll see information on the logic behind the suggested decision, why we think it will help you, and the estimated correlation rate for that decision. one.newrelic.com > Applied Intelligence > Incident intelligence > Decisions: Suggested decision block If there isn't enough data to see the correlation rate, a link right below the percentage estimate will guide you to other sources you can add to get stronger results. Note: if you have less than 5000 incidents per month, you probably won't have suggested decisions. To add the suggested decision, click Activate decision and it will appear enabled, alongside the other decisions. If the decision isn't relevant to your needs, click Dismiss. Create custom decisions You can reduce noise and improve correlation by building your own custom decisions. To start building a decision, go to one.newrelic.com and click Alerts & AI. In the left navigation, under Incident Intelligence, click Decisions, then click Add a decision. Tips on how to use that UI are in the table below. When building a decision, steps 1, 2 and 3 are optional on their own but at least one must be defined in order to create a decision. Option Description Step 1: Filter your data In this step you'll define your filters. Remember correlation occurs between two incidents. If no filters are defined all incoming Incidents will be considered by the decision. Define your filters for the first segment (or bucket) of incidents, and the second segment of Incidents. Types of filter operators range from substring matching to regex matching to help you target the incident events you want and exclude those you don't. All combination of event pairs between segment one and segment two are used in the next steps of the decision. Step 2: Contextual correlation Once you've filtered your data, define the logic used when comparing the incidents' context. You can correlate events based on the following methods: Attribute value comparisons with standard operators Attribute value similarity using similarity algorithms Attribute value regex with capture groups Entire incident comparisons using similarity or clustering algorithms Step 3: Topology correlation Topology correlation is currently in limited release. Contact your account representative to enable this feature. Once enabled, you'll first need to ingest your topology data via our NerdGraph aiTopologyCollector (search for aiTopology in the NerdGraph explorer). This allows any topology-related decision to be matched with your topology data. Learn more about setting up topology correlation. Give it a name After you configure your decision logic, give it a recognizable name and description. This is used in notifications and other areas of the UI to indicate which decision caused a pair of incidents to be correlated together. Advanced settings Optional. The advanced settings area allows you to further customize how your decision behaves when correlating events. Each setting has a default value so customization is optional. Time window: Sets the maximum time between two incidents created time for them to be eligible for correlation. Issue priority: Overrides the default priority setting (inherit priority) to add higher or lower priority if the Incidents are correlated. Frequency: Modifies the minimum number of incidents that need to meet the rule logic for the decision to trigger. Similarity: If you're using similar to operators in your rule logic, you can choose from a list of algorithms and set its sensitivity. This will apply to all similar to operators in your decision. Similarity algorithms Here are technical details on the similarity algorithms we use: Levenshtein distance This measure is useful for comparing short strings with static schema and fixed length, like host names. Levenshtein distance is also known as edit distance. Details Description How it works The Levenshtein distance between two strings is the minimum number of single-character edits to get from one string to the other. Allowed edit operations are deletion, insertion, and substitution. The default similarity threshold for Applied Intelligence decisions is an edit distance of 3. You can change this in the Advanced mode of the decision builder. When to use it This measure is most useful for comparing relatively short strings with static schema and fixed length. Common applications include spell checkers, computational biology, and speech recognition. Examples number/bumble: 3 (number → bumber → bumblr → bumble) trying/lying: 2 (trying → rying → lying) strong/through: 4 (strong → htrong → throng → throug → through) Potential drawbacks Levenshtein distance is not normalized by default to take into account string lengths. Fuzzy score This metric is useful for comparing same-length strings where the same prefix would be a good indicator of correlation. Details Description How it works The fuzzy score algorithm works by allocating \"points\" for character matches between strings: One point for each matching character Two bonus points for subsequent matches The higher the fuzzy score, the greater the similarity between two strings. When to use it Fuzzy score is most useful for strings that have the same, and relatively short (ideally < 5 character), prefixes. A minimum guaranteed score would be (length(expected prefix) * 3) - 2. Examples Example: Decisions / dcsions d: 1 c: 1 i 1 s: 2 o: 1 n: 1 si: 2 io: 2 on: 2 ns: 2 = 15 points Potential drawbacks If the first character of the first string can't be found in the second string, no points are awarded. Fuzzy wuzzy ratio This metric is useful for comparing strings of similar length. Details Description How it works The fuzzy wuzzy family of similarity measures was developed by SeatGeek to help find tickets for the same event that have different labels across multiple platforms. The fuzzy wuzzy ratio for two strings is expressed as a percentage, where a higher number indicates a more similar string. It's based on the SequenceMatcher algorithm in Python's difflib. When to use it Fuzzy wuzzy ratio is effective for very short (eg. hostname) or very long (eg. event description) strings, especially in comparing strings of similar length. Potential drawbacks This algorithm is too sensitive to be used effectively for 3-10 word strings. One of the other modifications to fuzzy wuzzy (see below) may be a better choice. Fuzzy wuzzy partial ratio This metric is useful for comparing strings of different length. This modification to the fuzzy wuzzy algorithm helps address the effective length limitation. Details Description How it works With fuzzy wuzzy partial ratio, the shorter string is compared to each substring of the same length within the longer string. The score of the “best matching” substring is used to determine the fuzzy wuzzy partial ratio. When to use it Fuzzy wuzzy partial ratio is especially effective for the types of comparisons the basic fuzzy wuzzy algorithm fails at: 3-10 word strings where some significant substrings are likely to be overlapping. Examples For example, between the following strings: DevOps and SRE teams DevOps …”DevOps” (the shorter string, length = 6) would be compared to each substring with length 6 within “DevOps and SRE teams.” Since one of those substrings (“DevOps”) is a perfect match, the fuzzy wuzzy partial ratio for these two strings will be high. Potential drawbacks Where fuzzy wuzzy may be too conservative, fuzzy wuzzy partial match may be more liberal than expected with correlations. You can adjust the threshold in the decision builder according to your needs. Fuzzy wuzzy token set ratio This metric is useful for comparing strings where the information may not be in the same order, and of possible different lengths. It works best for sentences such as messages, descriptions, etc. Details Description How it works The token set ratio algorithm follows a few steps to compare strings: Tokenize each string (eg. “DevOps and SRE teams” → “DevOps” “and” “SRE” “teams”; “SRE team and DevOps engineers” → “SRE” “teams” “and” “DevOps” “engineers”) Combine intersecting tokens into a new string, leaving the remaining tokens. (eg. intersecting: ”DevOps”, “and”, “SRE”; remainder1: “teams”; remainder2: “team”, “engineers”) Alphabetize each token group (eg. “and, DevOps, SRE”, “teams”, engineers, team”) Compare the following pairs of strings: Intersection group Intersection group + remainder1 Intersection group + remainder2 The comparison from these pairs (“best matches”) is the fuzzy wuzzy token set ratio. When to use it This metric is helpful in cases where similar strings may have overlapping words but different construction - for example, event descriptions for different issues with the same resource. Potential drawbacks Where fuzzy wuzzy may be too conservative, fuzzy wuzzy token set match may be more liberal than expected with correlations. You can adjust the threshold in the decision builder according to your needs. Jaro-winkler distance This metric is useful for short strings where identical prefixes are a strong indication of correlation. Details Description How it works This metric uses a scale of 0-1 to indicate the similarity between two strings, where 0 is no similarity (0 matching characters between strings) and 1 is an exact match. Jaro-Winkler similarity takes into account: matching: two characters that are the same and in similar positions in the strings. transpositions: matching characters that are in different sequence order in the strings. prefix scale: the Jaro-Winkler distance is adjusted favorably if strings match from the beginning (a prefix is up to 4 characters). When to use it This metric is fairly tolerant of transpositions, but transpositions further apart in the string are less useful. A generally-safe number to use for Jaro-Winkler similarity in moderate to long strings is 0.9; you could use ~ 0.85 in cases where more leniency is okay (if you have other, more specific logic in the decision). Cosine distance This measure is most commonly used to compare large blocks of text (for example, incident descriptions) and provides an easy visualization of similarity. Details Description How it works For each text block you're comparing, a vector is calculated to represent the count of each unique word in the block. The cosine distance of the resulting vectors is their dot product divided by the product of their magnitudes. When to use it This measure is most useful to compare long blocks of text, specifically when the comparison is meant to consider the text as a whole, and not differences or misspellings in individual words. Examples It is not length of life, but depth of life. Depth of life does not depend on length. Copy Here are the word counts for these sentences: it 1 0 is 0 1 not 1 1 length 1 1 of 2 1 life 2 1 but 1 0 depth 1 1 does 0 1 depend 0 1 on 0 1 And here are those counts represented as a vector: [1, 0, 1, 1, 2, 2, 1, 1, 0, 0, 0] [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1] Copy The cosine distance of these vectors is about 0.9 (1 is the highest similarity). Potential drawbacks Cosine distance is less useful for situations where small character differences in words are insignificant. Also, cosine distance ignores word order in the text blocks. For more information on cosine distance implementation, see this detailed walkthrough. Hamming distance This measure is useful for shorter text with static schema, but it works only for same-length strings. Details Description When to use it Hamming distance requires the compared strings to be of equal length. This is a useful similarity metric for situations where the difference between two strings may be due to typos, or where you want to compare two attributes with known lengths. For example: Low Disk Space in application myapp in datacenter us01 If you wanted to be tolerant to datacenter changes, the hamming distance should be set to 4. An average use case for Hamming distance would be around 2-3. Examples A simpler version of \"edit distance\" metrics like Levenshtein distance, the Hamming distance between two strings is the number of characters in the string that don't match (in the same position). For example, in the strings below, the Hamming distance is 2: flowers / florets Copy Potential drawbacks In the example above, if the application name changes instead of the datacenter, a correlation would also be created. As the distance grows, the usefulness of Hamming Distance plummets. For this reason, for anything remotely more complicated than being tolerant to 1-2 character substitutions (or if the string lengths will not match), a different similarity measurement should be used. Jaccard distance This measure is useful for comparing large blocks of text, like descriptions or entire incidents. Details Description How it works The distance, denoted as a percentage (0 being completely similar; 1 being totally dissimilar) is calculated with the following formula: 1 - [(# of characters in both sets) / (# of characters in either set) * 100] Copy In other words, the Jaccard distance is the number of shared characters divided by the total number of characters (shared and un-shared). A Jaccard distance of 0.1 means that 10% or fewer characters between two incidents are different. When to use it Jaccard distance is very easy to interpret and especially useful in cases with large data sets. For example, in comparing the similarity between two entire incidents (as opposed to one attribute). Potential drawbacks It's less effective for small data sets or situations with missing data. Also, different permutations of the character set don't affect Jaccard distance, so care should be taken to prevent false positives. Regex operators When building a decision, available operators include: contains (regex): used in Step 1: Filter your data. regular expression match: used in Step 2: Contextual correlation. The decision builder follows the standards outlined in these documents for regular expressions. Regex in Step 1 In order for your regex to test as true, the entire attribute value (the data you’re evaluating) must be matched by the regular expression provided. Captured groups can be used but are not explicitly evaluated. For instance, if the attribute value is foobarbaz, these examples would meet the criteria and test as true: foo.* ^.*baz \\w+ Regex in Step 2 In order for your regex to test as true, the entire attribute values for incident 1 and incident 2 must be included in the match. Also, each captured group (expressions in ( ) parentheses) must exist in both values (incident 1 and incident 2 attributes), and have the same value: The number of captured groups must be equal for both incident attributes. Each group must be equal to the corresponding group between attribute values: the value of the first captured group in the incident 1 attribute value is equal to the value of the first captured group in the incident 2 attribute. For instance, if attribute value 1 is abc-123-xyz and attribute value 2 is abc-777-xyz, then (\\w+)-(?:\\w+)-(\\w+) would meet the criteria: The whole value is matched by the expression. The first and third captured groups have the same respective values. The second group is not captured using ?:, which allows the whole value to match but isn’t used in the capture group comparison. About flags No flags are enabled by default. Some useful flags to include in regular expressions in the decision builder are: CASE_INSENSITIVE: (?i) MULTILINE: (?m) DOTALL: (?s) See field detail for more notes on the function and implementation of each of these flags. Correlation assistant You can use the correlation assistant to more quickly analyze incidents, create decision logic, and test the logic with a simulation. To use the correlation assistant: From one.newrelic.com, click Alerts & AI, click Overview, then click the Incidents tab. Check the boxes of incidents you'd like to correlate. Then, at the bottom of the incident list, click Correlate incidents. For best results for correlating incidents, select common attributes with a low frequency percentage. Learn more about using frequency. Click Simulate to see the likely effect of your new decision on the last week of your data. Click on examples of correlation pairs and determine of those correlations are desired. If you like what's been simulated, click Next, and then name and describe your decision. If the simulation result shows too many potential incidents, you may want to choose a different set of attributes and incidents for your decision and run another simulation. Learn more about simulation. Attribute analysis Here are explanations of the two types of attribute analysis displayed in the UI: Common attributes: This analysis simply highlights attributes and values that are the exact same between all selected incidents. Similar attributes: Similarity analysis uses the Levenshtein algorithm with a distance of 3 to find attributes whose values would be the same if 3 or less character changes are performed. Other details: Numerical values as well as single character values are filtered out of the results. Requires two incidents to be selected. Similarity analysis is not performed when 3 or more incidents are selected. To create the best decisions, we recommend choosing common attributes that have a lower frequency in your incidents. Here are tips for understanding how choosing low or high frequency attributes affects your decisions: Low frequency: As an example, an attribute with a 0% in the frequency column is likely a unique identifier or an attribute that only recently reported in your data in the last month. Choosing low frequency attributes may correlate few events. High frequency: On the other end, an attribute with 100% frequency would be one that is present on all your data. Choosing these attributes would correlate all of your events together. By default, the attributes are sorted by frequency with the least frequently reported attributes at the top. Click an attribute's frequency percentage to get more information about the distribution of values we've seen reported for that attribute in the last month. Tips on using simulation Using a set of incidents, the correlation assistant identifies common attributes among those incidents as well as attributes with similar values. Select attributes you believe are good indicators that events should correlate and then simulate the decision. Simulation will test the logic against the last week of your data and show you how many correlations would have happened, in addition to actual examples to inspect. If the simulation looks good, continue creating your real decision. If the simulation doesn't show examples of useful correlations, choose a different set of attributes, and run the simulation again. Here’s a breakdown of the decision preview information displayed when you create a simulation: Potential correlation rate: The percentage of tested incidents this decision would have affected. Total created incidents: The number of incidents tested by this decision. Total estimated correlated incidents: The estimated number of incidents this decision would have correlated. Incident examples: A list of incident pairs this decision would have correlated. You can click on these to see a side by side comparison of all attributes and values to help you determine if the correlation is desired or not. Run the simulation with different attributes as many times as you need until you see results you like. When you’re ready, follow the UI prompts to save your decision. Topology correlation What do we mean by “topology”? For New Relic's Applied Intelligence, topology is a representation of your service map: how the services and resources in your infrastructure relate to one another. When you create a custom decision, you can use our topology correlation, which finds relationships between incident sources to determine if incidents should correlate. Topology correlation is designed to improve the quality of your correlations and the speed at which they're found. Requirements Topology correlation is currently in limited release. Requirements: Given access to topology feature by a New Relic representative Limit of 10K vertices per New Relic organization per environment How does topology correlation work? In this service map, the hosts and apps are the vertices, and the lines showing their relationships are the edges. Topology correlation relies on two main concepts: Vertex: A vertex represents a monitored entity: it's the source from which your incident events are coming from, or describing a problematic symptom about. A vertex has attributes (key/value pairs) configured for it, like entity GUIDs or other IDs, which allow it be associated with incoming incident events. Edges: An edge is a connection between two vertices. Edges describe the relationship between vertices. To set up your topology, you'll use our NerdGraph API. But first, it may help to understand how topology is used to correlate incidents: First, New Relic gathers all relevant incidents. This includes incidents where decision-logic steps 1 and 2 are true, and that are also within the defined time window in advanced settings. In this example, all of the incidents in the dotted-line selection have met these requirements: they've gone through the decision logic in steps 1 and 2, and all contextual comparisons made in decision logic step 2 are true. Next, we attempt to associate each incident to a vertex in your topology graph using a vertex's defining attributes and the available attributes on the incident. Here's an example of the steps for associating incidents with the information in the topology graph. Next, the pairs of vertices which were associated with incidents are tested using the \"topologically dependent\" operator to determine if these vertices are connected to each other. This operator checks to see if there is any path in the graph that connect the two vertices within 5 hops. The incidents are then correlated and the issues are merged together. Add attributes to incident events Incidents are connected to vertices using a vertex's defining attributes (in the example topology under Topology explained, each vertex has a defining attribute \"CID\" with a unique value). Next, Applied Intelligence finds a vertex that matches the attribute. If the defining attribute you'd like to use on your vertices isn't already on your incident events there are a few ways to add it: Tag your entities in New Relic: By tagging your entities, those tags will enrich the incident events generated by Alerts. For example, if you've tagged your entities with CID and their corresponding unique values then you can have defining attributes on your vertex as follows: 'newrelic/tags/CID' : CID_VALUE Facet your data: Creating NRQL alert conditions with one or more facets defined will group your data by attribute. Also, incident events emitted will be enriched with those attributes and values. For incidents, faceted attributes follow the same format: newrelic/tags/ATTRIBUTE_NAME Create or view topology To set up your topology or view existing topology, see the NerdGraph topology tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 326.99976,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change <em>Applied</em> <em>Intelligence</em> <em>correlation</em> logic with decisions",
        "sections": "Change <em>Applied</em> <em>Intelligence</em> <em>correlation</em> logic with decisions",
        "body": ": Creating NRQL alert conditions with one or more facets defined will group your data by attribute. Also, <em>incident</em> events emitted will be enriched with those attributes and values. For incidents, faceted attributes follow the same format: newrelic&#x2F;tags&#x2F;ATTRIBUTE_NAME Create or view <em>topology</em> To set up your <em>topology</em> or view existing <em>topology</em>, see the <em>NerdGraph</em> <em>topology</em> <em>tutorial</em>."
      },
      "id": "603e974528ccbc20ceeba7bf"
    }
  ],
  "/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.0891,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36774,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.85782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "sections": "<em>NerdGraph</em> tutorial: View and manage workloads",
        "tags": "<em>APIs</em>",
        "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our <em>NerdGraph</em> <em>API</em> to do some workloads-related tasks: Get the workloads of an account Get the list of entities"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    }
  ],
  "/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-07T01:39:51Z",
      "title": "Collect data",
      "updated_at": "2021-07-05T01:38:40Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.84003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min <em>APIs</em>, agents, OS emitters - <em>get</em> any data Create custom events 5 min Define, visualize, and <em>get</em> alerts on the data you want using custom events Build queries with <em>NerdGraph</em> 25 min Try <em>NerdGraph</em> and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Dashboard API migration: from Insights API to NerdGraph",
        "Why a new dashboards API?",
        "Starting out with NerdGraph",
        "Operations mapping table",
        "Dashboard properties mapping table",
        "Widget properties mapping table",
        "Tip",
        "Visualizations mapping table",
        "Examples: from REST endpoints to GraphQL queries/mutations",
        "List (GET) -> entitySearch query",
        "List all dashboard entities you have access to",
        "List all dashboards by name",
        "List all dashboards by creator’s email",
        "List all dashboards by creator’s user id",
        "Show (GET) -> entity query",
        "Get dashboard info given its entity guid",
        "Create (POST) -> dashboardCreate mutation",
        "Create dashboard with two pages and two widgets per page",
        "Update (PUT) -> dashboardUpdate mutation",
        "Update previously created dashboard to 1 page and 1 widget per page",
        "Delete (DELETE) -> dashboardDelete mutation",
        "Delete previously created dashboard"
      ],
      "title": "Dashboard API migration: from Insights API to NerdGraph",
      "type": "docs",
      "tags": [
        "NerdGraph",
        "Dashboards",
        "Dashboards API"
      ],
      "external_id": "7a1a086f45b7aefccb5d2cd5f42b3a0f0dd526c2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/dashboards-api-migration-insights-api-nerdgraph/",
      "published_at": "2021-07-02T15:10:53Z",
      "updated_at": "2021-07-02T15:10:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Insights Dashboard API is deprecated, but you can use NerdGraph (our GraphQL API) to create and configure dashboards. If you are not migrating from the old Insights API, you can skip this and discover the new Dashboards API. Why a new dashboards API? Our Insights product, which was a way to query data and create charts and dashboards, has been deprecated and its set of features moved over to be a core part of the New Relic One platform. To learn more about this transition and new features, see the Insights to New Relic One migration guide. The Insights Dashboard API will be deprecated in July of 2021. Until then, if you are using Insights Dashboard API, you should attempt to switch over to using NerdGraph. Some details on this deprecation: You can continue to use your Insights insert API key with the Dashboards API, or you can create a new user API key (read more about API keys). Every user who wants to use NerdGraph needs their own user API key. The REST API for Insights queries is not affected by this change and won't be deprecated. For more information about which key to use with our APIs, see our documentation about . When using NerdGraph, it helps to understand that our dashboards are entities that report data from other entities, such as monitored apps, hosts and services. Starting out with NerdGraph If you're new to NerdGraph and GraphQL, you may want to first read our Introduction to NerdGraph and some of Create dashboards with NerdGraph. The NerdGraph API explorer is located at api.newrelic.com/graphiql. Operations mapping table The table below maps every Insights API operation to the new dashboards API. Insights API operation NerdGraph API query/mutation Notes List (GET) entitySearch() View a paginated list of dashboards that match the filter. Show (GET) entity() View an existing dashboard given its entity guid. Create (POST) dashboardCreate() Create a new dashboard. Update (PUT) dashboardUpdate() Update an existing dashboard given its entity guid. Delete (DELETE) dashboardDelete() Delete an existing dashboard given its entity guid. Dashboard properties mapping table For more information about all the fields in the new dashboards GraphQL schema, have a look at NerdGraph's GraphiQL explorer. The table below maps dashboard properties from the Insights API to the new dashboards API. Insights API dashboard property NerdGraph API dashboard property Notes id guid ID of the New Relic entity the dashboard now represents createdAt createdAt updatedAt updatedAt title name editable permissions editable and visibility merged in the same concept visibility permissions editable and visibility merged in the same concept description description metadata - No need of versioning in GraphQL APIs icon - Not translated to New Relic One grid_column_count - 12 column dashboards by default in New Relic One filter - Not translated to New Relic One yet Widget properties mapping table For more information about all the fields in the new dashboards GraphQL schema, have a look at NerdGraph's GraphiQL explorer. The table below maps widget properties from the Insights API to the new dashboards API. Insights API dashboard property NerdGraph API dashboard property Notes id id account_id - Translated into widget configuration for those that require one visualization visualization presentation.title title presentation.drilldown_dashboard_id linkedEntities Used to link a widget to a dashboard for the facet linking feature presentation.notes - Not translated to New Relic One yet layout layout data configuration + rawConfiguration Tip To learn how to build every type of widget, see Create dashboard widgets. Visualizations mapping table We have simplified our widget visualizations by grouping the ones that were in fact the same but obtained through different types of queries. For instance, a line widget is plotted the same way regardless of the type of query: old line_chart vs. comparison_line_chart in Insights. Insights API visualization NerdGraph API visualization uniques_list viz.table single_event viz.table facet_table viz.table event_table viz.table faceted_area_chart viz.area predefined_metric_chart.application_breakdown viz.area predefined_metric_chart.scope_breakdown viz.area predefined_metric_chart.browser_breakdown viz.area predefined_metric_chart.background_breakdown viz.area predefined_metric_chart.solr_breakdown viz.area predefined_metric_chart.gc_runs_breakdown viz.area facet_bar_chart viz.bar billboard viz.billboard attribute_sheet viz.billboard billboard_comparison viz.billboard gauge viz.bullet event_feed viz.event-feed funnel viz.funnel heatmap viz.heatmap histogram viz.histogram inventory infra.inventory raw_json viz.json line_chart viz.line comparison_line_chart viz.line faceted_line_chart viz.line metric_line_chart viz.line markdown viz.markdown facet_pie_chart viz.pie Examples: from REST endpoints to GraphQL queries/mutations One of the main benefits of NerdGraph being a GraphQL-format API is that it provides a complete and understandable description of the APIs' data. By using the NerdGraph API explorer, you can discover GraphQL types and fields, along with a brief explanation. We want to facilitate your migration from the Insights API to the new New Relic One dashboards API. Find below some examples that illustrate how the old REST endpoints map to the new GraphQL queries or mutations. List (GET) -> entitySearch query Dashboards in New Relic One embrace the concept of entity. They are now another entity in New Relic’s entity ecosystem. Try it out using the NerdGraph GraphiQL explorer. List all dashboard entities you have access to { actor { entitySearch(queryBuilder: {type: DASHBOARD}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy List all dashboards by name { actor { entitySearch(queryBuilder: {name: \"My dashboard\"}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy List all dashboards by creator’s email { actor { entitySearch(queryBuilder: {type: DASHBOARD, tags: {key: \"createdBy\", value: \"email@domain.com\"}}) { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy List all dashboards by creator’s user id { actor { entitySearch(query: \"type ='DASHBOARD' and ownerId = '2357322'\") { results { entities { ... on DashboardEntityOutline { guid name accountId } } } } } } Copy Show (GET) -> entity query In order to get information on a dashboard, all you need is to provide its unique entity identifier or entity guid. Then you can access all the dashboard properties that you are interested in by adding them in the GraphQL query. Try it out using the NerdGraph GraphiQL explorer. Get dashboard info given its entity guid { actor { entity(guid: \"MY_DASHBOARD_GUID\") { ... on DashboardEntity { guid accountId name createdAt updatedAt permissions description owner { email userId } pages { guid name createdAt updatedAt description owner { email userId } widgets { id visualization { id } title layout { row column height width } rawConfiguration linkedEntities { guid } } } } } } } Copy Create (POST) -> dashboardCreate mutation Operations that mutate the state of the system are mutations in GraphQL APIs. You can create a dashboard by providing the required input for the dashboardCreate mutation. Although GraphQL APIs aim to be self-explanatory, Nerdgraph docs can help you with some information about the fields, like the doc about how to build dashboard widgets. Try it out using the NerdGraph GraphiQL explorer. Create dashboard with two pages and two widgets per page mutation { dashboardCreate(accountId: 1, dashboard: { name: \"My awesome dashboard\", permissions: PUBLIC_READ_WRITE, pages: [{ name: \"My first page\", widgets: [{ visualization: { id: \"viz.markdown\" }, title: \"My markdown widget\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { text: \"#My markdown\" } }, { visualization: { id: \"viz.line\" }, title: \"My line widget\", layout: { row: 1, column: 5, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ accountId: 1, query: \"SELECT count(*) FROM Transaction FACET appName TIMESERIES\" }] } }] }, { name: \"My second page\", widgets: [{ visualization: { id: \"viz.billboard\" }, title: \"My billboard widget with thresholds\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ accountId: 1, query: \"SELECT count(*) FROM Transaction\" }], thresholds: [{ alertSeverity: WARNING, value: 650 }, { alertSeverity: CRITICAL, value: 1500 }] } }, { visualization: { id: \"viz.table\" }, title: \"My table widget\", layout: { row: 1, column: 5, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ query: \"SELECT * FROM Transaction\", accountId: 1 }] } }] }] }) { errors { description type } entityResult { guid accountId name createdAt updatedAt permissions description owner { email userId } pages { guid name createdAt updatedAt description owner { email userId } widgets { id visualization { id } title layout { row column height width } rawConfiguration linkedEntities { guid } } } } } } Copy Update (PUT) -> dashboardUpdate mutation The dashboardUpdate mutation allows you to update an existing dashboard by providing the existing dashboard guid and the new configuration. Similarly to creating a dashboard, the mutation tries to be self-explanatory, but you can look up the doc about how to build dashboard widgets. Try it out using the NerdGraph GraphiQL explorer. Update previously created dashboard to 1 page and 1 widget per page mutation { dashboardUpdate(guid: \"MY_DASHBOARD_GUID\" dashboard: { name: \"My awesome dashboard\", permissions: PUBLIC_READ_WRITE, pages: [{ name: \"My first page\", widgets: [{ visualization: { id: \"viz.line\" }, title: \"My line widget\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ accountId: 1, query: \"SELECT count(*) FROM Transaction FACET appName TIMESERIES\" }] } }] }, { name: \"My second page\", widgets: [{ visualization: { id: \"viz.table\" }, title: \"My table widget\", layout: { row: 1, column: 1, width: 4, height: 3 }, rawConfiguration: { nrqlQueries: [{ query: \"SELECT * FROM Transaction\", accountId: 1 }] } }] }] }) { errors { description type } entityResult { guid accountId name createdAt updatedAt permissions description owner { email userId } pages { guid name createdAt updatedAt description owner { email userId } widgets { id visualization { id } title layout { row column height width } rawConfiguration linkedEntities { guid } } } } } } Copy Delete (DELETE) -> dashboardDelete mutation The dashboardDelete mutation allows you to delete an existing dashboard by providing its entity guid. Try it out using the NerdGraph GraphiQL explorer. Delete previously created dashboard mutation { dashboardDelete(guid:\"MY_DASHBOARD_GUID\") { status errors { type description } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 273.3163,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Dashboard <em>API</em> migration: from Insights <em>API</em> to <em>NerdGraph</em>",
        "sections": "Dashboard <em>API</em> migration: from Insights <em>API</em> to <em>NerdGraph</em>",
        "tags": "<em>NerdGraph</em>",
        "body": "). Every user who wants to use <em>NerdGraph</em> needs their own user <em>API</em> key. The REST <em>API</em> for Insights queries is not affected by this change and won&#x27;t be deprecated. For more information about which key to use with our <em>APIs</em>, see our documentation about . When using <em>NerdGraph</em>, it helps to understand that our"
      },
      "id": "60441442e7b9d2020b5799b9"
    },
    {
      "sections": [
        "New Relic API keys",
        "Manage API keys in UI",
        "Overview of API keys",
        "Important",
        "User key",
        "Create a user key",
        "Edit a user key",
        "Delete a user key",
        "Tip",
        "License key",
        "Create a license key",
        "Edit a license key",
        "Delete a license API key",
        "Browser key",
        "Create a browser key",
        "Edit a browser key",
        "Delete a browser key",
        "REST API key",
        "Activate or change REST API key",
        "View REST API keys",
        "Delete REST API key",
        "Insights insert key",
        "Generate an Insights insert key",
        "Edit or delete an Insights insert key",
        "Insights query key",
        "Generate an Insights query key",
        "Edit or delete an Insights query key",
        "Admin key"
      ],
      "title": "New Relic API keys",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "b373cd68cf21daeb5d912ffb4b1ae3f14f500fcc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/",
      "published_at": "2021-07-01T18:41:20Z",
      "updated_at": "2021-06-20T20:48:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has several different APIs that each require their own type of API key to use. This resource describes our API keys, what they're used for, and how to access them. Manage API keys in UI Here's a direct link to the API keys UI page. To find this from the New Relic UI: From the account dropdown, select Account settings. Select API keys. Overview of API keys The table below summarizes our available API keys and their uses. Important Some keys are able to be used by more than one API. If you're using a specific API, see the docs for that API to understand which keys are required and recommended. Key type What it's for Where to access User key (Also known as a \"personal API key\") Used for NerdGraph (our GraphQL API) and for accessing REST API endpoints (dependent on user permissions). API keys UI License key Allows ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. API keys UI Insights insert key (Also known as a \"Insert key\") Allows ingestion of events via HTTPS request from our metric, log, trace, and event APIs and the tools that use those APIs. Go to the API keys UI and click Insights insert key. Browser key Allows ingestion of browser monitoring data. API keys UI Mobile key (aka \"mobile app token\") Allows mobile monitoring data to be sent to New Relic. See Mobile app token. REST API key Note: we recommend using the user key instead because it has fewer limitations. The REST API key is for using our REST APIs for Alerts, APM, Browser, Infrastructure alerts, as well as Mobile REST APIs and the API Explorer. Go to the API keys UI and click REST API key. Admin API key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. For more information, see Admin key and User key below. API keys UI (will appear as user keys) Insights query key (aka \"Query key\") This key allows use of the Insights query API. Note: we now recommend using NerdGraph to query New Relic data. Go to the API keys UI and click Insights query key. User key New Relic user keys (previously referred to as \"personal API keys\") are required for NerdGraph (our GraphQL API), which allows you to query most New Relic data and do some types of configuration. User keys also let you use our REST API, with restrictions based on your permissions. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a user key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select User. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a user key Go to the API keys UI. In the row of the user key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a user key Go to the API keys UI. In the row of the user key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Tip In December 2020, user keys supplanted Admin API keys. For details, see Admin API key. License key New Relic license keys allow the ingestion of data from APM agents, the infrastructure agent, and some other data-ingest APIs. If you're using a specific API, see the docs for that API to understand which keys are required or recommended. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a license key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select License. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a license key Go to the API keys UI. In the row of the license key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a license API key Go to the API keys UI. In the row of the license key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Important You can't manage or delete an original license key that was created when your account was created. For that, contact New Relic support. Browser key The browser key allows the ingestion of data from New Relic browser monitoring. The instructions below are for managing keys in the UI. For managing keys via API, see Manage keys with NerdGraph. Create a browser key Go to the API keys UI and click Create key. In the Account dropdown, choose the account for which you want the key to be created. In the Key type dropdown, select Browser. In the Name field, enter a descriptive name for your key. In the Notes field, add relevant details about the key. Click Create. Edit a browser key Go to the API keys UI. In the row of the browser API key you want to edit, click ... and select Edit. Make your changes and click Update key. Delete a browser key Go to the API keys UI. In the row of the browser API key you want to delete, click ... and select Delete. Click Delete key to confirm your deletion. Important You can't manage or delete an original browser key that was created when your account was created. For that, contact New Relic support. REST API key Important We highly recommend using a user key instead, because that key has fewer restrictions. You can use a REST API key with our REST API and the API Explorer. For accounts that have sub-accounts, each sub-account must use its own REST API key. Requirements: Requires admin-level user permissions. If you don't have access to the REST API key or the REST API explorer, it might be due to lack of permissions. Talk to your New Relic account manager, or use a user key instead. Each New Relic account can have only one REST API key. Activate or change REST API key Go to the API keys UI and select REST API key. Click Regenerate REST API key. Click (Show key) to view your account's new REST API key. Copy your account's REST API key to use with New Relic's REST API. View REST API keys To view REST API keys: Go to the API keys UI and select REST API key. Click (Show key) to view your account's new REST API key. Delete REST API key To delete your account's REST API key: Before you delete an API key, make sure you have the correct account or sub-account. Go to the API keys UI and select REST API key. Select the delete icon for the REST API key. Confirm the deletion by typing DELETION IS FOREVER in the text field. Select Delete. Insights insert key The Insights insert key (aka the \"Insert key\") is required for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. Generate an Insights insert key Go to the API keys UI and select Insights insert keys. Next to the Insert keys heading, select the button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights insert key Go to the API keys UI and select Insights insert keys. Under Insert Keys, find the key you want to modify. Select Edit or Delete. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. Generate an Insights query key You must have access to the UIs you plan to query and the correct permissions in order to register or modify this key. Important Insights query keys are generated per account; they're not associated with a specific user. This means that any user in an account with access to a query key can use it. To register this key: Go to the API keys UI and select Insights query keys. Next to the Query Keys heading, select the button. A cURL command containing your insert key will appear, as well as NRQL query field. Edit the NRQL query field. Add comments in the Notes field if desired. Click Save your notes. Edit or delete an Insights query key To edit or delete this key: Go to the API keys UI page and select Insights query keys. Under Query Keys, find the key you want to modify. Select Edit or Delete. Admin key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don’t need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says “Migrated from an admin user key” in the key table, so you’ll be able to find them easily.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 268.96472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>API</em> keys",
        "sections": "New Relic <em>API</em> keys",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " and recommended. Key type What it&#x27;s for Where to access User key (Also known as a &quot;personal <em>API</em> key&quot;) Used for <em>NerdGraph</em> (our <em>Graph</em>QL <em>API</em>) and for accessing REST <em>API</em> endpoints (dependent on user permissions). <em>API</em> keys UI License key Allows ingestion of data from APM agents, the infrastructure agent"
      },
      "id": "6043fa3464441f1358378f3b"
    }
  ],
  "/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials": [
    {
      "sections": [
        "NerdGraph tutorial: Managing data partition rules",
        "Important",
        "How to query data partitions rules",
        "Data partition rule schema",
        "How to create data partitions rules",
        "How to delete data partitions rules"
      ],
      "title": "NerdGraph tutorial:  Managing data partition rules",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples",
        "Logs"
      ],
      "external_id": "b2a64a1935bf04aadfa82cf15ec7544eb40dcc99",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic’s NerdGraph GraphQL explorer to query and manage your data partition rules. This document includes: Example partition rules queries How to create a data partition rule How to delete a data partition rule Important Managing data partitions through NerdGraph is an opt-in feature. If you're interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This NerdGraph API request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account(id: 123456) { logConfigurations { dataPartitionRules { id targetDataPartition description matchingCriteria { attributeName matchingOperator matchingExpression } } } } } } Copy Data partition rule schema Here's the complete list of possible data partition rule fields: Fields Description id Unique data partition rule identifier. targetDataPartition The name of the data partition. description A description of what this data partition rule represents. matchingCriteria The matching criteria for this data partition rule. Once the rule is enables, logs matching this criteria will be routed to the specified data partition. retentionPolicy The retention policy of the data partition data. createdAt The date and time the rule was created. createdBy The user who created the rule. updatedAt The date and time the rule was last changed. updatedBy The user who last updated the rule. enabled Whether or not this data partition rule is enabled. deleted Whether or not this data partition rule has been deleted. Deleting a data partition rule does not delete the already routed logs. How to create data partitions rules This example creates a new data partition rule. Before creating the rule, please be sure to check this article: Organize data with partitions and make sure the targetDataPartition name startsDeleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsCreateDataPartitionRule( accountId: 1123456, rule: { targetDataPartition: \"Log_aNewDataPartitionRule\", description: \"Example data partition rule\", matchingCriteria: { attributeName: \"attribute\", matchingMethod: LIKE, matchingExpression: \"'%example%'\" }, retentionPolicy: STANDARD, enabled: true }) { rule { id targetDataPartition description } errors { message type } } } Copy How to delete data partitions rules This example deletes a data partition rule. Deleting a data partition rule doesn't delete the already persisted data. This data will be retained for a given period of time defined by the retention policy field. mutation { logConfigurationsDeleteDataPartitionRule(id: \"1111\", accountId: 123456) { errors { message type } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.089,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial:  Managing data partition rules",
        "sections": "<em>NerdGraph</em> tutorial: Managing data partition rules",
        "tags": "<em>APIs</em>",
        "body": ". If you&#x27;re interested in having this feature enabled for your account, please contact customer support. How to query data partitions rules This <em>NerdGraph</em> <em>API</em> request example gets all of the data partition rules for a given account. In this example, only a few fields are requested. { actor { account"
      },
      "id": "60dedc7a196a674f914ea040"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.36758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Configure cloud integrations",
        "sections": "Access the <em>NerdGraph</em> <em>GraphiQL</em> explorer",
        "tags": "<em>APIs</em>",
        "body": " to connect cloud integrations with New Relic. Created an <em>API</em> key. Access the <em>NerdGraph</em> GraphiQL explorer To access the <em>NerdGraph</em> GraphiQL explorer: Go to <em>api</em>.newrelic.com&#x2F;graphiql. Add any of the following <em>examples</em>. Query <em>examples</em> Queries are requests that are intended to only fetch data (no side"
      },
      "id": "6044293864441f1bdc378f05"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-07T01:39:51Z",
      "title": "Collect data",
      "updated_at": "2021-07-05T01:38:40Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.84003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min <em>APIs</em>, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with <em>NerdGraph</em> 25 min Try <em>NerdGraph</em> and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes"
      },
      "id": "6091fa38196a67a932d52a29"
    }
  ],
  "/docs/apis/nerdgraph/tutorials/provisions-your-subscriptions-nerdgraph": [
    {
      "sections": [
        "Partnership admin console",
        "Console components",
        "Partnership configuration settings",
        "Customer activity monitoring",
        "State-of-the-Partnership report",
        "Partner customer monitoring",
        "View an arbitrary customer",
        "Viewing detailed customer data"
      ],
      "title": "Partnership admin console",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Getting started"
      ],
      "external_id": "670e4d2e1db957100b23a7b8b0af6bf50cc8c996",
      "image": "https://docs.newrelic.com/static/43369c88523ebf526ae58fa5719d4efe/0abdd/crop-partnership-owner-account-settings.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/getting-started/partnership-admin-console/",
      "published_at": "2021-07-02T15:19:01Z",
      "updated_at": "2021-07-02T15:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Partnership Admin Console is the interface for managing your customers' accounts and integration with New Relic. To access the console, sign into the partnership owner account, and go to: https://partner-admin-console.newrelic.com/accounts/ACCOUNT_ID/admin_console/ Copy You can also access the console from the New Relic UI: Go to one.newrelic.com > (account dropdown) > Account settings. From the left menu bar, select Partnerships. one.newrelic.com > (account dropdown) > Account settings > Partnerships: Partnership owners can access the Partnership Admin Console from their account settings in the New Relic UI. Console components The Partnership Admin Console has two main components: Partnership configuration settings Customer activity monitoring If multiple partnerships are associated with the New Relic parent account, the menu also includes an option to switch partnership accounts. Partnership configuration settings In developing your integration with New Relic, you must specify a number of settings. For your convenience these settings are grouped together in the partnership console, including URLs for header/footer and various redirects, SSO configuration, and keys and the ability to manipulate them. Customer activity monitoring New Relic provides you with two tools for managing your customers: State-of-the-Partnership reports and live monitoring of all deployed New Relic agents in your partnership. Both of these tools provide insight into your customers who are using New Relic. They can be used to identify up-sale opportunities or to assist your support group in proactive support. State-of-the-Partnership report The State-of-the-Partnership report provides a summary of your customers with New Relic accounts and their activities. The report is broken down by language of the agents deployed, the agent version and the language version for each account. This report is run weekly for each partner. It is available on request from your New Relic Business Development contact. This report is an excellent way to see which of your customers with New Relic accounts are in fact using the service. Partner customer monitoring The Partner customer monitoring facility provides application performance data on the New Relic enabled applications that are running on your service. This facility allows you to easily identify customers experiencing performance problems. Where the performance problems are caused by under capacity, these customers are excellent sales opportunities. Alternatively your support or services organization will find this information useful in pre-emptively identifying customer issues or as good prospects for consulting services. View an arbitrary customer To view activity of a customer that does not appear in any of the filtered views: Go to one.newrelic.com > (account dropdown) > Switch accounts > Other accounts. New Relic will list all of the reporting accounts in the partnership. You can filter or search the list. Viewing detailed customer data Under normal circumstances a partner will be able to see only the summary level data in a customer's New Relic account. Through the Partnership Admin Console, partners will be permitted to drill down to the more detailed presentation. If you want to drill down from the Partnership Admin Console, add your user (typically support@partner.com or something similar) to the account. Typically this will be done at account creation. Avoid provisioning this user as the account Owner.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.93417,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> admin console",
        "sections": "<em>Partnership</em> admin console",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " the console from the <em>New</em> <em>Relic</em> UI: Go to one.newrelic.com &gt; (account dropdown) &gt; Account settings. From the left menu bar, select <em>Partnerships</em>. one.newrelic.com &gt; (account dropdown) &gt; Account settings &gt; <em>Partnerships</em>: <em>Partnership</em> owners can access the <em>Partnership</em> Admin Console from their account settings"
      },
      "id": "603ed3e3196a6735baa83dad"
    },
    {
      "sections": [
        "Partnership accounts, users, and subscriptions",
        "Partnerships with New Relic",
        "Account hierarchy",
        "Tip",
        "Partnership owner accounts (POA)",
        "Child accounts with partnerships",
        "Account users",
        "Partnership pricing"
      ],
      "title": "Partnership accounts, users, and subscriptions",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partner integration guide",
        "Partner account maintenance"
      ],
      "external_id": "ae2f39a8ff0395815b3e31a9d8ad9361beca2c4e",
      "image": "https://docs.newrelic.com/static/7280d9af3c35c6eac85c43c7034ae789/db3a5/partnership-hierarchy.png",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partner-integration-guide/partner-account-maintenance/partnership-accounts-users-subscriptions/",
      "published_at": "2021-07-02T15:20:58Z",
      "updated_at": "2021-07-02T15:20:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic organizations set up as partnership accounts have access to an enhanced hierarchical way of organizing their account structure. Partnerships with New Relic There are two types of New Relic organizations that are able to use our partnership account structure and the Partnership API: An actual partnership: A partnership refers to managed service providers or resellers, who offer New Relic products to their customers. Heroku is one example of such a New Relic partner. A customer partnership: some of our larger organizations also make use of our partnership account structure. We call these customers \"customer partnerships.\" Use of our partnership account structure requires prior approval and set up by New Relic representatives. For customer partnerships, New Relic contacts organizations that would benefit from such a structure. Partnerships are identified by a numeric PARTNER_ID. In some cases, a New Relic customer may have more than one partnership; for example, when one section of New Relic users must be managed differently from another. Partnerships are administered by a partnership owner account. The account that owns a partnership functions differently from a regular account. If multiple partnerships have been set up, each has a unique PARTNER_ID. Account hierarchy New Relic partnership organizations consist of the partnership owning account, partnerships, parent accounts, and child accounts. A partnership can have multiple parent and child accounts. To understand how child accounts and parent accounts scale with EU region accounts, see EU region account hierarchy. Tip If you don't have a partnership organization, you can only have one parent account. For more information, see Manage apps or users with child accounts. All parent and child accounts roll up to your partnership account. Partnership owner accounts (POA) The partnership owner account (POA) is the entity that is used to administer a partnership. It controls which users manage accounts under partnerships, have access to the partner API, and manage other aspects of the partnership. Do not monitor your own applications from the partnership owner account. Instead, create an account within the partnership and monitor apps from that account. Users on the partnership owner account can access accounts under their partnerships and enjoy User level privileges. Admins on the POA can access accounts under their partnerships and enjoy Admin level privileges, including permission to manage users. The Owner of the partnership owner account will still only have Admin level access on accounts under the partnership. That means that the owner cannot enable SAML SSO, change the account owner, cancel the account via the UI, etc. The partnership owner account enjoys special privileges, and it lets you exercise the capabilities defined in your partnership agreement with New Relic. For example, you may use your partnership owner account with the New Relic Partnership API to set up and manage users on your accounts or to view your customers' performance data in the New Relic UI. Tip Many of the Partnership API calls return an account status as part of the XML. Child accounts with partnerships Child accounts behave differently than other New Relic accounts provisioned through your partnership: Child accounts Comments Account creation Child accounts can be created through the Partnership API or New Relic user interface. In order to group accounts through the New Relic user interface, your partnership must have Admin privileges, and the account must have the appropriate subscription level. If you have any questions about partnership privileges or subscription levels, contact your New Relic account representative. Child accounts do not have a New Relic subscription of their own. They inherit the parent account's subscription. Billing Billing is applied at the parent account level. Exception: Reseller partnerships receive consolidated billing for all accounts under the partnership. Permissions Admin-level users on a parent account have the ability to create, modify, and delete children accounts for the parent account. Users that have been granted access permissions on a parent account automatically inherit the same level of access for all children accounts. This is also true for add-on roles. Exception: Child account users won't receive alert emails or weekly report emails unless they are explicitly granted permission on these child accounts. Account users You can use the Partnership user API to add and maintain your customer users. An account must always have at least one person (the Owner) associated with it. For security purposes, you cannot change an account Owner with the Partnership user API. Instead, you must change the account Owner from the Users page in the New Relic UI. In addition, a specific user may be associated with multiple accounts. For example, many New Relic users have accounts through a partnership, and they also have accounts they created directly with New Relic. Partnership pricing Accounts within a partnership organization may have different levels of access to New Relic products. Tip Many of the Partnership API calls return a subscription status as part of the XML. For accounts set up through a partnership: An account can have multiple New Relic products associated with it. However, only one subscription per product may be active at any time. For example, a user may have both an Essentials subscription and a higher service level Pro Trial subscription. When the Pro Trial subscription expires, the service level returns to the Essentials subscription. Promotions may appear as a subscription change. Several factors affect starting and stopping subscriptions, including how New Relic handles pricing and billing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.89352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> accounts, users, and subscriptions",
        "sections": "<em>Partnerships</em> with <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": "<em>New</em> <em>Relic</em> organizations set up as <em>partnership</em> accounts have access to an enhanced hierarchical way of organizing their account structure. <em>Partnerships</em> with <em>New</em> <em>Relic</em> There are two types of <em>New</em> <em>Relic</em> organizations that are able to use our <em>partnership</em> account structure and the <em>Partnership</em> API"
      },
      "id": "603ece55e7b9d273782a0804"
    },
    {
      "sections": [
        "Partnership API account object",
        "Requirements",
        "Account object attributes",
        "name (REQUIRED to create an account)",
        "phone_number",
        "allow_api_access",
        "testing",
        "users (REQUIRED for some accounts)",
        "subscriptions (REQUIRED for some accounts)",
        "Important",
        "Account API calls",
        "Status definitions",
        "JSON example",
        "Account object JSON request",
        "JSON response",
        "Account object API examples",
        "List",
        "Show",
        "Create",
        "Update",
        "Delete"
      ],
      "title": "Partnership API account object",
      "type": "docs",
      "tags": [
        "New Relic partnerships",
        "Partnerships",
        "Partner API"
      ],
      "external_id": "0b1fde4800f2f9f355e0381796f55e23e61342c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-partnerships/partnerships/partner-api/partnership-api-account-object/",
      "published_at": "2021-07-02T15:23:47Z",
      "updated_at": "2021-07-02T15:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This doc explains how to use the Partnership API to manage accounts. For child accounts, you'd use the child account object. Requirements You may not be able to use some aspects of this object. Before using, first read the requirements. Account object attributes Here are the Partnership API account object's attributes. name (REQUIRED to create an account) Type: String Default: (none) The account name attribute is required for new accounts. This name must be unique in New Relic's database. If the specified name is not unique, it will be auto-incremented with a numeric suffix as follows: conflicting_name_1 conflicting_name_2 etc. Copy phone_number Type: String Default: (none) Primary contact phone number for the account. allow_api_access Type: Boolean Default: False This flag allows API access to application data. This must be set to true for partnerships remotely administering accounts. testing Type: Boolean Default: False Use this flag to indicate a test account. Test accounts are assumed to contain garbage data and are ignored by internal systems. The data they generate may be deleted at any time. users (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of users. There are some restrictions in place dependent on the status of your account: For customer partnerships who have switched to the New Relic One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you'd use these user management procedures. For all other accounts, which have users on our original user model: When you first create an account, this field is required, and only one user can be defined: the account Owner. To add additional users, use the Partnership API user object. For more on restrictions, read the Requirements. subscriptions (REQUIRED for some accounts) Type: Array Default: (none) An array defining a list of subscriptions. There are some restrictions in place dependent on the status of your account: For customer partnerships on our New Relic One pricing plan: ignore this field because it applies to the original pricing plan, not yours. If you use this, it will be ignored. For all other accounts: You are on our original product-based pricing plan. The subscriptions attribute is required for new accounts. If it is empty, default product tiers will be used. To update subscription information, use the Partnership API subscription object. Important When creating an account with this object, it can take some time for the account settings to populate. This means that the returned response may initially show aspects that are not true (for example, it may return a response showing default Lite subscriptions). To specify an empty JSON array, don't use subscriptions: [ {} ]. Instead, use this format: subscriptions: [ ] Copy The account API does not include an attribute to create a child account. Instead, to create child accounts, use the parent account's Account settings page in the New Relic UI. Account API calls Here are the URL patterns for account API functions. If using this URL pattern, send an HTTP header containing the Partner API key along with the JSON request body. For example: GET .../api/v2/partners/:PARTNER_ID/accounts/:ID x-api-key: :PARTNER_ACCOUNT_KEY Content-Type: application/json { JSON data } Copy Call Resource URL pattern List (index) all accounts of a partner. GET /api/v2/partners/PARTNER_ID/accounts Copy Show the attributes of an account. GET /api/v2/partners/PARTNER_ID/accounts/:ID Copy Update the attributes of an account. PUT /api/v2/partners/PARTNER_ID/accounts/:ID Copy Create an account with the given parameters. POST /api/v2/partners/PARTNER_ID/accounts Copy Cancel an account. DELETE /api/v2/partners/PARTNER_ID/accounts/:ID Copy Status definitions When an account is created or listed with an API call, the account status is included automatically. Some of these statuses don't apply to all pricing plans. Account status Definition pending Free account created, but primary admin is not yet activated. paid_pending Account created with a paid subscription, but the primary admin is not yet activated. new Free account, active primary admin, no application data has been collected. paid_new Paid subscription, active primary admin, no application data has been collected. active Free subscription, receiving application data. paid_active Paid subscription, receiving application data. upgraded Account's subscription was upgraded. downgraded Account's subscription was downgraded. cancelled The New Relic account subscription has been cancelled. suspended The New Relic account has been suspended because the primary admin has not validated their email address. JSON example Here is an example of a JSON request and response using the Partnership API account object. Note that this is just an example, and that for some accounts, the users and subscriptions attributes are unnecessary and are ignored. Account object JSON request { \"account\": { \"name\": \"Sample Account\", \"application_type\": \"ruby\", \"users\": [ { \"email\": \"sample_user@sample.org\", \"password\": \"XXXXXXXX\", \"owner\": true, \"role\": \"admin\", \"first_name\": \"Sample\", \"last_name\": \"User\" } ], \"subscriptions\": [ { \"product_id\": 4, \"quantity\": 10 }, { \"product_id\": 10, \"quantity\": 0 } ], \"allow_api_access\": true, \"phone_number\": \"555-555-5555\" } } Copy JSON response { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Account object API examples Partnerships with more than 1000 accounts return a paginated response. To specify a page, add the following parameter to the query: ?page= Copy Here are examples of calls using the Partnership API account object. Note that these are examples, and that for some accounts, the users and subscriptions attributes don't apply and will be ignored. List List request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts Copy Response (line breaks are for readability): { \"accounts\": [ { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1990.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": null, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } ] } Copy Show Request: curl -X GET \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": 00000, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Create Here's an example of creating an account for an organization on our original pricing plan and on our original user model. For an example call of creating an account for organizations with the newer models, see the example after this one. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample Account\", \"users\":[{\"email\":\"sample_user@sample.org\", \"password\":\"XXXXXX\", \"first_name\":\"Sample\", \"last_name\":\"User\", \"role\":\"admin\", \"owner\":\"true\"}],\"subscriptions\":[{\"product_id\": 4,\"quantity\": 10},{\"product_id\": 10,\"quantity\": 0}]}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Sample Account\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Here's an example of creating an account for a customer partnership that is on our New Relic One pricing and our New Relic One account/user model. For more on restrictions on API use, see requirements. curl -X POST \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ Copy Update You can only use the Partnership API account object to update the name, phone_number, testing and allow_API_access values. To update subscription and users values, you must use the Partnership API subscription object and Partnership API user object. Request: curl -X PUT \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ -d '{\"account\":{\"name\":\"Sample account name\"}}' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response (line breaks are for readability): { \"id\": XXXXXX, \"name\": \"Account New Name\", \"status\": \"pending\", \"license_key\": \"caf8247360d8db295c142c72138fa8fb28df1403\", \"api_key\": \"86f818b6d81668b6c034661396b71c25bb323d8b8df1403\", \"browser_monitoring_key\": \"66617123f5\", \"allow_api_access\": true, \"high_security\": false, \"testing\": null, \"partner_external_identifier\": null, \"subscription\": { \"id\": XXXXXX, \"starts_on\": \"2016-05-17\", \"expires_on\": null, \"annual_renewal_on\": null, \"products\": [ { \"product_id\": 4, \"name\": \"Pro\", \"units\": 10, \"price\": 1999.0 }, { \"product_id\": 10, \"name\": \"Mobile Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 20, \"name\": \"Browser Lite\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 16, \"name\": \"Insights None\", \"units\": 0, \"price\": 0.0 }, { \"product_id\": 23, \"name\": \"Synthetics Lite\", \"units\": 0, \"price\": 0.0 } ] }, \"primary admin\": { \"id\": XXXXXX, \"email\": \"sample_user@sample.org\", \"first_name\": \"Sample\", \"last_name\": \"User\", \"state\": \"active\" } } Copy Delete Request: curl -X DELETE \\ -H 'x-api-key:PARTNER_ACCOUNT_KEY' \\ -H 'Content-Type:application/json' \\ https://rpm.newrelic.com/api/v2/partners/PARTNER_ID/accounts/ACCOUNT_ID Copy Response: No response body.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.77724,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Partnership</em> API account object",
        "sections": "<em>Partnership</em> API account object",
        "tags": "<em>New</em> <em>Relic</em> <em>partnerships</em>",
        "body": " a list of users. There are some restrictions in place dependent on the status of your account: For customer <em>partnerships</em> who have switched to the <em>New</em> <em>Relic</em> One user model: do not define users. If you add users with this field, they will be ignored. Instead, to add users, you&#x27;d use these user"
      },
      "id": "603ebc5f196a679110a83dd5"
    }
  ],
  "/docs/apis/rest-api-v1-deprecated/new-relic-rest-api-v1/working-new-relic-rest-api-v1-deprecated": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Collect data - any source",
        "Create custom events",
        "Build queries with NerdGraph",
        "Query data with NRQL"
      ],
      "published_at": "2021-07-07T01:39:51Z",
      "title": "Collect data",
      "updated_at": "2021-07-05T01:38:40Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add custom attributes   Use custom attributes for deeper analysis Collect data - any source 15 min APIs, agents, OS emitters - get any data Create custom events 5 min Define, visualize, and get alerts on the data you want using custom events Build queries with NerdGraph 25 min Try NerdGraph and build the queries you need Query data with NRQL 10 min Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.827744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "Through our opensource agents or <em>APIs</em>, <em>New</em> <em>Relic</em> makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Add"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/",
      "sections": [
        "Welcome to New Relic",
        "Create a free account",
        "Start collecting data",
        "Set up alerts",
        "Telemetry Data Platform",
        "Introduction to Telemetry Data Platform",
        "Data explorer",
        "Dashboards",
        "Log management",
        "APIs",
        "Manage data",
        "Build on New Relic One",
        "Full-Stack Observability",
        "Introduction to Full-Stack Observability",
        "APM",
        "Browser",
        "Distributed Tracing",
        "Infrastructure",
        "Logs in context",
        "Mobile",
        "Serverless",
        "Synthetics",
        "Workloads",
        "Alerts and Applied Intelligence (AI)",
        "Introduction to Alerts",
        "Introduction to Applied Intelligence",
        "Incident Intelligence",
        "Incident Workflows",
        "Proactive Detection",
        "New Relic integrations",
        "Back-end, front-end, and mobile applications",
        "Infrastructure and cloud platforms",
        "Open-source monitoring systems",
        "Security, privacy, and legal information",
        "Data privacy",
        "Security compliance",
        "Security bulletins",
        "Licenses"
      ],
      "published_at": "2021-07-07T01:38:36Z",
      "title": "New Relic Documentation",
      "updated_at": "2021-07-07T01:38:36Z",
      "type": "docs",
      "external_id": "807276d5fdd805ba0247a1ce1016af986fb31995",
      "popularity": 1,
      "body": "Welcome to New Relic If you're new, follow these three steps to create an account and get going. (It's free!) Scroll on for more about our Telemetry Data Platform, Full-Stack Observability, and Applied Intelligence. Or, to get a wider view of our platform's capabilities, read the Intro to New Relic, and use our solutions and best practices guides. Create a free account No credit card required. Start collecting data Our UI guides you through setup and install. Set up alerts Get notified quickly about changes in your system. Telemetry Data Platform Ingest, visualize, and alert on all your telemetry data in one place. Introduction to Telemetry Data Platform How to manage all your monitoring in one place. Data explorer Query and build charts with NRQL, our PromQL-style syntax, or our visual chart builder. Dashboards Combine data from anywhere in our platform into customized dashboards. Log management Get logs alongside your telemetry data with our fast, scalable log management. APIs Find APIs to send data in, get data out, or manage the New Relic platform. Manage data Monitor and control your data usage. Build on New Relic One Learn how to build custom apps on our platform at developer.newrelic.com Full-Stack Observability Analyze and troubleshoot problems easily across your entire software stack. Introduction to Full-Stack Observability Get deep insight into everything from infrastructure to server code to end-user apps. APM Get real-time and trending data about your app's performance and stability. Browser Measure website performance, track errors, and see how users interact with your site. Distributed Tracing Track requests through your distributed system to find trends and anomalies. Infrastructure Monitor your infrastructure—hosts, cloud providers, container services, backend services, orchestrators, and more. Logs in context Link your log data to APM agent data so you can pinpoint where things are going wrong. Mobile Understand user journeys in your Android and iOS apps and troubleshoot crashes. Serverless Monitor AWS Lambda, Azure Functions, and Google Cloud Functions. Synthetics Simulate user activity to detect outages and fix poor website performance. Workloads Group or monitor entities across your entire stack based on a team or a set of responsibilities. Alerts and Applied Intelligence (AI) Automatically detect anomalies, correlate issues, and reduce alert noise. Introduction to Alerts Get notified about important changes in your system based on any data you connect to New Relic. Introduction to Applied Intelligence Recognize issues sooner, resolve problems faster, and reduce noise for better incident management. Incident Intelligence Get an overview of all your incidents. See sources and related events, and find out how they all correlate. Incident Workflows Enrich your incidents with New Relic data before sending them to your notification platform. Proactive Detection Get notified by Slack or webhook of unusual app behavior. New Relic integrations Integrations connect the technologies in your stack to New Relic. Here are a few of our 370+ integrations: Back-end, front-end, and mobile applications Android Browser (JavaScript) C SDK Go iOS Java .NET Node.js PHP Python Ruby Synthetics Infrastructure and cloud platforms Apache AWS Azure Google Cloud Kafka Kubernetes Linux Microsoft SQL MongoDB MySQL NGINX PostgreSQL Redis Windows Open-source monitoring systems Dropwizard Istio JMX Kamon Micrometer OpenCensus OpenTelemetry Prometheus StatsD See all 370+ integrations Security, privacy, and legal information Find out how we ensure security, data privacy, and compliance, and find our terms of service. Data privacy New Relic takes your data privacy seriously. Our principles-based approach aims to go beyond the legal requirements for consent. Security compliance Whether your data is in transit to New Relic or at rest in our storage, strong encryption measures can help protect against unauthorized access or theft of valuable data. Security bulletins Security bulletins are a way for us to let you know about security vulnerabilities, remediation strategies, and applicable updates. Licenses All about New Relic's licenses, Usage Plan, and policies. Find out what open source software we use in our products.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.34129,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Documentation",
        "sections": "Welcome to <em>New</em> <em>Relic</em>",
        "body": " management Get logs alongside your telemetry data with our fast, scalable log management. <em>APIs</em> Find <em>APIs</em> to send data in, get data out, or manage the <em>New</em> <em>Relic</em> platform. Manage data Monitor and control your data usage. Build on <em>New</em> <em>Relic</em> One Learn how to build custom apps on our platform"
      },
      "id": "5be4e5d38e9c0f3585d72edf"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "Tip",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-07-02T08:51:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. Tip To use our APIs, or the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. What is NerdGraph? New Relic has several APIs. NerdGraph is our preferred API for querying New Relic data, and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing plan) Data partitions Manage data partitions NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 49.689484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em> NerdGraph, our GraphQL <em>API</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em> NerdGraph, our GraphQL <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": "NerdGraph is our GraphQL-format <em>API</em> that lets you query <em>New</em> <em>Relic</em> data and configure some <em>New</em> <em>Relic</em> features. Tip To use our <em>APIs</em>, or the <em>rest</em> of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data"
      },
      "id": "6043ff97196a67d0a0960f55"
    }
  ],
  "/docs/apis/rest-api-v2/account-examples-v2/listing-users-your-account": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.93135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic partnership <em>account</em> authentication",
        "sections": "New Relic partnership <em>account</em> authentication",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " <em>API</em> key, partner ID, and your <em>account</em> ID: X-<em>Api</em>-Key:YOUR_PARTNER_<em>ACCOUNT_API</em>_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-<em>Account</em>-Id:YOUR_CUSTOMERS_<em>ACCOUNT</em>_ID Providing authentication to the <em>REST</em> <em>API</em> (<em>v2</em>) in this form allows you to complete any <em>API</em> operation on your customer’s accounts"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.13792,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> Explorer. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "Use the API Explorer",
        "API key requirements",
        "Important",
        "Access the API Explorer"
      ],
      "title": "Use the API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "0af25c5683418b6c806b4ec2addad065fe569e07",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/use-api-explorer/",
      "published_at": "2021-07-02T08:41:54Z",
      "updated_at": "2021-06-20T03:51:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST API Explorer (v2) makes it easy to test and send requests for any available API endpoint. After you select your choice of functions for the type of API call (applications, browsers, etc.), the user interface provides an interactive form to view requirements and test your parameter values. It also provides a live source of documentation about the API values. API key requirements Before you can use the API Explorer, API access must be activated and an API key must be generated for your account. Important We recommend using the user key, not the REST API key, because the user key has fewer restrictions. Tips: If you're signed in to New Relic, when you use the API Explorer you can choose your API key at the top of the UI and that key will appear automatically in the Request and Parameters sections of the Explorer. If you're not signed in to New Relic, you can paste your API key into the API Explorer's Parameters. Access the API Explorer To use the New Relic API Explorer: Go to rpm.newrelic.com/api/explore. From the API Explorer's menu bar, select the account name for your app from the dropdown list. From the sidebar, select a product (Applications, Browsers, etc.) and an available API function: GET, PUT, DELETE. Type the other Parameters values for your API call. (Refer to the UI for descriptions and requirements for v2.) Select the format for your request: JSON or XML. Select Send Request.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.2208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use the <em>API</em> Explorer",
        "sections": "Use the <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "New Relic&#x27;s <em>REST</em> <em>API</em> Explorer (<em>v2</em>) makes it easy to test and send requests for any available <em>API</em> endpoint. After you select your choice of functions for the type of <em>API</em> call (applications, browsers, etc.), the user interface provides an interactive form to view requirements and test your parameter"
      },
      "id": "6043ffe528ccbcf8ca2c6069"
    }
  ],
  "/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer": [
    {
      "sections": [
        "Use the API Explorer",
        "API key requirements",
        "Important",
        "Access the API Explorer"
      ],
      "title": "Use the API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "0af25c5683418b6c806b4ec2addad065fe569e07",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/use-api-explorer/",
      "published_at": "2021-07-02T08:41:54Z",
      "updated_at": "2021-06-20T03:51:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST API Explorer (v2) makes it easy to test and send requests for any available API endpoint. After you select your choice of functions for the type of API call (applications, browsers, etc.), the user interface provides an interactive form to view requirements and test your parameter values. It also provides a live source of documentation about the API values. API key requirements Before you can use the API Explorer, API access must be activated and an API key must be generated for your account. Important We recommend using the user key, not the REST API key, because the user key has fewer restrictions. Tips: If you're signed in to New Relic, when you use the API Explorer you can choose your API key at the top of the UI and that key will appear automatically in the Request and Parameters sections of the Explorer. If you're not signed in to New Relic, you can paste your API key into the API Explorer's Parameters. Access the API Explorer To use the New Relic API Explorer: Go to rpm.newrelic.com/api/explore. From the API Explorer's menu bar, select the account name for your app from the dropdown list. From the sidebar, select a product (Applications, Browsers, etc.) and an available API function: GET, PUT, DELETE. Type the other Parameters values for your API call. (Refer to the UI for descriptions and requirements for v2.) Select the format for your request: JSON or XML. Select Send Request.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.29385,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use the <em>API</em> <em>Explorer</em>",
        "sections": "Use the <em>API</em> <em>Explorer</em>",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": "New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em> (<em>v2</em>) makes it easy to test and send requests for any available <em>API</em> endpoint. After you select your choice of functions for the type of <em>API</em> call (applications, browsers, etc.), the user interface provides an interactive form to view requirements and test your parameter"
      },
      "id": "6043ffe528ccbcf8ca2c6069"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2021-07-02T12:38:08Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.6996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    },
    {
      "sections": [
        "Get average CPU usage per host for an app",
        "Get CPU usage for a host",
        "Tip",
        "Get CPU usage for the entire app"
      ],
      "title": "Get average CPU usage per host for an app",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "d8301a66a2273586c11af5705b5201f0cf73d242",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-cpu-usage-host-app/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-13T02:39:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app's hosts, use a single command to obtain the metric names[]=CPU/User+Time with values[]=percent. This example shows the time range for the default time period (last 30 minutes): curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace the $HOST_ID with the host id of your target host. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields. Get CPU usage for the entire app To get the average CPU usage for your application, use a command similar to the one in the previous example but without the reference to the host_id: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Applications > GET Metric Data, and include your API key. Add your application ID, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.69177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app&#x27;s hosts, use a single"
      },
      "id": "604405bc196a6747d2960f3f"
    }
  ],
  "/docs/apis/rest-api-v2/api-explorer-v2/retrieve-metric-timeslice-data-your-app-explorer": [
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 271.3277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> <em>Explorer</em>. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "Use the API Explorer",
        "API key requirements",
        "Important",
        "Access the API Explorer"
      ],
      "title": "Use the API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "0af25c5683418b6c806b4ec2addad065fe569e07",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/use-api-explorer/",
      "published_at": "2021-07-02T08:41:54Z",
      "updated_at": "2021-06-20T03:51:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST API Explorer (v2) makes it easy to test and send requests for any available API endpoint. After you select your choice of functions for the type of API call (applications, browsers, etc.), the user interface provides an interactive form to view requirements and test your parameter values. It also provides a live source of documentation about the API values. API key requirements Before you can use the API Explorer, API access must be activated and an API key must be generated for your account. Important We recommend using the user key, not the REST API key, because the user key has fewer restrictions. Tips: If you're signed in to New Relic, when you use the API Explorer you can choose your API key at the top of the UI and that key will appear automatically in the Request and Parameters sections of the Explorer. If you're not signed in to New Relic, you can paste your API key into the API Explorer's Parameters. Access the API Explorer To use the New Relic API Explorer: Go to rpm.newrelic.com/api/explore. From the API Explorer's menu bar, select the account name for your app from the dropdown list. From the sidebar, select a product (Applications, Browsers, etc.) and an available API function: GET, PUT, DELETE. Type the other Parameters values for your API call. (Refer to the UI for descriptions and requirements for v2.) Select the format for your request: JSON or XML. Select Send Request.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.29382,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use the <em>API</em> <em>Explorer</em>",
        "sections": "Use the <em>API</em> <em>Explorer</em>",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": "New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em> (<em>v2</em>) makes it easy to test and send requests for any available <em>API</em> endpoint. After you select your choice of functions for the type of <em>API</em> call (applications, browsers, etc.), the user interface provides an interactive form to view requirements and test your parameter"
      },
      "id": "6043ffe528ccbcf8ca2c6069"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2021-07-02T12:38:08Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.6996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    }
  ],
  "/docs/apis/rest-api-v2/api-explorer-v2/use-api-explorer": [
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 271.3277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> <em>Explorer</em>. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2021-07-02T12:38:08Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.6996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    },
    {
      "sections": [
        "Get average CPU usage per host for an app",
        "Get CPU usage for a host",
        "Tip",
        "Get CPU usage for the entire app"
      ],
      "title": "Get average CPU usage per host for an app",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "d8301a66a2273586c11af5705b5201f0cf73d242",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-cpu-usage-host-app/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-13T02:39:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app's hosts, use a single command to obtain the metric names[]=CPU/User+Time with values[]=percent. This example shows the time range for the default time period (last 30 minutes): curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace the $HOST_ID with the host id of your target host. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields. Get CPU usage for the entire app To get the average CPU usage for your application, use a command similar to the one in the previous example but without the reference to the host_id: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Applications > GET Metric Data, and include your API key. Add your application ID, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.69176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app&#x27;s hosts, use a single"
      },
      "id": "604405bc196a6747d2960f3f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/application-error-rate-example-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/application-reporting-health-status-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/average-response-time-examples-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2021-07-02T12:38:08Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.51631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get host memory used for an <em>application</em>",
        "sections": "Get host memory used for an <em>application</em>",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your <em>application</em> on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-average-cpu-usage-host-app": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2021-07-02T12:38:08Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.51631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get host memory used for an <em>application</em>",
        "sections": "Get host memory used for an <em>application</em>",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your <em>application</em> on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-web-transaction-time-data-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2021-07-02T12:38:08Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.51631,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get host memory used for an <em>application</em>",
        "sections": "Get host memory used for an <em>application</em>",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your <em>application</em> on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/list-your-app-id-metric-timeslice-data-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)",
        "For more help"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2021-07-02T12:38:07Z",
      "updated_at": "2021-03-16T08:13:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.56523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "List an app's host IDs and instance IDs",
        "List current IDs by application name",
        "List current IDs by application ID",
        "List current IDs for all applications",
        "Example host ID and instance ID lists"
      ],
      "title": "List an app's host IDs and instance IDs",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "0c646e1047e58f0296ad791b965b314fd1ed9554",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids/",
      "published_at": "2021-07-02T12:39:04Z",
      "updated_at": "2021-03-13T07:32:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to get the list of instance IDs and host IDs for an application. The list shows any that have reported for approximately the last hour. List current IDs by application name You can also use the REST API Explorer's Applications > List to list the ID details. Enter the correct application name. To list all the instance and host IDs reporting in the last hour with an application name containing ${APP_NAME}, use the following command. This provides the current Summary data followed by the ID lists for instances and hosts for the applications with ${APP_NAME} in their name, in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[name]=${APP_NAME}\" Copy List current IDs by application ID You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. To list all the IDs reporting in the last hour when you know the application's ${APP_ID}, use this command: curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i Copy You can also use filter[id]: curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d \"filter[id]=${APP_ID}\" Copy List current IDs for all applications You can also use the REST API Explorer's Applications > List or Applications > List to list the ID details. Enter the correct application name. For all the applications, list all the instance IDs and host IDs reporting in the last hour by using the following command. This provides the current summary data followed by the ID lists for instances and hosts for all the applications in the account associated with the ${API_KEY}. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H \"X-Api-Key:${API_KEY}\" -i Copy Example host ID and instance ID lists Here is an example of how the lists of IDs appear in JSON format: ... }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ... Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.536,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "List current IDs by <em>application</em> name",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the list of instance IDs and host IDs for an <em>application</em>. The list shows any that have reported for approximately the last hour. List current IDs by <em>application</em> name You can also use the <em>REST</em> <em>API</em> Explorer&#x27;s Applications &gt; List"
      },
      "id": "604405fee7b9d26edb5799c4"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/api-overload-protection-handling-429-errors": [
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2021-07-02T09:19:50Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.71696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    },
    {
      "sections": [
        "Pagination for API output",
        "Requirements and limitations",
        "Important",
        "Request a specific page",
        "Link header examples showing page count",
        "Tip",
        "Example: Return 3 pages"
      ],
      "title": "Pagination for API output",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "e53248f738396172abad2740144738488b9f1c1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/pagination-api-output/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-03-13T05:36:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic REST API (v2) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination is no longer available for metrics output for some customers (deprecation beginning December 2020). Returns up to 3000 results per cell. For large outputs, we recommend narrowing the query using application ID or another attribute. The sort order for returned data is indeterminate. Do not assume or rely on a particular order. The data returned per page depends on what data is requested. The number of pages depends on the number of JSON objects necessary to complete the list. Important Before listing metric names, see Metric name listing guidelines. Request a specific page To specify a page, add the page= parameter to the query. Here's an example: curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json?page=3' \\ -H 'Api-Key:$API_KEY' -i Copy In the REST API Explorer, you can quickly change the page being viewed. Link header examples showing page count The API call returns the Link header if the data is paginated. This indicates the number of pages and the page being viewed. This line also appears at the top of the Response in the REST API Explorer. Important The Link header will only appear if the output data is paginated. Tip The rel=\"last\" reference will not be shown when making calls to the Violations endpoint (https://api.newrelic.com/v2/alerts_violations.json). To determine the final page when making calls to this endpoint, look for the absence of a rel=\"next\" reference. To obtain this line using some implementations of curl, you may need to include the -v option. curl -v -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/...' Copy New Relic uses the RFC 5988 standard format for links. Example: Return 3 pages The API output will contain a Link line similar to this. Lines are wrapped to improve readability. Link: <https://api.newrelic.com/v2/alert_policies.xml?page=2>;rel=\"next\", <https://api.newrelic.com/v2/alert_policies.xml?page=3>;rel=\"last\" Copy This indicates there are three pages and you are viewing the first one. Parameter Description ...page=2>;rel=\"next\" Page 2 is the next page ...page=3>;rel=\"last\" Page 3 is the last page",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.71571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Pagination for <em>API</em> output",
        "sections": "Pagination for <em>API</em> output",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "The New Relic <em>REST</em> <em>API</em> (<em>v2</em>) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination"
      },
      "id": "604406cf28ccbce7b02c60ab"
    },
    {
      "sections": [
        "Specify a time range (v2)",
        "Change the default 30 minute time range",
        "Tip",
        "Offset UTC",
        "This API call shows a time zone east of UTC by 2 hours (-02:00)",
        "This API call shows a time zone west of UTC by +8 hours (%2B08:00)"
      ],
      "title": "Specify a time range (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "77aec38cd1f565f3a461cfd9401f337cda0936b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/specify-time-range-v2/",
      "published_at": "2021-07-02T08:51:09Z",
      "updated_at": "2021-03-16T08:14:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can specify a time range for the data to be returned in a New Relic REST API call. You can also request to return an average over the time range instead of the series of values returned by default. Change the default 30 minute time range The default time range for an API call is the last 30 minutes. To modify the time range, include from= and optional to= values. (To end the time range at the current time, omit to=.) Tip Data availability is subject to the data retention policy for your subscription level. Example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00+00:00&to=2014-08-11T15:12:00+00:00' Copy The time period returned for each data point depends on the time range you specify. To modify the time period, include the period parameter in your query. If you are using the New Relic REST API Explorer (v2), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Offset UTC By default the API time input uses Universal Time Coordinated (UTC). To offset the UTC, use plus or minus 00:00 in your API call. This allows you to input times in a different time zone; however, this does not modify the output times, which are always UTC. For time zones east of UTC, use a minus sign (-). This symbol has no special meaning in HTTP or HTTPS requests. For time zones west of UTC, use the encoded value %2B to indicate a plus sign (+). If you have an EU region account, the following URLs begin with https://api.eu.newrelic.com. This API call shows a time zone east of UTC by 2 hours (-02:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 -02:00 &to=2014-08-11T15:12:00 -02:00 ' Copy This API call shows a time zone west of UTC by +8 hours (%2B08:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 %2B08:00 &to=2014-08-11T15:12:00 %2B08:00 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify a time range (<em>v2</em>)",
        "sections": "This <em>API</em> call shows a time zone east of UTC by <em>2</em> hours (-02:00)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". If you are using the New Relic <em>REST</em> <em>API</em> Explorer (<em>v2</em>), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https:&#x2F;&#x2F;<em>api</em>.eu.newrelic.com. Offset UTC By default the <em>API</em> time input uses Universal Time Coordinated (UTC). To offset the UTC, use"
      },
      "id": "603ece55196a67561ba83dc2"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/calculate-average-metric-values-summarize": [
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2021-07-02T09:19:50Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.71696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    },
    {
      "sections": [
        "Pagination for API output",
        "Requirements and limitations",
        "Important",
        "Request a specific page",
        "Link header examples showing page count",
        "Tip",
        "Example: Return 3 pages"
      ],
      "title": "Pagination for API output",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "e53248f738396172abad2740144738488b9f1c1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/pagination-api-output/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-03-13T05:36:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic REST API (v2) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination is no longer available for metrics output for some customers (deprecation beginning December 2020). Returns up to 3000 results per cell. For large outputs, we recommend narrowing the query using application ID or another attribute. The sort order for returned data is indeterminate. Do not assume or rely on a particular order. The data returned per page depends on what data is requested. The number of pages depends on the number of JSON objects necessary to complete the list. Important Before listing metric names, see Metric name listing guidelines. Request a specific page To specify a page, add the page= parameter to the query. Here's an example: curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json?page=3' \\ -H 'Api-Key:$API_KEY' -i Copy In the REST API Explorer, you can quickly change the page being viewed. Link header examples showing page count The API call returns the Link header if the data is paginated. This indicates the number of pages and the page being viewed. This line also appears at the top of the Response in the REST API Explorer. Important The Link header will only appear if the output data is paginated. Tip The rel=\"last\" reference will not be shown when making calls to the Violations endpoint (https://api.newrelic.com/v2/alerts_violations.json). To determine the final page when making calls to this endpoint, look for the absence of a rel=\"next\" reference. To obtain this line using some implementations of curl, you may need to include the -v option. curl -v -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/...' Copy New Relic uses the RFC 5988 standard format for links. Example: Return 3 pages The API output will contain a Link line similar to this. Lines are wrapped to improve readability. Link: <https://api.newrelic.com/v2/alert_policies.xml?page=2>;rel=\"next\", <https://api.newrelic.com/v2/alert_policies.xml?page=3>;rel=\"last\" Copy This indicates there are three pages and you are viewing the first one. Parameter Description ...page=2>;rel=\"next\" Page 2 is the next page ...page=3>;rel=\"last\" Page 3 is the last page",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.71571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Pagination for <em>API</em> output",
        "sections": "Pagination for <em>API</em> output",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "The New Relic <em>REST</em> <em>API</em> (<em>v2</em>) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination"
      },
      "id": "604406cf28ccbce7b02c60ab"
    },
    {
      "sections": [
        "Specify a time range (v2)",
        "Change the default 30 minute time range",
        "Tip",
        "Offset UTC",
        "This API call shows a time zone east of UTC by 2 hours (-02:00)",
        "This API call shows a time zone west of UTC by +8 hours (%2B08:00)"
      ],
      "title": "Specify a time range (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "77aec38cd1f565f3a461cfd9401f337cda0936b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/specify-time-range-v2/",
      "published_at": "2021-07-02T08:51:09Z",
      "updated_at": "2021-03-16T08:14:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can specify a time range for the data to be returned in a New Relic REST API call. You can also request to return an average over the time range instead of the series of values returned by default. Change the default 30 minute time range The default time range for an API call is the last 30 minutes. To modify the time range, include from= and optional to= values. (To end the time range at the current time, omit to=.) Tip Data availability is subject to the data retention policy for your subscription level. Example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00+00:00&to=2014-08-11T15:12:00+00:00' Copy The time period returned for each data point depends on the time range you specify. To modify the time period, include the period parameter in your query. If you are using the New Relic REST API Explorer (v2), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Offset UTC By default the API time input uses Universal Time Coordinated (UTC). To offset the UTC, use plus or minus 00:00 in your API call. This allows you to input times in a different time zone; however, this does not modify the output times, which are always UTC. For time zones east of UTC, use a minus sign (-). This symbol has no special meaning in HTTP or HTTPS requests. For time zones west of UTC, use the encoded value %2B to indicate a plus sign (+). If you have an EU region account, the following URLs begin with https://api.eu.newrelic.com. This API call shows a time zone east of UTC by 2 hours (-02:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 -02:00 &to=2014-08-11T15:12:00 -02:00 ' Copy This API call shows a time zone west of UTC by +8 hours (%2B08:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 %2B08:00 &to=2014-08-11T15:12:00 %2B08:00 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify a time range (<em>v2</em>)",
        "sections": "This <em>API</em> call shows a time zone east of UTC by <em>2</em> hours (-02:00)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". If you are using the New Relic <em>REST</em> <em>API</em> Explorer (<em>v2</em>), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https:&#x2F;&#x2F;<em>api</em>.eu.newrelic.com. Offset UTC By default the <em>API</em> time input uses Universal Time Coordinated (UTC). To offset the UTC, use"
      },
      "id": "603ece55196a67561ba83dc2"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/extract-metric-timeslice-data": [
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2021-07-02T09:19:50Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.71696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    },
    {
      "sections": [
        "Pagination for API output",
        "Requirements and limitations",
        "Important",
        "Request a specific page",
        "Link header examples showing page count",
        "Tip",
        "Example: Return 3 pages"
      ],
      "title": "Pagination for API output",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "e53248f738396172abad2740144738488b9f1c1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/pagination-api-output/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-03-13T05:36:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic REST API (v2) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination is no longer available for metrics output for some customers (deprecation beginning December 2020). Returns up to 3000 results per cell. For large outputs, we recommend narrowing the query using application ID or another attribute. The sort order for returned data is indeterminate. Do not assume or rely on a particular order. The data returned per page depends on what data is requested. The number of pages depends on the number of JSON objects necessary to complete the list. Important Before listing metric names, see Metric name listing guidelines. Request a specific page To specify a page, add the page= parameter to the query. Here's an example: curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json?page=3' \\ -H 'Api-Key:$API_KEY' -i Copy In the REST API Explorer, you can quickly change the page being viewed. Link header examples showing page count The API call returns the Link header if the data is paginated. This indicates the number of pages and the page being viewed. This line also appears at the top of the Response in the REST API Explorer. Important The Link header will only appear if the output data is paginated. Tip The rel=\"last\" reference will not be shown when making calls to the Violations endpoint (https://api.newrelic.com/v2/alerts_violations.json). To determine the final page when making calls to this endpoint, look for the absence of a rel=\"next\" reference. To obtain this line using some implementations of curl, you may need to include the -v option. curl -v -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/...' Copy New Relic uses the RFC 5988 standard format for links. Example: Return 3 pages The API output will contain a Link line similar to this. Lines are wrapped to improve readability. Link: <https://api.newrelic.com/v2/alert_policies.xml?page=2>;rel=\"next\", <https://api.newrelic.com/v2/alert_policies.xml?page=3>;rel=\"last\" Copy This indicates there are three pages and you are viewing the first one. Parameter Description ...page=2>;rel=\"next\" Page 2 is the next page ...page=3>;rel=\"last\" Page 3 is the last page",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.71571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Pagination for <em>API</em> output",
        "sections": "Pagination for <em>API</em> output",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "The New Relic <em>REST</em> <em>API</em> (<em>v2</em>) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination"
      },
      "id": "604406cf28ccbce7b02c60ab"
    },
    {
      "sections": [
        "Specify a time range (v2)",
        "Change the default 30 minute time range",
        "Tip",
        "Offset UTC",
        "This API call shows a time zone east of UTC by 2 hours (-02:00)",
        "This API call shows a time zone west of UTC by +8 hours (%2B08:00)"
      ],
      "title": "Specify a time range (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "77aec38cd1f565f3a461cfd9401f337cda0936b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/specify-time-range-v2/",
      "published_at": "2021-07-02T08:51:09Z",
      "updated_at": "2021-03-16T08:14:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can specify a time range for the data to be returned in a New Relic REST API call. You can also request to return an average over the time range instead of the series of values returned by default. Change the default 30 minute time range The default time range for an API call is the last 30 minutes. To modify the time range, include from= and optional to= values. (To end the time range at the current time, omit to=.) Tip Data availability is subject to the data retention policy for your subscription level. Example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00+00:00&to=2014-08-11T15:12:00+00:00' Copy The time period returned for each data point depends on the time range you specify. To modify the time period, include the period parameter in your query. If you are using the New Relic REST API Explorer (v2), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Offset UTC By default the API time input uses Universal Time Coordinated (UTC). To offset the UTC, use plus or minus 00:00 in your API call. This allows you to input times in a different time zone; however, this does not modify the output times, which are always UTC. For time zones east of UTC, use a minus sign (-). This symbol has no special meaning in HTTP or HTTPS requests. For time zones west of UTC, use the encoded value %2B to indicate a plus sign (+). If you have an EU region account, the following URLs begin with https://api.eu.newrelic.com. This API call shows a time zone east of UTC by 2 hours (-02:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 -02:00 &to=2014-08-11T15:12:00 -02:00 ' Copy This API call shows a time zone west of UTC by +8 hours (%2B08:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 %2B08:00 &to=2014-08-11T15:12:00 %2B08:00 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify a time range (<em>v2</em>)",
        "sections": "This <em>API</em> call shows a time zone east of UTC by <em>2</em> hours (-02:00)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". If you are using the New Relic <em>REST</em> <em>API</em> Explorer (<em>v2</em>), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https:&#x2F;&#x2F;<em>api</em>.eu.newrelic.com. Offset UTC By default the <em>API</em> time input uses Universal Time Coordinated (UTC). To offset the UTC, use"
      },
      "id": "603ece55196a67561ba83dc2"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/pagination-api-output": [
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2021-07-02T09:19:50Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.71696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    },
    {
      "sections": [
        "Specify a time range (v2)",
        "Change the default 30 minute time range",
        "Tip",
        "Offset UTC",
        "This API call shows a time zone east of UTC by 2 hours (-02:00)",
        "This API call shows a time zone west of UTC by +8 hours (%2B08:00)"
      ],
      "title": "Specify a time range (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "77aec38cd1f565f3a461cfd9401f337cda0936b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/specify-time-range-v2/",
      "published_at": "2021-07-02T08:51:09Z",
      "updated_at": "2021-03-16T08:14:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can specify a time range for the data to be returned in a New Relic REST API call. You can also request to return an average over the time range instead of the series of values returned by default. Change the default 30 minute time range The default time range for an API call is the last 30 minutes. To modify the time range, include from= and optional to= values. (To end the time range at the current time, omit to=.) Tip Data availability is subject to the data retention policy for your subscription level. Example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00+00:00&to=2014-08-11T15:12:00+00:00' Copy The time period returned for each data point depends on the time range you specify. To modify the time period, include the period parameter in your query. If you are using the New Relic REST API Explorer (v2), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Offset UTC By default the API time input uses Universal Time Coordinated (UTC). To offset the UTC, use plus or minus 00:00 in your API call. This allows you to input times in a different time zone; however, this does not modify the output times, which are always UTC. For time zones east of UTC, use a minus sign (-). This symbol has no special meaning in HTTP or HTTPS requests. For time zones west of UTC, use the encoded value %2B to indicate a plus sign (+). If you have an EU region account, the following URLs begin with https://api.eu.newrelic.com. This API call shows a time zone east of UTC by 2 hours (-02:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 -02:00 &to=2014-08-11T15:12:00 -02:00 ' Copy This API call shows a time zone west of UTC by +8 hours (%2B08:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 %2B08:00 &to=2014-08-11T15:12:00 %2B08:00 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify a time range (<em>v2</em>)",
        "sections": "This <em>API</em> call shows a time zone east of UTC by <em>2</em> hours (-02:00)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". If you are using the New Relic <em>REST</em> <em>API</em> Explorer (<em>v2</em>), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https:&#x2F;&#x2F;<em>api</em>.eu.newrelic.com. Offset UTC By default the <em>API</em> time input uses Universal Time Coordinated (UTC). To offset the UTC, use"
      },
      "id": "603ece55196a67561ba83dc2"
    },
    {
      "sections": [
        "Calculate average metric values (summarize)",
        "Tip"
      ],
      "title": "Calculate average metric values (summarize)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "d230a1e1af23ddfdfe0acabdd1308be55c2b1cfe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/calculate-average-metric-values-summarize/",
      "published_at": "2021-07-02T08:35:59Z",
      "updated_at": "2021-03-16T07:09:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, New Relic REST API calls return a series of metric data values based on time range restrictions. To obtain the average of these values, include &summarize=true in your API call. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APPID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00%2B08:00&to=2014-08-11T15:12:00%2B08:00&summarize=true' Copy If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Tip To prevent summarizing data, omit summarize in your API call. You do not need to specify &summarize=false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Calculate average metric <em>values</em> (summarize)",
        "sections": "Calculate average metric <em>values</em> (summarize)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "By default, New Relic <em>REST</em> <em>API</em> calls return a series of metric data values based on time range restrictions. To obtain the average of these values, include &amp;summarize=true in your <em>API</em> call. For example: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APPID&#x2F;metrics&#x2F;data.json&quot; \\ -H &quot;<em>Api</em>-Key"
      },
      "id": "603ed423e7b9d2e4032a07b9"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent": [
    {
      "sections": [
        "Pagination for API output",
        "Requirements and limitations",
        "Important",
        "Request a specific page",
        "Link header examples showing page count",
        "Tip",
        "Example: Return 3 pages"
      ],
      "title": "Pagination for API output",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "e53248f738396172abad2740144738488b9f1c1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/pagination-api-output/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-03-13T05:36:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic REST API (v2) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination is no longer available for metrics output for some customers (deprecation beginning December 2020). Returns up to 3000 results per cell. For large outputs, we recommend narrowing the query using application ID or another attribute. The sort order for returned data is indeterminate. Do not assume or rely on a particular order. The data returned per page depends on what data is requested. The number of pages depends on the number of JSON objects necessary to complete the list. Important Before listing metric names, see Metric name listing guidelines. Request a specific page To specify a page, add the page= parameter to the query. Here's an example: curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json?page=3' \\ -H 'Api-Key:$API_KEY' -i Copy In the REST API Explorer, you can quickly change the page being viewed. Link header examples showing page count The API call returns the Link header if the data is paginated. This indicates the number of pages and the page being viewed. This line also appears at the top of the Response in the REST API Explorer. Important The Link header will only appear if the output data is paginated. Tip The rel=\"last\" reference will not be shown when making calls to the Violations endpoint (https://api.newrelic.com/v2/alerts_violations.json). To determine the final page when making calls to this endpoint, look for the absence of a rel=\"next\" reference. To obtain this line using some implementations of curl, you may need to include the -v option. curl -v -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/...' Copy New Relic uses the RFC 5988 standard format for links. Example: Return 3 pages The API output will contain a Link line similar to this. Lines are wrapped to improve readability. Link: <https://api.newrelic.com/v2/alert_policies.xml?page=2>;rel=\"next\", <https://api.newrelic.com/v2/alert_policies.xml?page=3>;rel=\"last\" Copy This indicates there are three pages and you are viewing the first one. Parameter Description ...page=2>;rel=\"next\" Page 2 is the next page ...page=3>;rel=\"last\" Page 3 is the last page",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.71571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Pagination for <em>API</em> output",
        "sections": "Pagination for <em>API</em> output",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "The New Relic <em>REST</em> <em>API</em> (<em>v2</em>) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination"
      },
      "id": "604406cf28ccbce7b02c60ab"
    },
    {
      "sections": [
        "Specify a time range (v2)",
        "Change the default 30 minute time range",
        "Tip",
        "Offset UTC",
        "This API call shows a time zone east of UTC by 2 hours (-02:00)",
        "This API call shows a time zone west of UTC by +8 hours (%2B08:00)"
      ],
      "title": "Specify a time range (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "77aec38cd1f565f3a461cfd9401f337cda0936b5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/specify-time-range-v2/",
      "published_at": "2021-07-02T08:51:09Z",
      "updated_at": "2021-03-16T08:14:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can specify a time range for the data to be returned in a New Relic REST API call. You can also request to return an average over the time range instead of the series of values returned by default. Change the default 30 minute time range The default time range for an API call is the last 30 minutes. To modify the time range, include from= and optional to= values. (To end the time range at the current time, omit to=.) Tip Data availability is subject to the data retention policy for your subscription level. Example: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00+00:00&to=2014-08-11T15:12:00+00:00' Copy The time period returned for each data point depends on the time range you specify. To modify the time period, include the period parameter in your query. If you are using the New Relic REST API Explorer (v2), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Offset UTC By default the API time input uses Universal Time Coordinated (UTC). To offset the UTC, use plus or minus 00:00 in your API call. This allows you to input times in a different time zone; however, this does not modify the output times, which are always UTC. For time zones east of UTC, use a minus sign (-). This symbol has no special meaning in HTTP or HTTPS requests. For time zones west of UTC, use the encoded value %2B to indicate a plus sign (+). If you have an EU region account, the following URLs begin with https://api.eu.newrelic.com. This API call shows a time zone east of UTC by 2 hours (-02:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 -02:00 &to=2014-08-11T15:12:00 -02:00 ' Copy This API call shows a time zone west of UTC by +8 hours (%2B08:00) curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00 %2B08:00 &to=2014-08-11T15:12:00 %2B08:00 Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify a time range (<em>v2</em>)",
        "sections": "This <em>API</em> call shows a time zone east of UTC by <em>2</em> hours (-02:00)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". If you are using the New Relic <em>REST</em> <em>API</em> Explorer (<em>v2</em>), you can use the diamond icon to select time ranges. If you have an EU region account, the above URL begins with https:&#x2F;&#x2F;<em>api</em>.eu.newrelic.com. Offset UTC By default the <em>API</em> time input uses Universal Time Coordinated (UTC). To offset the UTC, use"
      },
      "id": "603ece55196a67561ba83dc2"
    },
    {
      "sections": [
        "Calculate average metric values (summarize)",
        "Tip"
      ],
      "title": "Calculate average metric values (summarize)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "d230a1e1af23ddfdfe0acabdd1308be55c2b1cfe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/calculate-average-metric-values-summarize/",
      "published_at": "2021-07-02T08:35:59Z",
      "updated_at": "2021-03-16T07:09:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, New Relic REST API calls return a series of metric data values based on time range restrictions. To obtain the average of these values, include &summarize=true in your API call. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APPID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00%2B08:00&to=2014-08-11T15:12:00%2B08:00&summarize=true' Copy If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Tip To prevent summarizing data, omit summarize in your API call. You do not need to specify &summarize=false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Calculate average metric <em>values</em> (summarize)",
        "sections": "Calculate average metric <em>values</em> (summarize)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "By default, New Relic <em>REST</em> <em>API</em> calls return a series of metric data values based on time range restrictions. To obtain the average of these values, include &amp;summarize=true in your <em>API</em> call. For example: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APPID&#x2F;metrics&#x2F;data.json&quot; \\ -H &quot;<em>Api</em>-Key"
      },
      "id": "603ed423e7b9d2e4032a07b9"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/specify-time-range-v2": [
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2021-07-02T09:19:50Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.71696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    },
    {
      "sections": [
        "Pagination for API output",
        "Requirements and limitations",
        "Important",
        "Request a specific page",
        "Link header examples showing page count",
        "Tip",
        "Example: Return 3 pages"
      ],
      "title": "Pagination for API output",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "e53248f738396172abad2740144738488b9f1c1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/pagination-api-output/",
      "published_at": "2021-07-02T08:51:08Z",
      "updated_at": "2021-03-13T05:36:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic REST API (v2) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination is no longer available for metrics output for some customers (deprecation beginning December 2020). Returns up to 3000 results per cell. For large outputs, we recommend narrowing the query using application ID or another attribute. The sort order for returned data is indeterminate. Do not assume or rely on a particular order. The data returned per page depends on what data is requested. The number of pages depends on the number of JSON objects necessary to complete the list. Important Before listing metric names, see Metric name listing guidelines. Request a specific page To specify a page, add the page= parameter to the query. Here's an example: curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json?page=3' \\ -H 'Api-Key:$API_KEY' -i Copy In the REST API Explorer, you can quickly change the page being viewed. Link header examples showing page count The API call returns the Link header if the data is paginated. This indicates the number of pages and the page being viewed. This line also appears at the top of the Response in the REST API Explorer. Important The Link header will only appear if the output data is paginated. Tip The rel=\"last\" reference will not be shown when making calls to the Violations endpoint (https://api.newrelic.com/v2/alerts_violations.json). To determine the final page when making calls to this endpoint, look for the absence of a rel=\"next\" reference. To obtain this line using some implementations of curl, you may need to include the -v option. curl -v -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/...' Copy New Relic uses the RFC 5988 standard format for links. Example: Return 3 pages The API output will contain a Link line similar to this. Lines are wrapped to improve readability. Link: <https://api.newrelic.com/v2/alert_policies.xml?page=2>;rel=\"next\", <https://api.newrelic.com/v2/alert_policies.xml?page=3>;rel=\"last\" Copy This indicates there are three pages and you are viewing the first one. Parameter Description ...page=2>;rel=\"next\" Page 2 is the next page ...page=3>;rel=\"last\" Page 3 is the last page",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 175.71571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Pagination for <em>API</em> output",
        "sections": "Pagination for <em>API</em> output",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "The New Relic <em>REST</em> <em>API</em> (<em>v2</em>) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination"
      },
      "id": "604406cf28ccbce7b02c60ab"
    },
    {
      "sections": [
        "Calculate average metric values (summarize)",
        "Tip"
      ],
      "title": "Calculate average metric values (summarize)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "d230a1e1af23ddfdfe0acabdd1308be55c2b1cfe",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/calculate-average-metric-values-summarize/",
      "published_at": "2021-07-02T08:35:59Z",
      "updated_at": "2021-03-16T07:09:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, New Relic REST API calls return a series of metric data values based on time range restrictions. To obtain the average of these values, include &summarize=true in your API call. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APPID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Agent/MetricsReported/count&from=2014-08-11T14:42:00%2B08:00&to=2014-08-11T15:12:00%2B08:00&summarize=true' Copy If you have an EU region account, the above URL begins with https://api.eu.newrelic.com. Tip To prevent summarizing data, omit summarize in your API call. You do not need to specify &summarize=false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.51321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Calculate average metric <em>values</em> (summarize)",
        "sections": "Calculate average metric <em>values</em> (summarize)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "By default, New Relic <em>REST</em> <em>API</em> calls return a series of metric data values based on time range restrictions. To obtain the average of these values, include &amp;summarize=true in your <em>API</em> call. For example: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APPID&#x2F;metrics&#x2F;data.json&quot; \\ -H &quot;<em>Api</em>-Key"
      },
      "id": "603ed423e7b9d2e4032a07b9"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2": [
    {
      "sections": [
        "Average browser page load time example (v2)",
        "Average page load time"
      ],
      "title": "Average browser page load time example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "2e2669a368831880e962cdbd39d95d31a98aa253",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-page-load-time-example-v2/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:36:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser page load time (or response time) appears at the top right of the main chart of your Summary page. This value is labeled Browser and shows the average page load time in seconds. Average page load time To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_response_time&summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.85,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> page load time <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> page load time <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&quot; \\ -H &quot;X-<em>Api</em>-Key:${<em>API</em>_KEY}&quot; -i \\ -d &#x27;names[]=EndUser&amp;values[]=average_response_time&amp;summarize=true&#x27; Copy"
      },
      "id": "604406cf196a670c98960f55"
    },
    {
      "sections": [
        "Obtaining Browser (end user) page load time data (v2)",
        "General API values",
        "Network time",
        "Page rendering time",
        "DOM processing time",
        "Web application time",
        "Request queuing time"
      ],
      "title": "Obtaining Browser (end user) page load time data (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "c0c497cf900d84a9e57a07aba5062003e86506a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/obtaining-browser-end-user-page-load-time-data-v2/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The metric timeslice data presented on the Browser page load time chart on your application's Summary page will depend on your web app's configuration. Possible components may include: Network time Page rendering time DOM processing time Web application time Request queuing time This describes how to use the New Relic REST API (v2) to obtain the data shown on the Browser page load time chart. General API values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these examples. For calculated values, the time range you specify must be consistent in all of the queries; otherwise the final calculations will be incorrect. You must replace the ${APPID} and ${API_KEY} variables in these examples with your specific application ID and corresponding REST API key. Ensure you adjust the time units returned by the API requests as needed. Network time The EndUser:average_network_time is the network latency, or time it takes for a request to make a round trip over the Internet. Use the following command to obtain this. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_network_time' Copy This time is returned in milliseconds. Page rendering time Page rendering time is a derived value. To calculate it, use this equation: \"Page rendering\" time = EndUser:average_fe_response_time - EndUser/RB:average_dom_content_load_time Copy To obtain the data for this calculation, use the following commands. EndUser:average_fe_response_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_fe_response_time' Copy This time is returned in milliseconds. EndUser/RB:average_dom_content_load_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. DOM processing time The EndUser/RB:average_dom_content_load_time is the time spent in the browser to parse and interpret the HTML. This is measured by the browser's DOM Content event. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. Web application time The Web application time is the time spent in the application code. To calculate this value, use this equation: Web application = EndUser:total_app_time / EndUser:call_count Copy To obtain the data for this calculation, use the following commands. EndUser:total_app_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=total_app_time' Copy This time is returned in seconds. EndUser:call_count curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=call_count' Copy Request queuing time The EndUser/RB:average_queue_time is the wait time between the web server and the application code. Large numbers indicate a busy application server. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_queue_time' Copy This time is returned in milliseconds. The request queuing time is not included in the calculation of averages. New Relic includes it in this chart as a convenience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.65744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Obtaining <em>Browser</em> (end user) page load time data (<em>v2</em>)",
        "sections": "Obtaining <em>Browser</em> (end user) page load time data (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the data shown on the <em>Browser</em> page load time chart. General <em>API</em> values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these <em>examples</em>. For calculated values, the time range you"
      },
      "id": "6044070de7b9d2b9f7579a16"
    },
    {
      "sections": [
        "Average browser (end user) page throughput example (v2)",
        "Average page throughput",
        "For more help"
      ],
      "title": "Average browser (end user) page throughput example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "713534d353c7a66e7c02ec00f7d5340dab172740",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2/",
      "published_at": "2021-07-02T08:52:37Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser throughput appears at the top right of the Throughput by browser chart on your Summary page. This is the average pages per minute (PPM) by browser type in the time range shown on the chart. Average page throughput To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET 'https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json' \\ -H 'X-Api-Key:${API_KEY}' -i \\ -d 'names[]=EndUser&values[]=requests_per_minute&summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.65744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " minutes), use the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&#x27; \\ -H &#x27;X-<em>Api</em>-Key:${<em>API</em>_KEY}&#x27; -i \\ -d &#x27;names[]=EndUser&amp;values[]=requests_per_minute&amp;summarize=true&#x27; Copy For more help"
      },
      "id": "604406cf28ccbc10652c6091"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2": [
    {
      "sections": [
        "Add or list Browser apps via API (v2)",
        "Important",
        "Add browser apps",
        "List all browser apps",
        "View specific browser apps"
      ],
      "title": "Add or list Browser apps via API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "53568984e3b360bac9255a33adad7e6b43fadf5d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2/",
      "published_at": "2021-07-02T08:52:34Z",
      "updated_at": "2021-06-14T23:01:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to add apps to browser monitoring or to get a list of your browser apps for a specific API key. This helps you manage deployment outside of New Relic One. These API calls are useful, for example, with larger organizations deploying multiple apps, or for integration partners who facilitate New Relic account creation and browser monitoring deployments. Important When you add a browser app via API (v2), you can only instrument basic page load timing. To use instrumentation supporting all SPA features, see Use Browser SPA agent. To add a fully instrumented app, go to one.newrelic.com, and click the Add more data button on the top right hand-side. Then, use the guided install to start monitoring your app. Add browser apps To add an app to New Relic One, replace ${APIKEY} with your New Relic API key, and replace ${STRING} with the app's name in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > POST Create. Use the following command: curl -X POST 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i -H 'Content-Type: application/json' \\ -d \\ '{ \"browser_application\": { \"name\": ${STRING} } }' Copy The API returns an array of data where the element is a Browser application and the data associated with it: { \"browser_application\": { \"id\": \"integer\", \"name\": \"string\", \"browser_monitoring_key\": \"string\", \"loader_script\": \"string\" } Copy API (v2) output Description Browser app id (integer) This is the unique identification code for each app in New Relic One. App name (string) This is the app's name as it appears in the New Relic One. The browser_monitoring_key (string) This a unique key that is linked to (but is not the same as) the account license key. It is used to indicate the account in New Relic One where data will be reported. It cannot be used to determine your New Relic account's license key. Browser monitoring loader_script (string) The returned loader script is a JSON-encoded JavaScript snippet that is configured with the New Relic license key and application ID. The rest of the script is static and is approximately 10k in size. The loader script must be inserted into the user’s HTML pages correctly: It must appear in the page's <head> tag before the first script tag. If there are no script tags, put the JavaScript immediately before the </head> (end of head) tag. The entire loader script must be inserted in-line, not as a link to the .js file. List all browser apps To view a list of your apps in New Relic Browser, replace ${APIKEY} with your New Relic API key in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > GET List. Use the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can use the results to verify the account or name, and to get a copy of the loader script for the app, if needed. View specific browser apps View by name: To view a specific Browser app if you know its name, replace ${APIKEY} with your New Relic API key, and replace ${NAME} with your app's name in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${NAME}\" Copy View by Browser application ID: To view a specific Browser app if you know its ID, replace ${APIKEY} with your New Relic API key, and replace ${ID} with your Browser application ID in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[ids]=${ID}' Copy View multiple browser apps: To get information for multiple apps, separate the name or ID values with a comma in these commands; for example: -d 'filter[ids]=12345,23456' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.75551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add or list <em>Browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "sections": "Add or list <em>Browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to add apps to <em>browser</em> monitoring or to get a list of your <em>browser</em> apps for a specific <em>API</em> key. This helps you manage deployment outside of New Relic One. These <em>API</em> calls are useful, for example, with larger organizations deploying"
      },
      "id": "603ed6a928ccbc422beba77b"
    },
    {
      "sections": [
        "Average browser page load time example (v2)",
        "Average page load time"
      ],
      "title": "Average browser page load time example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "2e2669a368831880e962cdbd39d95d31a98aa253",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-page-load-time-example-v2/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:36:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser page load time (or response time) appears at the top right of the main chart of your Summary page. This value is labeled Browser and shows the average page load time in seconds. Average page load time To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_response_time&summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.85,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> page load time <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> page load time <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&quot; \\ -H &quot;X-<em>Api</em>-Key:${<em>API</em>_KEY}&quot; -i \\ -d &#x27;names[]=EndUser&amp;values[]=average_response_time&amp;summarize=true&#x27; Copy"
      },
      "id": "604406cf196a670c98960f55"
    },
    {
      "sections": [
        "Obtaining Browser (end user) page load time data (v2)",
        "General API values",
        "Network time",
        "Page rendering time",
        "DOM processing time",
        "Web application time",
        "Request queuing time"
      ],
      "title": "Obtaining Browser (end user) page load time data (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "c0c497cf900d84a9e57a07aba5062003e86506a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/obtaining-browser-end-user-page-load-time-data-v2/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The metric timeslice data presented on the Browser page load time chart on your application's Summary page will depend on your web app's configuration. Possible components may include: Network time Page rendering time DOM processing time Web application time Request queuing time This describes how to use the New Relic REST API (v2) to obtain the data shown on the Browser page load time chart. General API values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these examples. For calculated values, the time range you specify must be consistent in all of the queries; otherwise the final calculations will be incorrect. You must replace the ${APPID} and ${API_KEY} variables in these examples with your specific application ID and corresponding REST API key. Ensure you adjust the time units returned by the API requests as needed. Network time The EndUser:average_network_time is the network latency, or time it takes for a request to make a round trip over the Internet. Use the following command to obtain this. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_network_time' Copy This time is returned in milliseconds. Page rendering time Page rendering time is a derived value. To calculate it, use this equation: \"Page rendering\" time = EndUser:average_fe_response_time - EndUser/RB:average_dom_content_load_time Copy To obtain the data for this calculation, use the following commands. EndUser:average_fe_response_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_fe_response_time' Copy This time is returned in milliseconds. EndUser/RB:average_dom_content_load_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. DOM processing time The EndUser/RB:average_dom_content_load_time is the time spent in the browser to parse and interpret the HTML. This is measured by the browser's DOM Content event. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. Web application time The Web application time is the time spent in the application code. To calculate this value, use this equation: Web application = EndUser:total_app_time / EndUser:call_count Copy To obtain the data for this calculation, use the following commands. EndUser:total_app_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=total_app_time' Copy This time is returned in seconds. EndUser:call_count curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=call_count' Copy Request queuing time The EndUser/RB:average_queue_time is the wait time between the web server and the application code. Large numbers indicate a busy application server. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_queue_time' Copy This time is returned in milliseconds. The request queuing time is not included in the calculation of averages. New Relic includes it in this chart as a convenience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.65744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Obtaining <em>Browser</em> (end user) page load time data (<em>v2</em>)",
        "sections": "Obtaining <em>Browser</em> (end user) page load time data (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the data shown on the <em>Browser</em> page load time chart. General <em>API</em> values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these <em>examples</em>. For calculated values, the time range you"
      },
      "id": "6044070de7b9d2b9f7579a16"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/average-browser-page-load-time-example-v2": [
    {
      "sections": [
        "Add or list Browser apps via API (v2)",
        "Important",
        "Add browser apps",
        "List all browser apps",
        "View specific browser apps"
      ],
      "title": "Add or list Browser apps via API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "53568984e3b360bac9255a33adad7e6b43fadf5d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2/",
      "published_at": "2021-07-02T08:52:34Z",
      "updated_at": "2021-06-14T23:01:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to add apps to browser monitoring or to get a list of your browser apps for a specific API key. This helps you manage deployment outside of New Relic One. These API calls are useful, for example, with larger organizations deploying multiple apps, or for integration partners who facilitate New Relic account creation and browser monitoring deployments. Important When you add a browser app via API (v2), you can only instrument basic page load timing. To use instrumentation supporting all SPA features, see Use Browser SPA agent. To add a fully instrumented app, go to one.newrelic.com, and click the Add more data button on the top right hand-side. Then, use the guided install to start monitoring your app. Add browser apps To add an app to New Relic One, replace ${APIKEY} with your New Relic API key, and replace ${STRING} with the app's name in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > POST Create. Use the following command: curl -X POST 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i -H 'Content-Type: application/json' \\ -d \\ '{ \"browser_application\": { \"name\": ${STRING} } }' Copy The API returns an array of data where the element is a Browser application and the data associated with it: { \"browser_application\": { \"id\": \"integer\", \"name\": \"string\", \"browser_monitoring_key\": \"string\", \"loader_script\": \"string\" } Copy API (v2) output Description Browser app id (integer) This is the unique identification code for each app in New Relic One. App name (string) This is the app's name as it appears in the New Relic One. The browser_monitoring_key (string) This a unique key that is linked to (but is not the same as) the account license key. It is used to indicate the account in New Relic One where data will be reported. It cannot be used to determine your New Relic account's license key. Browser monitoring loader_script (string) The returned loader script is a JSON-encoded JavaScript snippet that is configured with the New Relic license key and application ID. The rest of the script is static and is approximately 10k in size. The loader script must be inserted into the user’s HTML pages correctly: It must appear in the page's <head> tag before the first script tag. If there are no script tags, put the JavaScript immediately before the </head> (end of head) tag. The entire loader script must be inserted in-line, not as a link to the .js file. List all browser apps To view a list of your apps in New Relic Browser, replace ${APIKEY} with your New Relic API key in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > GET List. Use the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can use the results to verify the account or name, and to get a copy of the loader script for the app, if needed. View specific browser apps View by name: To view a specific Browser app if you know its name, replace ${APIKEY} with your New Relic API key, and replace ${NAME} with your app's name in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${NAME}\" Copy View by Browser application ID: To view a specific Browser app if you know its ID, replace ${APIKEY} with your New Relic API key, and replace ${ID} with your Browser application ID in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[ids]=${ID}' Copy View multiple browser apps: To get information for multiple apps, separate the name or ID values with a comma in these commands; for example: -d 'filter[ids]=12345,23456' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.75551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add or list <em>Browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "sections": "Add or list <em>Browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to add apps to <em>browser</em> monitoring or to get a list of your <em>browser</em> apps for a specific <em>API</em> key. This helps you manage deployment outside of New Relic One. These <em>API</em> calls are useful, for example, with larger organizations deploying"
      },
      "id": "603ed6a928ccbc422beba77b"
    },
    {
      "sections": [
        "Obtaining Browser (end user) page load time data (v2)",
        "General API values",
        "Network time",
        "Page rendering time",
        "DOM processing time",
        "Web application time",
        "Request queuing time"
      ],
      "title": "Obtaining Browser (end user) page load time data (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "c0c497cf900d84a9e57a07aba5062003e86506a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/obtaining-browser-end-user-page-load-time-data-v2/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The metric timeslice data presented on the Browser page load time chart on your application's Summary page will depend on your web app's configuration. Possible components may include: Network time Page rendering time DOM processing time Web application time Request queuing time This describes how to use the New Relic REST API (v2) to obtain the data shown on the Browser page load time chart. General API values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these examples. For calculated values, the time range you specify must be consistent in all of the queries; otherwise the final calculations will be incorrect. You must replace the ${APPID} and ${API_KEY} variables in these examples with your specific application ID and corresponding REST API key. Ensure you adjust the time units returned by the API requests as needed. Network time The EndUser:average_network_time is the network latency, or time it takes for a request to make a round trip over the Internet. Use the following command to obtain this. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_network_time' Copy This time is returned in milliseconds. Page rendering time Page rendering time is a derived value. To calculate it, use this equation: \"Page rendering\" time = EndUser:average_fe_response_time - EndUser/RB:average_dom_content_load_time Copy To obtain the data for this calculation, use the following commands. EndUser:average_fe_response_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_fe_response_time' Copy This time is returned in milliseconds. EndUser/RB:average_dom_content_load_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. DOM processing time The EndUser/RB:average_dom_content_load_time is the time spent in the browser to parse and interpret the HTML. This is measured by the browser's DOM Content event. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. Web application time The Web application time is the time spent in the application code. To calculate this value, use this equation: Web application = EndUser:total_app_time / EndUser:call_count Copy To obtain the data for this calculation, use the following commands. EndUser:total_app_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=total_app_time' Copy This time is returned in seconds. EndUser:call_count curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=call_count' Copy Request queuing time The EndUser/RB:average_queue_time is the wait time between the web server and the application code. Large numbers indicate a busy application server. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_queue_time' Copy This time is returned in milliseconds. The request queuing time is not included in the calculation of averages. New Relic includes it in this chart as a convenience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.65744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Obtaining <em>Browser</em> (end user) page load time data (<em>v2</em>)",
        "sections": "Obtaining <em>Browser</em> (end user) page load time data (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the data shown on the <em>Browser</em> page load time chart. General <em>API</em> values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these <em>examples</em>. For calculated values, the time range you"
      },
      "id": "6044070de7b9d2b9f7579a16"
    },
    {
      "sections": [
        "Average browser (end user) page throughput example (v2)",
        "Average page throughput",
        "For more help"
      ],
      "title": "Average browser (end user) page throughput example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "713534d353c7a66e7c02ec00f7d5340dab172740",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2/",
      "published_at": "2021-07-02T08:52:37Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser throughput appears at the top right of the Throughput by browser chart on your Summary page. This is the average pages per minute (PPM) by browser type in the time range shown on the chart. Average page throughput To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET 'https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json' \\ -H 'X-Api-Key:${API_KEY}' -i \\ -d 'names[]=EndUser&values[]=requests_per_minute&summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.65744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " minutes), use the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&#x27; \\ -H &#x27;X-<em>Api</em>-Key:${<em>API</em>_KEY}&#x27; -i \\ -d &#x27;names[]=EndUser&amp;values[]=requests_per_minute&amp;summarize=true&#x27; Copy For more help"
      },
      "id": "604406cf28ccbc10652c6091"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/obtaining-browser-end-user-page-load-time-data-v2": [
    {
      "sections": [
        "Add or list Browser apps via API (v2)",
        "Important",
        "Add browser apps",
        "List all browser apps",
        "View specific browser apps"
      ],
      "title": "Add or list Browser apps via API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "53568984e3b360bac9255a33adad7e6b43fadf5d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2/",
      "published_at": "2021-07-02T08:52:34Z",
      "updated_at": "2021-06-14T23:01:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to add apps to browser monitoring or to get a list of your browser apps for a specific API key. This helps you manage deployment outside of New Relic One. These API calls are useful, for example, with larger organizations deploying multiple apps, or for integration partners who facilitate New Relic account creation and browser monitoring deployments. Important When you add a browser app via API (v2), you can only instrument basic page load timing. To use instrumentation supporting all SPA features, see Use Browser SPA agent. To add a fully instrumented app, go to one.newrelic.com, and click the Add more data button on the top right hand-side. Then, use the guided install to start monitoring your app. Add browser apps To add an app to New Relic One, replace ${APIKEY} with your New Relic API key, and replace ${STRING} with the app's name in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > POST Create. Use the following command: curl -X POST 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i -H 'Content-Type: application/json' \\ -d \\ '{ \"browser_application\": { \"name\": ${STRING} } }' Copy The API returns an array of data where the element is a Browser application and the data associated with it: { \"browser_application\": { \"id\": \"integer\", \"name\": \"string\", \"browser_monitoring_key\": \"string\", \"loader_script\": \"string\" } Copy API (v2) output Description Browser app id (integer) This is the unique identification code for each app in New Relic One. App name (string) This is the app's name as it appears in the New Relic One. The browser_monitoring_key (string) This a unique key that is linked to (but is not the same as) the account license key. It is used to indicate the account in New Relic One where data will be reported. It cannot be used to determine your New Relic account's license key. Browser monitoring loader_script (string) The returned loader script is a JSON-encoded JavaScript snippet that is configured with the New Relic license key and application ID. The rest of the script is static and is approximately 10k in size. The loader script must be inserted into the user’s HTML pages correctly: It must appear in the page's <head> tag before the first script tag. If there are no script tags, put the JavaScript immediately before the </head> (end of head) tag. The entire loader script must be inserted in-line, not as a link to the .js file. List all browser apps To view a list of your apps in New Relic Browser, replace ${APIKEY} with your New Relic API key in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > GET List. Use the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can use the results to verify the account or name, and to get a copy of the loader script for the app, if needed. View specific browser apps View by name: To view a specific Browser app if you know its name, replace ${APIKEY} with your New Relic API key, and replace ${NAME} with your app's name in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${NAME}\" Copy View by Browser application ID: To view a specific Browser app if you know its ID, replace ${APIKEY} with your New Relic API key, and replace ${ID} with your Browser application ID in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[ids]=${ID}' Copy View multiple browser apps: To get information for multiple apps, separate the name or ID values with a comma in these commands; for example: -d 'filter[ids]=12345,23456' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.75551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add or list <em>Browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "sections": "Add or list <em>Browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to add apps to <em>browser</em> monitoring or to get a list of your <em>browser</em> apps for a specific <em>API</em> key. This helps you manage deployment outside of New Relic One. These <em>API</em> calls are useful, for example, with larger organizations deploying"
      },
      "id": "603ed6a928ccbc422beba77b"
    },
    {
      "sections": [
        "Average browser page load time example (v2)",
        "Average page load time"
      ],
      "title": "Average browser page load time example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "2e2669a368831880e962cdbd39d95d31a98aa253",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-page-load-time-example-v2/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:36:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser page load time (or response time) appears at the top right of the main chart of your Summary page. This value is labeled Browser and shows the average page load time in seconds. Average page load time To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_response_time&summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.85,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> page load time <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> page load time <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&quot; \\ -H &quot;X-<em>Api</em>-Key:${<em>API</em>_KEY}&quot; -i \\ -d &#x27;names[]=EndUser&amp;values[]=average_response_time&amp;summarize=true&#x27; Copy"
      },
      "id": "604406cf196a670c98960f55"
    },
    {
      "sections": [
        "Average browser (end user) page throughput example (v2)",
        "Average page throughput",
        "For more help"
      ],
      "title": "Average browser (end user) page throughput example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "713534d353c7a66e7c02ec00f7d5340dab172740",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2/",
      "published_at": "2021-07-02T08:52:37Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser throughput appears at the top right of the Throughput by browser chart on your Summary page. This is the average pages per minute (PPM) by browser type in the time range shown on the chart. Average page throughput To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET 'https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json' \\ -H 'X-Api-Key:${API_KEY}' -i \\ -d 'names[]=EndUser&values[]=requests_per_minute&summarize=true' Copy For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.65744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " minutes), use the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&#x27; \\ -H &#x27;X-<em>Api</em>-Key:${<em>API</em>_KEY}&#x27; -i \\ -d &#x27;names[]=EndUser&amp;values[]=requests_per_minute&amp;summarize=true&#x27; Copy For more help"
      },
      "id": "604406cf28ccbc10652c6091"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships": [
    {
      "sections": [
        "Get app and other IDs in New Relic One",
        "Find IDs using New Relic One",
        "APM: App ID",
        "Browser app ID",
        "Mobile app ID"
      ],
      "title": "Get app and other IDs in New Relic One",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "90dfb764139b1e4ad047635210a4ca7470293c8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/get-app-other-ids-new-relic-one/",
      "published_at": "2021-07-02T08:55:22Z",
      "updated_at": "2021-03-16T07:10:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using the New Relic REST API, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $PLUGIN_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to get some of these IDs. You can also get a list of IDs using the REST API Explorer. Find IDs using New Relic One New Relic One includes the IDs of applications and some other components in a metadata panel. Click the icon next to the application name to open the metadata panel. Here are some examples: APM: App ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click APM and select an application. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Browser app ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click Browser and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Mobile app ID To locate the $MOBILE_ID from the New Relic UI: From one.newrelic.com, click Mobile and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $MOBILE_ID in your REST API calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.04819,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> app and other IDs in New Relic One",
        "sections": "<em>Get</em> app and other IDs in New Relic One",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "When using the New Relic <em>REST</em> <em>API</em>, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $PLUGIN_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to <em>get</em> some of these IDs. You can also <em>get</em> a list of IDs using the <em>REST</em> <em>API</em>"
      },
      "id": "603ed46c64441f70d44e8839"
    },
    {
      "sections": [
        "List application ID, host ID, instance ID",
        "Use the API Explorer",
        "List application IDs",
        "List host IDs",
        "Host ID and summary data using the REST API Explorer",
        "{HOST_ID} output",
        "List instance IDs",
        "Instance ID and summary data using the REST API Explorer",
        "{INSTANCE_ID} output",
        "Java instance ID (JVM) using the UI",
        "REST API application list example"
      ],
      "title": "List application ID, host ID, instance ID",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "87dd2a198e50edc8e78d7bb7c70ba724aff73053",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/list-application-id-host-id-instance-id/",
      "published_at": "2021-07-02T08:56:42Z",
      "updated_at": "2021-03-13T03:21:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM assigns IDs to entities related to an application. These are used to collect information about the operation and performance from different view points. These IDs can be returned via New Relic's REST API. The IDs may include: Application ID $APP_ID for each instrumented app Host ID $HOST_ID for each host Instance ID $INSTANCE_ID if there are multiple instances of the app To list any of these IDs in the New Relic API Explorer, you need an API key. Use the API Explorer You can use the API Explorer to return a list of all product IDs for a particular product: Go to one.newrelic.com > APM > (select an app). Go to the API Explorer at rpm.newrelic.com/api/explore, then select your account name from the Select an account dropdown. From the sidebar, select (product category) > GET List. Select Send Request. Browse the Response to locate the product ID. Use the product ID you located in your REST API calls. List application IDs Each app monitored by an APM agent is assigned a name. A unique $APP_ID is also associated with that name. The $APP_ID is fundamental for retrieving APM information about your apps. For more information about listing and using the $APP_ID, and obtaining the summary data, see Listing your app ID. List host IDs The $HOST_ID is used to get APM data for a specific host running an app. A physical server may have more than one host. For example, a web server program running on a physical server may be configured to have more than one virtual host. IDs for the host and physical server are not the same. Each host ID is unique and represents different items. Use the $HOST_ID to retrieve summary metrics for the host as well as specific metric timeslice values. For more information about available metrics: Go to rpm.newrelic.com. Go to the API Explorer, then select your account name from the Select an account dropdown. Go to the API Explorer's Application host page at rpm.newrelic.com/api/explore/application_hosts/names. Host ID and summary data using the REST API Explorer To use the API Explorer to return a list of every $HOST_ID for a particular application, you will need the $APP_ID. Go to the API Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/hosts.json' \\ -H 'Api-Key:$API_KEY' -i Copy If you have an EU region account, the endpoint begins with https://api.eu.newrelic.com. Select Send Request. Browse the Response to locate the {HOST_ID} for each host. {HOST_ID} output The output will appear similar to this: { \"application_hosts\": [ { \"id\": 34966, <---<<< {HOST_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-10.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1234, <---<<< {APP_ID} \"application_instances\": [ 13512 <---<<< {INSTANCE_ID} ], } }, { \"id\": 9999999, <---<<< {HOST_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-11.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { \". . . }, \"links\": { \"application\": 1234, <---<<< {APP_ID} \"application_instances\": [ 186288 <---<<< {INSTANCE_ID} ], } }, . . . Copy List instance IDs The instance ID meaning depends on the New Relic language agent being used. You can list this ID from the REST API. For Java, you can also view the instance ID (JVM) from New Relic APM's Overview page. Agent Instance ID represents Go The Go program on the host reporting to the app name Java A Java Virtual Machine (JVM) .NET For New Relic's .NET Framework agent, this is the AppDomain Node.js A worker process PHP The daemon agent Ruby An individual Ruby worker process Python The master and worker processes You can retrieve summary metrics for the instance as well as specific metric timeslice values using the {INSTANCE_ID}. For details about available metrics, use the REST API Explorer Application Instance page. Instance ID and summary data using the REST API Explorer To use the API Explorer to return a list of every $INSTANCE_ID for a particular application, you will need the $APP_ID. Go to the API Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/hosts.json' \\ -H 'Api-Key:$API_KEY' -i Copy If you have an EU region account, the endpoint begins with https://api.eu.newrelic.com. Select Send Request. Browse the Response to locate the $INSTANCE_ID for each instance. {INSTANCE_ID} output The { INSTANCE_ID} output will appear similar to this: { \"application_instances\": [ { \"id\": 35120, <---<<< {INSTANCE_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-10.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1441, <---<<< {APP_ID} \"application_host\": 34966, <---<<< {HOST_ID} } }, { \"id\": 186288, <---<<< {INSTANCE_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-11.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1441, <---<<< {APP_ID} \"application_host\": 186283, <---<<< {HOST_ID} } }, . . . Copy Java instance ID (JVM) using the UI Java apps: To locate a specific JVM $INSTANCE_ID in New Relic: Go to one.newrelic.com > APM > Applications > (select an app) > JVMs. Select the name of the instance. In the URL, the number after the _i designator represents the Java JVM instance: https://rpm.newrelic.com/accounts/$ACCOUNT_ID/applications/$APP_ID_i$INSTANCE_ID Copy REST API application list example The following example shows how to locate all the ID information for an application by using the APP_ID. If you have an EU account, the endpoint begins with https://api.eu.newrelic.com. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'filter[ids]=1441' <----<<<< {APP_ID} Copy The resulting example output is running on five servers. One server is hosting two virtual hosts for a total of six hosts. The output includes a links section listing the application_instances and application_hosts for the application. { \"applications\": [ { \"id\": 1441, <----<<<< {APP_ID} \"name\": \"RPM Combined Production\", \"language\": \"ruby\", \"health_status\": \"green\", \"reporting\": true, \"last_reported_at\": \"2015-11-10T23:19:47+00:00\", \"application_summary\": { . . . }, \"end_user_summary\": { . . . }, \"settings\": { . . . }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ], . . . Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.7665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Host ID and summary data using the <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " for a particular application, you will need the $APP_ID. Go to the <em>API</em> Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X <em>GET</em> &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;hosts.json&#x27; \\ -H &#x27;<em>Api</em>-Key:$<em>API</em>_KEY&#x27; -i Copy"
      },
      "id": "60440c9628ccbc2de32c6078"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Tip",
        "Setup",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2021-07-02T08:55:22Z",
      "updated_at": "2021-03-13T01:22:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Tip To use APIs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following for example REST API use cases: APM examples (how to retrieve metric timeslice data from New Relic APM) Browser examples (how to retrieve metric timeslice data from New Relic Browser) Infrastructure alert examples Plugin examples (how to retrieve information and metric timeslice data about plugins from New Relic Plugin Central) Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.75928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/get-app-other-ids-new-relic-one": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.57544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "List application ID, host ID, instance ID",
        "Use the API Explorer",
        "List application IDs",
        "List host IDs",
        "Host ID and summary data using the REST API Explorer",
        "{HOST_ID} output",
        "List instance IDs",
        "Instance ID and summary data using the REST API Explorer",
        "{INSTANCE_ID} output",
        "Java instance ID (JVM) using the UI",
        "REST API application list example"
      ],
      "title": "List application ID, host ID, instance ID",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "87dd2a198e50edc8e78d7bb7c70ba724aff73053",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/list-application-id-host-id-instance-id/",
      "published_at": "2021-07-02T08:56:42Z",
      "updated_at": "2021-03-13T03:21:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM assigns IDs to entities related to an application. These are used to collect information about the operation and performance from different view points. These IDs can be returned via New Relic's REST API. The IDs may include: Application ID $APP_ID for each instrumented app Host ID $HOST_ID for each host Instance ID $INSTANCE_ID if there are multiple instances of the app To list any of these IDs in the New Relic API Explorer, you need an API key. Use the API Explorer You can use the API Explorer to return a list of all product IDs for a particular product: Go to one.newrelic.com > APM > (select an app). Go to the API Explorer at rpm.newrelic.com/api/explore, then select your account name from the Select an account dropdown. From the sidebar, select (product category) > GET List. Select Send Request. Browse the Response to locate the product ID. Use the product ID you located in your REST API calls. List application IDs Each app monitored by an APM agent is assigned a name. A unique $APP_ID is also associated with that name. The $APP_ID is fundamental for retrieving APM information about your apps. For more information about listing and using the $APP_ID, and obtaining the summary data, see Listing your app ID. List host IDs The $HOST_ID is used to get APM data for a specific host running an app. A physical server may have more than one host. For example, a web server program running on a physical server may be configured to have more than one virtual host. IDs for the host and physical server are not the same. Each host ID is unique and represents different items. Use the $HOST_ID to retrieve summary metrics for the host as well as specific metric timeslice values. For more information about available metrics: Go to rpm.newrelic.com. Go to the API Explorer, then select your account name from the Select an account dropdown. Go to the API Explorer's Application host page at rpm.newrelic.com/api/explore/application_hosts/names. Host ID and summary data using the REST API Explorer To use the API Explorer to return a list of every $HOST_ID for a particular application, you will need the $APP_ID. Go to the API Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/hosts.json' \\ -H 'Api-Key:$API_KEY' -i Copy If you have an EU region account, the endpoint begins with https://api.eu.newrelic.com. Select Send Request. Browse the Response to locate the {HOST_ID} for each host. {HOST_ID} output The output will appear similar to this: { \"application_hosts\": [ { \"id\": 34966, <---<<< {HOST_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-10.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1234, <---<<< {APP_ID} \"application_instances\": [ 13512 <---<<< {INSTANCE_ID} ], } }, { \"id\": 9999999, <---<<< {HOST_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-11.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { \". . . }, \"links\": { \"application\": 1234, <---<<< {APP_ID} \"application_instances\": [ 186288 <---<<< {INSTANCE_ID} ], } }, . . . Copy List instance IDs The instance ID meaning depends on the New Relic language agent being used. You can list this ID from the REST API. For Java, you can also view the instance ID (JVM) from New Relic APM's Overview page. Agent Instance ID represents Go The Go program on the host reporting to the app name Java A Java Virtual Machine (JVM) .NET For New Relic's .NET Framework agent, this is the AppDomain Node.js A worker process PHP The daemon agent Ruby An individual Ruby worker process Python The master and worker processes You can retrieve summary metrics for the instance as well as specific metric timeslice values using the {INSTANCE_ID}. For details about available metrics, use the REST API Explorer Application Instance page. Instance ID and summary data using the REST API Explorer To use the API Explorer to return a list of every $INSTANCE_ID for a particular application, you will need the $APP_ID. Go to the API Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/hosts.json' \\ -H 'Api-Key:$API_KEY' -i Copy If you have an EU region account, the endpoint begins with https://api.eu.newrelic.com. Select Send Request. Browse the Response to locate the $INSTANCE_ID for each instance. {INSTANCE_ID} output The { INSTANCE_ID} output will appear similar to this: { \"application_instances\": [ { \"id\": 35120, <---<<< {INSTANCE_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-10.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1441, <---<<< {APP_ID} \"application_host\": 34966, <---<<< {HOST_ID} } }, { \"id\": 186288, <---<<< {INSTANCE_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-11.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1441, <---<<< {APP_ID} \"application_host\": 186283, <---<<< {HOST_ID} } }, . . . Copy Java instance ID (JVM) using the UI Java apps: To locate a specific JVM $INSTANCE_ID in New Relic: Go to one.newrelic.com > APM > Applications > (select an app) > JVMs. Select the name of the instance. In the URL, the number after the _i designator represents the Java JVM instance: https://rpm.newrelic.com/accounts/$ACCOUNT_ID/applications/$APP_ID_i$INSTANCE_ID Copy REST API application list example The following example shows how to locate all the ID information for an application by using the APP_ID. If you have an EU account, the endpoint begins with https://api.eu.newrelic.com. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'filter[ids]=1441' <----<<<< {APP_ID} Copy The resulting example output is running on five servers. One server is hosting two virtual hosts for a total of six hosts. The output includes a links section listing the application_instances and application_hosts for the application. { \"applications\": [ { \"id\": 1441, <----<<<< {APP_ID} \"name\": \"RPM Combined Production\", \"language\": \"ruby\", \"health_status\": \"green\", \"reporting\": true, \"last_reported_at\": \"2015-11-10T23:19:47+00:00\", \"application_summary\": { . . . }, \"end_user_summary\": { . . . }, \"settings\": { . . . }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ], . . . Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.7665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Host ID and summary data using the <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " for a particular application, you will need the $APP_ID. Go to the <em>API</em> Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X <em>GET</em> &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;hosts.json&#x27; \\ -H &#x27;<em>Api</em>-Key:$<em>API</em>_KEY&#x27; -i Copy"
      },
      "id": "60440c9628ccbc2de32c6078"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Tip",
        "Setup",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2021-07-02T08:55:22Z",
      "updated_at": "2021-03-13T01:22:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Tip To use APIs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following for example REST API use cases: APM examples (how to retrieve metric timeslice data from New Relic APM) Browser examples (how to retrieve metric timeslice data from New Relic Browser) Infrastructure alert examples Plugin examples (how to retrieve information and metric timeslice data about plugins from New Relic Plugin Central) Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.75928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.57544,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Get app and other IDs in New Relic One",
        "Find IDs using New Relic One",
        "APM: App ID",
        "Browser app ID",
        "Mobile app ID"
      ],
      "title": "Get app and other IDs in New Relic One",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "90dfb764139b1e4ad047635210a4ca7470293c8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/get-app-other-ids-new-relic-one/",
      "published_at": "2021-07-02T08:55:22Z",
      "updated_at": "2021-03-16T07:10:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using the New Relic REST API, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $PLUGIN_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to get some of these IDs. You can also get a list of IDs using the REST API Explorer. Find IDs using New Relic One New Relic One includes the IDs of applications and some other components in a metadata panel. Click the icon next to the application name to open the metadata panel. Here are some examples: APM: App ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click APM and select an application. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Browser app ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click Browser and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Mobile app ID To locate the $MOBILE_ID from the New Relic UI: From one.newrelic.com, click Mobile and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $MOBILE_ID in your REST API calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.04819,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> app and other IDs in New Relic One",
        "sections": "<em>Get</em> app and other IDs in New Relic One",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "When using the New Relic <em>REST</em> <em>API</em>, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $PLUGIN_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to <em>get</em> some of these IDs. You can also <em>get</em> a list of IDs using the <em>REST</em> <em>API</em>"
      },
      "id": "603ed46c64441f70d44e8839"
    },
    {
      "sections": [
        "List application ID, host ID, instance ID",
        "Use the API Explorer",
        "List application IDs",
        "List host IDs",
        "Host ID and summary data using the REST API Explorer",
        "{HOST_ID} output",
        "List instance IDs",
        "Instance ID and summary data using the REST API Explorer",
        "{INSTANCE_ID} output",
        "Java instance ID (JVM) using the UI",
        "REST API application list example"
      ],
      "title": "List application ID, host ID, instance ID",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "87dd2a198e50edc8e78d7bb7c70ba724aff73053",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/list-application-id-host-id-instance-id/",
      "published_at": "2021-07-02T08:56:42Z",
      "updated_at": "2021-03-13T03:21:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM assigns IDs to entities related to an application. These are used to collect information about the operation and performance from different view points. These IDs can be returned via New Relic's REST API. The IDs may include: Application ID $APP_ID for each instrumented app Host ID $HOST_ID for each host Instance ID $INSTANCE_ID if there are multiple instances of the app To list any of these IDs in the New Relic API Explorer, you need an API key. Use the API Explorer You can use the API Explorer to return a list of all product IDs for a particular product: Go to one.newrelic.com > APM > (select an app). Go to the API Explorer at rpm.newrelic.com/api/explore, then select your account name from the Select an account dropdown. From the sidebar, select (product category) > GET List. Select Send Request. Browse the Response to locate the product ID. Use the product ID you located in your REST API calls. List application IDs Each app monitored by an APM agent is assigned a name. A unique $APP_ID is also associated with that name. The $APP_ID is fundamental for retrieving APM information about your apps. For more information about listing and using the $APP_ID, and obtaining the summary data, see Listing your app ID. List host IDs The $HOST_ID is used to get APM data for a specific host running an app. A physical server may have more than one host. For example, a web server program running on a physical server may be configured to have more than one virtual host. IDs for the host and physical server are not the same. Each host ID is unique and represents different items. Use the $HOST_ID to retrieve summary metrics for the host as well as specific metric timeslice values. For more information about available metrics: Go to rpm.newrelic.com. Go to the API Explorer, then select your account name from the Select an account dropdown. Go to the API Explorer's Application host page at rpm.newrelic.com/api/explore/application_hosts/names. Host ID and summary data using the REST API Explorer To use the API Explorer to return a list of every $HOST_ID for a particular application, you will need the $APP_ID. Go to the API Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/hosts.json' \\ -H 'Api-Key:$API_KEY' -i Copy If you have an EU region account, the endpoint begins with https://api.eu.newrelic.com. Select Send Request. Browse the Response to locate the {HOST_ID} for each host. {HOST_ID} output The output will appear similar to this: { \"application_hosts\": [ { \"id\": 34966, <---<<< {HOST_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-10.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1234, <---<<< {APP_ID} \"application_instances\": [ 13512 <---<<< {INSTANCE_ID} ], } }, { \"id\": 9999999, <---<<< {HOST_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-11.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { \". . . }, \"links\": { \"application\": 1234, <---<<< {APP_ID} \"application_instances\": [ 186288 <---<<< {INSTANCE_ID} ], } }, . . . Copy List instance IDs The instance ID meaning depends on the New Relic language agent being used. You can list this ID from the REST API. For Java, you can also view the instance ID (JVM) from New Relic APM's Overview page. Agent Instance ID represents Go The Go program on the host reporting to the app name Java A Java Virtual Machine (JVM) .NET For New Relic's .NET Framework agent, this is the AppDomain Node.js A worker process PHP The daemon agent Ruby An individual Ruby worker process Python The master and worker processes You can retrieve summary metrics for the instance as well as specific metric timeslice values using the {INSTANCE_ID}. For details about available metrics, use the REST API Explorer Application Instance page. Instance ID and summary data using the REST API Explorer To use the API Explorer to return a list of every $INSTANCE_ID for a particular application, you will need the $APP_ID. Go to the API Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/hosts.json' \\ -H 'Api-Key:$API_KEY' -i Copy If you have an EU region account, the endpoint begins with https://api.eu.newrelic.com. Select Send Request. Browse the Response to locate the $INSTANCE_ID for each instance. {INSTANCE_ID} output The { INSTANCE_ID} output will appear similar to this: { \"application_instances\": [ { \"id\": 35120, <---<<< {INSTANCE_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-10.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1441, <---<<< {APP_ID} \"application_host\": 34966, <---<<< {HOST_ID} } }, { \"id\": 186288, <---<<< {INSTANCE_ID} \"application_name\": \"Combined Production\", \"host\": \"prod-app-11.com\", \"language\": \"ruby\", \"health_status\": \"green\", \"application_summary\": { . . . }, \"links\": { \"application\": 1441, <---<<< {APP_ID} \"application_host\": 186283, <---<<< {HOST_ID} } }, . . . Copy Java instance ID (JVM) using the UI Java apps: To locate a specific JVM $INSTANCE_ID in New Relic: Go to one.newrelic.com > APM > Applications > (select an app) > JVMs. Select the name of the instance. In the URL, the number after the _i designator represents the Java JVM instance: https://rpm.newrelic.com/accounts/$ACCOUNT_ID/applications/$APP_ID_i$INSTANCE_ID Copy REST API application list example The following example shows how to locate all the ID information for an application by using the APP_ID. If you have an EU account, the endpoint begins with https://api.eu.newrelic.com. curl -X GET 'https://api.newrelic.com/v2/applications.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'filter[ids]=1441' <----<<<< {APP_ID} Copy The resulting example output is running on five servers. One server is hosting two virtual hosts for a total of six hosts. The output includes a links section listing the application_instances and application_hosts for the application. { \"applications\": [ { \"id\": 1441, <----<<<< {APP_ID} \"name\": \"RPM Combined Production\", \"language\": \"ruby\", \"health_status\": \"green\", \"reporting\": true, \"last_reported_at\": \"2015-11-10T23:19:47+00:00\", \"application_summary\": { . . . }, \"end_user_summary\": { . . . }, \"settings\": { . . . }, \"links\": { \"application_instances\": [ <---<<<< {INSTANCE_ID} list 21790, 24810, 27948, 35120, 35121, 35122, 186288, 247253, 247254, 247255, 247256 ], \"application_hosts\": [ <---<<<< {HOST_ID} list 21788, 24808, 34966, 186283, 247245, 286551 ] } } ], . . . Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.7665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Host ID and summary data using the <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " for a particular application, you will need the $APP_ID. Go to the <em>API</em> Explorer, then select your account name from the Select an account dropdown. Enter the specific $APP_ID in the following command: curl -X <em>GET</em> &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;hosts.json&#x27; \\ -H &#x27;<em>Api</em>-Key:$<em>API</em>_KEY&#x27; -i Copy"
      },
      "id": "60440c9628ccbc2de32c6078"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/list-application-id-host-id-instance-id": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.57542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Get app and other IDs in New Relic One",
        "Find IDs using New Relic One",
        "APM: App ID",
        "Browser app ID",
        "Mobile app ID"
      ],
      "title": "Get app and other IDs in New Relic One",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "90dfb764139b1e4ad047635210a4ca7470293c8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/get-app-other-ids-new-relic-one/",
      "published_at": "2021-07-02T08:55:22Z",
      "updated_at": "2021-03-16T07:10:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using the New Relic REST API, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $PLUGIN_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to get some of these IDs. You can also get a list of IDs using the REST API Explorer. Find IDs using New Relic One New Relic One includes the IDs of applications and some other components in a metadata panel. Click the icon next to the application name to open the metadata panel. Here are some examples: APM: App ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click APM and select an application. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Browser app ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click Browser and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Mobile app ID To locate the $MOBILE_ID from the New Relic UI: From one.newrelic.com, click Mobile and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $MOBILE_ID in your REST API calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.04819,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> app and other IDs in New Relic One",
        "sections": "<em>Get</em> app and other IDs in New Relic One",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "When using the New Relic <em>REST</em> <em>API</em>, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $PLUGIN_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to <em>get</em> some of these IDs. You can also <em>get</em> a list of IDs using the <em>REST</em> <em>API</em>"
      },
      "id": "603ed46c64441f70d44e8839"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Tip",
        "Setup",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2021-07-02T08:55:22Z",
      "updated_at": "2021-03-13T01:22:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Tip To use APIs and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following for example REST API use cases: APM examples (how to retrieve metric timeslice data from New Relic APM) Browser examples (how to retrieve metric timeslice data from New Relic Browser) Infrastructure alert examples Plugin examples (how to retrieve information and metric timeslice data about plugins from New Relic Plugin Central) Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.75928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/rest-api-v2/labels-examples-v2/create-labels-apps-v2": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.15352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.9062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> Explorer. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.41104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your application (<em>v2</em>)",
        "sections": "Change the alias for your application (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    }
  ],
  "/docs/apis/rest-api-v2/mobile-examples-v2/mobile-crash-count-crash-rate-example-v2": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.15352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.9062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> Explorer. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds",
        "For more help"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2021-07-02T12:37:09Z",
      "updated_at": "2021-03-16T07:08:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface. For more help Additional documentation resources include: Getting started with the New Relic REST API (v2) (overview of the New Relic REST API, including the structure of an API call) Using the API Explorer (using the API Explorer's UI to get data in and data out of New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.41104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your application (<em>v2</em>)",
        "sections": "Change the alias for your application (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    }
  ],
  "/docs/apis/rest-api-v2/plugin-examples-v2/get-individual-plugin-components-v2": [
    {
      "sections": [
        "Get a list of plugins (v2)",
        "List all plugins",
        "List by plugin ID",
        "Filter by plugin ID or GUID",
        "Plugin list output",
        "Tip"
      ],
      "title": "Get a list of plugins (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "d8de5b6aeafe748d8d0eb8f9559319b60a7ea582",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-list-plugins-v2/",
      "published_at": "2021-07-02T10:58:50Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is an example of how to use the New Relic REST API (v2) to obtain a list of all plugins for the account associated with a REST API key, including: Each plugin ID, plugin name, and GUID A list of summary metrics available for each of the components, including component IDs, names, and other values You can also use the API Explorer to list plugins. List all plugins To obtain a list of the plugins, use: curl -X GET \"https://api.newrelic.com/v2/plugins.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can also use the New Relic API explorer to list information for all plugins. List by plugin ID To list the components defined for a single plugin, if you know the plugin's ID, use: curl -X GET \"https://api.newrelic.com/v2/plugins/${PLUGIN_ID}.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can also use the New Relic API explorer to list information for a single plugin. Filter by plugin ID or GUID To filter the plugins list by GUID or plugin ID, replace the [guid] and ids with your values: curl -X GET 'https://api.newrelic.com/v2/plugins.json' \\ -H 'X-Api-Key:' -i \\ -d 'filter[guid]=mysql' Copy curl -X GET 'https://api.newrelic.com/v2/plugins.json' \\ -H 'X-Api-Key:' -i \\ -d 'filter[ids]=123,234' Copy Plugin list output The output is in JSON format, but you can modify this by specifying plugins.xml rather than plugins.json. The output will appear in the following format (for JSON). Tip PIugin queries can result in a large quantity of data. For more information about formatting the output or viewing multiple pages, see Pagination for API output. { \"plugins\": [ { \"id\": 9568, <---<<< PLUGIN_ID \"name\": \"F5 LTM\", <---<<< PLUGIN_NAME \"guid\": \"com.newrelic.f5\", <---<<< PLUGIN_GUID \"publisher\": \"New Relic Inc.\", \"summary_metrics\": [ { \"id\": 116635,> <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\",> <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", \"value_function\": \"average_value\", \"thresholds\": { \"caution\": null, \"critical\": null } }, ..... } } ] ... Copy The output contains the summary_metrics that have been defined for the plugin. The summary_metric values are listed for each component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.46622,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get a list of <em>plugins</em> (<em>v2</em>)",
        "sections": "Get a list of <em>plugins</em> (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here is an example of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain a list of all plugins for the account associated with a <em>REST</em> <em>API</em> key, including: Each <em>plugin</em> ID, <em>plugin</em> name, and GUID A list of summary metrics available for each of the components, including component IDs, names, and other"
      },
      "id": "603eb55a28ccbca0bbeba78a"
    },
    {
      "sections": [
        "List multiple plugin components (v2)",
        "Important",
        "List all components",
        "List by plugin_id",
        "View the components' output"
      ],
      "title": "List multiple plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "f2dd690f5c5cd2a1db2b41b9b29476b1b289659c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/list-multiple-plugin-components-v2/",
      "published_at": "2021-07-02T11:00:03Z",
      "updated_at": "2021-03-16T07:10:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API and your API key to obtain information about multiple components (instances) for your plugin, including: The summary metric in raw and formatted form as set by the plugin publisher Threshold data indicating when Caution and Critical alerts will be triggered Each COMPONENT_ID and COMPONENT_NAME for the plugin Summary information for each component, including SUMMARY_METRIC_ID and SUMMARY_METRIC_NAME The associated summary metric information, including METRIC_NAME and METRIC_VALUE You can use the API Explorer to list components. Important When using these examples, be sure to replace each placeholder (for example, ${PLUGIN_ID}) with its specific ID. List all components To obtain a list of the plugin's components (instances) and the summary data for the account associated with your API key, use: curl -X GET \"https://api.newrelic.com/v2/components.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy List by plugin_id To obtain a list of the plugin's components (instances) and summary data for a single ${PLUGIN_ID}, use the following command. curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[plugin_id]=${PLUGIN_ID}\" Copy View the components' output The output for each component ID will be similar to the following example, which is annotated and formatted for JSON. Due to the potential length of the output, you may want to paginate it. { \"components\": [ { \"id\": 3947935, <---<<< COMPONENT_ID \"name\": \"F5-01-prod\", <---<<< COMPONENT_NAME \"summary_metrics\": [ { \"id\": 116635, <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\", <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD }, \"values\": { \"raw\": 78.79225, <---<<< SUMMARY_METRIC_VALUE \"formatted\": \"78.8 %\" <---<<< SUMMARY_METRIC_FORMATTED_VALUE } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", ... }, ] }, .... ] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.99571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "List multiple <em>plugin</em> components (<em>v2</em>)",
        "sections": "List multiple <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " these <em>examples</em>, be sure to replace each placeholder (for example, ${<em>PLUGIN</em>_ID}) with its specific ID. List all components To obtain a list of the <em>plugin</em>&#x27;s components (instances) and the summary data for the account associated with your <em>API</em> key, use: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components.json&quot; \\ -H"
      },
      "id": "603eb58fe7b9d2fdc22a07c8"
    },
    {
      "sections": [
        "Listing metric timeslice data for plugin components (v2)",
        "Tip",
        "Listing a component's metric names",
        "Listing a specific metric name and values",
        "Specifying the metric data values"
      ],
      "title": "Listing metric timeslice data for plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "cd1b96e5c2803623faac8fb3d63df498097df4df",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/listing-metrics-plugin-components-v2/",
      "published_at": "2021-07-02T11:00:03Z",
      "updated_at": "2021-03-13T03:27:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API to obtain a list of metric timeslice data about your plugin's components (instances), including metric names and values, for the account associated with your API key. Tip When using these examples, be sure to replace each placeholder (for example, ${COMPONENT_ID}) with its specific ID. Listing a component's metric names To obtain a list of the metric names for a single component by its ${COMPONENT_ID}, use this API call: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy The output (JSON format) lists the metric name and values: { \"metrics\": [ { \"name\": \"Agent/MetricsReported/count\", <---<<< METRIC_NAME \"values\": [ \"average_response_time\", <---<<< METRIC_VALUES listing \"calls_per_minute\", \"call_count\", \"min_response_time\", \"max_response_time\", \"average_exclusive_time\", \"average_value\", \"requests_per_minute\", \"standard_deviation\" ] }, { \"name\": \"Component/Client SSL Profiles/Current Cache Entries//Common/clientssl-insecure-compatible[entries]\", \"values\": [ \"average_value\", \"total_value\", \"max_value\", \"min_value\", \"standard_deviation\", \"rate\", \"count\" ] }, ... } } Copy Listing a specific metric name and values To obtain a single metric name and the available metric values for a specific plugin component, replace the $ { COMPONENT_ID} and $ { METRIC_NAME} placeholders with the actual values in the following API call: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"name=${METRIC_NAME}\" Copy The output will be similar to what appears when you create an API call for multiple metric names. Specifying the metric data values To obtain the metric timeslice data for a specific component, use any of the following API calls. Be sure to replace the $ { COMPONENT_ID}, $ { APIKEY}, $ { METRIC_NAME} and $ { METRIC_VALUE} placeholders with the actual values. If you want to... Use this API call... Obtain all metric values Use the metric name to acquire all the metric values: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}\" Copy Obtain a single metric value Specify the metric name and the metric value: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}\" Copy Change the default time period and UTC Specify from and to values, and adjust for your time zone as applicable. For example: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true\" Copy Return average metric data Include &summarize=true in the API call; for example: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.60242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Listing metric timeslice data for <em>plugin</em> components (<em>v2</em>)",
        "sections": "Listing metric timeslice data for <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " a specific metric name and values To obtain a single metric name and the available metric values for a specific <em>plugin</em> component, replace the $ { COMPONENT_ID} and $ { METRIC_NAME} placeholders with the actual values in the following <em>API</em> call: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components"
      },
      "id": "60440d4664441f2a65378ee9"
    }
  ],
  "/docs/apis/rest-api-v2/plugin-examples-v2/get-list-plugins-v2": [
    {
      "sections": [
        "Get individual plugin components (v2)",
        "Tip",
        "List by component name",
        "List by component ID",
        "View the component's output"
      ],
      "title": "Get individual plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "8e5d5b5961b55a021ba90b40d6a352743a86a607",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-individual-plugin-components-v2/",
      "published_at": "2021-07-02T08:29:24Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API and your API key to obtain information about a single component for your plugin, including: The summary metric values in raw and formatted form as set by the plugin publisher Threshold data indicating where Caution and Critical alerts will be triggered The COMPONENT_ID and COMPONENT_NAME for the plugin Summary information, including SUMMARY_METRIC_ID and SUMMARY_METRIC_NAME The associated summary metric information, including METRIC_NAME and METRIC_VALUE You can use the API Explorer to list components. Tip When using these examples, be sure to replace each placeholder (for example, ${PLUGIN_ID}) with its specific ID. List by component name To obtain a list of the summary data values for a single component by name, use: curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${COMPONENT_NAME}\" Copy List by component ID To obtain a list of the summary data for a single component by its component ID, use one of the following commands. curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[id]=${COMPONENT_ID}\" Copy OR: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy View the component's output The output for each component ID will be similar to the following example (annotated and formatted for JSON). Due to the potential length of the output, you may want to paginate it. { \"components\": [ { \"id\": 3947935, <---<<< COMPONENT_ID \"name\": \"F5-01-prod\", <---<<< COMPONENT_NAME \"summary_metrics\": [ { \"id\": 116635, <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\", <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD }, \"values\": { \"raw\": 78.79225, <---<<< SUMMARY_METRIC_VALUE \"formatted\": \"78.8 %\" <---<<< Formatted SUMMARY_METRIC_VALUE } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", \"value_functions\": ... . . . } . . . ] } }, } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.00148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get individual <em>plugin</em> components (<em>v2</em>)",
        "sections": "Get individual <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " placeholder (for example, ${<em>PLUGIN</em>_ID}) with its specific ID. List by component name To obtain a list of the summary data values for a single component by name, use: curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components.json&#x27; \\ -H &quot;X-<em>Api</em>-Key:${APIKEY}&quot; -i \\ -d &quot;filter[name]=${COMPONENT_NAME}&quot; Copy List"
      },
      "id": "603eb58f196a6724b2a83dbf"
    },
    {
      "sections": [
        "List multiple plugin components (v2)",
        "Important",
        "List all components",
        "List by plugin_id",
        "View the components' output"
      ],
      "title": "List multiple plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "f2dd690f5c5cd2a1db2b41b9b29476b1b289659c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/list-multiple-plugin-components-v2/",
      "published_at": "2021-07-02T11:00:03Z",
      "updated_at": "2021-03-16T07:10:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API and your API key to obtain information about multiple components (instances) for your plugin, including: The summary metric in raw and formatted form as set by the plugin publisher Threshold data indicating when Caution and Critical alerts will be triggered Each COMPONENT_ID and COMPONENT_NAME for the plugin Summary information for each component, including SUMMARY_METRIC_ID and SUMMARY_METRIC_NAME The associated summary metric information, including METRIC_NAME and METRIC_VALUE You can use the API Explorer to list components. Important When using these examples, be sure to replace each placeholder (for example, ${PLUGIN_ID}) with its specific ID. List all components To obtain a list of the plugin's components (instances) and the summary data for the account associated with your API key, use: curl -X GET \"https://api.newrelic.com/v2/components.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy List by plugin_id To obtain a list of the plugin's components (instances) and summary data for a single ${PLUGIN_ID}, use the following command. curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[plugin_id]=${PLUGIN_ID}\" Copy View the components' output The output for each component ID will be similar to the following example, which is annotated and formatted for JSON. Due to the potential length of the output, you may want to paginate it. { \"components\": [ { \"id\": 3947935, <---<<< COMPONENT_ID \"name\": \"F5-01-prod\", <---<<< COMPONENT_NAME \"summary_metrics\": [ { \"id\": 116635, <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\", <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD }, \"values\": { \"raw\": 78.79225, <---<<< SUMMARY_METRIC_VALUE \"formatted\": \"78.8 %\" <---<<< SUMMARY_METRIC_FORMATTED_VALUE } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", ... }, ] }, .... ] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.99571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "List multiple <em>plugin</em> components (<em>v2</em>)",
        "sections": "List multiple <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " these <em>examples</em>, be sure to replace each placeholder (for example, ${<em>PLUGIN</em>_ID}) with its specific ID. List all components To obtain a list of the <em>plugin</em>&#x27;s components (instances) and the summary data for the account associated with your <em>API</em> key, use: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components.json&quot; \\ -H"
      },
      "id": "603eb58fe7b9d2fdc22a07c8"
    },
    {
      "sections": [
        "Listing metric timeslice data for plugin components (v2)",
        "Tip",
        "Listing a component's metric names",
        "Listing a specific metric name and values",
        "Specifying the metric data values"
      ],
      "title": "Listing metric timeslice data for plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "cd1b96e5c2803623faac8fb3d63df498097df4df",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/listing-metrics-plugin-components-v2/",
      "published_at": "2021-07-02T11:00:03Z",
      "updated_at": "2021-03-13T03:27:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API to obtain a list of metric timeslice data about your plugin's components (instances), including metric names and values, for the account associated with your API key. Tip When using these examples, be sure to replace each placeholder (for example, ${COMPONENT_ID}) with its specific ID. Listing a component's metric names To obtain a list of the metric names for a single component by its ${COMPONENT_ID}, use this API call: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy The output (JSON format) lists the metric name and values: { \"metrics\": [ { \"name\": \"Agent/MetricsReported/count\", <---<<< METRIC_NAME \"values\": [ \"average_response_time\", <---<<< METRIC_VALUES listing \"calls_per_minute\", \"call_count\", \"min_response_time\", \"max_response_time\", \"average_exclusive_time\", \"average_value\", \"requests_per_minute\", \"standard_deviation\" ] }, { \"name\": \"Component/Client SSL Profiles/Current Cache Entries//Common/clientssl-insecure-compatible[entries]\", \"values\": [ \"average_value\", \"total_value\", \"max_value\", \"min_value\", \"standard_deviation\", \"rate\", \"count\" ] }, ... } } Copy Listing a specific metric name and values To obtain a single metric name and the available metric values for a specific plugin component, replace the $ { COMPONENT_ID} and $ { METRIC_NAME} placeholders with the actual values in the following API call: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"name=${METRIC_NAME}\" Copy The output will be similar to what appears when you create an API call for multiple metric names. Specifying the metric data values To obtain the metric timeslice data for a specific component, use any of the following API calls. Be sure to replace the $ { COMPONENT_ID}, $ { APIKEY}, $ { METRIC_NAME} and $ { METRIC_VALUE} placeholders with the actual values. If you want to... Use this API call... Obtain all metric values Use the metric name to acquire all the metric values: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}\" Copy Obtain a single metric value Specify the metric name and the metric value: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}\" Copy Change the default time period and UTC Specify from and to values, and adjust for your time zone as applicable. For example: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true\" Copy Return average metric data Include &summarize=true in the API call; for example: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.60242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Listing metric timeslice data for <em>plugin</em> components (<em>v2</em>)",
        "sections": "Listing metric timeslice data for <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " a specific metric name and values To obtain a single metric name and the available metric values for a specific <em>plugin</em> component, replace the $ { COMPONENT_ID} and $ { METRIC_NAME} placeholders with the actual values in the following <em>API</em> call: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components"
      },
      "id": "60440d4664441f2a65378ee9"
    }
  ],
  "/docs/apis/rest-api-v2/plugin-examples-v2/list-multiple-plugin-components-v2": [
    {
      "sections": [
        "Get a list of plugins (v2)",
        "List all plugins",
        "List by plugin ID",
        "Filter by plugin ID or GUID",
        "Plugin list output",
        "Tip"
      ],
      "title": "Get a list of plugins (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "d8de5b6aeafe748d8d0eb8f9559319b60a7ea582",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-list-plugins-v2/",
      "published_at": "2021-07-02T10:58:50Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is an example of how to use the New Relic REST API (v2) to obtain a list of all plugins for the account associated with a REST API key, including: Each plugin ID, plugin name, and GUID A list of summary metrics available for each of the components, including component IDs, names, and other values You can also use the API Explorer to list plugins. List all plugins To obtain a list of the plugins, use: curl -X GET \"https://api.newrelic.com/v2/plugins.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can also use the New Relic API explorer to list information for all plugins. List by plugin ID To list the components defined for a single plugin, if you know the plugin's ID, use: curl -X GET \"https://api.newrelic.com/v2/plugins/${PLUGIN_ID}.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can also use the New Relic API explorer to list information for a single plugin. Filter by plugin ID or GUID To filter the plugins list by GUID or plugin ID, replace the [guid] and ids with your values: curl -X GET 'https://api.newrelic.com/v2/plugins.json' \\ -H 'X-Api-Key:' -i \\ -d 'filter[guid]=mysql' Copy curl -X GET 'https://api.newrelic.com/v2/plugins.json' \\ -H 'X-Api-Key:' -i \\ -d 'filter[ids]=123,234' Copy Plugin list output The output is in JSON format, but you can modify this by specifying plugins.xml rather than plugins.json. The output will appear in the following format (for JSON). Tip PIugin queries can result in a large quantity of data. For more information about formatting the output or viewing multiple pages, see Pagination for API output. { \"plugins\": [ { \"id\": 9568, <---<<< PLUGIN_ID \"name\": \"F5 LTM\", <---<<< PLUGIN_NAME \"guid\": \"com.newrelic.f5\", <---<<< PLUGIN_GUID \"publisher\": \"New Relic Inc.\", \"summary_metrics\": [ { \"id\": 116635,> <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\",> <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", \"value_function\": \"average_value\", \"thresholds\": { \"caution\": null, \"critical\": null } }, ..... } } ] ... Copy The output contains the summary_metrics that have been defined for the plugin. The summary_metric values are listed for each component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.46622,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get a list of <em>plugins</em> (<em>v2</em>)",
        "sections": "Get a list of <em>plugins</em> (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here is an example of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain a list of all plugins for the account associated with a <em>REST</em> <em>API</em> key, including: Each <em>plugin</em> ID, <em>plugin</em> name, and GUID A list of summary metrics available for each of the components, including component IDs, names, and other"
      },
      "id": "603eb55a28ccbca0bbeba78a"
    },
    {
      "sections": [
        "Get individual plugin components (v2)",
        "Tip",
        "List by component name",
        "List by component ID",
        "View the component's output"
      ],
      "title": "Get individual plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "8e5d5b5961b55a021ba90b40d6a352743a86a607",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-individual-plugin-components-v2/",
      "published_at": "2021-07-02T08:29:24Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API and your API key to obtain information about a single component for your plugin, including: The summary metric values in raw and formatted form as set by the plugin publisher Threshold data indicating where Caution and Critical alerts will be triggered The COMPONENT_ID and COMPONENT_NAME for the plugin Summary information, including SUMMARY_METRIC_ID and SUMMARY_METRIC_NAME The associated summary metric information, including METRIC_NAME and METRIC_VALUE You can use the API Explorer to list components. Tip When using these examples, be sure to replace each placeholder (for example, ${PLUGIN_ID}) with its specific ID. List by component name To obtain a list of the summary data values for a single component by name, use: curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${COMPONENT_NAME}\" Copy List by component ID To obtain a list of the summary data for a single component by its component ID, use one of the following commands. curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[id]=${COMPONENT_ID}\" Copy OR: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy View the component's output The output for each component ID will be similar to the following example (annotated and formatted for JSON). Due to the potential length of the output, you may want to paginate it. { \"components\": [ { \"id\": 3947935, <---<<< COMPONENT_ID \"name\": \"F5-01-prod\", <---<<< COMPONENT_NAME \"summary_metrics\": [ { \"id\": 116635, <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\", <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD }, \"values\": { \"raw\": 78.79225, <---<<< SUMMARY_METRIC_VALUE \"formatted\": \"78.8 %\" <---<<< Formatted SUMMARY_METRIC_VALUE } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", \"value_functions\": ... . . . } . . . ] } }, } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.00148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get individual <em>plugin</em> components (<em>v2</em>)",
        "sections": "Get individual <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " placeholder (for example, ${<em>PLUGIN</em>_ID}) with its specific ID. List by component name To obtain a list of the summary data values for a single component by name, use: curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components.json&#x27; \\ -H &quot;X-<em>Api</em>-Key:${APIKEY}&quot; -i \\ -d &quot;filter[name]=${COMPONENT_NAME}&quot; Copy List"
      },
      "id": "603eb58f196a6724b2a83dbf"
    },
    {
      "sections": [
        "Listing metric timeslice data for plugin components (v2)",
        "Tip",
        "Listing a component's metric names",
        "Listing a specific metric name and values",
        "Specifying the metric data values"
      ],
      "title": "Listing metric timeslice data for plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "cd1b96e5c2803623faac8fb3d63df498097df4df",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/listing-metrics-plugin-components-v2/",
      "published_at": "2021-07-02T11:00:03Z",
      "updated_at": "2021-03-13T03:27:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API to obtain a list of metric timeslice data about your plugin's components (instances), including metric names and values, for the account associated with your API key. Tip When using these examples, be sure to replace each placeholder (for example, ${COMPONENT_ID}) with its specific ID. Listing a component's metric names To obtain a list of the metric names for a single component by its ${COMPONENT_ID}, use this API call: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy The output (JSON format) lists the metric name and values: { \"metrics\": [ { \"name\": \"Agent/MetricsReported/count\", <---<<< METRIC_NAME \"values\": [ \"average_response_time\", <---<<< METRIC_VALUES listing \"calls_per_minute\", \"call_count\", \"min_response_time\", \"max_response_time\", \"average_exclusive_time\", \"average_value\", \"requests_per_minute\", \"standard_deviation\" ] }, { \"name\": \"Component/Client SSL Profiles/Current Cache Entries//Common/clientssl-insecure-compatible[entries]\", \"values\": [ \"average_value\", \"total_value\", \"max_value\", \"min_value\", \"standard_deviation\", \"rate\", \"count\" ] }, ... } } Copy Listing a specific metric name and values To obtain a single metric name and the available metric values for a specific plugin component, replace the $ { COMPONENT_ID} and $ { METRIC_NAME} placeholders with the actual values in the following API call: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"name=${METRIC_NAME}\" Copy The output will be similar to what appears when you create an API call for multiple metric names. Specifying the metric data values To obtain the metric timeslice data for a specific component, use any of the following API calls. Be sure to replace the $ { COMPONENT_ID}, $ { APIKEY}, $ { METRIC_NAME} and $ { METRIC_VALUE} placeholders with the actual values. If you want to... Use this API call... Obtain all metric values Use the metric name to acquire all the metric values: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}\" Copy Obtain a single metric value Specify the metric name and the metric value: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}\" Copy Change the default time period and UTC Specify from and to values, and adjust for your time zone as applicable. For example: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true\" Copy Return average metric data Include &summarize=true in the API call; for example: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"names[]=${METRIC_NAME}&values[]=${METRIC_VALUE}&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.60242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Listing metric timeslice data for <em>plugin</em> components (<em>v2</em>)",
        "sections": "Listing metric timeslice data for <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " a specific metric name and values To obtain a single metric name and the available metric values for a specific <em>plugin</em> component, replace the $ { COMPONENT_ID} and $ { METRIC_NAME} placeholders with the actual values in the following <em>API</em> call: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components"
      },
      "id": "60440d4664441f2a65378ee9"
    }
  ],
  "/docs/apis/rest-api-v2/plugin-examples-v2/listing-metrics-plugin-components-v2": [
    {
      "sections": [
        "Get a list of plugins (v2)",
        "List all plugins",
        "List by plugin ID",
        "Filter by plugin ID or GUID",
        "Plugin list output",
        "Tip"
      ],
      "title": "Get a list of plugins (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "d8de5b6aeafe748d8d0eb8f9559319b60a7ea582",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-list-plugins-v2/",
      "published_at": "2021-07-02T10:58:50Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is an example of how to use the New Relic REST API (v2) to obtain a list of all plugins for the account associated with a REST API key, including: Each plugin ID, plugin name, and GUID A list of summary metrics available for each of the components, including component IDs, names, and other values You can also use the API Explorer to list plugins. List all plugins To obtain a list of the plugins, use: curl -X GET \"https://api.newrelic.com/v2/plugins.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can also use the New Relic API explorer to list information for all plugins. List by plugin ID To list the components defined for a single plugin, if you know the plugin's ID, use: curl -X GET \"https://api.newrelic.com/v2/plugins/${PLUGIN_ID}.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can also use the New Relic API explorer to list information for a single plugin. Filter by plugin ID or GUID To filter the plugins list by GUID or plugin ID, replace the [guid] and ids with your values: curl -X GET 'https://api.newrelic.com/v2/plugins.json' \\ -H 'X-Api-Key:' -i \\ -d 'filter[guid]=mysql' Copy curl -X GET 'https://api.newrelic.com/v2/plugins.json' \\ -H 'X-Api-Key:' -i \\ -d 'filter[ids]=123,234' Copy Plugin list output The output is in JSON format, but you can modify this by specifying plugins.xml rather than plugins.json. The output will appear in the following format (for JSON). Tip PIugin queries can result in a large quantity of data. For more information about formatting the output or viewing multiple pages, see Pagination for API output. { \"plugins\": [ { \"id\": 9568, <---<<< PLUGIN_ID \"name\": \"F5 LTM\", <---<<< PLUGIN_NAME \"guid\": \"com.newrelic.f5\", <---<<< PLUGIN_GUID \"publisher\": \"New Relic Inc.\", \"summary_metrics\": [ { \"id\": 116635,> <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\",> <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", \"value_function\": \"average_value\", \"thresholds\": { \"caution\": null, \"critical\": null } }, ..... } } ] ... Copy The output contains the summary_metrics that have been defined for the plugin. The summary_metric values are listed for each component.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.46622,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get a list of <em>plugins</em> (<em>v2</em>)",
        "sections": "Get a list of <em>plugins</em> (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here is an example of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain a list of all plugins for the account associated with a <em>REST</em> <em>API</em> key, including: Each <em>plugin</em> ID, <em>plugin</em> name, and GUID A list of summary metrics available for each of the components, including component IDs, names, and other"
      },
      "id": "603eb55a28ccbca0bbeba78a"
    },
    {
      "sections": [
        "Get individual plugin components (v2)",
        "Tip",
        "List by component name",
        "List by component ID",
        "View the component's output"
      ],
      "title": "Get individual plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "8e5d5b5961b55a021ba90b40d6a352743a86a607",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/get-individual-plugin-components-v2/",
      "published_at": "2021-07-02T08:29:24Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API and your API key to obtain information about a single component for your plugin, including: The summary metric values in raw and formatted form as set by the plugin publisher Threshold data indicating where Caution and Critical alerts will be triggered The COMPONENT_ID and COMPONENT_NAME for the plugin Summary information, including SUMMARY_METRIC_ID and SUMMARY_METRIC_NAME The associated summary metric information, including METRIC_NAME and METRIC_VALUE You can use the API Explorer to list components. Tip When using these examples, be sure to replace each placeholder (for example, ${PLUGIN_ID}) with its specific ID. List by component name To obtain a list of the summary data values for a single component by name, use: curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${COMPONENT_NAME}\" Copy List by component ID To obtain a list of the summary data for a single component by its component ID, use one of the following commands. curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[id]=${COMPONENT_ID}\" Copy OR: curl -X GET \"https://api.newrelic.com/v2/components/${COMPONENT_ID}.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy View the component's output The output for each component ID will be similar to the following example (annotated and formatted for JSON). Due to the potential length of the output, you may want to paginate it. { \"components\": [ { \"id\": 3947935, <---<<< COMPONENT_ID \"name\": \"F5-01-prod\", <---<<< COMPONENT_NAME \"summary_metrics\": [ { \"id\": 116635, <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\", <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD }, \"values\": { \"raw\": 78.79225, <---<<< SUMMARY_METRIC_VALUE \"formatted\": \"78.8 %\" <---<<< Formatted SUMMARY_METRIC_VALUE } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", \"value_functions\": ... . . . } . . . ] } }, } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.00148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get individual <em>plugin</em> components (<em>v2</em>)",
        "sections": "Get individual <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " placeholder (for example, ${<em>PLUGIN</em>_ID}) with its specific ID. List by component name To obtain a list of the summary data values for a single component by name, use: curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components.json&#x27; \\ -H &quot;X-<em>Api</em>-Key:${APIKEY}&quot; -i \\ -d &quot;filter[name]=${COMPONENT_NAME}&quot; Copy List"
      },
      "id": "603eb58f196a6724b2a83dbf"
    },
    {
      "sections": [
        "List multiple plugin components (v2)",
        "Important",
        "List all components",
        "List by plugin_id",
        "View the components' output"
      ],
      "title": "List multiple plugin components (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Plugin examples (v2)"
      ],
      "external_id": "f2dd690f5c5cd2a1db2b41b9b29476b1b289659c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/plugin-examples-v2/list-multiple-plugin-components-v2/",
      "published_at": "2021-07-02T11:00:03Z",
      "updated_at": "2021-03-16T07:10:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's REST API and your API key to obtain information about multiple components (instances) for your plugin, including: The summary metric in raw and formatted form as set by the plugin publisher Threshold data indicating when Caution and Critical alerts will be triggered Each COMPONENT_ID and COMPONENT_NAME for the plugin Summary information for each component, including SUMMARY_METRIC_ID and SUMMARY_METRIC_NAME The associated summary metric information, including METRIC_NAME and METRIC_VALUE You can use the API Explorer to list components. Important When using these examples, be sure to replace each placeholder (for example, ${PLUGIN_ID}) with its specific ID. List all components To obtain a list of the plugin's components (instances) and the summary data for the account associated with your API key, use: curl -X GET \"https://api.newrelic.com/v2/components.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i Copy List by plugin_id To obtain a list of the plugin's components (instances) and summary data for a single ${PLUGIN_ID}, use the following command. curl -X GET 'https://api.newrelic.com/v2/components.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[plugin_id]=${PLUGIN_ID}\" Copy View the components' output The output for each component ID will be similar to the following example, which is annotated and formatted for JSON. Due to the potential length of the output, you may want to paginate it. { \"components\": [ { \"id\": 3947935, <---<<< COMPONENT_ID \"name\": \"F5-01-prod\", <---<<< COMPONENT_NAME \"summary_metrics\": [ { \"id\": 116635, <---<<< SUMMARY_METRIC_ID \"name\": \"CPU\", <---<<< SUMMARY_METRIC_NAME \"metric\": \"Component/CPU/Total/Global[%]\", <---<<< METRIC_NAME \"value_function\": \"average_value\", <---<<< METRIC_VALUE \"thresholds\": { \"caution\": 75, <---<<< SUMMARY_METRIC_CAUTION_THRESHOLD \"critical\": 85 <---<<< SUMMARY_METRIC_CRITICAL_THRESHOLD }, \"values\": { \"raw\": 78.79225, <---<<< SUMMARY_METRIC_VALUE \"formatted\": \"78.8 %\" <---<<< SUMMARY_METRIC_FORMATTED_VALUE } }, { \"id\": 116636, \"name\": \"Throughput\", \"metric\": \"Component/Throughput/Total[bits/sec]\", ... }, ] }, .... ] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.99571,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "List multiple <em>plugin</em> components (<em>v2</em>)",
        "sections": "List multiple <em>plugin</em> components (<em>v2</em>)",
        "tags": "<em>Plugin</em> <em>examples</em> (<em>v2</em>)",
        "body": " these <em>examples</em>, be sure to replace each placeholder (for example, ${<em>PLUGIN</em>_ID}) with its specific ID. List all components To obtain a list of the <em>plugin</em>&#x27;s components (instances) and the summary data for the account associated with your <em>API</em> key, use: curl -X GET &quot;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;components.json&quot; \\ -H"
      },
      "id": "603eb58fe7b9d2fdc22a07c8"
    }
  ],
  "/docs/apis/rest-api-v2/troubleshooting/301-response-rest-api-calls": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.93134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.13766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> Explorer. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "500 error when starting the API Explorer",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "500 error when starting the API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Troubleshooting"
      ],
      "external_id": "0d2e9b27f827da7773a3a53c032ba4e00faf5a0e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/troubleshooting/500-error-when-starting-api-explorer/",
      "published_at": "2021-07-02T08:48:28Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A 500 error appears when starting the API Explorer. Solution To correct this, make sure you have a default account: Go to one.newrelic.com > (account dropdown) > User preferences. From the Default account dropdown, select your choice, then save. Cause This occurs when you do not have a current or valid default New Relic account associated with your login. This keeps the Explorer from displaying the API keys available to you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.37164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "500 error when starting the <em>API</em> Explorer",
        "sections": "500 error when starting the <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "Problem A 500 error appears when starting the <em>API</em> Explorer. Solution To correct this, make sure you have a default account: Go to one.newrelic.com &gt; (account dropdown) &gt; User preferences. From the Default account dropdown, select your choice, then save. Cause This occurs when you do not have a current or valid default New Relic account associated with your login. This keeps the Explorer from displaying the <em>API</em> keys available to you."
      },
      "id": "603ea7aee7b9d214cc2a080b"
    }
  ],
  "/docs/apis/rest-api-v2/troubleshooting/500-error-when-starting-api-explorer": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.93134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.13766,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> Explorer. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "200 Status with API Explorer",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "200 Status with API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Troubleshooting"
      ],
      "external_id": "44ed18edf91f49851578684a113202050b4dbf42",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/troubleshooting/http-200-status-api-explorer/",
      "published_at": "2021-07-02T09:07:29Z",
      "updated_at": "2021-03-16T06:31:22Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You received an HTTP 200 status code, but the message body is empty. Solution To correct this, add an Accept header containing application/json or application/xml to your GET request. For example: curl -X GET 'https://api.newrelic.com/v2/applications/YOUR_APP_ID/metrics/data.json' -H 'X-Api-Key:YOUR_API_KEY' -i -H 'Accept: application/json' Copy Cause This may occur when using a default GET header that does not specify the accepted content type. For more information on HTTP headers, see this tutorial on Content negotiation using HTTP headers.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.36469,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>200</em> Status with <em>API</em> Explorer",
        "sections": "<em>200</em> Status with <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "Problem You received an HTTP 200 status code, but the message body is empty. Solution To correct this, add an Accept header containing application&#x2F;json or application&#x2F;xml to your GET request. For example: curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;YOUR_APP_ID&#x2F;metrics&#x2F;data.json&#x27; -H &#x27;X-<em>Api</em>"
      },
      "id": "603ec2d4196a676e02a83dbe"
    }
  ],
  "/docs/apis/rest-api-v2/troubleshooting/http-200-status-api-explorer": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2021-07-02T08:53:57Z",
      "updated_at": "2021-03-13T03:10:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Plugin API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.93134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip",
        "For more help"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2021-07-02T08:44:28Z",
      "updated_at": "2021-06-20T20:42:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.13765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> Explorer. For more help"
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "500 error when starting the API Explorer",
        "Problem",
        "Solution",
        "Cause"
      ],
      "title": "500 error when starting the API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Troubleshooting"
      ],
      "external_id": "0d2e9b27f827da7773a3a53c032ba4e00faf5a0e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/troubleshooting/500-error-when-starting-api-explorer/",
      "published_at": "2021-07-02T08:48:28Z",
      "updated_at": "2021-03-16T08:15:46Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem A 500 error appears when starting the API Explorer. Solution To correct this, make sure you have a default account: Go to one.newrelic.com > (account dropdown) > User preferences. From the Default account dropdown, select your choice, then save. Cause This occurs when you do not have a current or valid default New Relic account associated with your login. This keeps the Explorer from displaying the API keys available to you.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.37164,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "500 error when starting the <em>API</em> Explorer",
        "sections": "500 error when starting the <em>API</em> Explorer",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "Problem A 500 error appears when starting the <em>API</em> Explorer. Solution To correct this, make sure you have a default account: Go to one.newrelic.com &gt; (account dropdown) &gt; User preferences. From the Default account dropdown, select your choice, then save. Cause This occurs when you do not have a current or valid default New Relic account associated with your login. This keeps the Explorer from displaying the <em>API</em> keys available to you."
      },
      "id": "603ea7aee7b9d214cc2a080b"
    }
  ],
  "/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api": [
    {
      "sections": [
        "Synthetics REST API version 1 (deprecated)",
        "Caution",
        "Managing simple and scripted monitors",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Delete an existing monitor",
        "Get list of valid locations",
        "Managing scripted monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Synthetics attributes",
        "Specific monitor endpoint",
        "For more help"
      ],
      "title": "Synthetics REST API version 1 (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "38f3b7d441889cea39fa8a10d1593473bffa8cf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1/",
      "published_at": "2021-07-02T02:23:51Z",
      "updated_at": "2021-03-13T03:47:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the Synthetics API: v1 and v3. Version 3 was released October 2016. Version 1 is deprecated and will eventually no longer be available. No termination date has been announced. However, no further development or modifications will be made to v1. Caution Recommendation: Create new monitors using the v3 Synthetics API and migrate v1 scripts to their v3 equivalent. To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls via the command line. Managing simple and scripted monitors You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. These examples show curl commands: Get all monitors To view a list of all monitors in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors. For example: curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"count\": integer, \"monitors\": [ { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } ] } Copy Get a specific monitor To view a single existing monitor in New Relic, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return the error 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your account in New Relic, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/monitors with a JSON payload that describes the monitor: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings (send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/locations to get a list of valid locations) [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, } Copy In addition, to add a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. Replace the Synthetics REST API attributes in the following example with your specific values. curl -v \\ -X POST -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. Replace the { id} in the following example with the specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} \\ -d '{ \"name\" : \"updated monitor name\", \"type\" : \"simple\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response, 404 Not Found: The specified monitor does not exist. Get list of valid locations To retrieve the list of valid locations in New Relic, use the following command. curl -v \\ -X GET -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/locations Copy Managing scripted monitors In addition to the general API, there are several API methods for the monitor types Scripted Browser (SCRIPT_BROWSER) and API Test (SCRIPT_API). These examples show curl commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script. Replace the { id} with the specific monitor ID. For example: curl -v -H 'X-Api-Key: {Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the ${MONITOR_UUID}/script endpoint. For more information, refer to the example. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script with a JSON payload that contains the scriptText (required). The scriptLocations data is required only for private locations with Verified Script Execution turned on. The password used to generate the HMAC string must match the password set for the private location. When generating the HMAC string, use the SHA256 algorithm. { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy Replace the { id} with the specific monitor ID. Here is an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation. curl -v -H 'X-Api-Key: '{Admin_User_Key}' -H 'content-type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4\"} ]}' Copy A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows curl commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example show the bash script that will create the SCRIPTED_BROWSER monitor. #!/bin/bash # Admin API key from your account settings adminAPIKey='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload='{\"scriptText\":\"'$encoded'\"}' curl -s -X PUT -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy Synthetics attributes Here are the attributes used with Synthetics REST API calls, listed in alphabetical order. Synthetics API attribute Definition apiVersion String: The version number. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific Synthetics monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected Synthetics monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/. For more help Additional documentation resources include: Manage Synthetics monitors via the REST API (v3) (Synthetics API version 3) Manage Synthetics alert notifications via the REST API (REST API calls for email alerts for New Relic monitors) Use Synthetics label APIs (REST API calls for labels and categories used by New Relic monitors)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.22768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "sections": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " the SCRIPTED_BROWSER <em>monitor</em>. #!&#x2F;bin&#x2F;bash # Admin <em>API</em> key from your account settings adminAPIKey=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>Type=&#x27;SCRIPT_BROWSER"
      },
      "id": "60452541e7b9d27829579a0a"
    },
    {
      "sections": [
        "Payload attributes for the Synthetics REST API",
        "Synthetic monitoring attributes",
        "Specific monitor endpoint",
        "For more help"
      ],
      "title": "Payload attributes for the Synthetics REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "ed3202f6715ae367d5c7c58d63a332d073535995",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api/",
      "published_at": "2021-07-02T11:24:38Z",
      "updated_at": "2021-03-11T11:46:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For REST API requirements for synthetics, see Use the API. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the Synthetics REST API: Synthetics API attribute Definition apiVersion String: The version number. count Integer: The number of monitors returned. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific synthetic monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. options Object: options for SIMPLE and BROWSER monitor types. Options include: validationString: string verifySSL: boolean (true, false) bypassHEADRequest: boolean (true, false) treatRedirectAsFailure: boolean (true, false) Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected synthetic monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/. For more help Additional documentation resources include: Manage synthetic monitors via the REST API (API procedures for synthetic simple and scripted monitors) Manage synthetic alert notifications via the REST API (REST API calls for email alerts for synthetic monitors) Use synthetics label APIs (REST API calls for labels and categories used by synthetic monitors)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.05615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "sections": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " The <em>monitor</em>_uuid is the value that follows &#x2F;monitors&#x2F;. For more help Additional documentation resources include: Manage synthetic monitors via the <em>REST</em> <em>API</em> (<em>API</em> procedures for synthetic simple and scripted monitors) Manage synthetic alert notifications via the <em>REST</em> <em>API</em> (<em>REST</em> <em>API</em> calls for email alerts for synthetic monitors) Use <em>synthetics</em> label <em>APIs</em> (<em>REST</em> <em>API</em> calls for labels and categories used by synthetic monitors)"
      },
      "id": "6043f9ae28ccbc98002c607a"
    },
    {
      "sections": [
        "Use synthetic monitoring secure credentials APIs",
        "Requirements and rules",
        "API examples",
        "Add a secure credential",
        "Get all secure credentials",
        "Get a specific secure credential",
        "Update an existing secure credential",
        "Delete an existing secure credential",
        "For more help"
      ],
      "title": "Use synthetic monitoring secure credentials APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Secure credentials examples"
      ],
      "external_id": "bd66e43160c1fd4c9f66bfdfa2d9a3223eb5d4d7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/secure-credentials-examples/use-synthetics-secure-credentials-apis/",
      "published_at": "2021-07-02T09:19:49Z",
      "updated_at": "2021-03-13T05:09:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Synthetics REST API, you can make API calls to change or retrieve secure credentials data. This document explains the API requirements and contains API curl command examples. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials. Requirements and rules For general rules about this feature, see the secure credentials requirements. API requirements and rules include: See general Synthetics REST API requirements. An account's rate of requests is limited to three requests per second. Requests that exceed this threshold will return a 429 response code. A key's value cannot be accessed via the API; an unauthorized user would not have access to the secure key values. API examples Add a secure credential To send a secure credential to your New Relic account, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials with a JSON payload that describes the secure credential. Here's an example: { \"key\": string [required, 1-64 characters uppercase], \"value\": string [required, 1-3,000 characters], \"description\": string [optional] } Copy Here's an example of doing this with a curl command: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy A successful request will return a 201 Created response, with the URI of the newly-created secure credential specified in the location header. Possible error codes include: 303 See Other: The specified key already exists. The returned location header will contain the URI to the key. 400 Bad Request: Key too long or missing, value too long or missing, non-parsable JSON payload. Get all secure credentials To view a list of all the secure credentials in your New Relic account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials. For example: curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"secureCredentials\": [ { \"key\": \"MYKEY1\", \"description\": \"Description of MYKEY1\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" }, { \"key\": \"MYKEY2\", \"description\": \"Description of MYKEY2\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" } ], \"count\": 2 } Copy Get a specific secure credential To view a single secure credential, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"key\": string, \"description\": string, \"createdAt\": date,​ \"lastUpdated\": date } Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Update an existing secure credential To update an existing credential in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Delete an existing secure credential To delete an existing credential in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy Please note that if the specified key does not exist, no error will occur. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.111145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "sections": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": "With the <em>Synthetics</em> <em>REST</em> <em>API</em>, you can make <em>API</em> calls to change or retrieve secure credentials data. This document explains the <em>API</em> requirements and contains <em>API</em> curl command <em>examples</em>. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials"
      },
      "id": "6044070d196a67b171960f76"
    }
  ],
  "/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api": [
    {
      "sections": [
        "Synthetics REST API version 1 (deprecated)",
        "Caution",
        "Managing simple and scripted monitors",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Delete an existing monitor",
        "Get list of valid locations",
        "Managing scripted monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Synthetics attributes",
        "Specific monitor endpoint",
        "For more help"
      ],
      "title": "Synthetics REST API version 1 (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "38f3b7d441889cea39fa8a10d1593473bffa8cf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1/",
      "published_at": "2021-07-02T02:23:51Z",
      "updated_at": "2021-03-13T03:47:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the Synthetics API: v1 and v3. Version 3 was released October 2016. Version 1 is deprecated and will eventually no longer be available. No termination date has been announced. However, no further development or modifications will be made to v1. Caution Recommendation: Create new monitors using the v3 Synthetics API and migrate v1 scripts to their v3 equivalent. To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls via the command line. Managing simple and scripted monitors You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. These examples show curl commands: Get all monitors To view a list of all monitors in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors. For example: curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"count\": integer, \"monitors\": [ { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } ] } Copy Get a specific monitor To view a single existing monitor in New Relic, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return the error 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your account in New Relic, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/monitors with a JSON payload that describes the monitor: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings (send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/locations to get a list of valid locations) [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, } Copy In addition, to add a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. Replace the Synthetics REST API attributes in the following example with your specific values. curl -v \\ -X POST -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. Replace the { id} in the following example with the specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} \\ -d '{ \"name\" : \"updated monitor name\", \"type\" : \"simple\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response, 404 Not Found: The specified monitor does not exist. Get list of valid locations To retrieve the list of valid locations in New Relic, use the following command. curl -v \\ -X GET -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/locations Copy Managing scripted monitors In addition to the general API, there are several API methods for the monitor types Scripted Browser (SCRIPT_BROWSER) and API Test (SCRIPT_API). These examples show curl commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script. Replace the { id} with the specific monitor ID. For example: curl -v -H 'X-Api-Key: {Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the ${MONITOR_UUID}/script endpoint. For more information, refer to the example. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script with a JSON payload that contains the scriptText (required). The scriptLocations data is required only for private locations with Verified Script Execution turned on. The password used to generate the HMAC string must match the password set for the private location. When generating the HMAC string, use the SHA256 algorithm. { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy Replace the { id} with the specific monitor ID. Here is an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation. curl -v -H 'X-Api-Key: '{Admin_User_Key}' -H 'content-type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4\"} ]}' Copy A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows curl commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example show the bash script that will create the SCRIPTED_BROWSER monitor. #!/bin/bash # Admin API key from your account settings adminAPIKey='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload='{\"scriptText\":\"'$encoded'\"}' curl -s -X PUT -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy Synthetics attributes Here are the attributes used with Synthetics REST API calls, listed in alphabetical order. Synthetics API attribute Definition apiVersion String: The version number. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific Synthetics monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected Synthetics monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/. For more help Additional documentation resources include: Manage Synthetics monitors via the REST API (v3) (Synthetics API version 3) Manage Synthetics alert notifications via the REST API (REST API calls for email alerts for New Relic monitors) Use Synthetics label APIs (REST API calls for labels and categories used by New Relic monitors)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.22768,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "sections": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " the SCRIPTED_BROWSER <em>monitor</em>. #!&#x2F;bin&#x2F;bash # Admin <em>API</em> key from your account settings adminAPIKey=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>Type=&#x27;SCRIPT_BROWSER"
      },
      "id": "60452541e7b9d27829579a0a"
    },
    {
      "sections": [
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Caution",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Patch an existing monitor",
        "Delete an existing monitor",
        "Get a list of valid locations",
        "Script API for scripted browser and API test monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Using private location scripts with verified script execution",
        "Important",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Tip"
      ],
      "title": "Manage synthetic monitors via REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "83a3e8ad751c7f0865785a1c2fad193604a7f7da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api/",
      "published_at": "2021-07-02T09:34:31Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api Copy For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api Copy Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Copy Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 20. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' Copy The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Copy Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } Copy In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' Copy PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Copy Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted Browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload Copy If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' Copy Important You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. Tip In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.05157,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "sections": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " will disable line wrapping: base64 -w 0 $scriptfile #!&#x2F;bin&#x2F;bash # <em>API</em> key from your account settings <em>API</em>_KEY=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>"
      },
      "id": "60440d4628ccbc74532c606a"
    },
    {
      "sections": [
        "Use synthetic monitoring secure credentials APIs",
        "Requirements and rules",
        "API examples",
        "Add a secure credential",
        "Get all secure credentials",
        "Get a specific secure credential",
        "Update an existing secure credential",
        "Delete an existing secure credential",
        "For more help"
      ],
      "title": "Use synthetic monitoring secure credentials APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Secure credentials examples"
      ],
      "external_id": "bd66e43160c1fd4c9f66bfdfa2d9a3223eb5d4d7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/secure-credentials-examples/use-synthetics-secure-credentials-apis/",
      "published_at": "2021-07-02T09:19:49Z",
      "updated_at": "2021-03-13T05:09:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Synthetics REST API, you can make API calls to change or retrieve secure credentials data. This document explains the API requirements and contains API curl command examples. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials. Requirements and rules For general rules about this feature, see the secure credentials requirements. API requirements and rules include: See general Synthetics REST API requirements. An account's rate of requests is limited to three requests per second. Requests that exceed this threshold will return a 429 response code. A key's value cannot be accessed via the API; an unauthorized user would not have access to the secure key values. API examples Add a secure credential To send a secure credential to your New Relic account, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials with a JSON payload that describes the secure credential. Here's an example: { \"key\": string [required, 1-64 characters uppercase], \"value\": string [required, 1-3,000 characters], \"description\": string [optional] } Copy Here's an example of doing this with a curl command: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy A successful request will return a 201 Created response, with the URI of the newly-created secure credential specified in the location header. Possible error codes include: 303 See Other: The specified key already exists. The returned location header will contain the URI to the key. 400 Bad Request: Key too long or missing, value too long or missing, non-parsable JSON payload. Get all secure credentials To view a list of all the secure credentials in your New Relic account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials. For example: curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"secureCredentials\": [ { \"key\": \"MYKEY1\", \"description\": \"Description of MYKEY1\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" }, { \"key\": \"MYKEY2\", \"description\": \"Description of MYKEY2\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" } ], \"count\": 2 } Copy Get a specific secure credential To view a single secure credential, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"key\": string, \"description\": string, \"createdAt\": date,​ \"lastUpdated\": date } Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Update an existing secure credential To update an existing credential in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Delete an existing secure credential To delete an existing credential in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy Please note that if the specified key does not exist, no error will occur. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.111145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "sections": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": "With the <em>Synthetics</em> <em>REST</em> <em>API</em>, you can make <em>API</em> calls to change or retrieve secure credentials data. This document explains the <em>API</em> requirements and contains <em>API</em> curl command <em>examples</em>. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials"
      },
      "id": "6044070d196a67b171960f76"
    }
  ],
  "/docs/apis/synthetics-rest-api/secure-credentials-examples/use-synthetics-secure-credentials-apis": [
    {
      "sections": [
        "Synthetics REST API version 1 (deprecated)",
        "Caution",
        "Managing simple and scripted monitors",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Delete an existing monitor",
        "Get list of valid locations",
        "Managing scripted monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Synthetics attributes",
        "Specific monitor endpoint",
        "For more help"
      ],
      "title": "Synthetics REST API version 1 (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "38f3b7d441889cea39fa8a10d1593473bffa8cf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1/",
      "published_at": "2021-07-02T02:23:51Z",
      "updated_at": "2021-03-13T03:47:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the Synthetics API: v1 and v3. Version 3 was released October 2016. Version 1 is deprecated and will eventually no longer be available. No termination date has been announced. However, no further development or modifications will be made to v1. Caution Recommendation: Create new monitors using the v3 Synthetics API and migrate v1 scripts to their v3 equivalent. To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls via the command line. Managing simple and scripted monitors You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. These examples show curl commands: Get all monitors To view a list of all monitors in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors. For example: curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"count\": integer, \"monitors\": [ { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } ] } Copy Get a specific monitor To view a single existing monitor in New Relic, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return the error 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your account in New Relic, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/monitors with a JSON payload that describes the monitor: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings (send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/locations to get a list of valid locations) [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, } Copy In addition, to add a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. Replace the Synthetics REST API attributes in the following example with your specific values. curl -v \\ -X POST -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. Replace the { id} in the following example with the specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} \\ -d '{ \"name\" : \"updated monitor name\", \"type\" : \"simple\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response, 404 Not Found: The specified monitor does not exist. Get list of valid locations To retrieve the list of valid locations in New Relic, use the following command. curl -v \\ -X GET -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/locations Copy Managing scripted monitors In addition to the general API, there are several API methods for the monitor types Scripted Browser (SCRIPT_BROWSER) and API Test (SCRIPT_API). These examples show curl commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script. Replace the { id} with the specific monitor ID. For example: curl -v -H 'X-Api-Key: {Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the ${MONITOR_UUID}/script endpoint. For more information, refer to the example. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script with a JSON payload that contains the scriptText (required). The scriptLocations data is required only for private locations with Verified Script Execution turned on. The password used to generate the HMAC string must match the password set for the private location. When generating the HMAC string, use the SHA256 algorithm. { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy Replace the { id} with the specific monitor ID. Here is an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation. curl -v -H 'X-Api-Key: '{Admin_User_Key}' -H 'content-type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4\"} ]}' Copy A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows curl commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example show the bash script that will create the SCRIPTED_BROWSER monitor. #!/bin/bash # Admin API key from your account settings adminAPIKey='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload='{\"scriptText\":\"'$encoded'\"}' curl -s -X PUT -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy Synthetics attributes Here are the attributes used with Synthetics REST API calls, listed in alphabetical order. Synthetics API attribute Definition apiVersion String: The version number. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific Synthetics monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected Synthetics monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/. For more help Additional documentation resources include: Manage Synthetics monitors via the REST API (v3) (Synthetics API version 3) Manage Synthetics alert notifications via the REST API (REST API calls for email alerts for New Relic monitors) Use Synthetics label APIs (REST API calls for labels and categories used by New Relic monitors)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.09826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "sections": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " the SCRIPTED_BROWSER monitor. #!&#x2F;bin&#x2F;bash # Admin <em>API</em> key from your account settings adminAPIKey=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;monitor-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes monitorName=&#x27;Test <em>API</em> Script&#x27; monitorType=&#x27;SCRIPT_BROWSER"
      },
      "id": "60452541e7b9d27829579a0a"
    },
    {
      "sections": [
        "Payload attributes for the Synthetics REST API",
        "Synthetic monitoring attributes",
        "Specific monitor endpoint",
        "For more help"
      ],
      "title": "Payload attributes for the Synthetics REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "ed3202f6715ae367d5c7c58d63a332d073535995",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api/",
      "published_at": "2021-07-02T11:24:38Z",
      "updated_at": "2021-03-11T11:46:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For REST API requirements for synthetics, see Use the API. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the Synthetics REST API: Synthetics API attribute Definition apiVersion String: The version number. count Integer: The number of monitors returned. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific synthetic monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. options Object: options for SIMPLE and BROWSER monitor types. Options include: validationString: string verifySSL: boolean (true, false) bypassHEADRequest: boolean (true, false) treatRedirectAsFailure: boolean (true, false) Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected synthetic monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/. For more help Additional documentation resources include: Manage synthetic monitors via the REST API (API procedures for synthetic simple and scripted monitors) Manage synthetic alert notifications via the REST API (REST API calls for email alerts for synthetic monitors) Use synthetics label APIs (REST API calls for labels and categories used by synthetic monitors)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.973206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "sections": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " The monitor_uuid is the value that follows &#x2F;monitors&#x2F;. For more help Additional documentation resources include: Manage synthetic monitors via the <em>REST</em> <em>API</em> (<em>API</em> procedures for synthetic simple and scripted monitors) Manage synthetic alert notifications via the <em>REST</em> <em>API</em> (<em>REST</em> <em>API</em> calls for email alerts for synthetic monitors) Use <em>synthetics</em> label <em>APIs</em> (<em>REST</em> <em>API</em> calls for labels and categories used by synthetic monitors)"
      },
      "id": "6043f9ae28ccbc98002c607a"
    },
    {
      "sections": [
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Caution",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Patch an existing monitor",
        "Delete an existing monitor",
        "Get a list of valid locations",
        "Script API for scripted browser and API test monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Using private location scripts with verified script execution",
        "Important",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Tip"
      ],
      "title": "Manage synthetic monitors via REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "83a3e8ad751c7f0865785a1c2fad193604a7f7da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api/",
      "published_at": "2021-07-02T09:34:31Z",
      "updated_at": "2021-03-11T10:41:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api Copy For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api Copy Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Copy Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 20. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' Copy The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Copy Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } Copy In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' Copy PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Copy Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted Browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload Copy If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' Copy Important You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. Tip In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.96986,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>synthetic</em> monitors via <em>REST</em> <em>API</em>",
        "sections": "Manage <em>synthetic</em> monitors via <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " will disable line wrapping: base64 -w 0 $scriptfile #!&#x2F;bin&#x2F;bash # <em>API</em> key from your account settings <em>API</em>_KEY=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;monitor-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes monitorName=&#x27;Test <em>API</em> Script&#x27; monitorType"
      },
      "id": "60440d4628ccbc74532c606a"
    }
  ],
  "/docs/apm/apm-ui-pages/error-analytics/apm-error-profiles-troubleshoot-trends": [
    {
      "sections": [
        "Errors page: Find, fix, and verify problems",
        "View the APM Errors page",
        "Use the Errors workflow to identify problems",
        "Error rate chart: See patterns immediately",
        "Top five errors: Correlate to alerts or find significant groupings",
        "Error traces: Find the line of code and data needed to reproduce the issue",
        "Expected errors",
        "Errors outside transactions",
        "Select the time period for error data"
      ],
      "title": "Errors page: Find, fix, and verify problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "fe321816a8727f65e32b4ec1f381ba9d17c432b7",
      "image": "https://docs.newrelic.com/static/1b3bf12a5d48aa0396de5e488bf17f27/c1b63/WebPortal___New_Relic_One.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/errors-page-find-fix-verify-problems/",
      "published_at": "2021-07-02T08:45:49Z",
      "updated_at": "2021-03-13T03:30:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With Errors in New Relic One, you can see the line of code that's causing a bad experience for your users, and get enough data to reproduce the issue so you can fix it. When you do, you’ll be able to confirm your fix is working in production. Use Errors in New Relic One to: Group and filter events to triage important errors. Get alert notifications about errors. Review stack traces, logs, and other details. Share the error information with charts and dashboards. Report new errors using instrumentation, prevent certain errors from being reported, and filter out noisy errors using expected errors. View the APM Errors page To view the Errors page: Go to one.newrelic.com > APM > (select an app), then click the Error rate table's title on your selected app's Summary page. OR Go to one.newrelic.com > APM > (select an app) > Events > Errors. APM Errors UI: The Error rate chart always shows the rate for all errors, even if a filter is applied. To drill down further, use grouping and filter options for the Top 5 by count chart and Error traces table. Use the Instance dropdown to focus on a specific instance. Use the Errors workflow to identify problems Use this basic workflow to get the most out of the information you see from the Errors page. Start with the Error rate chart to see at a glance whether there are any unexpected spikes, dips, or patterns with errors in general. Correlate any general patterns on the Top 5 errors chart to alerts occurring during the same time period. Use the groups and filters to examine the error events and attributes in more detail, and look for patterns with error messages, transaction names, or other groupings. Explore and share Error trace table information, including specific stack trace details, logs, and attributes (host, URL, user, custom attributes, etc.) Also review the Error profiles page to guide your investigation into which attribute values might be correlated to the cause of errors, by comparing the frequency of those values between transactions where the error did and didn't occur (only in the old UI). Error rate chart: See patterns immediately Start with the Error rate chart to see at a glance whether there are any unexpected spikes, dips, or patterns with errors in general. For example, are there any spikes near a recent deployment? You may want to change the selected time period to look for other historical patterns. This chart always shows the overall error rate and count for the selected time period, even when you filter the rest of the page. If you want to focus your investigation on a particular type of error, use the Top 5 errors chart or the Error traces table. Top five errors: Correlate to alerts or find significant groupings Use the Top 5 errors chart to identify what error types and how many of those errors occurred during the same time period as the Error rate chart. For example: Is the error spike related to a specific exception class or transaction? Do the top errors point to a new host/container that recently got moved into production? Are the top error messages repeatedly about failed connections by hosts that you know are in a specific region of your organization? Have the chart backgrounds changed color to indicate an alert condition? (Light pink indicates the alert condition's Warning threshold, and dark pink indicates the Critical threshold.) If you want to... Do this... Change the \"top 5\" selection By default, Top 5 errors chart shows the top five errors by error class and transaction name. To group by other attributes, such as error message, host, or custom attribute, use the search bar. Explore or share error trend data The Top 5 errors chart uses error events, which include rich attribute data b default, along with any custom attributes you have added to the error event type. To examine this data in more detail, or to share it with others, select the View query or Add to dashboard links that appear when you click the chart's ... menu. Error traces: Find the line of code and data needed to reproduce the issue The Error traces table groups errors by the attributes you've selected, and links them to relevant detailed error traces. Each row helps you find answers to questions such as: How many of this transaction/class (or custom grouping) occurred within the selected time period? What is the most recent error message? When did this error first and last occur? Sometimes it may be useful to sort error trace data other than from the most to fewest occurrences. You can change the sort order or filter options to focus on just the types of errors that matter the most to you and your teams. For example: Which error has the fewest occurrences (sort on Errors column)? When did a particular error stop (sort on Last occurred)? Once you find the group of errors you want to fix, click a row in the Error traces table to drill down into the stack traces and attribute data that help pinpoint the cause. Expected errors Reduce noisy errors by marking them as “expected errors”. Such errors won't affect reported error rate or Apdex metrics. See Manage errors for more details. Expected errors aren't shown by default on the Errors page. You can show them by turning on the Show N expected errors switch below the Group by bar. Errors outside transactions Using the New Relic agent API, you can record custom errors at any point in the execution of your code. Sometimes, such custom errors will occur when a transaction is not executing, such as in high-volume aynchronous code that doesn't handle an HTTP transaction. Errors outside transactions are shown by default on the Errors page, but you can hide them by turning off the Show N errors outside transactions switch below the Group by bar. Select the time period for error data Use the time picker to examine details of error events over the past week. The error events view is available for up to a seven-day window of data collected over the last eight days. You may notice slight differences in count if your time window is set to ending now. This occurs because the counts for the list and table may be requested at slightly different times as the page auto-refreshes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.30959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Errors</em> <em>page</em>: Find, fix, and verify problems",
        "sections": "View the <em>APM</em> <em>Errors</em> <em>page</em>",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " errors. View the <em>APM</em> Errors <em>page</em> To view the Errors <em>page</em>: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app), then click the <em>Error</em> rate table&#x27;s title on your selected app&#x27;s Summary <em>page</em>. OR Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Events &gt; Errors. <em>APM</em> Errors <em>UI</em>: The <em>Error</em> rate chart always shows"
      },
      "id": "60440747e7b9d2f2295799b6"
    },
    {
      "sections": [
        "Manage error data",
        "Error data types: events and trace details",
        "Events",
        "Trace details",
        "Caps on error reporting",
        "Charting error rates and counts",
        "Report custom errors",
        "Ignore errors",
        "Reduce noise with expected errors",
        "Disable error traces",
        "Delete error traces",
        "Caution"
      ],
      "title": "Manage error data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "29a2ebdc7b91029a1fada50791b90e9dc548f17e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/manage-error-data/",
      "published_at": "2021-07-02T09:22:42Z",
      "updated_at": "2021-03-13T03:03:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM Errors page helps you identify, triage, and fix errors in your services. The Errors page uses data collected by the APM agent to display stack traces, transaction attributes such as HTTP header values, and any other custom attributes, so you can understand the context of the error and fix it. Error data types: events and trace details By default, our APM agents collect two type of error data: Events Trace details Events The error event data type includes default attributes, as well as any custom attributes instrumented in your service. It doesn't include a stack trace. Find your events data in the Errors UI as follows: The Errors column in the Error traces table. The Top 5 errors chart. When you’ve drilled into a grouping of errors, those errors not displaying a stack trace are based on this type of data. You can disable Show only errors with stack trace to show errors that have this type of data collected, but no associated trace details. Events are subject to sampling (see Caps on error reporting and Charting error rates and counts). For more on error event data, see Events reported by APM. Trace details The trace details error data type includes stack traces and attributes, and supplements events with more data. It's expected that more events will be reported than trace details--see Caps on error reporting. Find your trace details data in the Errors UI as follows: The “Stack traces” column of the Error traces table. When you’ve drilled into a grouping of errors, those errors with a stack trace use this type of data: Show only errors with stack trace is enabled by default, to constrain the errors shown to just those that have this type of data collected. This data is governed by specific retention rules for Error details. Caps on error reporting New Relic caps error reporting at: 100 events per minute per agent instance 20 trace details per minute per agent instance These caps prevent error reporting from negatively impacting application performance. Examples: App running across five EC2 instances, one JVM each. New Relic caps error reporting at: 100 events per minute x 5 instances = 500 events per minute 20 trace details per minute x 5 instances = 100 trace details per minute App running on one host with ten instances. New Relic caps error reporting at: 100 events per minute x 10 instances = 1000 events per minute 20 trace details per minute x 10 instances = 200 events per minute Charting error rates and counts The Error rate chart is driven by a query on metric timeslice data, which is an unsampled aggregate data type that is accurate but has very limited dimensionality. This data can't be faceted or filtered as flexibly as error event data. You can reproduce this chart in a dashboard, or explore the metric timeslice data further by clicking the ... menu on the Error rate chart, and then using the View query or Add to dashboard options. To chart faceted error counts using event data, as in the Top 5 errors chart, use an NRQL event query. Click the ... menu on the Top 5 errors chart and choose View query for a starting point in creating your chart. Since event data can be sampled (see Caps on error reporting), you can use the EXTRAPOLATE keyword to get an accurate error count, even if sampling is occurring. Report custom errors You can report errors not collected by default with our agents using our agent APIs. For more, see the documentation on the API. Ignore errors You can prevent certain errors that would normally be reported to New Relic from being collected using our agent APIs or the server-side configuration UI. For more details, see Manage errors in APM. Reduce noise with expected errors Sometimes you want to collect error data, but not have those errors wake you up through alerts. Using the agent API, you can mark such errors as “expected”. They’ll still be visible in the Errors page, but won’t affect your service’s error rate or Apdex metrics. Disable error traces To prevent certain errors from being reported to New Relic, disable them in your agent's configuration file. For most agents, you can ignore certain error codes or disable errors completely. For more information, see your specific agent's configuration documentation: C SDK Go (not applicable; the agent only reports errors when configured to do so) Java .NET Node.js PHP Python Ruby Delete error traces Caution You cannot recover error traces after you delete them. Deleting errors is currently only available in the legacy Errors Classic UI. If you want to... Do this... Delete all error traces for your app If you have permissions to delete all error traces for an app: Go to one.newrelic.com > APM > (select an app) > More views > Errors (classic). Select Delete all errors. Delete all error traces for your account To delete all error traces for your New Relic account, get support at support.newrelic.com. Delete individual error traces To delete individual error traces, use New Relic APM's Errors (classic) page. Drill into an error from the table of errors, then click Delete this error. In addition to deleting error traces, you may also want to delete transaction traces or database/slow SQL traces. This will remove potentially sensitive data while retaining your other application data (such as Apdex, deployment information, etc.).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.30716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>error</em> data",
        "sections": "Manage <em>error</em> data",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " configuration <em>UI</em>. For more details, see Manage errors in <em>APM</em>. Reduce noise with expected errors Sometimes you want to collect <em>error</em> data, but not have those errors wake you up through alerts. Using the agent API, you can mark such errors as “expected”. They’ll still be visible in the Errors <em>page</em>, but won’t"
      },
      "id": "6044077e28ccbcab752c60d1"
    },
    {
      "sections": [
        "Ticketing integrations",
        "Requirements",
        "Integrate with New Relic",
        "Tip",
        "File tickets"
      ],
      "title": "Ticketing integrations",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c6004eab5c13506e5bdf175be670ff86b0a24f52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/user-interface-functions/share-your-data/ticketing-integrations/",
      "published_at": "2021-07-02T11:33:40Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic APM's transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic's webhook IPs. In addition, Lighthouse setup requires: The subdomain for your installation; for example, https://subdomain.lighthouseapp.com Your Lighthouse account's email and password for ticket tracking Integrate with New Relic Tip Owner and Admins To connect your New Relic account to Lighthouse: Go to: account dropdown > Account settings > Integrations > Ticketing integrations. Select the tab for Lighthouse. Follow the instructions on the individual tab, then click Integrate. After your ticketing system has been integrated, the corresponding tab's health status indicator in New Relic's UI changes to green (enabled). File tickets To use the ticketing system integrated with your New Relic account: From the selected APM transaction trace or APM error trace, select File a ticket. Follow standard procedures to create a ticket from your Lighthouse account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.65935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic <em>APM</em>&#x27;s transaction traces and <em>error</em> <em>analytics</em>. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic"
      },
      "id": "603ebd11e7b9d292fc2a07ef"
    }
  ],
  "/docs/apm/apm-ui-pages/error-analytics/errors-page-find-fix-verify-problems": [
    {
      "sections": [
        "APM Error profiles: Troubleshoot trends",
        "Tip",
        "Error profile attribute examples",
        "Error profiles feature in New Relic APM",
        "Select error profile criteria",
        "Error profile criteria example",
        "Analyze error profile results",
        "Error and non-error distribution",
        "Top deviating values",
        "Other category",
        "No value category",
        "Filters"
      ],
      "title": "APM Error profiles: Troubleshoot trends",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "14c286f0cf0f8cc14674c6422fdfa6286393ca6e",
      "image": "https://docs.newrelic.com/static/fcd404afa812236cf952f7861f28cca3/8c557/apm-error-profile-tab-demo.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/apm-error-profiles-troubleshoot-trends/",
      "published_at": "2021-07-02T09:22:42Z",
      "updated_at": "2021-03-30T09:14:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When DevOps experts need to track down what causes errors in your app, it may not be easy to identify the cause. New Relic APM's error profiles automatically compare one set of events to another. Each error profile provides visual details about significant differences in the frequency of different values for the events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of non-erroring transactions This helps you take more of the guesswork out of resolving your app errors. You can more easily determine if you can safely ignore the error, or if you should attempt to resolve the error with a new deployment, code edits, customer communications, or other actions. Tip To view error profiles, you must use the classic APM view in New Relic One. To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. Error profile attribute examples Error profiles appear as a separate tab on your New Relic APM Errors page. Error profiles feature in New Relic APM Use error profiles to troubleshoot trends and significant differences in the frequency of error events for your app. An error profile is a collection of attributes with significantly different traits compared to non-errors. An attribute is \"unusual\" if a set of events represent what is normal (for example, errors compared to all traffic for a given time window), or differences between similar criteria (for example, two different hosts). Errors may be related to events such as: Specific web transaction names or non-web transaction names, JVM thread names, etc. Unique types of error messages, classes, etc. Random customer interactions; for example, a particular error comes from a single customer's account, while normal traffic comes from a wide variety of accounts External call counts or duration Timing differences among hosts in your ecosystem, cluster agent IDs, etc. Other anomalies Select error profile criteria Based on criteria in your app's Errors page, New Relic analyzes and lists unusual trends by their significance. Your selected criteria includes: Time window Errors page filters Search criteria on the Errors page or the Error profiles tab As you examine error profile results and want to dig deeper, add or change your app's error profile criteria. The Error profile tab refreshes to show the traits that distinguish the errors that match the updated criteria. Error profile criteria example Your app's Error profile tab currently shows several error classes or messages. To filter to a specific error class or message, use any of these options: From the Errors page's time picker, change the time range. For example, change the default (30 minutes) to Last 24 hours, ending now. From the Errors page's filter section: Select Back to groupings list, then select other Error groups, Error attributes, or Custom attributes. From the Errors page's filter section: Click a specific item on the list to narrow the filter. For example, if several error messages are listed, click only the message you are interested in. From the Error profiles tab's search box, type class, message, or other search values. Analyze error profile results To examine details for the attribute results in your app's error profile, you must use the classic APM view in New Relic One. Go to one.newrelic.com/apm > APM > (select an app) > Events > Errors, then toggle Show new view so that APM shows the classic view of the Errors page. From the Errors page, select the Error profile tab. From the Error profile tab, review the list of error attributes that match the currently selected error profile criteria. To view a specific attribute's details, click it. To highlight specific error details, mouse over any pie chart segment or table row for the attribute. To investigate a specific attribute for your app's errors, type its name in the Error profiles tab's search window, or change the currently selected error profile criteria. Compare values with large differences to identify the traits that distinguish the errors for an attribute. The comparative data in the error profile results and the error trace details can help you decide what steps to take for additional troubleshooting and resolving the error. Error and non-error distribution Depending on an error's attributes, sometimes the attribute is distributed differently for errors than for non-errors. Top deviating values New Relic analyzes each attribute for your app's errors and compares the distribution for errors that match your criteria to transactions without errors. If the proportions between these errors are roughly the same compared to transactions without any errors, the attribute does not contain much useful information for debugging. New Relic limits the error profile's pie chart and table for each attribute to show only the top deviating values. When proportions are roughly the same, New Relic does not include them in the error profile. Other category After the top deviating values, the error profile groups the rest into an Other category. This helps you focus on the values that are different for these errors. No value category If values are unusually present or are not present in the errors, you may see a No value category on the list of error profiles. Filters If you do not have any filters selected, the profile shows any distinguishing traits your errors exhibit in aggregate. Example: A certain kind of transaction makes up 20% of all of your traffic and is responsible for 80% of your errors. The error profile will show the unexpected proportions in the Transaction attribute. Adjust your error profile criteria to drill down even deeper into the profile results, so you can more effectively troubleshoot and resolve specific error events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.84267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>APM</em> <em>Error</em> profiles: Troubleshoot trends",
        "sections": "<em>APM</em> <em>Error</em> profiles: Troubleshoot trends",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": ". To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. <em>Error</em> profile attribute examples <em>Error</em> profiles appear as a separate tab on your New Relic <em>APM</em> Errors <em>page</em>. <em>Error</em> profiles feature in New Relic <em>APM</em> Use <em>error</em> profiles to troubleshoot"
      },
      "id": "6044074764441fe72a378f08"
    },
    {
      "sections": [
        "Manage error data",
        "Error data types: events and trace details",
        "Events",
        "Trace details",
        "Caps on error reporting",
        "Charting error rates and counts",
        "Report custom errors",
        "Ignore errors",
        "Reduce noise with expected errors",
        "Disable error traces",
        "Delete error traces",
        "Caution"
      ],
      "title": "Manage error data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "29a2ebdc7b91029a1fada50791b90e9dc548f17e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/manage-error-data/",
      "published_at": "2021-07-02T09:22:42Z",
      "updated_at": "2021-03-13T03:03:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM Errors page helps you identify, triage, and fix errors in your services. The Errors page uses data collected by the APM agent to display stack traces, transaction attributes such as HTTP header values, and any other custom attributes, so you can understand the context of the error and fix it. Error data types: events and trace details By default, our APM agents collect two type of error data: Events Trace details Events The error event data type includes default attributes, as well as any custom attributes instrumented in your service. It doesn't include a stack trace. Find your events data in the Errors UI as follows: The Errors column in the Error traces table. The Top 5 errors chart. When you’ve drilled into a grouping of errors, those errors not displaying a stack trace are based on this type of data. You can disable Show only errors with stack trace to show errors that have this type of data collected, but no associated trace details. Events are subject to sampling (see Caps on error reporting and Charting error rates and counts). For more on error event data, see Events reported by APM. Trace details The trace details error data type includes stack traces and attributes, and supplements events with more data. It's expected that more events will be reported than trace details--see Caps on error reporting. Find your trace details data in the Errors UI as follows: The “Stack traces” column of the Error traces table. When you’ve drilled into a grouping of errors, those errors with a stack trace use this type of data: Show only errors with stack trace is enabled by default, to constrain the errors shown to just those that have this type of data collected. This data is governed by specific retention rules for Error details. Caps on error reporting New Relic caps error reporting at: 100 events per minute per agent instance 20 trace details per minute per agent instance These caps prevent error reporting from negatively impacting application performance. Examples: App running across five EC2 instances, one JVM each. New Relic caps error reporting at: 100 events per minute x 5 instances = 500 events per minute 20 trace details per minute x 5 instances = 100 trace details per minute App running on one host with ten instances. New Relic caps error reporting at: 100 events per minute x 10 instances = 1000 events per minute 20 trace details per minute x 10 instances = 200 events per minute Charting error rates and counts The Error rate chart is driven by a query on metric timeslice data, which is an unsampled aggregate data type that is accurate but has very limited dimensionality. This data can't be faceted or filtered as flexibly as error event data. You can reproduce this chart in a dashboard, or explore the metric timeslice data further by clicking the ... menu on the Error rate chart, and then using the View query or Add to dashboard options. To chart faceted error counts using event data, as in the Top 5 errors chart, use an NRQL event query. Click the ... menu on the Top 5 errors chart and choose View query for a starting point in creating your chart. Since event data can be sampled (see Caps on error reporting), you can use the EXTRAPOLATE keyword to get an accurate error count, even if sampling is occurring. Report custom errors You can report errors not collected by default with our agents using our agent APIs. For more, see the documentation on the API. Ignore errors You can prevent certain errors that would normally be reported to New Relic from being collected using our agent APIs or the server-side configuration UI. For more details, see Manage errors in APM. Reduce noise with expected errors Sometimes you want to collect error data, but not have those errors wake you up through alerts. Using the agent API, you can mark such errors as “expected”. They’ll still be visible in the Errors page, but won’t affect your service’s error rate or Apdex metrics. Disable error traces To prevent certain errors from being reported to New Relic, disable them in your agent's configuration file. For most agents, you can ignore certain error codes or disable errors completely. For more information, see your specific agent's configuration documentation: C SDK Go (not applicable; the agent only reports errors when configured to do so) Java .NET Node.js PHP Python Ruby Delete error traces Caution You cannot recover error traces after you delete them. Deleting errors is currently only available in the legacy Errors Classic UI. If you want to... Do this... Delete all error traces for your app If you have permissions to delete all error traces for an app: Go to one.newrelic.com > APM > (select an app) > More views > Errors (classic). Select Delete all errors. Delete all error traces for your account To delete all error traces for your New Relic account, get support at support.newrelic.com. Delete individual error traces To delete individual error traces, use New Relic APM's Errors (classic) page. Drill into an error from the table of errors, then click Delete this error. In addition to deleting error traces, you may also want to delete transaction traces or database/slow SQL traces. This will remove potentially sensitive data while retaining your other application data (such as Apdex, deployment information, etc.).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.30716,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>error</em> data",
        "sections": "Manage <em>error</em> data",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " configuration <em>UI</em>. For more details, see Manage errors in <em>APM</em>. Reduce noise with expected errors Sometimes you want to collect <em>error</em> data, but not have those errors wake you up through alerts. Using the agent API, you can mark such errors as “expected”. They’ll still be visible in the Errors <em>page</em>, but won’t"
      },
      "id": "6044077e28ccbcab752c60d1"
    },
    {
      "sections": [
        "Ticketing integrations",
        "Requirements",
        "Integrate with New Relic",
        "Tip",
        "File tickets"
      ],
      "title": "Ticketing integrations",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c6004eab5c13506e5bdf175be670ff86b0a24f52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/user-interface-functions/share-your-data/ticketing-integrations/",
      "published_at": "2021-07-02T11:33:40Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic APM's transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic's webhook IPs. In addition, Lighthouse setup requires: The subdomain for your installation; for example, https://subdomain.lighthouseapp.com Your Lighthouse account's email and password for ticket tracking Integrate with New Relic Tip Owner and Admins To connect your New Relic account to Lighthouse: Go to: account dropdown > Account settings > Integrations > Ticketing integrations. Select the tab for Lighthouse. Follow the instructions on the individual tab, then click Integrate. After your ticketing system has been integrated, the corresponding tab's health status indicator in New Relic's UI changes to green (enabled). File tickets To use the ticketing system integrated with your New Relic account: From the selected APM transaction trace or APM error trace, select File a ticket. Follow standard procedures to create a ticket from your Lighthouse account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.65935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic <em>APM</em>&#x27;s transaction traces and <em>error</em> <em>analytics</em>. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic"
      },
      "id": "603ebd11e7b9d292fc2a07ef"
    }
  ],
  "/docs/apm/apm-ui-pages/error-analytics/manage-error-data": [
    {
      "sections": [
        "APM Error profiles: Troubleshoot trends",
        "Tip",
        "Error profile attribute examples",
        "Error profiles feature in New Relic APM",
        "Select error profile criteria",
        "Error profile criteria example",
        "Analyze error profile results",
        "Error and non-error distribution",
        "Top deviating values",
        "Other category",
        "No value category",
        "Filters"
      ],
      "title": "APM Error profiles: Troubleshoot trends",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "14c286f0cf0f8cc14674c6422fdfa6286393ca6e",
      "image": "https://docs.newrelic.com/static/fcd404afa812236cf952f7861f28cca3/8c557/apm-error-profile-tab-demo.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/apm-error-profiles-troubleshoot-trends/",
      "published_at": "2021-07-02T09:22:42Z",
      "updated_at": "2021-03-30T09:14:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When DevOps experts need to track down what causes errors in your app, it may not be easy to identify the cause. New Relic APM's error profiles automatically compare one set of events to another. Each error profile provides visual details about significant differences in the frequency of different values for the events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of non-erroring transactions This helps you take more of the guesswork out of resolving your app errors. You can more easily determine if you can safely ignore the error, or if you should attempt to resolve the error with a new deployment, code edits, customer communications, or other actions. Tip To view error profiles, you must use the classic APM view in New Relic One. To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. Error profile attribute examples Error profiles appear as a separate tab on your New Relic APM Errors page. Error profiles feature in New Relic APM Use error profiles to troubleshoot trends and significant differences in the frequency of error events for your app. An error profile is a collection of attributes with significantly different traits compared to non-errors. An attribute is \"unusual\" if a set of events represent what is normal (for example, errors compared to all traffic for a given time window), or differences between similar criteria (for example, two different hosts). Errors may be related to events such as: Specific web transaction names or non-web transaction names, JVM thread names, etc. Unique types of error messages, classes, etc. Random customer interactions; for example, a particular error comes from a single customer's account, while normal traffic comes from a wide variety of accounts External call counts or duration Timing differences among hosts in your ecosystem, cluster agent IDs, etc. Other anomalies Select error profile criteria Based on criteria in your app's Errors page, New Relic analyzes and lists unusual trends by their significance. Your selected criteria includes: Time window Errors page filters Search criteria on the Errors page or the Error profiles tab As you examine error profile results and want to dig deeper, add or change your app's error profile criteria. The Error profile tab refreshes to show the traits that distinguish the errors that match the updated criteria. Error profile criteria example Your app's Error profile tab currently shows several error classes or messages. To filter to a specific error class or message, use any of these options: From the Errors page's time picker, change the time range. For example, change the default (30 minutes) to Last 24 hours, ending now. From the Errors page's filter section: Select Back to groupings list, then select other Error groups, Error attributes, or Custom attributes. From the Errors page's filter section: Click a specific item on the list to narrow the filter. For example, if several error messages are listed, click only the message you are interested in. From the Error profiles tab's search box, type class, message, or other search values. Analyze error profile results To examine details for the attribute results in your app's error profile, you must use the classic APM view in New Relic One. Go to one.newrelic.com/apm > APM > (select an app) > Events > Errors, then toggle Show new view so that APM shows the classic view of the Errors page. From the Errors page, select the Error profile tab. From the Error profile tab, review the list of error attributes that match the currently selected error profile criteria. To view a specific attribute's details, click it. To highlight specific error details, mouse over any pie chart segment or table row for the attribute. To investigate a specific attribute for your app's errors, type its name in the Error profiles tab's search window, or change the currently selected error profile criteria. Compare values with large differences to identify the traits that distinguish the errors for an attribute. The comparative data in the error profile results and the error trace details can help you decide what steps to take for additional troubleshooting and resolving the error. Error and non-error distribution Depending on an error's attributes, sometimes the attribute is distributed differently for errors than for non-errors. Top deviating values New Relic analyzes each attribute for your app's errors and compares the distribution for errors that match your criteria to transactions without errors. If the proportions between these errors are roughly the same compared to transactions without any errors, the attribute does not contain much useful information for debugging. New Relic limits the error profile's pie chart and table for each attribute to show only the top deviating values. When proportions are roughly the same, New Relic does not include them in the error profile. Other category After the top deviating values, the error profile groups the rest into an Other category. This helps you focus on the values that are different for these errors. No value category If values are unusually present or are not present in the errors, you may see a No value category on the list of error profiles. Filters If you do not have any filters selected, the profile shows any distinguishing traits your errors exhibit in aggregate. Example: A certain kind of transaction makes up 20% of all of your traffic and is responsible for 80% of your errors. The error profile will show the unexpected proportions in the Transaction attribute. Adjust your error profile criteria to drill down even deeper into the profile results, so you can more effectively troubleshoot and resolve specific error events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.84267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>APM</em> <em>Error</em> profiles: Troubleshoot trends",
        "sections": "<em>APM</em> <em>Error</em> profiles: Troubleshoot trends",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": ". To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. <em>Error</em> profile attribute examples <em>Error</em> profiles appear as a separate tab on your New Relic <em>APM</em> Errors <em>page</em>. <em>Error</em> profiles feature in New Relic <em>APM</em> Use <em>error</em> profiles to troubleshoot"
      },
      "id": "6044074764441fe72a378f08"
    },
    {
      "sections": [
        "Errors page: Find, fix, and verify problems",
        "View the APM Errors page",
        "Use the Errors workflow to identify problems",
        "Error rate chart: See patterns immediately",
        "Top five errors: Correlate to alerts or find significant groupings",
        "Error traces: Find the line of code and data needed to reproduce the issue",
        "Expected errors",
        "Errors outside transactions",
        "Select the time period for error data"
      ],
      "title": "Errors page: Find, fix, and verify problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "fe321816a8727f65e32b4ec1f381ba9d17c432b7",
      "image": "https://docs.newrelic.com/static/1b3bf12a5d48aa0396de5e488bf17f27/c1b63/WebPortal___New_Relic_One.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/errors-page-find-fix-verify-problems/",
      "published_at": "2021-07-02T08:45:49Z",
      "updated_at": "2021-03-13T03:30:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With Errors in New Relic One, you can see the line of code that's causing a bad experience for your users, and get enough data to reproduce the issue so you can fix it. When you do, you’ll be able to confirm your fix is working in production. Use Errors in New Relic One to: Group and filter events to triage important errors. Get alert notifications about errors. Review stack traces, logs, and other details. Share the error information with charts and dashboards. Report new errors using instrumentation, prevent certain errors from being reported, and filter out noisy errors using expected errors. View the APM Errors page To view the Errors page: Go to one.newrelic.com > APM > (select an app), then click the Error rate table's title on your selected app's Summary page. OR Go to one.newrelic.com > APM > (select an app) > Events > Errors. APM Errors UI: The Error rate chart always shows the rate for all errors, even if a filter is applied. To drill down further, use grouping and filter options for the Top 5 by count chart and Error traces table. Use the Instance dropdown to focus on a specific instance. Use the Errors workflow to identify problems Use this basic workflow to get the most out of the information you see from the Errors page. Start with the Error rate chart to see at a glance whether there are any unexpected spikes, dips, or patterns with errors in general. Correlate any general patterns on the Top 5 errors chart to alerts occurring during the same time period. Use the groups and filters to examine the error events and attributes in more detail, and look for patterns with error messages, transaction names, or other groupings. Explore and share Error trace table information, including specific stack trace details, logs, and attributes (host, URL, user, custom attributes, etc.) Also review the Error profiles page to guide your investigation into which attribute values might be correlated to the cause of errors, by comparing the frequency of those values between transactions where the error did and didn't occur (only in the old UI). Error rate chart: See patterns immediately Start with the Error rate chart to see at a glance whether there are any unexpected spikes, dips, or patterns with errors in general. For example, are there any spikes near a recent deployment? You may want to change the selected time period to look for other historical patterns. This chart always shows the overall error rate and count for the selected time period, even when you filter the rest of the page. If you want to focus your investigation on a particular type of error, use the Top 5 errors chart or the Error traces table. Top five errors: Correlate to alerts or find significant groupings Use the Top 5 errors chart to identify what error types and how many of those errors occurred during the same time period as the Error rate chart. For example: Is the error spike related to a specific exception class or transaction? Do the top errors point to a new host/container that recently got moved into production? Are the top error messages repeatedly about failed connections by hosts that you know are in a specific region of your organization? Have the chart backgrounds changed color to indicate an alert condition? (Light pink indicates the alert condition's Warning threshold, and dark pink indicates the Critical threshold.) If you want to... Do this... Change the \"top 5\" selection By default, Top 5 errors chart shows the top five errors by error class and transaction name. To group by other attributes, such as error message, host, or custom attribute, use the search bar. Explore or share error trend data The Top 5 errors chart uses error events, which include rich attribute data b default, along with any custom attributes you have added to the error event type. To examine this data in more detail, or to share it with others, select the View query or Add to dashboard links that appear when you click the chart's ... menu. Error traces: Find the line of code and data needed to reproduce the issue The Error traces table groups errors by the attributes you've selected, and links them to relevant detailed error traces. Each row helps you find answers to questions such as: How many of this transaction/class (or custom grouping) occurred within the selected time period? What is the most recent error message? When did this error first and last occur? Sometimes it may be useful to sort error trace data other than from the most to fewest occurrences. You can change the sort order or filter options to focus on just the types of errors that matter the most to you and your teams. For example: Which error has the fewest occurrences (sort on Errors column)? When did a particular error stop (sort on Last occurred)? Once you find the group of errors you want to fix, click a row in the Error traces table to drill down into the stack traces and attribute data that help pinpoint the cause. Expected errors Reduce noisy errors by marking them as “expected errors”. Such errors won't affect reported error rate or Apdex metrics. See Manage errors for more details. Expected errors aren't shown by default on the Errors page. You can show them by turning on the Show N expected errors switch below the Group by bar. Errors outside transactions Using the New Relic agent API, you can record custom errors at any point in the execution of your code. Sometimes, such custom errors will occur when a transaction is not executing, such as in high-volume aynchronous code that doesn't handle an HTTP transaction. Errors outside transactions are shown by default on the Errors page, but you can hide them by turning off the Show N errors outside transactions switch below the Group by bar. Select the time period for error data Use the time picker to examine details of error events over the past week. The error events view is available for up to a seven-day window of data collected over the last eight days. You may notice slight differences in count if your time window is set to ending now. This occurs because the counts for the list and table may be requested at slightly different times as the page auto-refreshes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.30959,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Errors</em> <em>page</em>: Find, fix, and verify problems",
        "sections": "View the <em>APM</em> <em>Errors</em> <em>page</em>",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " errors. View the <em>APM</em> Errors <em>page</em> To view the Errors <em>page</em>: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app), then click the <em>Error</em> rate table&#x27;s title on your selected app&#x27;s Summary <em>page</em>. OR Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Events &gt; Errors. <em>APM</em> Errors <em>UI</em>: The <em>Error</em> rate chart always shows"
      },
      "id": "60440747e7b9d2f2295799b6"
    },
    {
      "sections": [
        "Ticketing integrations",
        "Requirements",
        "Integrate with New Relic",
        "Tip",
        "File tickets"
      ],
      "title": "Ticketing integrations",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c6004eab5c13506e5bdf175be670ff86b0a24f52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/user-interface-functions/share-your-data/ticketing-integrations/",
      "published_at": "2021-07-02T11:33:40Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic APM's transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic's webhook IPs. In addition, Lighthouse setup requires: The subdomain for your installation; for example, https://subdomain.lighthouseapp.com Your Lighthouse account's email and password for ticket tracking Integrate with New Relic Tip Owner and Admins To connect your New Relic account to Lighthouse: Go to: account dropdown > Account settings > Integrations > Ticketing integrations. Select the tab for Lighthouse. Follow the instructions on the individual tab, then click Integrate. After your ticketing system has been integrated, the corresponding tab's health status indicator in New Relic's UI changes to green (enabled). File tickets To use the ticketing system integrated with your New Relic account: From the selected APM transaction trace or APM error trace, select File a ticket. Follow standard procedures to create a ticket from your Lighthouse account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 153.65935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic <em>APM</em>&#x27;s transaction traces and <em>error</em> <em>analytics</em>. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic"
      },
      "id": "603ebd11e7b9d292fc2a07ef"
    }
  ],
  "/docs/apm/apm-ui-pages/errors-inbox/error-limiting": [
    {
      "image": "https://docs.newrelic.com/static/a67951798a5b60f8aca1b4aac861f61a/466da/insights-inspected-event-count-modal_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/rate-limits-nrql-queries/",
      "sections": [
        "Rate limits for NRQL queries",
        "Limits on queried events",
        "NRQL query rate limits",
        "Limits on count of data types"
      ],
      "published_at": "2021-07-02T21:14:18Z",
      "title": "Rate limits for NRQL queries",
      "updated_at": "2021-07-02T21:14:18Z",
      "type": "docs",
      "external_id": "6dd3504c517c84fe20e0066c36482a001d0e2f3a",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's query language, NRQL, has rate limits in place to ensure a high level of availability and reliability for all users. To understand the places NRQL can be used, see Where is NRQL used?. You will rarely encounter rate limiting, especially if you follow these general guidelines: Limit the amount of requests with complex queries (for example, queries with FACET or TIMESERIES clauses, or queries of over a million events) that run at the same time. Limit the amount of requests run concurrently over extended periods of time to a maximum of 5, especially if they include complex queries. Limits on queried events When you run a NRQL query, it will display the number of events inspected, as shown below: In this context, \"events\" is used in a general sense to refer to all NRQL-available objects; this includes events, metrics, logs, and distributed tracing (span) data. Each New Relic account has limits on the total number of events that can be inspected. There are limits that apply over two different time frames: A rolling 30-minute time window A 24-hour period These limits are as follows: Time period Limit Rolling 30 minutes 300 billion events inspected (equivalent to a sustained rate of 10 billion events inspected per minute) 24 hours 7.2 trillion events inspected Once the limit has been reached for a given time period, limiting will be imposed and some queries may be impacted. After the time period has passed, if query volume drops below the limit, restrictions will be removed automatically. NRQL query rate limits The limit on NRQL queries is 3000 queries per account per minute. When this limit is exceeded, queries may be rejected until the number of queries sent per minute no longer exceed the limit. Limits on count of data types The limit for total number of reported data types is 250 per account over a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. This limit applies to all NRQL-queryable data types. Because there aren't that many different data types reported by New Relic products and integrations, this will mainly be a limit on custom events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.74994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rate <em>limits</em> for NRQL queries",
        "sections": "Rate <em>limits</em> for NRQL queries",
        "body": " rate of 10 billion events inspected per minute) 24 hours 7.2 trillion events inspected Once the <em>limit</em> has been <em>reached</em> for a given time period, limiting will be imposed and some queries may be impacted. After the time period has passed, if query volume drops below the <em>limit</em>, restrictions"
      },
      "id": "603e8e46e7b9d2143d2a07b0"
    },
    {
      "sections": [
        "View system limits",
        "Responses to limit violations",
        "System limits UI",
        "Troubleshooting limits",
        "For more information"
      ],
      "title": "View system limits",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Manage data"
      ],
      "external_id": "d6ff940e92c5d1a3ae34f391e9fa3be5dfa21c2f",
      "image": "https://docs.newrelic.com/static/8ee61e3091f6e044202cff92026afada/8c557/limits-graph.png",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/manage-data/view-system-limits/",
      "published_at": "2021-07-01T18:55:01Z",
      "updated_at": "2021-05-15T10:05:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure our systems are always up and ready to support you, and to keep you from unintended use, we place limits on the amount of data you can send, query, and store. Responses to limit violations Limits are enforced per sub-account, and across our APIs. You might reach a limit if you start monitoring a new high-traffic application, or have a sudden data spike. When you do reach a limit, New Relic responds according to the type of data and the limit that’s reached. For example: We place a limit on the number of ingested requests per minute (RPM) per data type. When this limit is reached, we stop accepting data and return a 429 status code for the duration of the minute. For queries, we place limits on the number of records inspected (see query limits). When this limit is reached, New Relic will reject traffic from the source scanning the largest number of records and attempt to allow traffic from other sources. For metrics, we place a limit on the number of unique timeseries (cardinality) per account and per metric. When this limit is reached, aggregated data is turned off for the rest of the UTC day. For every major limit violation, New Relic creates an NrIntegrationError event for that account, which have these limit-related attributes: Attribute Description category 'RateLimit' or 'ApiLimit'. The 'RateLimit' category is used for limits based on a unit of time such as the number of requests ingested per minute. The 'ApiLimit' is used for constant limits, such as the number of attributes on a record. limitName The name of the limit. message Describes the limit and the impact. limitValue The limit reached. System limits UI The system Limits page (from the account dropdown, click Manage your data and click Limits on the left) displays when your account has encountered a rate limit in the specified time period. The page displays a default period of 24 hours; you can set a custom range from the top-right of the page. Non-limit-related NrIntegrationError events are not displayed here. In addition, this page does not display information about limits you have not hit, or how close you are to reaching a limit. For more on creating queries and alerts for data ingest and billing metrics, see Query billing/usage data. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a chart on the Limits UI page displaying a cardinality violation limit issue. To add more detail, or build a dashboard, click the View NRQL button on the chart to see the NRQL powering this view. The graph displays each unique limit type that was reached during the selected time-period. This can help you find any trends based on time. The Limits page also provides a table where you can find the limit name, the limit event message associated with it, and last occurrence time and date. If you click a limit in the table, you see more about what happened, and when. one.newrelic.com > account dropdown > Manage your data > Limits: An example of a limit events table on the Limits UI page. Troubleshooting limits To troubleshoot limits when you reach them, click the limit info in the table, and then follow the docs link that's provided. Different limits have different solutions. For more information See Troubleshoot Metric API with NRIntegrationError events",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.97865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View system <em>limits</em>",
        "sections": "View system <em>limits</em>",
        "body": " monitoring a new high-traffic application, or have a sudden data spike. When you do <em>reach</em> a <em>limit</em>, New Relic responds according to the type of data and the <em>limit</em> that’s <em>reached</em>. For example: We place a <em>limit</em> on the number of ingested requests per minute (RPM) per data type. When this <em>limit</em> is <em>reached</em>, we"
      },
      "id": "60446a7c64441f48d7378f2b"
    },
    {
      "sections": [
        "Troubleshoot Metric API with NRIntegrationError events",
        "Problem",
        "Solution",
        "View error details",
        "Match errors to ingested payloads",
        "Programmatically retrieve NrIntegrationError events",
        "Tip"
      ],
      "title": "Troubleshoot Metric API with NRIntegrationError events",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Ingest APIs"
      ],
      "external_id": "7e0acfa00ae2dd25e23e41dbbf9d38c56ac485ae",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/ingest-apis/troubleshoot-nrintegrationerror-events/",
      "published_at": "2021-07-01T18:53:18Z",
      "updated_at": "2021-06-09T02:27:14Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You sent metric data points to the Metric API, and are not seeing what you expect when querying the data. Use the following checklist to determine the root cause: Make sure you are querying the data correctly. Check the HTTP status codes returned by the API. Issues like authorization failures can be diagnosed with HTTP status codes. If you are sending data from a Prometheus server via New Relic's remote_write endpoint, check your Prometheus server logs for errors or non-2xx HTTP responses from the New Relic endpoint. Query your account for NrIntegrationError events. New Relic's ingestion endpoints are asynchronous, meaning the endpoint verifies the payload after it returns the HTTP response. If any issues occur while verifying your payload, then an NrIntegrationError event will be created in your account. New Relic also uses NrIntegrationError events to notify customers when various rate limits have been reached. Solution View error details To view details about the errors, run this NRQL query: SELECT count(*) FROM NrIntegrationError WHERE newRelicFeature ='Metrics' facet category, message limit 100 since 24 hours ago Copy The category indicates the type of error and the message provides more detailed information about the error. If the category is rateLimit, then you should also examine the rateLimitType field for more information on the type of rate limiting. Category rateLimitType Description and solution BadRequest (not set) There is an issue with the JSON payload. These include JSON syntax errors, attribute names, or values that are too long. Check the message field to determine the exact issue. Then review the JSON payload, and update it to ensure it meets the proper semantic guidelines. RateLimit DatapointsPerMinute You are sending too many datapoints per minute. If you get this error, you can either send data less frequently, or request changes to your metric rate limits by contacting your New Relic account representative, or visiting our Support portal. RateLimit UniqueTimeseriesPerDay You have an attribute with a high number of unique values, like containerId or URI. To resolve this error, review any attributes that may be causing the issue and remove them. If desired, you can use a data dropping rule to remove attributes at ingest time. RateLimit UniquePrometheusTimeseries You have Prometheus servers reporting too many unique timeseries via New Relic's remote_write endpoint. Reduce the number of unique timeseries reported by modifying your Prometheus server configuration to reduce the number of targets being scraped, or by using relabel rules in the remote_write section of your server configuration to drop timeseries or highly unique labels. RateLimit RequestsPerMinute Too many requests per minute are being sent. To resolve this, put more datapoints in each request, and send them less frequently. RateLimit ErrorGroupsPerDay You have exceeded your daily error group limit. Incoming error groups will be dropped for the remainder of the day and will continue as normal after UTC midnight. To resolve this, reduce the amount of unique error messages collected by New Relic. Match errors to ingested payloads When a NrIntegrationError event is created as a result of a syntax issue with the HTTP request payload, then the event contains the attributes apiKeyPrefix and requestId. The apiKeyPrefix matches the first 6 characters of the API key used to send the data. The requestId matches the requestId sent in the HTTP response. To view these fields, run this NRQL query: SELECT message, apiKeyPrefix, requestId FROM NrIntegrationError limit 100 Copy To verify a specific requestId, run this NRQL query: SELECT * FROM NrIntegrationError where requestId ='REQUEST_ID' Copy Programmatically retrieve NrIntegrationError events To programmatically retrieve these errors: Ensure you have an Insights query API key (go to insights.newrelic.com > Manage data > API keys). Create an HTTP request as shown below: Tip If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. curl -H \"Accept: application/json\" -H \"X-Query-Key:YOUR_API_KEY_HERE\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCONT_HERE/query?nrql=SELECT%20*%20FROM%20NrIntegrationError%20where%20newRelicFeature='Metrics'\" Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.84654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View <em>error</em> details",
        "body": " various rate limits have been <em>reached</em>. Solution View <em>error</em> details To view details about the errors, run this NRQL query: SELECT count(*) FROM NrIntegration<em>Error</em> WHERE newRelicFeature =&#x27;Metrics&#x27; facet category, message <em>limit</em> 100 since 24 hours ago Copy The category indicates the type of <em>error</em>"
      },
      "id": "603ea57b64441f44f34e887d"
    }
  ],
  "/docs/apm/apm-ui-pages/errors-inbox/errors-inbox": [
    {
      "image": "https://docs.newrelic.com/static/45de34e3a56f26f44cbd62f69d1bb8b6/ae694/error.png",
      "url": "https://docs.newrelic.com/whats-new/2021/06/errors-inbox/",
      "sections": [
        "Errors Inbox: Error tracking across your entire stack"
      ],
      "published_at": "2021-07-01T21:33:48Z",
      "title": "Errors Inbox: Error tracking across your entire stack",
      "updated_at": "2021-06-25T12:10:39Z",
      "type": "docs",
      "external_id": "9ee9b292d1ae812a2b6cff8dbf6f0a2b19a9caa0",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "Recently, we launched New Relic Errors Inbox, an error tracking solution that provides you a single place to view, triage and resolve errors across your full application stack. This exciting feature now includes Logs in Context and an integration with Slack. Read more about the latest updates in our blog post and watch a demo in the latest Nerdlog episode here. What’s Included with New Relic Errors Inbox: Errors Inbox. Errors are grouped and displayed on a single screen for visibility and easy triaging. Filter to just the applications and services that you care about. Rich Error Details. Resolve errors faster with context of the full stack, including APM, Browser (RUM), Mobile, and Serverless (AWS Lambda Function) data. Error data persists to provide continued context for recurring errors. Log Data. Logs in Context are provided alongside other error data right in the error group details for even more information to resolve errors faster. Cross Team Collaboration. Work errors as a team with shared error visibility, shared comments, and an integration with Slack. Next Steps New Relic Errors Inbox is available to all New Relic Full-Stack Observability customers in the U.S. datacenter. To enable Errors Inbox, sign up for a free account or log in to your existing account and follow these steps: From one.newrelic.com, select More in the top right and click Errors Inbox. If this is your first time accessing Errors Inbox, you will be prompted to select a workload in the top left.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.6138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Errors</em> <em>Inbox</em>: <em>Error</em> tracking across <em>your</em> entire stack",
        "sections": "<em>Errors</em> <em>Inbox</em>: <em>Error</em> tracking across <em>your</em> entire stack",
        "body": "Recently, we launched New Relic <em>Errors</em> <em>Inbox</em>, an <em>error</em> tracking solution that provides you a single place to view, triage and resolve <em>errors</em> across <em>your</em> full application stack. This exciting feature now includes Logs in Context and an integration with Slack. Read more about the latest updates"
      },
      "id": "60d5c7bfe7b9d208f1d67792"
    },
    {
      "sections": [
        "Add and manage users, groups, and roles",
        "Important",
        "Requirements",
        "Manage users in the UI",
        "Overview of user management concepts",
        "User management definitions",
        "Example user management tasks",
        "Add, edit, and delete users",
        "Assign users access to accounts (access grants)",
        "Create new custom groups and roles",
        "Set up SAML SSO and/or SCIM provisioning",
        "Grant users ability to manage other users",
        "Control how basic users upgrade to full users",
        "Track changes"
      ],
      "title": "Add and manage users, groups, and roles",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "New Relic One user management"
      ],
      "external_id": "9e37836740ce56302734d4af636bdbe087b4dbc3",
      "image": "https://docs.newrelic.com/static/b1c2da968a637f68569e890c8bd72a1c/c1b63/new-relic-one-user-mgmt.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/add-manage-users-groups-roles/",
      "published_at": "2021-07-01T20:35:49Z",
      "updated_at": "2021-07-01T20:35:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For users on our New Relic One user model, we provide various user management features, including the ability to: Use role based access control (RBAC) to assign default or custom roles to user groups Create custom user groups Grant user groups access to specific roles and accounts Important This doc applies to users on the New Relic One user model. For managing users on our original user model, see Original users. Not sure which user model you're on? See User models. Requirements To see if you can access these user management features, go to the user management UI and see what you have access to. Access requirements: These features allow managing of users on the New Relic One user model. To learn more, see User models. To avoid configuration conflicts, ensure that only one user is managing users at a time. Simultaneous configuration by more than one user may result in errors and unexpected results. Most capabilities require the Authentication domain manager role and some require the Organization manager role. For details, see Standard roles. Pricing edition requirements: To manage user groups, roles, and access grants: Pro or Enterprise edition is required. To import users from an identity provider: Enterprise is required. A New Relic user can have a maximum of either three concurrent active sessions, or three unique IP addresses in use at any given time. Manage users in the UI For users on the New Relic One user model, to find your user management options: From the account dropdown, select Administration. There are two user management UI pages there: User management: Use this to add users, update user information, and approve upgrade requests. Organization and access: Use this page to create and manage groups, roles, and access grants, and to set up SAML SSO and SCIM provisioning. Important If you can't see these UI pages, it may be because you're on our original user model or because you don't have the required user management role. Overview of user management concepts To optimally use our more advanced user management features, it's important to first understand the concept of the \"access grant.\" An access grant gives a group of users access to a) a role and b) an account. For a New Relic organization that has many accounts, groups typically require more than one access grant because users in a group usually need access to multiple accounts and roles. The diagram below explains the elements that make up an access grant. Note that if your organization is on Standard edition and you want to assign a user to a default group (Admin or User), you don't need to create an access grant: you would simply add a user to that group and you're done. But for Pro and Enterprise edition, if you're trying to grant users access to a custom group, a custom role, or to other accounts, you must create an access grant. A diagram explaining how you can grant user groups access to roles and accounts. Note that this applies to users on our New Relic One user model (and not our original user model). Some tips on setting up access grants: It may help to first plan out how your access grants will be organized. How many accounts will you have? What user groups will get access to which roles and which accounts? Will you use our default groups and roles or create your own custom groups and roles? For smaller, flatter organizations that are okay with full internal transparency, you may only need a couple groups. A common configuration for organizations with many accounts (roughly 20 or more) is setting up groups with the more organization-scoped roles (Organization manager, Authentication domain manager, and Billing user) on the primary account, and then on other accounts, setting up groups with the more product-scoped roles (like All product admin, Standard user, or custom roles). For examples of some common user management tasks, see Example tasks. User management definitions Here are some definitions of our user management terms and how they relate to each other: A New Relic organization is the representation of your organization, containing all your accounts, users, and data. For more information, see Organization and account structure. A capability is an ability to use or edit a specific, granular New Relic feature. Examples of capabilities: The ability to modify APM settings The ability to delete alert conditions A role is a set of capabilities. Our default standard roles have various capability sets, and you can create custom roles that have a custom set of capabilities. See some specific New Relic capabilities. A user group has one or more roles associated with it. You assign your users to a group. We have default user groups (Admin and User), and you can make your own groups. An access grant is what grants a user group access to roles and specific New Relic accounts. An access grant essentially states, \"This group is assigned this role on this New Relic account.\" Adding a user to a group doesn’t do anything unless that group is included in an access grant. An authentication domain contains a set of users who are added to New Relic and who log in to New Relic in the same way. For example, you may have one authentication domain for users who log in via username/password and another authentication domain for users who log in via SAML. If a user is a basic user, this takes precedence over any role-related limitations. For more on this, see Basic user and roles. Example user management tasks In the Organization and access UI, you can create custom groups, roles, and grant access to user groups. Here are some example user management procedures: Add, edit, and delete users To add or edit users, use the User management UI. To add users: If you have multiple authentication domains, choose one from the authentication domain dropdown. Click Add user. Complete the process, including choosing user type and user group. Assign users access to accounts (access grants) See our user management tutorial. Create new custom groups and roles See our user management tutorial. Set up SAML SSO and/or SCIM provisioning See Get started with SAML SSO or SCIM. Grant users ability to manage other users To grant your users the ability to manage other users, you'll need to add users to a group that has the Authentication domain manager role. Important Users cannot have only organization-scoped roles assigned; they must also be in a group that has account-scoped roles (for example, the default Admin group). You have two options: From the User management UI, you can add a user to the default Admin group, which includes both of those roles. OR You can assign those roles to a custom group. From the Organization and access UI: Select Access grants, and choose To this organization. Create an access grant that assigns the Authentication domain manager role to a custom group. From the User management UI, add users to that group. To see a tutorial on creating new groups and roles, see Tutorial. Control how basic users upgrade to full users See the authentication domain settings. Track changes To see an audit log of changes to your account, including user management actions, you can query the NrAuditEvent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.29816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic <em>One</em> user management",
        "body": " to. Access requirements: These features allow managing of users on the New Relic <em>One</em> user model. To learn more, see User models. To avoid configuration conflicts, ensure that only <em>one</em> user is managing users at a time. Simultaneous configuration by more than <em>one</em> user may result in <em>errors</em>"
      },
      "id": "603e7bce28ccbc415beba74c"
    },
    {
      "sections": [
        "New Relic Lookout: Monitor your estate at a glance",
        "Why it matters",
        "Requirements",
        "Get started with New Relic Lookout",
        "Circle visualization and table view",
        "Abnormal golden signals",
        "Instant search",
        "Change view",
        "Drill down into the details",
        "Performance tab",
        "Abnormal History tab",
        "Correlations tab",
        "Profile tab",
        "Traces tab",
        "Create a custom view",
        "Query: Compare the last 15 minutes to the same time 1 day ago",
        "Query: Compare a specific time range to the same range a month ago",
        "Example: Unusual increases in error count"
      ],
      "title": "New Relic Lookout: Monitor your estate at a glance",
      "type": "docs",
      "tags": [
        "New Relic One",
        "Use New Relic One",
        "Core concepts"
      ],
      "external_id": "9193dcc8851c185ff5d96f6f93ab412bd1be69e9",
      "image": "https://docs.newrelic.com/static/178b37068bad2a68cff027c8bdcf663a/c1b63/lookout-intro.png",
      "url": "https://docs.newrelic.com/docs/new-relic-one/use-new-relic-one/core-concepts/new-relic-lookout-monitor-your-estate-glance/",
      "published_at": "2021-07-02T15:10:53Z",
      "updated_at": "2021-05-05T01:24:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Lookout provides visibility into your entire estate. It doesn't require any configuration — you can query anything in your estate that matters to you right now and understand your system as a whole, or dive deep into causes and effects, so you can quickly get the data you need to take action. Know exactly where to focus your attention with New Relic Lookout. The brighter the color, the more severe the change, and the bigger the size, the bigger the scale. Then dig deeper with correlations and abnormal history to see how it impacts your whole system—no configuration needed. Why it matters New Relic Lookout helps software teams of any size discover potential issues before they have an impact. Fill gaps in monitoring with full coverage out-of-the-box, no configuration or setup required. Immediately see anything deviating from normal across your entire estate. Proactively spot emerging problems in a real-time visualization of all system components. Gain faster incidents resolution through automatically surfaced causes and effects. Analyze any data in New Relic database (NRDB), including third-party, open, and custom data. Launch into other areas of New Relic One for deeper understanding Requirements New Relic Lookout requires Pro or Enterprise edition. If you are on Standard edition, you can still use the New Relic Lookout view in the New Relic Explorer. If you want to see data spanning 13-months, correlations, profiles, traces, and other details, you must upgrade to a higher edition. Get started with New Relic Lookout To access New Relic Lookout, click the Apps button in New Relic One and locate the New Relic Lookout launcher. You can also access New Relic Lookout directly from the New Relic One header bar, via the More dropdown. Enablement of key service performance indicator data is required for New Relic Lookout to provide value from the data you already have. The default view provides insight into three key Service performance indicators broken down by application: throughput, response time, and errors. These metrics are analyzed to show how the data has behaved during the last five minutes compared to the prior hour. one.newrelic.com > Apps > New Relic Lookout: Anything that significantly deviates from the trend is automatically discovered by New Relic Lookout, which doesn't require any configuration. Circle visualization and table view Each application (or other facet) is represented by a circle. The size of the circles indicate the magnitude of the signal for that application and the color indicates whether the value has significantly decreased or increased in the last five minutes, based on the standard deviation of the prior hour (default evaluation and comparison time windows.) Please note that the type of signal is important when interpreting your results. When you first look at the legend below, you might be tempted to interpret yellow as good and dark purple as bad, but that is not always the case. Here are some examples: In the APM/Services golden signals, a dark yellow circle in Throughput might signify that something bad has occurred and led to a drop in traffic. At the same time, a dark purple circle might also be concerning due to unexpected load. Both are significant findings worth exploring. In Browser golden signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to your site! With Errors golden signals (in all entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of errors in your system is important to investigate. The legend allows you to change the colors used to highlight deviating services To change the color palette, click the gear icon by the low-high color legend. This allows you to change the colors used to highlight deviating services. To get a table view of the same data, click the toggle on the right. You can also hover over each color to filter the view by degree lower or higher deviance. Abnormal golden signals On the right, New Relic Lookout displays the most significantly deviating applications (or other facet) in a side panel, weighted by both the magnitude of the performance indicators and the scale of their deviations. Details include the name of the key performance indicator, their magnitude during the recent time window, and the difference between the averages from one time compared to the other. Instant search Click the magnifying glass icon in the side panel to open a search box. Typing into the search box filters the circles, table, and abnormal signals to applications (or other facets) that contain the text. This is a good way to quickly zoom to various subsystems. New Relic Lookout doesn't rerun the analysis when using the instant search. Change view Click the Change View button on the right side panel. The panel that appears shows you all the entity-specific golden signals you can toggle between out of the box. By choosing the Browser Golden Signal or other views, you can change from the default view. Each new view will have the golden signals appropriate for that entity type. Drill down into the details To analyze an application or facet, click a circle, table row, or abnormal golden signal. The details panel shows the degree of deviation of the performance indicator, a link to the affected entity, and recent alert and deployment activity for that entity, when available. There’s also an indication of whether the selected evaluation time period would be abnormal or not in reference to other comparison time windows, such as the same time yesterday or the same time last week. This allows you to quickly see if the abnormal behavior is odd in general, or just based on the comparison time window. Performance tab The default tab shows charts for other key performance indicators for the selected application or facet. The charts compare the two time windows being analyzed. You can click their titles to rerun the analysis, focusing on the selected key performance indicator. When the target is a New Relic One application, we show the top transactions, error classes, external services, and database operations, alongside links to the relevant New Relic One features. Abnormal History tab This section analyzes past performance of the selected signal and calls out any time periods with notable abnormalities. Each card represents an abnormal time window and can be clicked for more details. The charts will display any relevant violations and deployments in New Relic. Correlations tab New Relic Lookout can find other signals that began behaving differently around the same time as the selected signal for that entity type. Clicking the name of the signal reruns the analysis, focusing on that key performance indicator. The chart titles link to New Relic One when there’s an associated entity in your account. Note that correlations currently do not analyze across accounts. The correlated signals displayed are for others in the account of the original application you are viewing. This helps focus the data on correlations that are more likely related to your issue. Profile tab Based on the same technology as New Relic’s error profiles, this tab compares the last five minutes to the prior hour by default (or whatever time windows you’ve selected with query editing) and surfaces any attributes that have significantly different distributions in the events being targeted by the selected signal. For example, if a custom attribute indicated that a recent throughput spike came from one user, that would surface highly in Profiles if most of the traffic usually comes from many users. Traces tab If the entity has distributed traces configured and available in the selected evaluated time window, the Traces section is enabled. Each card shows a summary of a trace and can be clicked for details. The Explore all traces links to the distributed traces application, filtered to the selected entity. Create a custom view To target signals and time windows beyond the default values, click the Change view button and select Custom view. To create your own view: Select the account or subaccount. Select the data type (metrics or events). Different functionality is available depending on the type. In View a chart with, select the metric or event you are interested in. Default is golden signals (throughput, response time, and errors). You can also build custom queries (filters) to target a signal that isn't on the list. In Facet by, select what the circles represent. Default is appName, but you can also choose host or any other facetable attribute available for the signal you’ve selected. If you plan to save/favorite this new view, provide a name in the Name your view box. Keep in mind that you can edit this view at any time using the pencil icon. The default time windows analyzed by New Relic Lookout are the last five minutes compared to the hour before. Use the time controls (View data from and Compare data to) to target other time windows. one.newrelic.com > Apps > New Relic Lookout: All event and metric data in the New Relic database can be queried using the Edit query feature. Click Analyze to begin analyzing the signal you’ve selected. You can also create your own query: Create your query. This query is comparing data from the past thirty minutes to data from the same range a day ago. Change from Basic to Advanced after clicking the Custom view button. Select the data type (metrics or events). Different functionality is available depending on the type. Enter your query using NRQL. Please note that not all NRQL features are available in the Lookout Advanced query feature. By default, the system will run this query using the last five minutes of data compared to the previous hour. Some examples of the syntax for changing the comparison and evaluation time windows are below. Click Analyze to begin analyzing the signal you’ve selected. Query: Compare the last 15 minutes to the same time 1 day ago Please note that the UNTIL NOW portion is required here unlike in standard NRQL. Without the UNTIL NOW added, the system will query a 5 minute slice of data starting 15 minutes ago SINCE 15 minutes AGO UNTIL NOW COMPARE WITH 1 day ago Copy Query: Compare a specific time range to the same range a month ago SINCE ‘2021-03-07 07:00-0500’ UNTIL ‘2021-03-08 07:00-0500’ COMPARE WITH 1 month ago Copy Or: SINCE ‘today at midnight’ UNTIL ‘now’ COMPARE WITH 1 MONTH AGO Copy Example: Unusual increases in error count The default view of New Relic Lookout shows application status across your estate, comparing the last five minutes to the hour before. Under regular operation, most large systems may have a handful of abnormalities, but usually most things will indicate normal behavior. Suddenly, several circles begin to change to red under the Errors section. This indicates that several applications are experiencing unusual increases in error count. It may be that one or two circles for important systems are red, and perhaps much larger than they usually appear. Clicking one of these can provide more information on what is happening. You might see that the error rate is substantially elevated, even thousands of percent higher than normal. To troubleshoot this issue, here's what you might discover in the New Relic Lookout tabs: Performance would show you data about other signals, illuminating the characteristics of the change in system dynamics. Correlations would surface other applications that are affected and how, as well as opportunities to pivot to other applications that may be closer to the underlying causes. Traces, in turn, would show distributed traces, which can provide specific examples of traffic running through those systems. Abnormal history would show other times in the past week with elevated errors, showing whether or not this problem happens regularly, such as every day at the same time or whenever there is a deployment. Profiles might show that all or most of the new errors share common properties, such as all being isolated to just one region/account/user. Combining the information from these sections, not only can you get a sense of what is going on, but also where to focus actions to resolve the problem.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.35745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic Lookout: Monitor <em>your</em> estate at a glance",
        "sections": "New Relic Lookout: Monitor <em>your</em> estate at a glance",
        "tags": "New Relic <em>One</em>",
        "body": " signals, a dark purple circle in Page Views might be great, as you are seeing more traffic to <em>your</em> site! With <em>Errors</em> golden signals (in <em>all</em> entity types), a large circle, even if gray (not deviating from normal volume), is worth exploring because a high count of <em>errors</em> in <em>your</em> system is important"
      },
      "id": "603e821e64441f5a444e8845"
    }
  ],
  "/docs/apm/apm-ui-pages/events/deployments-page-view-impact-your-app-users": [
    {
      "sections": [
        "Thread profiler tool",
        "Supported agents",
        "Start the profiler",
        "View profile data",
        "Agent considerations",
        ".NET-specific notes",
        "Python-specific notes",
        "Ruby-specific notes"
      ],
      "title": "Thread profiler tool",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Events"
      ],
      "external_id": "e2d300aa5dd9bdbf73684a04080773db0d1acd2b",
      "image": "https://docs.newrelic.com/static/9c9ff25ac45a7e0772db3c71a5c2754f/c1b63/thread-profiler-start_1.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/events/thread-profiler-tool/",
      "published_at": "2021-07-02T08:47:23Z",
      "updated_at": "2021-03-16T08:17:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The thread profiler is a low-impact profiling tool that can be used in production to identify bottlenecks in an application. It works by periodically (100ms) capturing the stack trace of each thread for a specified duration. At the end of the specified duration, the stack traces are aggregated to build a tree. The call count in the tree corresponds to the number of times that function was present in the stack traces under the same context. Although the call tree cannot capture the entire execution, a large enough sample can be a good representation of the application behavior. This provides insights into the \"hot\" functions of the app where most of the time is spent. With this scope, entries sampled less than 0.05% are omitted. Supported agents This feature is available only for specific agents and versions: Java: Agent versions 1.2.004.6 or higher .NET: Framework: Agent versions 2.12.146.0 or higher .NET Core 2.0: Agent versions 8.3.360.0 or higher (Windows only) Linux: .NET Core 3.0 or higher and agent versions 8.23 or higher Python: Agent versions 1.7.0 or higher Ruby: Agent versions 3.5.5 or higher Start the profiler The thread profiler feature is enabled by default. You also may be able to turn it on or off in your agent configuration file: Java: thread_profiler.enabled NET: You cannot disable the thread profiler with .NET apps. Python: thread_profiler.enabled Ruby: thread_profiler.enabled When enabled, you can view the thread profiler from our user interface: Go to one.newrelic.com > APM > (select an app) > Events > Thread profiler. Select the host you want to run the profiler on. Set the duration for the profiling session. Select Start profiler. This triggers the agent to start the thread profiler during the next harvest cycle (every one minute) and capture data for the specified duration. We record thread backtraces whether or not they are in a runnable state at the time the sample is taken. Threads that are sleeping or blocked on IO may appear in the call tree. one.newrelic.com > APM > (select an app) > Events > Thread profiler: Use this page to define the settings for the thread profiler duration and to view the results. View profile data After the profiler finishes running, the agent will report the profile data. The call tree automatically appears on the Thread profiler page. The percentages in the call tree represent the percentage of thread backtrace samples in which each call path appeared during the profiling session. The data collection started at the PROFILE COLLECTED time. one.newrelic.com > APM > (select an app) > Events > Thread profiler > (selected profile): Here is an example of a call tree from a thread profile. The page color-codes the tree results: Red: Percentages greater than 30% Yellow: Percentages greater than 10% Black: Percentages less than 10% If you want to... Do this... Change how the thread profile information appears Select your choices of available options in the Tree settings, and select Refresh tree. Change how much information appears Select the Expand or Collapse options above the call tree, or select the name or arrow on any line in the call tree. View summary information about any line in the call tree Mouse over the line. Email the thread profile results to others Select Share this profile. Start another session or view a different thread profile Select Back to all profiles. Agent considerations Depending on which agent you use, the thread profiling feature has additional considerations. .NET-specific notes When using thread profiling with the .NET Framework agent, be aware of the following. .NET agent Thread profiler notes Supported on Linux Thread profiling on Linux is supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Managed threads only For .NET agents, the thread profiler only captures stack traces on managed threads. It does not capture stack traces on unmanaged threads. If a call to an unmanaged function occurs on a managed thread, the thread profiler will show Native:Function Call in the call tree. No line numbers A .NET thread profile does not include line numbers in the call tree. The Show line numbers checkbox in the Tree Settings does not have any effect. Bug with 64-bit v4.0 .NET CLR There is a bug in the 64-bit version 4.0 .NET Common Language Runtime (CLR) that interferes with the agent's ability to retrieve managed stack traces. If your app experiences this bug, APM will show empty thread profiles. This bug does not affect 32-bit applications. The bug is fixed in the CLR releases for .NET 4.5. To verify whether your 64-bit application has the fixed version, look at the full version of the mscorlib.dll in the C: \\ Windows \\ Microsoft.NET \\ Framework64 \\ v4.0.30319 directory. The fix is in versions 4.0.30319.17379 or higher. Other category only All threads are put in the Other category. The Web Request and Background categories are not supported. Python-specific notes When using thread profiling with the Python agent, be aware of the following. Python agent Thread profiler notes Co-routine based systems There are limits to capturing details when a co-routine based system is being used, such as gevent or eventlet modes of gunicorn. If creating a new thread, the Python agent will actually create a greenlet instead of a thread profiler background thread. Therefore, the thread profiler will not capture any web request and background transactions on the thread profiler page. Greenlets A greenlet can run only when other greenlets explicitly yield control, such as when they block. For example, if the thread sampler does get to run, it will only sample the stack for other greenlets at a point where they are blocked. It will not sample them when they are executing arbitrary code. It can completely miss execution within a greenlet if it never blocked or otherwise yielded to another greenlet. Time in Python code Time spent in pure Python code that isn't blocking requests will not be picked up, and no information will be recorded or reported. This is because results are misleading when co-routines are used. Ruby-specific notes When using thread profiling with the Ruby agent, be aware of the following. Ruby agent Thread profiler notes Backtraces The thread profiler depends on the ability to capture thread backtraces from within your Ruby application. For this reason, it requires MRI 1.9.2 or higher (for the Thread#backtrace method). Resque The Ruby agent does not currently support thread profiles with Resque background jobs. A thread profiling session initiated against Resque will only capture traces from the parent process, not the job processes. JRuby JRuby support is considered experimental at this time. There are known issues with JRuby's Thread#backtrace implementation that will affect the accuracy of and reliability of backtraces collected under JRuby.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.74924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " for the specified duration. We record thread backtraces whether or not they are in a runnable state at the time the sample is taken. Threads that are sleeping or blocked on IO may appear in the call tree. one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Events</em> &gt; Thread profiler: Use this <em>page</em> to define"
      },
      "id": "603ebd4928ccbccc3ceba78e"
    },
    {
      "sections": [
        "View alert history",
        "Tip",
        "Alerts for specific apps",
        "Alerts across apps and hosts"
      ],
      "title": "View alert history",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Events"
      ],
      "external_id": "7e8a0d04e47d51735e156f50bb823b31691d9929",
      "image": "https://docs.newrelic.com/static/2ad296d1897574998b28865d9c9b6d7b/8c557/alerts_dashboard_0.png",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/events/view-alert-history/",
      "published_at": "2021-07-02T12:46:10Z",
      "updated_at": "2021-03-16T06:31:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic APM's Alerts page shows a table of alerts over the past two weeks that you can drill down into detailed information, including throughput, error rate percentage, and history. You can view alert history for a specific application or for all applications. Tip Access to this feature depends on your subscription level. Alerts for specific apps To view a list of alerts for a specific app: Go to rpm.newrelic.com/apm > (select an app) > Events > Alerts. rpm.newrelic.com/apm > (select an app) > Events > Alerts: Use this page to view or filter information about alerts over the past two weeks. The Alerts page shows a list of alerts over the past two weeks, if any. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Each alert notification includes the alert icon and summary information. To view details about an alert notification on the Alerts page, select its link. For example: To view details about a specific alert, select its name. To narrow the list of alerts, use the Filter. To view all alerts for all of your apps and hosts, select the All alerts link. To select a specific Java Virtual Machine (JVM) if applicable, select your choice from the JVMs menu. Alerts across apps and hosts To view history about Critical alerts and outages across all of your applications and hosts: Go to rpm.newrelic.com/apm > Alerts > Alert history. Optional: Select Show alerts for hidden applications. The list separates alerts into categories, including: In progress Today Yesterday This week Prior to last week From here you can filter and select select specific incidents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.74045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " on your subscription level. Alerts for specific apps To view a list of alerts for a specific app: Go to rpm.newrelic.com&#x2F;<em>apm</em> &gt; (select an app) &gt; <em>Events</em> &gt; Alerts. rpm.newrelic.com&#x2F;<em>apm</em> &gt; (select an app) &gt; <em>Events</em> &gt; Alerts: Use this <em>page</em> to view or filter information about alerts over the past two weeks"
      },
      "id": "603ebe4c196a676588a83dd6"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.80467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, <em>events</em>, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/apm-ui-pages/events/thread-profiler-tool": [
    {
      "sections": [
        "Deployments page: View impact on your app and users",
        "Set up deployment notifications",
        "View deployment details",
        "View performance after a deployment",
        "Tip"
      ],
      "title": "Deployments page: View impact on your app and users",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Events"
      ],
      "external_id": "e312ce78e93b452b265b646406db3a39d3f7e696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/events/deployments-page-view-impact-your-app-users/",
      "published_at": "2021-07-02T08:45:49Z",
      "updated_at": "2021-03-16T06:31:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Deployments page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. You can view and drill down details, use search and sort options, hide or delete the error, share it with others, or file a ticket about it. Set up deployment notifications For all APM agents, you can record deployments by using webhooks or by using the New Relic REST API (v2). Some agents also have specific methods, such as the Java agent jar or the Python agent's newrelic-admin script. View deployment details After you configure the deployment information, you can view and drill down into details: Go to one.newrelic.com > APM > (select an app) > Events > Deployments. Use any of New Relic's standard user interface functions to drill down into detailed information. To view details for a particular event, select its date link. To view the errors page for this deployment, select the error link. To view details for a specific deployment if applicable, select Change log or Change report. The Change log contains any detail provided through the changelog parameter when recording the deployment. The Change report displays the behavior of the top ten transactions before and after the deployment. View performance after a deployment The Deployments page link for individual deployments appears on the selected app's Summary page in the Events section. For time frames shorter than 14 days, a blue vertical bar on a chart will indicate a deployment. To view summary information about the deployment, mouse over the blue bar. Tip You can also use the Compare with option on your APM summary page to select a time period to compare the same data. If you enable Compare with, the UI does not show deployment markers.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.74045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Deployments <em>page</em>: View impact on your app and users",
        "sections": "Deployments <em>page</em>: View impact on your app and users",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " the deployment information, you can view and drill down into details: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Events</em> &gt; Deployments. Use any of New Relic&#x27;s standard user interface functions to drill down into detailed information. To view details for a particular <em>event</em>, select its date link. To view"
      },
      "id": "603ebe19e7b9d2bc362a07cc"
    },
    {
      "sections": [
        "View alert history",
        "Tip",
        "Alerts for specific apps",
        "Alerts across apps and hosts"
      ],
      "title": "View alert history",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Events"
      ],
      "external_id": "7e8a0d04e47d51735e156f50bb823b31691d9929",
      "image": "https://docs.newrelic.com/static/2ad296d1897574998b28865d9c9b6d7b/8c557/alerts_dashboard_0.png",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/events/view-alert-history/",
      "published_at": "2021-07-02T12:46:10Z",
      "updated_at": "2021-03-16T06:31:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic APM's Alerts page shows a table of alerts over the past two weeks that you can drill down into detailed information, including throughput, error rate percentage, and history. You can view alert history for a specific application or for all applications. Tip Access to this feature depends on your subscription level. Alerts for specific apps To view a list of alerts for a specific app: Go to rpm.newrelic.com/apm > (select an app) > Events > Alerts. rpm.newrelic.com/apm > (select an app) > Events > Alerts: Use this page to view or filter information about alerts over the past two weeks. The Alerts page shows a list of alerts over the past two weeks, if any. Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Each alert notification includes the alert icon and summary information. To view details about an alert notification on the Alerts page, select its link. For example: To view details about a specific alert, select its name. To narrow the list of alerts, use the Filter. To view all alerts for all of your apps and hosts, select the All alerts link. To select a specific Java Virtual Machine (JVM) if applicable, select your choice from the JVMs menu. Alerts across apps and hosts To view history about Critical alerts and outages across all of your applications and hosts: Go to rpm.newrelic.com/apm > Alerts > Alert history. Optional: Select Show alerts for hidden applications. The list separates alerts into categories, including: In progress Today Yesterday This week Prior to last week From here you can filter and select select specific incidents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.74045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " on your subscription level. Alerts for specific apps To view a list of alerts for a specific app: Go to rpm.newrelic.com&#x2F;<em>apm</em> &gt; (select an app) &gt; <em>Events</em> &gt; Alerts. rpm.newrelic.com&#x2F;<em>apm</em> &gt; (select an app) &gt; <em>Events</em> &gt; Alerts: Use this <em>page</em> to view or filter information about alerts over the past two weeks"
      },
      "id": "603ebe4c196a676588a83dd6"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.80467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, <em>events</em>, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/apm-ui-pages/features/analyze-database-instance-level-performance-issues": [
    {
      "sections": [
        "Ticketing integrations",
        "Requirements",
        "Integrate with New Relic",
        "Tip",
        "File tickets"
      ],
      "title": "Ticketing integrations",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c6004eab5c13506e5bdf175be670ff86b0a24f52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/user-interface-functions/share-your-data/ticketing-integrations/",
      "published_at": "2021-07-02T11:33:40Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic APM's transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic's webhook IPs. In addition, Lighthouse setup requires: The subdomain for your installation; for example, https://subdomain.lighthouseapp.com Your Lighthouse account's email and password for ticket tracking Integrate with New Relic Tip Owner and Admins To connect your New Relic account to Lighthouse: Go to: account dropdown > Account settings > Integrations > Ticketing integrations. Select the tab for Lighthouse. Follow the instructions on the individual tab, then click Integrate. After your ticketing system has been integrated, the corresponding tab's health status indicator in New Relic's UI changes to green (enabled). File tickets To use the ticketing system integrated with your New Relic account: From the selected APM transaction trace or APM error trace, select File a ticket. Follow standard procedures to create a ticket from your Lighthouse account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.90155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic <em>APM</em>&#x27;s transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic"
      },
      "id": "603ebd11e7b9d292fc2a07ef"
    },
    {
      "sections": [
        "Configure request queue reporting",
        "HTTP header",
        "Tip",
        "C SDK",
        "Go agent",
        "Java, Node.js, Python, Ruby agents",
        ".NET agent",
        "PHP agent"
      ],
      "title": "Configure request queue reporting",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "3226477ad8d63af87fd5947589af31d0d679b89b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/features/configure-request-queue-reporting/",
      "published_at": "2021-07-02T12:45:18Z",
      "updated_at": "2021-03-16T08:18:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Request queuing occurs before the request reaches your application (where the agent resides). This is why you need to do some straightforward configuration of the agent and your production hosts to take advantage of this feature. HTTP header In order to report request queuing, most New Relic agents depend on an HTTP header set by the front-end web server (such as Apache or Nginx) or load balancer (such as HAProxy or F5). You can configure these front-end servers to set the timestamp in the HTTP header that represents when the request first entered your production infrastructure. Tip Set this header as soon after the request enters your infrastructure as possible so that you are less likely to miss performance problems in your infrastructure that occur before the header is set. Most New Relic agents will interpret an X-Queue-Start or X-Request-Start header and use it to calculate Request Queuing. The agents treat these headers identically. Include a value in the format t=MICROSECONDS_SINCE_EPOCH where MICROSECONDS_SINCE_EPOCH is an integer value of the number of microseconds that have elapsed since the beginning of the Unix epoch (for example, January 1, 1970). Nearly any front-end HTTP server or load balancer can be configured to add this header. Additional details depend on your specific agent and server configuration. For more information, see the request queue configuration examples. C SDK The C SDK does not support request queuing. Go agent With the Go agent, set either header to record a metric for it. Java, Node.js, Python, Ruby agents The most recent versions of the Java, Node.js, Python, and Ruby agents provide more flexibility in the format of the X-Request-Start or X-Queue-Start header. These agents allow the timestamp to be submitted in seconds, milliseconds, or microseconds as an integer or floating point value. These agents also allow the leading t= in the header value to be omitted. Based on the order of magnitude, these agents automatically interpret the time unit as seconds, milliseconds, or microseconds. New Relic can do this reliably since a millisecond timestamp, interpreted as microseconds, would result in a queue time over 40 years. Python agent only: When using Apache/mod_wsgi 3.4 or higher, mod_wsgi will automatically insert an equivalent to the X-Queue-Start header into the WSGI environ dictionary for each request. This will mark the specific point in time where Apache first accepted the request. The value set by mod_wsgi will be picked up and used by the Python agent if no separate X-Request-Start or X-Queue-Start header has been manually configured into a web server's front end or in Apache itself. .NET agent The .NET agent does not require (and will ignore) any configuration of HTTP headers to calculate queue time. It works by instrumenting the IIS-queuing mechanism directly and reports queue time as the difference between when the HttpContext constructor executes and when the HttpApplication.BeginRequest event fires. Request queue time is only reported for .NET Framework applications hosted on IIS (for example: ASP.NET applications). It is not reported for ASP .NET Core applications (targeting .NET Core or Framework), nor for self-hosted OWIN applications. PHP agent The PHP agent only supports the X-Request-Start header. This identifies the timestamp in microseconds as an integer, with an optional t= in the header value. To ensure that the header is read properly, check your phpinfo() under the PHP Variables section, and verify that _SERVER[\"HTTP_X_REQUEST_START\"] exists and is in the expected format. If you are using Nginx, see Request queue server configuration examples for additional information on setting the header.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>"
      },
      "id": "603eb8ba28ccbc4b1deba769"
    },
    {
      "sections": [
        "Request queue server configuration examples",
        "Apache",
        "Nginx",
        "F5 load balancers",
        "Network timing"
      ],
      "title": "Request queue server configuration examples",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c7a069b8875af411530a34aaef67155d20d7fb19",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/features/request-queue-server-configuration-examples/",
      "published_at": "2021-07-02T12:46:10Z",
      "updated_at": "2021-03-16T07:13:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to report request queuing, New Relic agents depend on an HTTP header set by the front-end web server (such as Apache or Nginx) or load balancer (such as HAProxy or F5). These examples use the X-Request-Start header, since it is has broader support across platforms. If this does not work with your server configuration for request queuing, try using the X-Queue-Start header. The syntax should otherwise be the same. Apache Apache's mod_headers module includes a %t variable that is formatted correctly. To enable request queue reporting, add this code to your Apache config: RequestHeader set X-Request-Start \"%t\" Copy Nginx If you are using Nginx version 1.2.6 or higher and the latest version of the Ruby, Python, or PHP agent, Nginx can easily be configured to report queue time. (For Nginx versions 1.2.6 or lower, you must recompile Nginx with a module or patch.) Configuring with Nginx 1.2.6 or higher uses the ${msec} variable, which is a number in seconds with milliseconds resolution. For more information, see http://nginx.org/en/docs/http/ngx_http_core_module.html#variables. Add the appropriate information to your Nginx config: Nginx configuration Values General Nginx use proxy_set_header X-Request-Start \"t=${msec}\"; Copy Passenger Version 5 or higher: >passenger_set_header X-REQUEST-START \"t=${msec}\"; Copy Older versions: passenger_set_cgi_param X_REQUEST_START \"t=${msec}\"; Copy fastcgi fastcgi_param HTTP_X_REQUEST_START \"t=${msec}\"; Copy uWSGI uwsgi_param HTTP_X_REQUEST_START \"t=${msec}\"; Copy F5 load balancers For F5 load balancers, use this configuration snippet: when HTTP_REQUEST_SEND { # TCL 8.4 so we have to calculate the time in millisecond resolution # Calculation from: https://groups.google.com/forum/? fromgroups=#!topic/comp.lang.tcl/tV9H6TDv0t8 set secs [clock seconds] set ms [clock clicks -milliseconds] set base [expr { $secs * 1000 }] set fract [expr { $ms - $base }] if { $fract >= 1000 } { set diff [expr { $fract / 1000 }] incr secs $diff incr fract [expr { -1000 * $diff }] } set micros [format \"%d%03d000\" $secs $fract] # Want this header inserted as if coming from the client clientside { HTTP::header insert X-Request-Start \"t=${micros}\" } } Copy Network timing Even with request queuing configured, the front-end server's setup can still affect network time in your Browser data. This is because the front-end server does not add the queuing time header until after it actually accepts and processes the request. The queuing time headers can never account for backlog in the listener socket used to accept requests. For example, if the front-end server's configuration results in a backlog of requests that queue in the listener socket, page load timing will show an increase in network time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " the queuing time header until after it actually accepts and processes the request. The queuing time headers can never account for backlog in the listener socket used to accept requests. For example, if the front-end server&#x27;s configuration results in a backlog of requests that queue in the listener socket, <em>page</em> load timing will show an increase in network time."
      },
      "id": "603eb84a28ccbc1734eba7a5"
    }
  ],
  "/docs/apm/apm-ui-pages/features/request-queuing-tracking-front-end-time": [
    {
      "sections": [
        "Ticketing integrations",
        "Requirements",
        "Integrate with New Relic",
        "Tip",
        "File tickets"
      ],
      "title": "Ticketing integrations",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c6004eab5c13506e5bdf175be670ff86b0a24f52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/user-interface-functions/share-your-data/ticketing-integrations/",
      "published_at": "2021-07-02T11:33:40Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic APM's transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic's webhook IPs. In addition, Lighthouse setup requires: The subdomain for your installation; for example, https://subdomain.lighthouseapp.com Your Lighthouse account's email and password for ticket tracking Integrate with New Relic Tip Owner and Admins To connect your New Relic account to Lighthouse: Go to: account dropdown > Account settings > Integrations > Ticketing integrations. Select the tab for Lighthouse. Follow the instructions on the individual tab, then click Integrate. After your ticketing system has been integrated, the corresponding tab's health status indicator in New Relic's UI changes to green (enabled). File tickets To use the ticketing system integrated with your New Relic account: From the selected APM transaction trace or APM error trace, select File a ticket. Follow standard procedures to create a ticket from your Lighthouse account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.90155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic <em>APM</em>&#x27;s transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic"
      },
      "id": "603ebd11e7b9d292fc2a07ef"
    },
    {
      "sections": [
        "Configure request queue reporting",
        "HTTP header",
        "Tip",
        "C SDK",
        "Go agent",
        "Java, Node.js, Python, Ruby agents",
        ".NET agent",
        "PHP agent"
      ],
      "title": "Configure request queue reporting",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "3226477ad8d63af87fd5947589af31d0d679b89b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/features/configure-request-queue-reporting/",
      "published_at": "2021-07-02T12:45:18Z",
      "updated_at": "2021-03-16T08:18:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Request queuing occurs before the request reaches your application (where the agent resides). This is why you need to do some straightforward configuration of the agent and your production hosts to take advantage of this feature. HTTP header In order to report request queuing, most New Relic agents depend on an HTTP header set by the front-end web server (such as Apache or Nginx) or load balancer (such as HAProxy or F5). You can configure these front-end servers to set the timestamp in the HTTP header that represents when the request first entered your production infrastructure. Tip Set this header as soon after the request enters your infrastructure as possible so that you are less likely to miss performance problems in your infrastructure that occur before the header is set. Most New Relic agents will interpret an X-Queue-Start or X-Request-Start header and use it to calculate Request Queuing. The agents treat these headers identically. Include a value in the format t=MICROSECONDS_SINCE_EPOCH where MICROSECONDS_SINCE_EPOCH is an integer value of the number of microseconds that have elapsed since the beginning of the Unix epoch (for example, January 1, 1970). Nearly any front-end HTTP server or load balancer can be configured to add this header. Additional details depend on your specific agent and server configuration. For more information, see the request queue configuration examples. C SDK The C SDK does not support request queuing. Go agent With the Go agent, set either header to record a metric for it. Java, Node.js, Python, Ruby agents The most recent versions of the Java, Node.js, Python, and Ruby agents provide more flexibility in the format of the X-Request-Start or X-Queue-Start header. These agents allow the timestamp to be submitted in seconds, milliseconds, or microseconds as an integer or floating point value. These agents also allow the leading t= in the header value to be omitted. Based on the order of magnitude, these agents automatically interpret the time unit as seconds, milliseconds, or microseconds. New Relic can do this reliably since a millisecond timestamp, interpreted as microseconds, would result in a queue time over 40 years. Python agent only: When using Apache/mod_wsgi 3.4 or higher, mod_wsgi will automatically insert an equivalent to the X-Queue-Start header into the WSGI environ dictionary for each request. This will mark the specific point in time where Apache first accepted the request. The value set by mod_wsgi will be picked up and used by the Python agent if no separate X-Request-Start or X-Queue-Start header has been manually configured into a web server's front end or in Apache itself. .NET agent The .NET agent does not require (and will ignore) any configuration of HTTP headers to calculate queue time. It works by instrumenting the IIS-queuing mechanism directly and reports queue time as the difference between when the HttpContext constructor executes and when the HttpApplication.BeginRequest event fires. Request queue time is only reported for .NET Framework applications hosted on IIS (for example: ASP.NET applications). It is not reported for ASP .NET Core applications (targeting .NET Core or Framework), nor for self-hosted OWIN applications. PHP agent The PHP agent only supports the X-Request-Start header. This identifies the timestamp in microseconds as an integer, with an optional t= in the header value. To ensure that the header is read properly, check your phpinfo() under the PHP Variables section, and verify that _SERVER[\"HTTP_X_REQUEST_START\"] exists and is in the expected format. If you are using Nginx, see Request queue server configuration examples for additional information on setting the header.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>"
      },
      "id": "603eb8ba28ccbc4b1deba769"
    },
    {
      "sections": [
        "Request queue server configuration examples",
        "Apache",
        "Nginx",
        "F5 load balancers",
        "Network timing"
      ],
      "title": "Request queue server configuration examples",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c7a069b8875af411530a34aaef67155d20d7fb19",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/features/request-queue-server-configuration-examples/",
      "published_at": "2021-07-02T12:46:10Z",
      "updated_at": "2021-03-16T07:13:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to report request queuing, New Relic agents depend on an HTTP header set by the front-end web server (such as Apache or Nginx) or load balancer (such as HAProxy or F5). These examples use the X-Request-Start header, since it is has broader support across platforms. If this does not work with your server configuration for request queuing, try using the X-Queue-Start header. The syntax should otherwise be the same. Apache Apache's mod_headers module includes a %t variable that is formatted correctly. To enable request queue reporting, add this code to your Apache config: RequestHeader set X-Request-Start \"%t\" Copy Nginx If you are using Nginx version 1.2.6 or higher and the latest version of the Ruby, Python, or PHP agent, Nginx can easily be configured to report queue time. (For Nginx versions 1.2.6 or lower, you must recompile Nginx with a module or patch.) Configuring with Nginx 1.2.6 or higher uses the ${msec} variable, which is a number in seconds with milliseconds resolution. For more information, see http://nginx.org/en/docs/http/ngx_http_core_module.html#variables. Add the appropriate information to your Nginx config: Nginx configuration Values General Nginx use proxy_set_header X-Request-Start \"t=${msec}\"; Copy Passenger Version 5 or higher: >passenger_set_header X-REQUEST-START \"t=${msec}\"; Copy Older versions: passenger_set_cgi_param X_REQUEST_START \"t=${msec}\"; Copy fastcgi fastcgi_param HTTP_X_REQUEST_START \"t=${msec}\"; Copy uWSGI uwsgi_param HTTP_X_REQUEST_START \"t=${msec}\"; Copy F5 load balancers For F5 load balancers, use this configuration snippet: when HTTP_REQUEST_SEND { # TCL 8.4 so we have to calculate the time in millisecond resolution # Calculation from: https://groups.google.com/forum/? fromgroups=#!topic/comp.lang.tcl/tV9H6TDv0t8 set secs [clock seconds] set ms [clock clicks -milliseconds] set base [expr { $secs * 1000 }] set fract [expr { $ms - $base }] if { $fract >= 1000 } { set diff [expr { $fract / 1000 }] incr secs $diff incr fract [expr { -1000 * $diff }] } set micros [format \"%d%03d000\" $secs $fract] # Want this header inserted as if coming from the client clientside { HTTP::header insert X-Request-Start \"t=${micros}\" } } Copy Network timing Even with request queuing configured, the front-end server's setup can still affect network time in your Browser data. This is because the front-end server does not add the queuing time header until after it actually accepts and processes the request. The queuing time headers can never account for backlog in the listener socket used to accept requests. For example, if the front-end server's configuration results in a backlog of requests that queue in the listener socket, page load timing will show an increase in network time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " the queuing time header until after it actually accepts and processes the request. The queuing time headers can never account for backlog in the listener socket used to accept requests. For example, if the front-end server&#x27;s configuration results in a backlog of requests that queue in the listener socket, <em>page</em> load timing will show an increase in network time."
      },
      "id": "603eb84a28ccbc1734eba7a5"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/agent-specific-ui-pages": [
    {
      "sections": [
        "View slow query details",
        "Slow query data samples",
        "View slow query data",
        "Tip",
        "Configuration",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Slow queries metrics",
        "Troubleshooting: No slow query data"
      ],
      "title": "View slow query details",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "877f2ba64963875fce3cc4b656f5a66f43563cdd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-slow-query-details/",
      "published_at": "2021-07-02T12:44:26Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, when transaction traces are collected, there may be additional Slow query data available on the Databases page. Let's look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples the slowest database queries in those traces and reports data about them on the Databases page. Slow query data can include: Duration of query segments Query/explain plans (if recognized) Host and instance level details (if supported by agent) View slow query data Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To see your slow query data: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Databases. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Databases. Select a database transaction. If available, select any available slow queries listed on the page. If you do not see expected slow query data, follow the troubleshooting tips. Configuration In general, you can configure your slow query settings either of these ways: Agent configuration Server-side configuration (if available for your agent) Agent configuration gives you more options than server-side configuration does. How you choose to configure slow queries will depend on your own setup and preferences. For more information, see the documentation for the specific agent: C SDK You can report slow query traces for SQL databases only. For more information, see Instrument your application with the C SDK. Go Agent configuration options: Enable/disable: SlowQuery.Enabled Slow query threshold: SlowQuery.Threshold For other datastore config options, see Datastore tracer configuration. Java Agent configuration: Slow query threshold: explain_threshold. For other settings related to slow transactions and queries, see the Transaction tracer config options. You can also edit basic slow query settings via server-side configuration. .NET Agent configuration: Enable/disable: slowSql enabled Slow query threshold: explainThreshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Node.js Agent configuration: Enable/disable: enabled Threshold: explain_threshold Maximum slow query samples: max_samples For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration of slow query data is not possible for the Node.js agent. PHP Agent configuration: Enable/disable: slow_sql Threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration is not possible for the PHP agent. Python Agent configuration: Slow query threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Ruby Agent configuration: Enable/disable: slow_sql.enabled Slow query threshold: slow_sql.explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Slow SQL config options. If applicable for your application's agent language, you can also edit basic slow query settings by using server-side configuration. Slow queries metrics The slow queries list contains the following metrics: Metric Description Response time The average response time for the statements sampled. Sample count The number of slow queries identified in the sample. To view additional details, select an individual slow query: Metric Description Start time When the stack trace began collecting the data shown. Max time The maximum time for all similar query statements in the sample. Action The action or process invoking the query. Query The query that is being reported as slow. Depending on your configuration, some parts of the query may be obfuscated. Stack trace Where in the code the statement was called. For MySQL, we provide a query analysis, which explains what happened in your query and what you might do to speed it up. Other databases display an explain plan whenever possible. Troubleshooting: No slow query data If you do not see slow query data, it may be for any of these reasons: The slow query feature has been disabled. The threshold is set to too high a duration and no slow queries are being reported. The query obfuscation setting (usually record_sql or similar) may be set to Off. To solve the problem, try adjusting the configuration options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "In <em>APM</em>, when transaction traces are collected, there may be additional Slow query data available on the Databases <em>page</em>. Let&#x27;s look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples"
      },
      "id": "604407dae7b9d26489579a05"
    },
    {
      "sections": [
        "Transactions page: Find specific performance problems",
        "Types of transactions",
        "Tip",
        "Wall-clock time",
        "View transactions",
        "Use drill-down functions",
        "Change the displayed transaction Type",
        "Select the type of performance measurement (Sort)",
        "Mouse over summary information about a transaction",
        "Select detailed information about a transaction",
        "View transaction data in different visual formats",
        "Show corresponding Browser request data",
        "Identify transaction segments with high call counts or time",
        "Show all transactions",
        "Additional functions",
        "Caution"
      ],
      "title": "Transactions page: Find specific performance problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "af8aa4a977d05428494b8b34aed1ac6ea831d8db",
      "image": "https://docs.newrelic.com/static/0b30cbf2e9065777c252216f96c80ad7/a2d4f/APM-transaction-high-time-colorization_0.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/",
      "published_at": "2021-07-02T12:44:27Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Transactions page helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This page lists the selected app's transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per minute or rpm). For non-web transactions (such as message processing, background tasks, and other processes and jobs that do not handle web requests), this page shows charts of CPU and memory usage. Types of transactions Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Depending on your selected application, the Transactions page may include a dropdown you can use to select from the types of transactions available. New Relic measures processing time by type of request (web transaction or non-web transaction). This may include: Web: App server requests Non-web: Other requests (operations, background tasks, etc.) The Transactions page also may include links to transaction traces and key transactions. The types of information available will depend on your selected app and the type of request (web or non-web). Wall-clock time Wall-clock time is the amount of time recorded by the clock. New Relic uses wall-clock time for all the transactions and then sums that value across all of the transactions. The host can execute requests in parallel, so you may see percentages over 100. For example, 100% would indicate that the execution time across all selected transactions is equal to the time expended when recording wall-clock time. View transactions To view information about your app's transaction requests: Do one of the following: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. If applicable: To change which available types of transactions appear, select the Type. Select the sort order, or keep the default. Select the type of view as a chart (default), histogram, or percentile, if available. To view additional details, use any of the transaction drill-down functions. To add a chart to a dashboard, mouse over the chart, then select the Add to a dashboard link that appears below it. If a chart's background is light red, this indicates a time period when an alert condition's Critical threshold has been violated. To view the incident details in New Relic Alerts, click the chart. For more information, see the documentation about navigating core UI components in New Relic One. Use drill-down functions Use any of New Relic's standard user interface functions to drill down into detailed information. The Transactions page has additional drill-down functions. Change the displayed transaction Type If the Type dropdown appears above list of transactions, you can select your choice of transaction type. The available types depend on what transactions your application uses. Select the type of performance measurement (Sort) The Sort dropdown above the transaction list allows you to review transactions according to different measurements. This helps you identify good candidates for performance tuning or fixing errors. You can sort by: Sort option Comments Most time consuming (default) Highest percentage of the app's total time used. This measures which transactions consumed the most time in total. This is calculated by multiplying the number of times the transaction is called by the time the transaction took to complete. A transaction could be short, but if it is frequently called, it would appear at the top of this ranking. Slowest average response time Slowest individual transactions for the time period as averaged. This measures the slowest types of transaction. A transaction could be called only a few times, but if it is one of the longest transactions to finish, it would appear at the top of this ranking. Apdex most dissatisfying Transactions with the highest percentages of user dissatisfaction levels for the response time of your web apps and services (Apdex). The dissatisfaction level is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score, based on your Apdex settings. Transactions that have the highest (worst) percentages appear at the top of this ranking. Highest throughput This measures the amount of throughput, in operation requests per minute or rpm. (For web throughput, requests per minute is sometimes called pages per minute or ppm.) Transactions that have the highest number of requests per minute appear at the top of this ranking. Tip Depending on the transaction type you choose, different sort options may be available. Mouse over summary information about a transaction To quickly view key pieces of information about the transaction, mouse over its name on the list. Select detailed information about a transaction To view detailed information, select a transaction from the list, then select App performance or Historical performance. You can also view transaction traces. View transaction data in different visual formats The Transaction page's Top 5 transactions chart and a selected transaction's App performance window include options to view data as a: Chart Histogram Percentile In addition, from the Breakdown table for a selected transaction, you can select the link to show or hide all segments of the breakdown data. Show corresponding Browser request data In order to view browser information, you must enable New Relic Browser. Then, to view corresponding browser request data, use either of these options: Select the Browser drill-down link if available. Go to one.newrelic.com > Browser > (select an app) > Page views. Identify transaction segments with high call counts or time In a transaction's Breakdown table, the Avg calls (per txn) column may include colorized segment values. These indicate instrumented segments that have exceeded thresholds. Yellow: Segment time is more than 10% of total transaction time and call count is higher than 10. Red: Segment time is more than 10% of total transaction time and call count is higher than 20. Show all transactions To view all available transactions as a table, select the Show all transactions table link. From here, use any of the available options: To change the sort order, select any column header. To export the data to a file with comma-separated values, select Export as CSV. To return to the previous chart view, select Back to top transactions. CSV tables for ending now time periods are calculated at run time. They may show slightly higher values than what appears in the APM table. For each transaction, the Show all transactions table includes these measurements: Measurement Definition Apdex The average Apdex score for all transactions that occurred in the selected time range. Apdex scores marked with an * asterisk indicate the agent collected fewer than 100 samples for that transaction name. Data for these transactions may be less accurate than data for transactions with higher throughput. Count The total number of all transactions that occurred in the selected time range. Avg (ms) The average time taken by all transactions in the selected time range. SD (ms) The standard deviation of all timing measurements for all transactions in the selected time range. Min (ms) The time taken by the fastest transaction in the selected time range. Max (ms) The time taken by the slowest transaction in the selected time range. Total (ms) The total amount of time taken by all transactions that occurred in the selected time range. Total (% time) The total amount of time for all transactions of that type, expressed as a percentage of the total amount of time taken by all transactions. Dissat (%) The percentage of the transactions that did not have satisfied Apdex scores. If you view transactions as a table, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in the Dissat (%) column is 100%. Additional functions Here are some additional functions for the Transactions page's selected transaction. If you want to... Do this... View transactions for operations and other background tasks Change the Type to Other transactions (or a specific type listed), then select a specific transaction. The Transactions page shows the top five transactions for this selection by wall-clock time, CPU usage, and memory usage. Track a transaction that is important to your business Select the transaction's name, then select Track as key transaction. View transaction trace details A transaction trace is a complete picture of a single transaction. From the Transactions page, select the transaction trace. Select the view for Summary, Trace details, or Database queries, if available. To expand the transaction trace to full screen view, select the full screen icon. To return to the Transactions page: Next to the transaction trace's name, select the back arrow. Add or view transaction segments To add segments to a transaction, use custom instrumentation. To view the segments of a specific transaction, use transaction traces. View reports You can also use the Web transactions analysis report for web transactions and the Background jobs analysis report for non-web transactions to compare the amount of time spent in throughput, total time in the transaction, average time to execute it, and Apdex score as applicable. Delete all transaction traces Caution If you select Delete all traces, you cannot recover them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transactions <em>page</em>: Find specific performance problems",
        "sections": "Transactions <em>page</em>: Find specific performance problems",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em>&#x27;s Transactions <em>page</em> helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This <em>page</em> lists the selected app&#x27;s transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per"
      },
      "id": "603ebd8228ccbcd2d3eba77b"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/apm-summary-page-view-transaction-apdex-usage-data": [
    {
      "sections": [
        "View slow query details",
        "Slow query data samples",
        "View slow query data",
        "Tip",
        "Configuration",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Slow queries metrics",
        "Troubleshooting: No slow query data"
      ],
      "title": "View slow query details",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "877f2ba64963875fce3cc4b656f5a66f43563cdd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-slow-query-details/",
      "published_at": "2021-07-02T12:44:26Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, when transaction traces are collected, there may be additional Slow query data available on the Databases page. Let's look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples the slowest database queries in those traces and reports data about them on the Databases page. Slow query data can include: Duration of query segments Query/explain plans (if recognized) Host and instance level details (if supported by agent) View slow query data Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To see your slow query data: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Databases. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Databases. Select a database transaction. If available, select any available slow queries listed on the page. If you do not see expected slow query data, follow the troubleshooting tips. Configuration In general, you can configure your slow query settings either of these ways: Agent configuration Server-side configuration (if available for your agent) Agent configuration gives you more options than server-side configuration does. How you choose to configure slow queries will depend on your own setup and preferences. For more information, see the documentation for the specific agent: C SDK You can report slow query traces for SQL databases only. For more information, see Instrument your application with the C SDK. Go Agent configuration options: Enable/disable: SlowQuery.Enabled Slow query threshold: SlowQuery.Threshold For other datastore config options, see Datastore tracer configuration. Java Agent configuration: Slow query threshold: explain_threshold. For other settings related to slow transactions and queries, see the Transaction tracer config options. You can also edit basic slow query settings via server-side configuration. .NET Agent configuration: Enable/disable: slowSql enabled Slow query threshold: explainThreshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Node.js Agent configuration: Enable/disable: enabled Threshold: explain_threshold Maximum slow query samples: max_samples For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration of slow query data is not possible for the Node.js agent. PHP Agent configuration: Enable/disable: slow_sql Threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration is not possible for the PHP agent. Python Agent configuration: Slow query threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Ruby Agent configuration: Enable/disable: slow_sql.enabled Slow query threshold: slow_sql.explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Slow SQL config options. If applicable for your application's agent language, you can also edit basic slow query settings by using server-side configuration. Slow queries metrics The slow queries list contains the following metrics: Metric Description Response time The average response time for the statements sampled. Sample count The number of slow queries identified in the sample. To view additional details, select an individual slow query: Metric Description Start time When the stack trace began collecting the data shown. Max time The maximum time for all similar query statements in the sample. Action The action or process invoking the query. Query The query that is being reported as slow. Depending on your configuration, some parts of the query may be obfuscated. Stack trace Where in the code the statement was called. For MySQL, we provide a query analysis, which explains what happened in your query and what you might do to speed it up. Other databases display an explain plan whenever possible. Troubleshooting: No slow query data If you do not see slow query data, it may be for any of these reasons: The slow query feature has been disabled. The threshold is set to too high a duration and no slow queries are being reported. The query obfuscation setting (usually record_sql or similar) may be set to Off. To solve the problem, try adjusting the configuration options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "In <em>APM</em>, when transaction traces are collected, there may be additional Slow query data available on the Databases <em>page</em>. Let&#x27;s look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples"
      },
      "id": "604407dae7b9d26489579a05"
    },
    {
      "sections": [
        "Transactions page: Find specific performance problems",
        "Types of transactions",
        "Tip",
        "Wall-clock time",
        "View transactions",
        "Use drill-down functions",
        "Change the displayed transaction Type",
        "Select the type of performance measurement (Sort)",
        "Mouse over summary information about a transaction",
        "Select detailed information about a transaction",
        "View transaction data in different visual formats",
        "Show corresponding Browser request data",
        "Identify transaction segments with high call counts or time",
        "Show all transactions",
        "Additional functions",
        "Caution"
      ],
      "title": "Transactions page: Find specific performance problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "af8aa4a977d05428494b8b34aed1ac6ea831d8db",
      "image": "https://docs.newrelic.com/static/0b30cbf2e9065777c252216f96c80ad7/a2d4f/APM-transaction-high-time-colorization_0.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/",
      "published_at": "2021-07-02T12:44:27Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Transactions page helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This page lists the selected app's transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per minute or rpm). For non-web transactions (such as message processing, background tasks, and other processes and jobs that do not handle web requests), this page shows charts of CPU and memory usage. Types of transactions Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Depending on your selected application, the Transactions page may include a dropdown you can use to select from the types of transactions available. New Relic measures processing time by type of request (web transaction or non-web transaction). This may include: Web: App server requests Non-web: Other requests (operations, background tasks, etc.) The Transactions page also may include links to transaction traces and key transactions. The types of information available will depend on your selected app and the type of request (web or non-web). Wall-clock time Wall-clock time is the amount of time recorded by the clock. New Relic uses wall-clock time for all the transactions and then sums that value across all of the transactions. The host can execute requests in parallel, so you may see percentages over 100. For example, 100% would indicate that the execution time across all selected transactions is equal to the time expended when recording wall-clock time. View transactions To view information about your app's transaction requests: Do one of the following: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. If applicable: To change which available types of transactions appear, select the Type. Select the sort order, or keep the default. Select the type of view as a chart (default), histogram, or percentile, if available. To view additional details, use any of the transaction drill-down functions. To add a chart to a dashboard, mouse over the chart, then select the Add to a dashboard link that appears below it. If a chart's background is light red, this indicates a time period when an alert condition's Critical threshold has been violated. To view the incident details in New Relic Alerts, click the chart. For more information, see the documentation about navigating core UI components in New Relic One. Use drill-down functions Use any of New Relic's standard user interface functions to drill down into detailed information. The Transactions page has additional drill-down functions. Change the displayed transaction Type If the Type dropdown appears above list of transactions, you can select your choice of transaction type. The available types depend on what transactions your application uses. Select the type of performance measurement (Sort) The Sort dropdown above the transaction list allows you to review transactions according to different measurements. This helps you identify good candidates for performance tuning or fixing errors. You can sort by: Sort option Comments Most time consuming (default) Highest percentage of the app's total time used. This measures which transactions consumed the most time in total. This is calculated by multiplying the number of times the transaction is called by the time the transaction took to complete. A transaction could be short, but if it is frequently called, it would appear at the top of this ranking. Slowest average response time Slowest individual transactions for the time period as averaged. This measures the slowest types of transaction. A transaction could be called only a few times, but if it is one of the longest transactions to finish, it would appear at the top of this ranking. Apdex most dissatisfying Transactions with the highest percentages of user dissatisfaction levels for the response time of your web apps and services (Apdex). The dissatisfaction level is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score, based on your Apdex settings. Transactions that have the highest (worst) percentages appear at the top of this ranking. Highest throughput This measures the amount of throughput, in operation requests per minute or rpm. (For web throughput, requests per minute is sometimes called pages per minute or ppm.) Transactions that have the highest number of requests per minute appear at the top of this ranking. Tip Depending on the transaction type you choose, different sort options may be available. Mouse over summary information about a transaction To quickly view key pieces of information about the transaction, mouse over its name on the list. Select detailed information about a transaction To view detailed information, select a transaction from the list, then select App performance or Historical performance. You can also view transaction traces. View transaction data in different visual formats The Transaction page's Top 5 transactions chart and a selected transaction's App performance window include options to view data as a: Chart Histogram Percentile In addition, from the Breakdown table for a selected transaction, you can select the link to show or hide all segments of the breakdown data. Show corresponding Browser request data In order to view browser information, you must enable New Relic Browser. Then, to view corresponding browser request data, use either of these options: Select the Browser drill-down link if available. Go to one.newrelic.com > Browser > (select an app) > Page views. Identify transaction segments with high call counts or time In a transaction's Breakdown table, the Avg calls (per txn) column may include colorized segment values. These indicate instrumented segments that have exceeded thresholds. Yellow: Segment time is more than 10% of total transaction time and call count is higher than 10. Red: Segment time is more than 10% of total transaction time and call count is higher than 20. Show all transactions To view all available transactions as a table, select the Show all transactions table link. From here, use any of the available options: To change the sort order, select any column header. To export the data to a file with comma-separated values, select Export as CSV. To return to the previous chart view, select Back to top transactions. CSV tables for ending now time periods are calculated at run time. They may show slightly higher values than what appears in the APM table. For each transaction, the Show all transactions table includes these measurements: Measurement Definition Apdex The average Apdex score for all transactions that occurred in the selected time range. Apdex scores marked with an * asterisk indicate the agent collected fewer than 100 samples for that transaction name. Data for these transactions may be less accurate than data for transactions with higher throughput. Count The total number of all transactions that occurred in the selected time range. Avg (ms) The average time taken by all transactions in the selected time range. SD (ms) The standard deviation of all timing measurements for all transactions in the selected time range. Min (ms) The time taken by the fastest transaction in the selected time range. Max (ms) The time taken by the slowest transaction in the selected time range. Total (ms) The total amount of time taken by all transactions that occurred in the selected time range. Total (% time) The total amount of time for all transactions of that type, expressed as a percentage of the total amount of time taken by all transactions. Dissat (%) The percentage of the transactions that did not have satisfied Apdex scores. If you view transactions as a table, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in the Dissat (%) column is 100%. Additional functions Here are some additional functions for the Transactions page's selected transaction. If you want to... Do this... View transactions for operations and other background tasks Change the Type to Other transactions (or a specific type listed), then select a specific transaction. The Transactions page shows the top five transactions for this selection by wall-clock time, CPU usage, and memory usage. Track a transaction that is important to your business Select the transaction's name, then select Track as key transaction. View transaction trace details A transaction trace is a complete picture of a single transaction. From the Transactions page, select the transaction trace. Select the view for Summary, Trace details, or Database queries, if available. To expand the transaction trace to full screen view, select the full screen icon. To return to the Transactions page: Next to the transaction trace's name, select the back arrow. Add or view transaction segments To add segments to a transaction, use custom instrumentation. To view the segments of a specific transaction, use transaction traces. View reports You can also use the Web transactions analysis report for web transactions and the Background jobs analysis report for non-web transactions to compare the amount of time spent in throughput, total time in the transaction, average time to execute it, and Apdex score as applicable. Delete all transaction traces Caution If you select Delete all traces, you cannot recover them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transactions <em>page</em>: Find specific performance problems",
        "sections": "Transactions <em>page</em>: Find specific performance problems",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em>&#x27;s Transactions <em>page</em> helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This <em>page</em> lists the selected app&#x27;s transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per"
      },
      "id": "603ebd8228ccbcd2d3eba77b"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/databases-page-view-operations-throughput-response-time": [
    {
      "sections": [
        "View slow query details",
        "Slow query data samples",
        "View slow query data",
        "Tip",
        "Configuration",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Slow queries metrics",
        "Troubleshooting: No slow query data"
      ],
      "title": "View slow query details",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "877f2ba64963875fce3cc4b656f5a66f43563cdd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-slow-query-details/",
      "published_at": "2021-07-02T12:44:26Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, when transaction traces are collected, there may be additional Slow query data available on the Databases page. Let's look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples the slowest database queries in those traces and reports data about them on the Databases page. Slow query data can include: Duration of query segments Query/explain plans (if recognized) Host and instance level details (if supported by agent) View slow query data Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To see your slow query data: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Databases. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Databases. Select a database transaction. If available, select any available slow queries listed on the page. If you do not see expected slow query data, follow the troubleshooting tips. Configuration In general, you can configure your slow query settings either of these ways: Agent configuration Server-side configuration (if available for your agent) Agent configuration gives you more options than server-side configuration does. How you choose to configure slow queries will depend on your own setup and preferences. For more information, see the documentation for the specific agent: C SDK You can report slow query traces for SQL databases only. For more information, see Instrument your application with the C SDK. Go Agent configuration options: Enable/disable: SlowQuery.Enabled Slow query threshold: SlowQuery.Threshold For other datastore config options, see Datastore tracer configuration. Java Agent configuration: Slow query threshold: explain_threshold. For other settings related to slow transactions and queries, see the Transaction tracer config options. You can also edit basic slow query settings via server-side configuration. .NET Agent configuration: Enable/disable: slowSql enabled Slow query threshold: explainThreshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Node.js Agent configuration: Enable/disable: enabled Threshold: explain_threshold Maximum slow query samples: max_samples For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration of slow query data is not possible for the Node.js agent. PHP Agent configuration: Enable/disable: slow_sql Threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration is not possible for the PHP agent. Python Agent configuration: Slow query threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Ruby Agent configuration: Enable/disable: slow_sql.enabled Slow query threshold: slow_sql.explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Slow SQL config options. If applicable for your application's agent language, you can also edit basic slow query settings by using server-side configuration. Slow queries metrics The slow queries list contains the following metrics: Metric Description Response time The average response time for the statements sampled. Sample count The number of slow queries identified in the sample. To view additional details, select an individual slow query: Metric Description Start time When the stack trace began collecting the data shown. Max time The maximum time for all similar query statements in the sample. Action The action or process invoking the query. Query The query that is being reported as slow. Depending on your configuration, some parts of the query may be obfuscated. Stack trace Where in the code the statement was called. For MySQL, we provide a query analysis, which explains what happened in your query and what you might do to speed it up. Other databases display an explain plan whenever possible. Troubleshooting: No slow query data If you do not see slow query data, it may be for any of these reasons: The slow query feature has been disabled. The threshold is set to too high a duration and no slow queries are being reported. The query obfuscation setting (usually record_sql or similar) may be set to Off. To solve the problem, try adjusting the configuration options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "In <em>APM</em>, when transaction traces are collected, there may be additional Slow query data available on the Databases <em>page</em>. Let&#x27;s look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples"
      },
      "id": "604407dae7b9d26489579a05"
    },
    {
      "sections": [
        "Transactions page: Find specific performance problems",
        "Types of transactions",
        "Tip",
        "Wall-clock time",
        "View transactions",
        "Use drill-down functions",
        "Change the displayed transaction Type",
        "Select the type of performance measurement (Sort)",
        "Mouse over summary information about a transaction",
        "Select detailed information about a transaction",
        "View transaction data in different visual formats",
        "Show corresponding Browser request data",
        "Identify transaction segments with high call counts or time",
        "Show all transactions",
        "Additional functions",
        "Caution"
      ],
      "title": "Transactions page: Find specific performance problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "af8aa4a977d05428494b8b34aed1ac6ea831d8db",
      "image": "https://docs.newrelic.com/static/0b30cbf2e9065777c252216f96c80ad7/a2d4f/APM-transaction-high-time-colorization_0.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/",
      "published_at": "2021-07-02T12:44:27Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Transactions page helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This page lists the selected app's transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per minute or rpm). For non-web transactions (such as message processing, background tasks, and other processes and jobs that do not handle web requests), this page shows charts of CPU and memory usage. Types of transactions Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Depending on your selected application, the Transactions page may include a dropdown you can use to select from the types of transactions available. New Relic measures processing time by type of request (web transaction or non-web transaction). This may include: Web: App server requests Non-web: Other requests (operations, background tasks, etc.) The Transactions page also may include links to transaction traces and key transactions. The types of information available will depend on your selected app and the type of request (web or non-web). Wall-clock time Wall-clock time is the amount of time recorded by the clock. New Relic uses wall-clock time for all the transactions and then sums that value across all of the transactions. The host can execute requests in parallel, so you may see percentages over 100. For example, 100% would indicate that the execution time across all selected transactions is equal to the time expended when recording wall-clock time. View transactions To view information about your app's transaction requests: Do one of the following: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. If applicable: To change which available types of transactions appear, select the Type. Select the sort order, or keep the default. Select the type of view as a chart (default), histogram, or percentile, if available. To view additional details, use any of the transaction drill-down functions. To add a chart to a dashboard, mouse over the chart, then select the Add to a dashboard link that appears below it. If a chart's background is light red, this indicates a time period when an alert condition's Critical threshold has been violated. To view the incident details in New Relic Alerts, click the chart. For more information, see the documentation about navigating core UI components in New Relic One. Use drill-down functions Use any of New Relic's standard user interface functions to drill down into detailed information. The Transactions page has additional drill-down functions. Change the displayed transaction Type If the Type dropdown appears above list of transactions, you can select your choice of transaction type. The available types depend on what transactions your application uses. Select the type of performance measurement (Sort) The Sort dropdown above the transaction list allows you to review transactions according to different measurements. This helps you identify good candidates for performance tuning or fixing errors. You can sort by: Sort option Comments Most time consuming (default) Highest percentage of the app's total time used. This measures which transactions consumed the most time in total. This is calculated by multiplying the number of times the transaction is called by the time the transaction took to complete. A transaction could be short, but if it is frequently called, it would appear at the top of this ranking. Slowest average response time Slowest individual transactions for the time period as averaged. This measures the slowest types of transaction. A transaction could be called only a few times, but if it is one of the longest transactions to finish, it would appear at the top of this ranking. Apdex most dissatisfying Transactions with the highest percentages of user dissatisfaction levels for the response time of your web apps and services (Apdex). The dissatisfaction level is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score, based on your Apdex settings. Transactions that have the highest (worst) percentages appear at the top of this ranking. Highest throughput This measures the amount of throughput, in operation requests per minute or rpm. (For web throughput, requests per minute is sometimes called pages per minute or ppm.) Transactions that have the highest number of requests per minute appear at the top of this ranking. Tip Depending on the transaction type you choose, different sort options may be available. Mouse over summary information about a transaction To quickly view key pieces of information about the transaction, mouse over its name on the list. Select detailed information about a transaction To view detailed information, select a transaction from the list, then select App performance or Historical performance. You can also view transaction traces. View transaction data in different visual formats The Transaction page's Top 5 transactions chart and a selected transaction's App performance window include options to view data as a: Chart Histogram Percentile In addition, from the Breakdown table for a selected transaction, you can select the link to show or hide all segments of the breakdown data. Show corresponding Browser request data In order to view browser information, you must enable New Relic Browser. Then, to view corresponding browser request data, use either of these options: Select the Browser drill-down link if available. Go to one.newrelic.com > Browser > (select an app) > Page views. Identify transaction segments with high call counts or time In a transaction's Breakdown table, the Avg calls (per txn) column may include colorized segment values. These indicate instrumented segments that have exceeded thresholds. Yellow: Segment time is more than 10% of total transaction time and call count is higher than 10. Red: Segment time is more than 10% of total transaction time and call count is higher than 20. Show all transactions To view all available transactions as a table, select the Show all transactions table link. From here, use any of the available options: To change the sort order, select any column header. To export the data to a file with comma-separated values, select Export as CSV. To return to the previous chart view, select Back to top transactions. CSV tables for ending now time periods are calculated at run time. They may show slightly higher values than what appears in the APM table. For each transaction, the Show all transactions table includes these measurements: Measurement Definition Apdex The average Apdex score for all transactions that occurred in the selected time range. Apdex scores marked with an * asterisk indicate the agent collected fewer than 100 samples for that transaction name. Data for these transactions may be less accurate than data for transactions with higher throughput. Count The total number of all transactions that occurred in the selected time range. Avg (ms) The average time taken by all transactions in the selected time range. SD (ms) The standard deviation of all timing measurements for all transactions in the selected time range. Min (ms) The time taken by the fastest transaction in the selected time range. Max (ms) The time taken by the slowest transaction in the selected time range. Total (ms) The total amount of time taken by all transactions that occurred in the selected time range. Total (% time) The total amount of time for all transactions of that type, expressed as a percentage of the total amount of time taken by all transactions. Dissat (%) The percentage of the transactions that did not have satisfied Apdex scores. If you view transactions as a table, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in the Dissat (%) column is 100%. Additional functions Here are some additional functions for the Transactions page's selected transaction. If you want to... Do this... View transactions for operations and other background tasks Change the Type to Other transactions (or a specific type listed), then select a specific transaction. The Transactions page shows the top five transactions for this selection by wall-clock time, CPU usage, and memory usage. Track a transaction that is important to your business Select the transaction's name, then select Track as key transaction. View transaction trace details A transaction trace is a complete picture of a single transaction. From the Transactions page, select the transaction trace. Select the view for Summary, Trace details, or Database queries, if available. To expand the transaction trace to full screen view, select the full screen icon. To return to the Transactions page: Next to the transaction trace's name, select the back arrow. Add or view transaction segments To add segments to a transaction, use custom instrumentation. To view the segments of a specific transaction, use transaction traces. View reports You can also use the Web transactions analysis report for web transactions and the Background jobs analysis report for non-web transactions to compare the amount of time spent in throughput, total time in the transaction, average time to execute it, and Apdex score as applicable. Delete all transaction traces Caution If you select Delete all traces, you cannot recover them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transactions <em>page</em>: Find specific performance problems",
        "sections": "Transactions <em>page</em>: Find specific performance problems",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em>&#x27;s Transactions <em>page</em> helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This <em>page</em> lists the selected app&#x27;s transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per"
      },
      "id": "603ebd8228ccbcd2d3eba77b"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/external-services-page-view-web-cloud-network-data": [
    {
      "sections": [
        "View slow query details",
        "Slow query data samples",
        "View slow query data",
        "Tip",
        "Configuration",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Slow queries metrics",
        "Troubleshooting: No slow query data"
      ],
      "title": "View slow query details",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "877f2ba64963875fce3cc4b656f5a66f43563cdd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-slow-query-details/",
      "published_at": "2021-07-02T12:44:26Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, when transaction traces are collected, there may be additional Slow query data available on the Databases page. Let's look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples the slowest database queries in those traces and reports data about them on the Databases page. Slow query data can include: Duration of query segments Query/explain plans (if recognized) Host and instance level details (if supported by agent) View slow query data Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To see your slow query data: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Databases. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Databases. Select a database transaction. If available, select any available slow queries listed on the page. If you do not see expected slow query data, follow the troubleshooting tips. Configuration In general, you can configure your slow query settings either of these ways: Agent configuration Server-side configuration (if available for your agent) Agent configuration gives you more options than server-side configuration does. How you choose to configure slow queries will depend on your own setup and preferences. For more information, see the documentation for the specific agent: C SDK You can report slow query traces for SQL databases only. For more information, see Instrument your application with the C SDK. Go Agent configuration options: Enable/disable: SlowQuery.Enabled Slow query threshold: SlowQuery.Threshold For other datastore config options, see Datastore tracer configuration. Java Agent configuration: Slow query threshold: explain_threshold. For other settings related to slow transactions and queries, see the Transaction tracer config options. You can also edit basic slow query settings via server-side configuration. .NET Agent configuration: Enable/disable: slowSql enabled Slow query threshold: explainThreshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Node.js Agent configuration: Enable/disable: enabled Threshold: explain_threshold Maximum slow query samples: max_samples For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration of slow query data is not possible for the Node.js agent. PHP Agent configuration: Enable/disable: slow_sql Threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration is not possible for the PHP agent. Python Agent configuration: Slow query threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Ruby Agent configuration: Enable/disable: slow_sql.enabled Slow query threshold: slow_sql.explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Slow SQL config options. If applicable for your application's agent language, you can also edit basic slow query settings by using server-side configuration. Slow queries metrics The slow queries list contains the following metrics: Metric Description Response time The average response time for the statements sampled. Sample count The number of slow queries identified in the sample. To view additional details, select an individual slow query: Metric Description Start time When the stack trace began collecting the data shown. Max time The maximum time for all similar query statements in the sample. Action The action or process invoking the query. Query The query that is being reported as slow. Depending on your configuration, some parts of the query may be obfuscated. Stack trace Where in the code the statement was called. For MySQL, we provide a query analysis, which explains what happened in your query and what you might do to speed it up. Other databases display an explain plan whenever possible. Troubleshooting: No slow query data If you do not see slow query data, it may be for any of these reasons: The slow query feature has been disabled. The threshold is set to too high a duration and no slow queries are being reported. The query obfuscation setting (usually record_sql or similar) may be set to Off. To solve the problem, try adjusting the configuration options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "In <em>APM</em>, when transaction traces are collected, there may be additional Slow query data available on the Databases <em>page</em>. Let&#x27;s look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples"
      },
      "id": "604407dae7b9d26489579a05"
    },
    {
      "sections": [
        "Transactions page: Find specific performance problems",
        "Types of transactions",
        "Tip",
        "Wall-clock time",
        "View transactions",
        "Use drill-down functions",
        "Change the displayed transaction Type",
        "Select the type of performance measurement (Sort)",
        "Mouse over summary information about a transaction",
        "Select detailed information about a transaction",
        "View transaction data in different visual formats",
        "Show corresponding Browser request data",
        "Identify transaction segments with high call counts or time",
        "Show all transactions",
        "Additional functions",
        "Caution"
      ],
      "title": "Transactions page: Find specific performance problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "af8aa4a977d05428494b8b34aed1ac6ea831d8db",
      "image": "https://docs.newrelic.com/static/0b30cbf2e9065777c252216f96c80ad7/a2d4f/APM-transaction-high-time-colorization_0.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/",
      "published_at": "2021-07-02T12:44:27Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Transactions page helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This page lists the selected app's transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per minute or rpm). For non-web transactions (such as message processing, background tasks, and other processes and jobs that do not handle web requests), this page shows charts of CPU and memory usage. Types of transactions Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Depending on your selected application, the Transactions page may include a dropdown you can use to select from the types of transactions available. New Relic measures processing time by type of request (web transaction or non-web transaction). This may include: Web: App server requests Non-web: Other requests (operations, background tasks, etc.) The Transactions page also may include links to transaction traces and key transactions. The types of information available will depend on your selected app and the type of request (web or non-web). Wall-clock time Wall-clock time is the amount of time recorded by the clock. New Relic uses wall-clock time for all the transactions and then sums that value across all of the transactions. The host can execute requests in parallel, so you may see percentages over 100. For example, 100% would indicate that the execution time across all selected transactions is equal to the time expended when recording wall-clock time. View transactions To view information about your app's transaction requests: Do one of the following: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. If applicable: To change which available types of transactions appear, select the Type. Select the sort order, or keep the default. Select the type of view as a chart (default), histogram, or percentile, if available. To view additional details, use any of the transaction drill-down functions. To add a chart to a dashboard, mouse over the chart, then select the Add to a dashboard link that appears below it. If a chart's background is light red, this indicates a time period when an alert condition's Critical threshold has been violated. To view the incident details in New Relic Alerts, click the chart. For more information, see the documentation about navigating core UI components in New Relic One. Use drill-down functions Use any of New Relic's standard user interface functions to drill down into detailed information. The Transactions page has additional drill-down functions. Change the displayed transaction Type If the Type dropdown appears above list of transactions, you can select your choice of transaction type. The available types depend on what transactions your application uses. Select the type of performance measurement (Sort) The Sort dropdown above the transaction list allows you to review transactions according to different measurements. This helps you identify good candidates for performance tuning or fixing errors. You can sort by: Sort option Comments Most time consuming (default) Highest percentage of the app's total time used. This measures which transactions consumed the most time in total. This is calculated by multiplying the number of times the transaction is called by the time the transaction took to complete. A transaction could be short, but if it is frequently called, it would appear at the top of this ranking. Slowest average response time Slowest individual transactions for the time period as averaged. This measures the slowest types of transaction. A transaction could be called only a few times, but if it is one of the longest transactions to finish, it would appear at the top of this ranking. Apdex most dissatisfying Transactions with the highest percentages of user dissatisfaction levels for the response time of your web apps and services (Apdex). The dissatisfaction level is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score, based on your Apdex settings. Transactions that have the highest (worst) percentages appear at the top of this ranking. Highest throughput This measures the amount of throughput, in operation requests per minute or rpm. (For web throughput, requests per minute is sometimes called pages per minute or ppm.) Transactions that have the highest number of requests per minute appear at the top of this ranking. Tip Depending on the transaction type you choose, different sort options may be available. Mouse over summary information about a transaction To quickly view key pieces of information about the transaction, mouse over its name on the list. Select detailed information about a transaction To view detailed information, select a transaction from the list, then select App performance or Historical performance. You can also view transaction traces. View transaction data in different visual formats The Transaction page's Top 5 transactions chart and a selected transaction's App performance window include options to view data as a: Chart Histogram Percentile In addition, from the Breakdown table for a selected transaction, you can select the link to show or hide all segments of the breakdown data. Show corresponding Browser request data In order to view browser information, you must enable New Relic Browser. Then, to view corresponding browser request data, use either of these options: Select the Browser drill-down link if available. Go to one.newrelic.com > Browser > (select an app) > Page views. Identify transaction segments with high call counts or time In a transaction's Breakdown table, the Avg calls (per txn) column may include colorized segment values. These indicate instrumented segments that have exceeded thresholds. Yellow: Segment time is more than 10% of total transaction time and call count is higher than 10. Red: Segment time is more than 10% of total transaction time and call count is higher than 20. Show all transactions To view all available transactions as a table, select the Show all transactions table link. From here, use any of the available options: To change the sort order, select any column header. To export the data to a file with comma-separated values, select Export as CSV. To return to the previous chart view, select Back to top transactions. CSV tables for ending now time periods are calculated at run time. They may show slightly higher values than what appears in the APM table. For each transaction, the Show all transactions table includes these measurements: Measurement Definition Apdex The average Apdex score for all transactions that occurred in the selected time range. Apdex scores marked with an * asterisk indicate the agent collected fewer than 100 samples for that transaction name. Data for these transactions may be less accurate than data for transactions with higher throughput. Count The total number of all transactions that occurred in the selected time range. Avg (ms) The average time taken by all transactions in the selected time range. SD (ms) The standard deviation of all timing measurements for all transactions in the selected time range. Min (ms) The time taken by the fastest transaction in the selected time range. Max (ms) The time taken by the slowest transaction in the selected time range. Total (ms) The total amount of time taken by all transactions that occurred in the selected time range. Total (% time) The total amount of time for all transactions of that type, expressed as a percentage of the total amount of time taken by all transactions. Dissat (%) The percentage of the transactions that did not have satisfied Apdex scores. If you view transactions as a table, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in the Dissat (%) column is 100%. Additional functions Here are some additional functions for the Transactions page's selected transaction. If you want to... Do this... View transactions for operations and other background tasks Change the Type to Other transactions (or a specific type listed), then select a specific transaction. The Transactions page shows the top five transactions for this selection by wall-clock time, CPU usage, and memory usage. Track a transaction that is important to your business Select the transaction's name, then select Track as key transaction. View transaction trace details A transaction trace is a complete picture of a single transaction. From the Transactions page, select the transaction trace. Select the view for Summary, Trace details, or Database queries, if available. To expand the transaction trace to full screen view, select the full screen icon. To return to the Transactions page: Next to the transaction trace's name, select the back arrow. Add or view transaction segments To add segments to a transaction, use custom instrumentation. To view the segments of a specific transaction, use transaction traces. View reports You can also use the Web transactions analysis report for web transactions and the Background jobs analysis report for non-web transactions to compare the amount of time spent in throughput, total time in the transaction, average time to execute it, and Apdex score as applicable. Delete all transaction traces Caution If you select Delete all traces, you cannot recover them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transactions <em>page</em>: Find specific performance problems",
        "sections": "Transactions <em>page</em>: Find specific performance problems",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em>&#x27;s Transactions <em>page</em> helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This <em>page</em> lists the selected app&#x27;s transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per"
      },
      "id": "603ebd8228ccbcd2d3eba77b"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/response-time-chart-types-apm-browser": [
    {
      "sections": [
        "View slow query details",
        "Slow query data samples",
        "View slow query data",
        "Tip",
        "Configuration",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Slow queries metrics",
        "Troubleshooting: No slow query data"
      ],
      "title": "View slow query details",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "877f2ba64963875fce3cc4b656f5a66f43563cdd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-slow-query-details/",
      "published_at": "2021-07-02T12:44:26Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, when transaction traces are collected, there may be additional Slow query data available on the Databases page. Let's look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples the slowest database queries in those traces and reports data about them on the Databases page. Slow query data can include: Duration of query segments Query/explain plans (if recognized) Host and instance level details (if supported by agent) View slow query data Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To see your slow query data: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Databases. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Databases. Select a database transaction. If available, select any available slow queries listed on the page. If you do not see expected slow query data, follow the troubleshooting tips. Configuration In general, you can configure your slow query settings either of these ways: Agent configuration Server-side configuration (if available for your agent) Agent configuration gives you more options than server-side configuration does. How you choose to configure slow queries will depend on your own setup and preferences. For more information, see the documentation for the specific agent: C SDK You can report slow query traces for SQL databases only. For more information, see Instrument your application with the C SDK. Go Agent configuration options: Enable/disable: SlowQuery.Enabled Slow query threshold: SlowQuery.Threshold For other datastore config options, see Datastore tracer configuration. Java Agent configuration: Slow query threshold: explain_threshold. For other settings related to slow transactions and queries, see the Transaction tracer config options. You can also edit basic slow query settings via server-side configuration. .NET Agent configuration: Enable/disable: slowSql enabled Slow query threshold: explainThreshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Node.js Agent configuration: Enable/disable: enabled Threshold: explain_threshold Maximum slow query samples: max_samples For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration of slow query data is not possible for the Node.js agent. PHP Agent configuration: Enable/disable: slow_sql Threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration is not possible for the PHP agent. Python Agent configuration: Slow query threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Ruby Agent configuration: Enable/disable: slow_sql.enabled Slow query threshold: slow_sql.explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Slow SQL config options. If applicable for your application's agent language, you can also edit basic slow query settings by using server-side configuration. Slow queries metrics The slow queries list contains the following metrics: Metric Description Response time The average response time for the statements sampled. Sample count The number of slow queries identified in the sample. To view additional details, select an individual slow query: Metric Description Start time When the stack trace began collecting the data shown. Max time The maximum time for all similar query statements in the sample. Action The action or process invoking the query. Query The query that is being reported as slow. Depending on your configuration, some parts of the query may be obfuscated. Stack trace Where in the code the statement was called. For MySQL, we provide a query analysis, which explains what happened in your query and what you might do to speed it up. Other databases display an explain plan whenever possible. Troubleshooting: No slow query data If you do not see slow query data, it may be for any of these reasons: The slow query feature has been disabled. The threshold is set to too high a duration and no slow queries are being reported. The query obfuscation setting (usually record_sql or similar) may be set to Off. To solve the problem, try adjusting the configuration options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "In <em>APM</em>, when transaction traces are collected, there may be additional Slow query data available on the Databases <em>page</em>. Let&#x27;s look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples"
      },
      "id": "604407dae7b9d26489579a05"
    },
    {
      "sections": [
        "Transactions page: Find specific performance problems",
        "Types of transactions",
        "Tip",
        "Wall-clock time",
        "View transactions",
        "Use drill-down functions",
        "Change the displayed transaction Type",
        "Select the type of performance measurement (Sort)",
        "Mouse over summary information about a transaction",
        "Select detailed information about a transaction",
        "View transaction data in different visual formats",
        "Show corresponding Browser request data",
        "Identify transaction segments with high call counts or time",
        "Show all transactions",
        "Additional functions",
        "Caution"
      ],
      "title": "Transactions page: Find specific performance problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "af8aa4a977d05428494b8b34aed1ac6ea831d8db",
      "image": "https://docs.newrelic.com/static/0b30cbf2e9065777c252216f96c80ad7/a2d4f/APM-transaction-high-time-colorization_0.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/",
      "published_at": "2021-07-02T12:44:27Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Transactions page helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This page lists the selected app's transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per minute or rpm). For non-web transactions (such as message processing, background tasks, and other processes and jobs that do not handle web requests), this page shows charts of CPU and memory usage. Types of transactions Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Depending on your selected application, the Transactions page may include a dropdown you can use to select from the types of transactions available. New Relic measures processing time by type of request (web transaction or non-web transaction). This may include: Web: App server requests Non-web: Other requests (operations, background tasks, etc.) The Transactions page also may include links to transaction traces and key transactions. The types of information available will depend on your selected app and the type of request (web or non-web). Wall-clock time Wall-clock time is the amount of time recorded by the clock. New Relic uses wall-clock time for all the transactions and then sums that value across all of the transactions. The host can execute requests in parallel, so you may see percentages over 100. For example, 100% would indicate that the execution time across all selected transactions is equal to the time expended when recording wall-clock time. View transactions To view information about your app's transaction requests: Do one of the following: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. If applicable: To change which available types of transactions appear, select the Type. Select the sort order, or keep the default. Select the type of view as a chart (default), histogram, or percentile, if available. To view additional details, use any of the transaction drill-down functions. To add a chart to a dashboard, mouse over the chart, then select the Add to a dashboard link that appears below it. If a chart's background is light red, this indicates a time period when an alert condition's Critical threshold has been violated. To view the incident details in New Relic Alerts, click the chart. For more information, see the documentation about navigating core UI components in New Relic One. Use drill-down functions Use any of New Relic's standard user interface functions to drill down into detailed information. The Transactions page has additional drill-down functions. Change the displayed transaction Type If the Type dropdown appears above list of transactions, you can select your choice of transaction type. The available types depend on what transactions your application uses. Select the type of performance measurement (Sort) The Sort dropdown above the transaction list allows you to review transactions according to different measurements. This helps you identify good candidates for performance tuning or fixing errors. You can sort by: Sort option Comments Most time consuming (default) Highest percentage of the app's total time used. This measures which transactions consumed the most time in total. This is calculated by multiplying the number of times the transaction is called by the time the transaction took to complete. A transaction could be short, but if it is frequently called, it would appear at the top of this ranking. Slowest average response time Slowest individual transactions for the time period as averaged. This measures the slowest types of transaction. A transaction could be called only a few times, but if it is one of the longest transactions to finish, it would appear at the top of this ranking. Apdex most dissatisfying Transactions with the highest percentages of user dissatisfaction levels for the response time of your web apps and services (Apdex). The dissatisfaction level is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score, based on your Apdex settings. Transactions that have the highest (worst) percentages appear at the top of this ranking. Highest throughput This measures the amount of throughput, in operation requests per minute or rpm. (For web throughput, requests per minute is sometimes called pages per minute or ppm.) Transactions that have the highest number of requests per minute appear at the top of this ranking. Tip Depending on the transaction type you choose, different sort options may be available. Mouse over summary information about a transaction To quickly view key pieces of information about the transaction, mouse over its name on the list. Select detailed information about a transaction To view detailed information, select a transaction from the list, then select App performance or Historical performance. You can also view transaction traces. View transaction data in different visual formats The Transaction page's Top 5 transactions chart and a selected transaction's App performance window include options to view data as a: Chart Histogram Percentile In addition, from the Breakdown table for a selected transaction, you can select the link to show or hide all segments of the breakdown data. Show corresponding Browser request data In order to view browser information, you must enable New Relic Browser. Then, to view corresponding browser request data, use either of these options: Select the Browser drill-down link if available. Go to one.newrelic.com > Browser > (select an app) > Page views. Identify transaction segments with high call counts or time In a transaction's Breakdown table, the Avg calls (per txn) column may include colorized segment values. These indicate instrumented segments that have exceeded thresholds. Yellow: Segment time is more than 10% of total transaction time and call count is higher than 10. Red: Segment time is more than 10% of total transaction time and call count is higher than 20. Show all transactions To view all available transactions as a table, select the Show all transactions table link. From here, use any of the available options: To change the sort order, select any column header. To export the data to a file with comma-separated values, select Export as CSV. To return to the previous chart view, select Back to top transactions. CSV tables for ending now time periods are calculated at run time. They may show slightly higher values than what appears in the APM table. For each transaction, the Show all transactions table includes these measurements: Measurement Definition Apdex The average Apdex score for all transactions that occurred in the selected time range. Apdex scores marked with an * asterisk indicate the agent collected fewer than 100 samples for that transaction name. Data for these transactions may be less accurate than data for transactions with higher throughput. Count The total number of all transactions that occurred in the selected time range. Avg (ms) The average time taken by all transactions in the selected time range. SD (ms) The standard deviation of all timing measurements for all transactions in the selected time range. Min (ms) The time taken by the fastest transaction in the selected time range. Max (ms) The time taken by the slowest transaction in the selected time range. Total (ms) The total amount of time taken by all transactions that occurred in the selected time range. Total (% time) The total amount of time for all transactions of that type, expressed as a percentage of the total amount of time taken by all transactions. Dissat (%) The percentage of the transactions that did not have satisfied Apdex scores. If you view transactions as a table, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in the Dissat (%) column is 100%. Additional functions Here are some additional functions for the Transactions page's selected transaction. If you want to... Do this... View transactions for operations and other background tasks Change the Type to Other transactions (or a specific type listed), then select a specific transaction. The Transactions page shows the top five transactions for this selection by wall-clock time, CPU usage, and memory usage. Track a transaction that is important to your business Select the transaction's name, then select Track as key transaction. View transaction trace details A transaction trace is a complete picture of a single transaction. From the Transactions page, select the transaction trace. Select the view for Summary, Trace details, or Database queries, if available. To expand the transaction trace to full screen view, select the full screen icon. To return to the Transactions page: Next to the transaction trace's name, select the back arrow. Add or view transaction segments To add segments to a transaction, use custom instrumentation. To view the segments of a specific transaction, use transaction traces. View reports You can also use the Web transactions analysis report for web transactions and the Background jobs analysis report for non-web transactions to compare the amount of time spent in throughput, total time in the transaction, average time to execute it, and Apdex score as applicable. Delete all transaction traces Caution If you select Delete all traces, you cannot recover them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transactions <em>page</em>: Find specific performance problems",
        "sections": "Transactions <em>page</em>: Find specific performance problems",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em>&#x27;s Transactions <em>page</em> helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This <em>page</em> lists the selected app&#x27;s transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per"
      },
      "id": "603ebd8228ccbcd2d3eba77b"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems": [
    {
      "sections": [
        "View slow query details",
        "Slow query data samples",
        "View slow query data",
        "Tip",
        "Configuration",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Slow queries metrics",
        "Troubleshooting: No slow query data"
      ],
      "title": "View slow query details",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "877f2ba64963875fce3cc4b656f5a66f43563cdd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-slow-query-details/",
      "published_at": "2021-07-02T12:44:26Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, when transaction traces are collected, there may be additional Slow query data available on the Databases page. Let's look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples the slowest database queries in those traces and reports data about them on the Databases page. Slow query data can include: Duration of query segments Query/explain plans (if recognized) Host and instance level details (if supported by agent) View slow query data Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To see your slow query data: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Databases. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Databases. Select a database transaction. If available, select any available slow queries listed on the page. If you do not see expected slow query data, follow the troubleshooting tips. Configuration In general, you can configure your slow query settings either of these ways: Agent configuration Server-side configuration (if available for your agent) Agent configuration gives you more options than server-side configuration does. How you choose to configure slow queries will depend on your own setup and preferences. For more information, see the documentation for the specific agent: C SDK You can report slow query traces for SQL databases only. For more information, see Instrument your application with the C SDK. Go Agent configuration options: Enable/disable: SlowQuery.Enabled Slow query threshold: SlowQuery.Threshold For other datastore config options, see Datastore tracer configuration. Java Agent configuration: Slow query threshold: explain_threshold. For other settings related to slow transactions and queries, see the Transaction tracer config options. You can also edit basic slow query settings via server-side configuration. .NET Agent configuration: Enable/disable: slowSql enabled Slow query threshold: explainThreshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Node.js Agent configuration: Enable/disable: enabled Threshold: explain_threshold Maximum slow query samples: max_samples For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration of slow query data is not possible for the Node.js agent. PHP Agent configuration: Enable/disable: slow_sql Threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration is not possible for the PHP agent. Python Agent configuration: Slow query threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Ruby Agent configuration: Enable/disable: slow_sql.enabled Slow query threshold: slow_sql.explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Slow SQL config options. If applicable for your application's agent language, you can also edit basic slow query settings by using server-side configuration. Slow queries metrics The slow queries list contains the following metrics: Metric Description Response time The average response time for the statements sampled. Sample count The number of slow queries identified in the sample. To view additional details, select an individual slow query: Metric Description Start time When the stack trace began collecting the data shown. Max time The maximum time for all similar query statements in the sample. Action The action or process invoking the query. Query The query that is being reported as slow. Depending on your configuration, some parts of the query may be obfuscated. Stack trace Where in the code the statement was called. For MySQL, we provide a query analysis, which explains what happened in your query and what you might do to speed it up. Other databases display an explain plan whenever possible. Troubleshooting: No slow query data If you do not see slow query data, it may be for any of these reasons: The slow query feature has been disabled. The threshold is set to too high a duration and no slow queries are being reported. The query obfuscation setting (usually record_sql or similar) may be set to Off. To solve the problem, try adjusting the configuration options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "In <em>APM</em>, when transaction traces are collected, there may be additional Slow query data available on the Databases <em>page</em>. Let&#x27;s look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples"
      },
      "id": "604407dae7b9d26489579a05"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    },
    {
      "sections": [
        "External services page: View web, cloud, network data"
      ],
      "title": "External services page: View web, cloud, network data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "65e965112c3fdc66d619cdc7a34d677efa3c5cb6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/external-services-page-view-web-cloud-network-data/",
      "published_at": "2021-07-02T12:43:40Z",
      "updated_at": "2021-03-30T09:18:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud, and any other network calls. (It does not include other first class back-end components such as MemCache and the database itself.) APM's External services page provides charts with your top five external services by response time and external calls per minute. You can also sort the list of external services by slowest average response time, most time consuming, or highest throughput (requests per minute). In our UI, this is also referred to as web external or background external data. To view out-of-process services for your app: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > External services. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > External services. To view detailed information about a service, select its name. Use any of New Relic's standard user interface functions to drill down into detailed information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.53246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "External services <em>page</em>: View web, cloud, network data",
        "sections": "External services <em>page</em>: View web, cloud, network data",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud, and any other network calls. (It does not include other first class back-end components such as MemCache and the database itself.) <em>APM</em>&#x27;s External services <em>page</em> provides charts"
      },
      "id": "603ebdad64441f05634e8844"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/view-slow-query-details": [
    {
      "sections": [
        "Transactions page: Find specific performance problems",
        "Types of transactions",
        "Tip",
        "Wall-clock time",
        "View transactions",
        "Use drill-down functions",
        "Change the displayed transaction Type",
        "Select the type of performance measurement (Sort)",
        "Mouse over summary information about a transaction",
        "Select detailed information about a transaction",
        "View transaction data in different visual formats",
        "Show corresponding Browser request data",
        "Identify transaction segments with high call counts or time",
        "Show all transactions",
        "Additional functions",
        "Caution"
      ],
      "title": "Transactions page: Find specific performance problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "af8aa4a977d05428494b8b34aed1ac6ea831d8db",
      "image": "https://docs.newrelic.com/static/0b30cbf2e9065777c252216f96c80ad7/a2d4f/APM-transaction-high-time-colorization_0.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/",
      "published_at": "2021-07-02T12:44:27Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Transactions page helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This page lists the selected app's transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per minute or rpm). For non-web transactions (such as message processing, background tasks, and other processes and jobs that do not handle web requests), this page shows charts of CPU and memory usage. Types of transactions Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Depending on your selected application, the Transactions page may include a dropdown you can use to select from the types of transactions available. New Relic measures processing time by type of request (web transaction or non-web transaction). This may include: Web: App server requests Non-web: Other requests (operations, background tasks, etc.) The Transactions page also may include links to transaction traces and key transactions. The types of information available will depend on your selected app and the type of request (web or non-web). Wall-clock time Wall-clock time is the amount of time recorded by the clock. New Relic uses wall-clock time for all the transactions and then sums that value across all of the transactions. The host can execute requests in parallel, so you may see percentages over 100. For example, 100% would indicate that the execution time across all selected transactions is equal to the time expended when recording wall-clock time. View transactions To view information about your app's transaction requests: Do one of the following: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. If applicable: To change which available types of transactions appear, select the Type. Select the sort order, or keep the default. Select the type of view as a chart (default), histogram, or percentile, if available. To view additional details, use any of the transaction drill-down functions. To add a chart to a dashboard, mouse over the chart, then select the Add to a dashboard link that appears below it. If a chart's background is light red, this indicates a time period when an alert condition's Critical threshold has been violated. To view the incident details in New Relic Alerts, click the chart. For more information, see the documentation about navigating core UI components in New Relic One. Use drill-down functions Use any of New Relic's standard user interface functions to drill down into detailed information. The Transactions page has additional drill-down functions. Change the displayed transaction Type If the Type dropdown appears above list of transactions, you can select your choice of transaction type. The available types depend on what transactions your application uses. Select the type of performance measurement (Sort) The Sort dropdown above the transaction list allows you to review transactions according to different measurements. This helps you identify good candidates for performance tuning or fixing errors. You can sort by: Sort option Comments Most time consuming (default) Highest percentage of the app's total time used. This measures which transactions consumed the most time in total. This is calculated by multiplying the number of times the transaction is called by the time the transaction took to complete. A transaction could be short, but if it is frequently called, it would appear at the top of this ranking. Slowest average response time Slowest individual transactions for the time period as averaged. This measures the slowest types of transaction. A transaction could be called only a few times, but if it is one of the longest transactions to finish, it would appear at the top of this ranking. Apdex most dissatisfying Transactions with the highest percentages of user dissatisfaction levels for the response time of your web apps and services (Apdex). The dissatisfaction level is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score, based on your Apdex settings. Transactions that have the highest (worst) percentages appear at the top of this ranking. Highest throughput This measures the amount of throughput, in operation requests per minute or rpm. (For web throughput, requests per minute is sometimes called pages per minute or ppm.) Transactions that have the highest number of requests per minute appear at the top of this ranking. Tip Depending on the transaction type you choose, different sort options may be available. Mouse over summary information about a transaction To quickly view key pieces of information about the transaction, mouse over its name on the list. Select detailed information about a transaction To view detailed information, select a transaction from the list, then select App performance or Historical performance. You can also view transaction traces. View transaction data in different visual formats The Transaction page's Top 5 transactions chart and a selected transaction's App performance window include options to view data as a: Chart Histogram Percentile In addition, from the Breakdown table for a selected transaction, you can select the link to show or hide all segments of the breakdown data. Show corresponding Browser request data In order to view browser information, you must enable New Relic Browser. Then, to view corresponding browser request data, use either of these options: Select the Browser drill-down link if available. Go to one.newrelic.com > Browser > (select an app) > Page views. Identify transaction segments with high call counts or time In a transaction's Breakdown table, the Avg calls (per txn) column may include colorized segment values. These indicate instrumented segments that have exceeded thresholds. Yellow: Segment time is more than 10% of total transaction time and call count is higher than 10. Red: Segment time is more than 10% of total transaction time and call count is higher than 20. Show all transactions To view all available transactions as a table, select the Show all transactions table link. From here, use any of the available options: To change the sort order, select any column header. To export the data to a file with comma-separated values, select Export as CSV. To return to the previous chart view, select Back to top transactions. CSV tables for ending now time periods are calculated at run time. They may show slightly higher values than what appears in the APM table. For each transaction, the Show all transactions table includes these measurements: Measurement Definition Apdex The average Apdex score for all transactions that occurred in the selected time range. Apdex scores marked with an * asterisk indicate the agent collected fewer than 100 samples for that transaction name. Data for these transactions may be less accurate than data for transactions with higher throughput. Count The total number of all transactions that occurred in the selected time range. Avg (ms) The average time taken by all transactions in the selected time range. SD (ms) The standard deviation of all timing measurements for all transactions in the selected time range. Min (ms) The time taken by the fastest transaction in the selected time range. Max (ms) The time taken by the slowest transaction in the selected time range. Total (ms) The total amount of time taken by all transactions that occurred in the selected time range. Total (% time) The total amount of time for all transactions of that type, expressed as a percentage of the total amount of time taken by all transactions. Dissat (%) The percentage of the transactions that did not have satisfied Apdex scores. If you view transactions as a table, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in the Dissat (%) column is 100%. Additional functions Here are some additional functions for the Transactions page's selected transaction. If you want to... Do this... View transactions for operations and other background tasks Change the Type to Other transactions (or a specific type listed), then select a specific transaction. The Transactions page shows the top five transactions for this selection by wall-clock time, CPU usage, and memory usage. Track a transaction that is important to your business Select the transaction's name, then select Track as key transaction. View transaction trace details A transaction trace is a complete picture of a single transaction. From the Transactions page, select the transaction trace. Select the view for Summary, Trace details, or Database queries, if available. To expand the transaction trace to full screen view, select the full screen icon. To return to the Transactions page: Next to the transaction trace's name, select the back arrow. Add or view transaction segments To add segments to a transaction, use custom instrumentation. To view the segments of a specific transaction, use transaction traces. View reports You can also use the Web transactions analysis report for web transactions and the Background jobs analysis report for non-web transactions to compare the amount of time spent in throughput, total time in the transaction, average time to execute it, and Apdex score as applicable. Delete all transaction traces Caution If you select Delete all traces, you cannot recover them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transactions <em>page</em>: Find specific performance problems",
        "sections": "Transactions <em>page</em>: Find specific performance problems",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em>&#x27;s Transactions <em>page</em> helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This <em>page</em> lists the selected app&#x27;s transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per"
      },
      "id": "603ebd8228ccbcd2d3eba77b"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    },
    {
      "sections": [
        "External services page: View web, cloud, network data"
      ],
      "title": "External services page: View web, cloud, network data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "65e965112c3fdc66d619cdc7a34d677efa3c5cb6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/external-services-page-view-web-cloud-network-data/",
      "published_at": "2021-07-02T12:43:40Z",
      "updated_at": "2021-03-30T09:18:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud, and any other network calls. (It does not include other first class back-end components such as MemCache and the database itself.) APM's External services page provides charts with your top five external services by response time and external calls per minute. You can also sort the list of external services by slowest average response time, most time consuming, or highest throughput (requests per minute). In our UI, this is also referred to as web external or background external data. To view out-of-process services for your app: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > External services. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > External services. To view detailed information about a service, select its name. Use any of New Relic's standard user interface functions to drill down into detailed information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.53246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "External services <em>page</em>: View web, cloud, network data",
        "sections": "External services <em>page</em>: View web, cloud, network data",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud, and any other network calls. (It does not include other first class back-end components such as MemCache and the database itself.) <em>APM</em>&#x27;s External services <em>page</em> provides charts"
      },
      "id": "603ebdad64441f05634e8844"
    }
  ],
  "/docs/apm/apm-ui-pages/monitoring/view-your-applications-index": [
    {
      "sections": [
        "View slow query details",
        "Slow query data samples",
        "View slow query data",
        "Tip",
        "Configuration",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Slow queries metrics",
        "Troubleshooting: No slow query data"
      ],
      "title": "View slow query details",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "877f2ba64963875fce3cc4b656f5a66f43563cdd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-slow-query-details/",
      "published_at": "2021-07-02T12:44:26Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, when transaction traces are collected, there may be additional Slow query data available on the Databases page. Let's look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples the slowest database queries in those traces and reports data about them on the Databases page. Slow query data can include: Duration of query segments Query/explain plans (if recognized) Host and instance level details (if supported by agent) View slow query data Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To see your slow query data: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Databases. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Databases. Select a database transaction. If available, select any available slow queries listed on the page. If you do not see expected slow query data, follow the troubleshooting tips. Configuration In general, you can configure your slow query settings either of these ways: Agent configuration Server-side configuration (if available for your agent) Agent configuration gives you more options than server-side configuration does. How you choose to configure slow queries will depend on your own setup and preferences. For more information, see the documentation for the specific agent: C SDK You can report slow query traces for SQL databases only. For more information, see Instrument your application with the C SDK. Go Agent configuration options: Enable/disable: SlowQuery.Enabled Slow query threshold: SlowQuery.Threshold For other datastore config options, see Datastore tracer configuration. Java Agent configuration: Slow query threshold: explain_threshold. For other settings related to slow transactions and queries, see the Transaction tracer config options. You can also edit basic slow query settings via server-side configuration. .NET Agent configuration: Enable/disable: slowSql enabled Slow query threshold: explainThreshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Node.js Agent configuration: Enable/disable: enabled Threshold: explain_threshold Maximum slow query samples: max_samples For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration of slow query data is not possible for the Node.js agent. PHP Agent configuration: Enable/disable: slow_sql Threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options. Server-side configuration is not possible for the PHP agent. Python Agent configuration: Slow query threshold: explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Datastore tracer options. You can also edit basic slow query settings via server-side configuration. Ruby Agent configuration: Enable/disable: slow_sql.enabled Slow query threshold: slow_sql.explain_threshold For other settings related to slow transactions and queries, see the Transaction tracer config options and the Slow SQL config options. If applicable for your application's agent language, you can also edit basic slow query settings by using server-side configuration. Slow queries metrics The slow queries list contains the following metrics: Metric Description Response time The average response time for the statements sampled. Sample count The number of slow queries identified in the sample. To view additional details, select an individual slow query: Metric Description Start time When the stack trace began collecting the data shown. Max time The maximum time for all similar query statements in the sample. Action The action or process invoking the query. Query The query that is being reported as slow. Depending on your configuration, some parts of the query may be obfuscated. Stack trace Where in the code the statement was called. For MySQL, we provide a query analysis, which explains what happened in your query and what you might do to speed it up. Other databases display an explain plan whenever possible. Troubleshooting: No slow query data If you do not see slow query data, it may be for any of these reasons: The slow query feature has been disabled. The threshold is set to too high a duration and no slow queries are being reported. The query obfuscation setting (usually record_sql or similar) may be set to Off. To solve the problem, try adjusting the configuration options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "In <em>APM</em>, when transaction traces are collected, there may be additional Slow query data available on the Databases <em>page</em>. Let&#x27;s look at what slow query data is, where to find it, and how to configure it. Slow query data samples When transaction traces are reported, the slow queries feature samples"
      },
      "id": "604407dae7b9d26489579a05"
    },
    {
      "sections": [
        "Transactions page: Find specific performance problems",
        "Types of transactions",
        "Tip",
        "Wall-clock time",
        "View transactions",
        "Use drill-down functions",
        "Change the displayed transaction Type",
        "Select the type of performance measurement (Sort)",
        "Mouse over summary information about a transaction",
        "Select detailed information about a transaction",
        "View transaction data in different visual formats",
        "Show corresponding Browser request data",
        "Identify transaction segments with high call counts or time",
        "Show all transactions",
        "Additional functions",
        "Caution"
      ],
      "title": "Transactions page: Find specific performance problems",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "af8aa4a977d05428494b8b34aed1ac6ea831d8db",
      "image": "https://docs.newrelic.com/static/0b30cbf2e9065777c252216f96c80ad7/a2d4f/APM-transaction-high-time-colorization_0.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/transactions-page-find-specific-performance-problems/",
      "published_at": "2021-07-02T12:44:27Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Transactions page helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This page lists the selected app's transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per minute or rpm). For non-web transactions (such as message processing, background tasks, and other processes and jobs that do not handle web requests), this page shows charts of CPU and memory usage. Types of transactions Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Depending on your selected application, the Transactions page may include a dropdown you can use to select from the types of transactions available. New Relic measures processing time by type of request (web transaction or non-web transaction). This may include: Web: App server requests Non-web: Other requests (operations, background tasks, etc.) The Transactions page also may include links to transaction traces and key transactions. The types of information available will depend on your selected app and the type of request (web or non-web). Wall-clock time Wall-clock time is the amount of time recorded by the clock. New Relic uses wall-clock time for all the transactions and then sums that value across all of the transactions. The host can execute requests in parallel, so you may see percentages over 100. For example, 100% would indicate that the execution time across all selected transactions is equal to the time expended when recording wall-clock time. View transactions To view information about your app's transaction requests: Do one of the following: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. If applicable: To change which available types of transactions appear, select the Type. Select the sort order, or keep the default. Select the type of view as a chart (default), histogram, or percentile, if available. To view additional details, use any of the transaction drill-down functions. To add a chart to a dashboard, mouse over the chart, then select the Add to a dashboard link that appears below it. If a chart's background is light red, this indicates a time period when an alert condition's Critical threshold has been violated. To view the incident details in New Relic Alerts, click the chart. For more information, see the documentation about navigating core UI components in New Relic One. Use drill-down functions Use any of New Relic's standard user interface functions to drill down into detailed information. The Transactions page has additional drill-down functions. Change the displayed transaction Type If the Type dropdown appears above list of transactions, you can select your choice of transaction type. The available types depend on what transactions your application uses. Select the type of performance measurement (Sort) The Sort dropdown above the transaction list allows you to review transactions according to different measurements. This helps you identify good candidates for performance tuning or fixing errors. You can sort by: Sort option Comments Most time consuming (default) Highest percentage of the app's total time used. This measures which transactions consumed the most time in total. This is calculated by multiplying the number of times the transaction is called by the time the transaction took to complete. A transaction could be short, but if it is frequently called, it would appear at the top of this ranking. Slowest average response time Slowest individual transactions for the time period as averaged. This measures the slowest types of transaction. A transaction could be called only a few times, but if it is one of the longest transactions to finish, it would appear at the top of this ranking. Apdex most dissatisfying Transactions with the highest percentages of user dissatisfaction levels for the response time of your web apps and services (Apdex). The dissatisfaction level is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score, based on your Apdex settings. Transactions that have the highest (worst) percentages appear at the top of this ranking. Highest throughput This measures the amount of throughput, in operation requests per minute or rpm. (For web throughput, requests per minute is sometimes called pages per minute or ppm.) Transactions that have the highest number of requests per minute appear at the top of this ranking. Tip Depending on the transaction type you choose, different sort options may be available. Mouse over summary information about a transaction To quickly view key pieces of information about the transaction, mouse over its name on the list. Select detailed information about a transaction To view detailed information, select a transaction from the list, then select App performance or Historical performance. You can also view transaction traces. View transaction data in different visual formats The Transaction page's Top 5 transactions chart and a selected transaction's App performance window include options to view data as a: Chart Histogram Percentile In addition, from the Breakdown table for a selected transaction, you can select the link to show or hide all segments of the breakdown data. Show corresponding Browser request data In order to view browser information, you must enable New Relic Browser. Then, to view corresponding browser request data, use either of these options: Select the Browser drill-down link if available. Go to one.newrelic.com > Browser > (select an app) > Page views. Identify transaction segments with high call counts or time In a transaction's Breakdown table, the Avg calls (per txn) column may include colorized segment values. These indicate instrumented segments that have exceeded thresholds. Yellow: Segment time is more than 10% of total transaction time and call count is higher than 10. Red: Segment time is more than 10% of total transaction time and call count is higher than 20. Show all transactions To view all available transactions as a table, select the Show all transactions table link. From here, use any of the available options: To change the sort order, select any column header. To export the data to a file with comma-separated values, select Export as CSV. To return to the previous chart view, select Back to top transactions. CSV tables for ending now time periods are calculated at run time. They may show slightly higher values than what appears in the APM table. For each transaction, the Show all transactions table includes these measurements: Measurement Definition Apdex The average Apdex score for all transactions that occurred in the selected time range. Apdex scores marked with an * asterisk indicate the agent collected fewer than 100 samples for that transaction name. Data for these transactions may be less accurate than data for transactions with higher throughput. Count The total number of all transactions that occurred in the selected time range. Avg (ms) The average time taken by all transactions in the selected time range. SD (ms) The standard deviation of all timing measurements for all transactions in the selected time range. Min (ms) The time taken by the fastest transaction in the selected time range. Max (ms) The time taken by the slowest transaction in the selected time range. Total (ms) The total amount of time taken by all transactions that occurred in the selected time range. Total (% time) The total amount of time for all transactions of that type, expressed as a percentage of the total amount of time taken by all transactions. Dissat (%) The percentage of the transactions that did not have satisfied Apdex scores. If you view transactions as a table, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in the Dissat (%) column is 100%. Additional functions Here are some additional functions for the Transactions page's selected transaction. If you want to... Do this... View transactions for operations and other background tasks Change the Type to Other transactions (or a specific type listed), then select a specific transaction. The Transactions page shows the top five transactions for this selection by wall-clock time, CPU usage, and memory usage. Track a transaction that is important to your business Select the transaction's name, then select Track as key transaction. View transaction trace details A transaction trace is a complete picture of a single transaction. From the Transactions page, select the transaction trace. Select the view for Summary, Trace details, or Database queries, if available. To expand the transaction trace to full screen view, select the full screen icon. To return to the Transactions page: Next to the transaction trace's name, select the back arrow. Add or view transaction segments To add segments to a transaction, use custom instrumentation. To view the segments of a specific transaction, use transaction traces. View reports You can also use the Web transactions analysis report for web transactions and the Background jobs analysis report for non-web transactions to compare the amount of time spent in throughput, total time in the transaction, average time to execute it, and Apdex score as applicable. Delete all transaction traces Caution If you select Delete all traces, you cannot recover them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.5326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Transactions <em>page</em>: Find specific performance problems",
        "sections": "Transactions <em>page</em>: Find specific performance problems",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em>&#x27;s Transactions <em>page</em> helps you identify transactions that may be good candidates for fine-tuning performance problems or resolving errors. This <em>page</em> lists the selected app&#x27;s transaction Requests, the top five transactions by percent of wall-clock time, and relevant throughputs (requests per"
      },
      "id": "603ebd8228ccbcd2d3eba77b"
    },
    {
      "sections": [
        "External services page: View web, cloud, network data"
      ],
      "title": "External services page: View web, cloud, network data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "65e965112c3fdc66d619cdc7a34d677efa3c5cb6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/external-services-page-view-web-cloud-network-data/",
      "published_at": "2021-07-02T12:43:40Z",
      "updated_at": "2021-03-30T09:18:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud, and any other network calls. (It does not include other first class back-end components such as MemCache and the database itself.) APM's External services page provides charts with your top five external services by response time and external calls per minute. You can also sort the list of external services by slowest average response time, most time consuming, or highest throughput (requests per minute). In our UI, this is also referred to as web external or background external data. To view out-of-process services for your app: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > External services. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > External services. To view detailed information about a service, select its name. Use any of New Relic's standard user interface functions to drill down into detailed information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.53246,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "External services <em>page</em>: View web, cloud, network data",
        "sections": "External services <em>page</em>: View web, cloud, network data",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "External service instrumentation captures calls to out-of-process services such as web services, resources in the cloud, and any other network calls. (It does not include other first class back-end components such as MemCache and the database itself.) <em>APM</em>&#x27;s External services <em>page</em> provides charts"
      },
      "id": "603ebdad64441f05634e8844"
    }
  ],
  "/docs/apm/applications-menu/events/view-alert-history": [
    {
      "sections": [
        "Thread profiler tool",
        "Supported agents",
        "Start the profiler",
        "View profile data",
        "Agent considerations",
        ".NET-specific notes",
        "Python-specific notes",
        "Ruby-specific notes"
      ],
      "title": "Thread profiler tool",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Events"
      ],
      "external_id": "e2d300aa5dd9bdbf73684a04080773db0d1acd2b",
      "image": "https://docs.newrelic.com/static/9c9ff25ac45a7e0772db3c71a5c2754f/c1b63/thread-profiler-start_1.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/events/thread-profiler-tool/",
      "published_at": "2021-07-02T08:47:23Z",
      "updated_at": "2021-03-16T08:17:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The thread profiler is a low-impact profiling tool that can be used in production to identify bottlenecks in an application. It works by periodically (100ms) capturing the stack trace of each thread for a specified duration. At the end of the specified duration, the stack traces are aggregated to build a tree. The call count in the tree corresponds to the number of times that function was present in the stack traces under the same context. Although the call tree cannot capture the entire execution, a large enough sample can be a good representation of the application behavior. This provides insights into the \"hot\" functions of the app where most of the time is spent. With this scope, entries sampled less than 0.05% are omitted. Supported agents This feature is available only for specific agents and versions: Java: Agent versions 1.2.004.6 or higher .NET: Framework: Agent versions 2.12.146.0 or higher .NET Core 2.0: Agent versions 8.3.360.0 or higher (Windows only) Linux: .NET Core 3.0 or higher and agent versions 8.23 or higher Python: Agent versions 1.7.0 or higher Ruby: Agent versions 3.5.5 or higher Start the profiler The thread profiler feature is enabled by default. You also may be able to turn it on or off in your agent configuration file: Java: thread_profiler.enabled NET: You cannot disable the thread profiler with .NET apps. Python: thread_profiler.enabled Ruby: thread_profiler.enabled When enabled, you can view the thread profiler from our user interface: Go to one.newrelic.com > APM > (select an app) > Events > Thread profiler. Select the host you want to run the profiler on. Set the duration for the profiling session. Select Start profiler. This triggers the agent to start the thread profiler during the next harvest cycle (every one minute) and capture data for the specified duration. We record thread backtraces whether or not they are in a runnable state at the time the sample is taken. Threads that are sleeping or blocked on IO may appear in the call tree. one.newrelic.com > APM > (select an app) > Events > Thread profiler: Use this page to define the settings for the thread profiler duration and to view the results. View profile data After the profiler finishes running, the agent will report the profile data. The call tree automatically appears on the Thread profiler page. The percentages in the call tree represent the percentage of thread backtrace samples in which each call path appeared during the profiling session. The data collection started at the PROFILE COLLECTED time. one.newrelic.com > APM > (select an app) > Events > Thread profiler > (selected profile): Here is an example of a call tree from a thread profile. The page color-codes the tree results: Red: Percentages greater than 30% Yellow: Percentages greater than 10% Black: Percentages less than 10% If you want to... Do this... Change how the thread profile information appears Select your choices of available options in the Tree settings, and select Refresh tree. Change how much information appears Select the Expand or Collapse options above the call tree, or select the name or arrow on any line in the call tree. View summary information about any line in the call tree Mouse over the line. Email the thread profile results to others Select Share this profile. Start another session or view a different thread profile Select Back to all profiles. Agent considerations Depending on which agent you use, the thread profiling feature has additional considerations. .NET-specific notes When using thread profiling with the .NET Framework agent, be aware of the following. .NET agent Thread profiler notes Supported on Linux Thread profiling on Linux is supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Managed threads only For .NET agents, the thread profiler only captures stack traces on managed threads. It does not capture stack traces on unmanaged threads. If a call to an unmanaged function occurs on a managed thread, the thread profiler will show Native:Function Call in the call tree. No line numbers A .NET thread profile does not include line numbers in the call tree. The Show line numbers checkbox in the Tree Settings does not have any effect. Bug with 64-bit v4.0 .NET CLR There is a bug in the 64-bit version 4.0 .NET Common Language Runtime (CLR) that interferes with the agent's ability to retrieve managed stack traces. If your app experiences this bug, APM will show empty thread profiles. This bug does not affect 32-bit applications. The bug is fixed in the CLR releases for .NET 4.5. To verify whether your 64-bit application has the fixed version, look at the full version of the mscorlib.dll in the C: \\ Windows \\ Microsoft.NET \\ Framework64 \\ v4.0.30319 directory. The fix is in versions 4.0.30319.17379 or higher. Other category only All threads are put in the Other category. The Web Request and Background categories are not supported. Python-specific notes When using thread profiling with the Python agent, be aware of the following. Python agent Thread profiler notes Co-routine based systems There are limits to capturing details when a co-routine based system is being used, such as gevent or eventlet modes of gunicorn. If creating a new thread, the Python agent will actually create a greenlet instead of a thread profiler background thread. Therefore, the thread profiler will not capture any web request and background transactions on the thread profiler page. Greenlets A greenlet can run only when other greenlets explicitly yield control, such as when they block. For example, if the thread sampler does get to run, it will only sample the stack for other greenlets at a point where they are blocked. It will not sample them when they are executing arbitrary code. It can completely miss execution within a greenlet if it never blocked or otherwise yielded to another greenlet. Time in Python code Time spent in pure Python code that isn't blocking requests will not be picked up, and no information will be recorded or reported. This is because results are misleading when co-routines are used. Ruby-specific notes When using thread profiling with the Ruby agent, be aware of the following. Ruby agent Thread profiler notes Backtraces The thread profiler depends on the ability to capture thread backtraces from within your Ruby application. For this reason, it requires MRI 1.9.2 or higher (for the Thread#backtrace method). Resque The Ruby agent does not currently support thread profiles with Resque background jobs. A thread profiling session initiated against Resque will only capture traces from the parent process, not the job processes. JRuby JRuby support is considered experimental at this time. There are known issues with JRuby's Thread#backtrace implementation that will affect the accuracy of and reliability of backtraces collected under JRuby.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.74922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " for the specified duration. We record thread backtraces whether or not they are in a runnable state at the time the sample is taken. Threads that are sleeping or blocked on IO may appear in the call tree. one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Events</em> &gt; Thread profiler: Use this <em>page</em> to define"
      },
      "id": "603ebd4928ccbccc3ceba78e"
    },
    {
      "sections": [
        "Deployments page: View impact on your app and users",
        "Set up deployment notifications",
        "View deployment details",
        "View performance after a deployment",
        "Tip"
      ],
      "title": "Deployments page: View impact on your app and users",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Events"
      ],
      "external_id": "e312ce78e93b452b265b646406db3a39d3f7e696",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/events/deployments-page-view-impact-your-app-users/",
      "published_at": "2021-07-02T08:45:49Z",
      "updated_at": "2021-03-16T06:31:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's Deployments page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. You can view and drill down details, use search and sort options, hide or delete the error, share it with others, or file a ticket about it. Set up deployment notifications For all APM agents, you can record deployments by using webhooks or by using the New Relic REST API (v2). Some agents also have specific methods, such as the Java agent jar or the Python agent's newrelic-admin script. View deployment details After you configure the deployment information, you can view and drill down into details: Go to one.newrelic.com > APM > (select an app) > Events > Deployments. Use any of New Relic's standard user interface functions to drill down into detailed information. To view details for a particular event, select its date link. To view the errors page for this deployment, select the error link. To view details for a specific deployment if applicable, select Change log or Change report. The Change log contains any detail provided through the changelog parameter when recording the deployment. The Change report displays the behavior of the top ten transactions before and after the deployment. View performance after a deployment The Deployments page link for individual deployments appears on the selected app's Summary page in the Events section. For time frames shorter than 14 days, a blue vertical bar on a chart will indicate a deployment. To view summary information about the deployment, mouse over the blue bar. Tip You can also use the Compare with option on your APM summary page to select a time period to compare the same data. If you enable Compare with, the UI does not show deployment markers.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.74045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Deployments <em>page</em>: View impact on your app and users",
        "sections": "Deployments <em>page</em>: View impact on your app and users",
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " the deployment information, you can view and drill down into details: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Events</em> &gt; Deployments. Use any of New Relic&#x27;s standard user interface functions to drill down into detailed information. To view details for a particular <em>event</em>, select its date link. To view"
      },
      "id": "603ebe19e7b9d2bc362a07cc"
    },
    {
      "sections": [
        "View your applications index",
        "Tip"
      ],
      "title": "View your applications index",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Monitoring"
      ],
      "external_id": "8e70cf3b6602b38efff4a6fb2443724a08a6701c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/monitoring/view-your-applications-index/",
      "published_at": "2021-07-02T12:45:17Z",
      "updated_at": "2021-03-30T09:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you go to one.newrelic.com > APM, you get an index of all APM apps associated with your New Relic account ID. The page automatically refreshes the index of applications every two minutes with the most current health status, events, and performance statistics. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Here are some of the things you can do on this page: If you want to... Do this... View an app's details To go directly to the application's Summary page by clicking on the application's name. Find an app in the index Use any of these options to find what you want: Filter or roll up the index by category or tag. Use the search (magnifying glass) function at the top of the index. View details about a recent event or alert On the Summary page, review the entries under Application activity. You can select the link to get details. For more information, see View an app's alert information.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.804665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "When you go to one.newrelic.com &gt; <em>APM</em>, you get an index of all <em>APM</em> apps associated with your New Relic account ID. The <em>page</em> automatically refreshes the index of applications every two minutes with the most current health status, <em>events</em>, and performance statistics. Tip To get a high-level overview"
      },
      "id": "60455c3de7b9d2951a5799f3"
    }
  ],
  "/docs/apm/applications-menu/features/configure-request-queue-reporting": [
    {
      "sections": [
        "Ticketing integrations",
        "Requirements",
        "Integrate with New Relic",
        "Tip",
        "File tickets"
      ],
      "title": "Ticketing integrations",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c6004eab5c13506e5bdf175be670ff86b0a24f52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/user-interface-functions/share-your-data/ticketing-integrations/",
      "published_at": "2021-07-02T11:33:40Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic APM's transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic's webhook IPs. In addition, Lighthouse setup requires: The subdomain for your installation; for example, https://subdomain.lighthouseapp.com Your Lighthouse account's email and password for ticket tracking Integrate with New Relic Tip Owner and Admins To connect your New Relic account to Lighthouse: Go to: account dropdown > Account settings > Integrations > Ticketing integrations. Select the tab for Lighthouse. Follow the instructions on the individual tab, then click Integrate. After your ticketing system has been integrated, the corresponding tab's health status indicator in New Relic's UI changes to green (enabled). File tickets To use the ticketing system integrated with your New Relic account: From the selected APM transaction trace or APM error trace, select File a ticket. Follow standard procedures to create a ticket from your Lighthouse account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.90154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic <em>APM</em>&#x27;s transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic"
      },
      "id": "603ebd11e7b9d292fc2a07ef"
    },
    {
      "sections": [
        "Request queue server configuration examples",
        "Apache",
        "Nginx",
        "F5 load balancers",
        "Network timing"
      ],
      "title": "Request queue server configuration examples",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c7a069b8875af411530a34aaef67155d20d7fb19",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/features/request-queue-server-configuration-examples/",
      "published_at": "2021-07-02T12:46:10Z",
      "updated_at": "2021-03-16T07:13:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In order to report request queuing, New Relic agents depend on an HTTP header set by the front-end web server (such as Apache or Nginx) or load balancer (such as HAProxy or F5). These examples use the X-Request-Start header, since it is has broader support across platforms. If this does not work with your server configuration for request queuing, try using the X-Queue-Start header. The syntax should otherwise be the same. Apache Apache's mod_headers module includes a %t variable that is formatted correctly. To enable request queue reporting, add this code to your Apache config: RequestHeader set X-Request-Start \"%t\" Copy Nginx If you are using Nginx version 1.2.6 or higher and the latest version of the Ruby, Python, or PHP agent, Nginx can easily be configured to report queue time. (For Nginx versions 1.2.6 or lower, you must recompile Nginx with a module or patch.) Configuring with Nginx 1.2.6 or higher uses the ${msec} variable, which is a number in seconds with milliseconds resolution. For more information, see http://nginx.org/en/docs/http/ngx_http_core_module.html#variables. Add the appropriate information to your Nginx config: Nginx configuration Values General Nginx use proxy_set_header X-Request-Start \"t=${msec}\"; Copy Passenger Version 5 or higher: >passenger_set_header X-REQUEST-START \"t=${msec}\"; Copy Older versions: passenger_set_cgi_param X_REQUEST_START \"t=${msec}\"; Copy fastcgi fastcgi_param HTTP_X_REQUEST_START \"t=${msec}\"; Copy uWSGI uwsgi_param HTTP_X_REQUEST_START \"t=${msec}\"; Copy F5 load balancers For F5 load balancers, use this configuration snippet: when HTTP_REQUEST_SEND { # TCL 8.4 so we have to calculate the time in millisecond resolution # Calculation from: https://groups.google.com/forum/? fromgroups=#!topic/comp.lang.tcl/tV9H6TDv0t8 set secs [clock seconds] set ms [clock clicks -milliseconds] set base [expr { $secs * 1000 }] set fract [expr { $ms - $base }] if { $fract >= 1000 } { set diff [expr { $fract / 1000 }] incr secs $diff incr fract [expr { -1000 * $diff }] } set micros [format \"%d%03d000\" $secs $fract] # Want this header inserted as if coming from the client clientside { HTTP::header insert X-Request-Start \"t=${micros}\" } } Copy Network timing Even with request queuing configured, the front-end server's setup can still affect network time in your Browser data. This is because the front-end server does not add the queuing time header until after it actually accepts and processes the request. The queuing time headers can never account for backlog in the listener socket used to accept requests. For example, if the front-end server's configuration results in a backlog of requests that queue in the listener socket, page load timing will show an increase in network time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": " the queuing time header until after it actually accepts and processes the request. The queuing time headers can never account for backlog in the listener socket used to accept requests. For example, if the front-end server&#x27;s configuration results in a backlog of requests that queue in the listener socket, <em>page</em> load timing will show an increase in network time."
      },
      "id": "603eb84a28ccbc1734eba7a5"
    },
    {
      "sections": [
        "Request queuing and tracking front-end time",
        "Use request queuing to identify scaling problems",
        "Apdex calculations",
        "Clock skew"
      ],
      "title": "Request queuing and tracking front-end time",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "73285326db3b9d5e7d6477e83e45aeac1b541efa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/features/request-queuing-tracking-front-end-time/",
      "published_at": "2021-07-02T12:41:06Z",
      "updated_at": "2021-03-16T06:46:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM tracks the time after a request enters your production systems and before it reaches your application. We call this portion of your request's life cycle request queuing. Depending on the specifics of your production systems, this measurement of time may or may not include an actual queue that requests enter. It may also represent other functions (such as load balancing or internal network latency). Use request queuing to identify scaling problems Tracking time spent in request queuing is useful for identifying certain types of performance and scaling problems; for example: When your front-end web server is spending time waiting for application workers to become available When extra time is spent warming up application workers after a deploy or restart You must configure your New Relic agent and server to report request queuing. Then the information will appear in the selected application's Requests time chart for web transactions (from APM's Applications list, select the app), as well as other places in the user interface. The chart's legend indicates which color represents request queueing. Apdex calculations Request queuing is the time from when the browser requests content to the time it receives the content. Since your Apdex score will reflect these calculations, you can select whether to report request queue time separately or not. For more information, see Agent configuration. Clock skew If the front-end web server (such as Nginx) and your application do not reside on the same physical server, reported request queuing may be affected by clock skew. NTP provides an excellent way to keep server clocks in sync. However, they still will drift relative to each other. Since New Relic agents rely on a timestamp set by the front-end server, it may over- or under-report request queuing if the clock on that server is not closely synchronized with the clock on the app server. This may seem like a major problem with the feature; however, clock skew is unlikely to result in sudden spikes in reported request queuing. Sudden spikes generally occur when an app is restarted or becomes overloaded with requests. Our experience is that request queue reporting can be useful to identify real performance problems, but be sure to consider clock skew when interpreting this data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em> tracks the time after a request enters your production systems and before it reaches your application. We call this portion of your request&#x27;s life cycle request queuing. Depending on the specifics of your production systems, this measurement of time may or may not include an actual queue"
      },
      "id": "603eb84a196a678358a83dcc"
    }
  ],
  "/docs/apm/applications-menu/features/request-queue-server-configuration-examples": [
    {
      "sections": [
        "Ticketing integrations",
        "Requirements",
        "Integrate with New Relic",
        "Tip",
        "File tickets"
      ],
      "title": "Ticketing integrations",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "c6004eab5c13506e5bdf175be670ff86b0a24f52",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/user-interface-functions/share-your-data/ticketing-integrations/",
      "published_at": "2021-07-02T11:33:40Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic APM's transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic's webhook IPs. In addition, Lighthouse setup requires: The subdomain for your installation; for example, https://subdomain.lighthouseapp.com Your Lighthouse account's email and password for ticket tracking Integrate with New Relic Tip Owner and Admins To connect your New Relic account to Lighthouse: Go to: account dropdown > Account settings > Integrations > Ticketing integrations. Select the tab for Lighthouse. Follow the instructions on the individual tab, then click Integrate. After your ticketing system has been integrated, the corresponding tab's health status indicator in New Relic's UI changes to green (enabled). File tickets To use the ticketing system integrated with your New Relic account: From the selected APM transaction trace or APM error trace, select File a ticket. Follow standard procedures to create a ticket from your Lighthouse account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.90154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "You can integrate New Relic with Lighthouse. This is useful to create tickets about performance issues in New Relic <em>APM</em>&#x27;s transaction traces and error analytics. Requirements New Relic sends information to the ticketing system with webhooks. Make sure your system accepts traffic from New Relic"
      },
      "id": "603ebd11e7b9d292fc2a07ef"
    },
    {
      "sections": [
        "Configure request queue reporting",
        "HTTP header",
        "Tip",
        "C SDK",
        "Go agent",
        "Java, Node.js, Python, Ruby agents",
        ".NET agent",
        "PHP agent"
      ],
      "title": "Configure request queue reporting",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "3226477ad8d63af87fd5947589af31d0d679b89b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/applications-menu/features/configure-request-queue-reporting/",
      "published_at": "2021-07-02T12:45:18Z",
      "updated_at": "2021-03-16T08:18:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Request queuing occurs before the request reaches your application (where the agent resides). This is why you need to do some straightforward configuration of the agent and your production hosts to take advantage of this feature. HTTP header In order to report request queuing, most New Relic agents depend on an HTTP header set by the front-end web server (such as Apache or Nginx) or load balancer (such as HAProxy or F5). You can configure these front-end servers to set the timestamp in the HTTP header that represents when the request first entered your production infrastructure. Tip Set this header as soon after the request enters your infrastructure as possible so that you are less likely to miss performance problems in your infrastructure that occur before the header is set. Most New Relic agents will interpret an X-Queue-Start or X-Request-Start header and use it to calculate Request Queuing. The agents treat these headers identically. Include a value in the format t=MICROSECONDS_SINCE_EPOCH where MICROSECONDS_SINCE_EPOCH is an integer value of the number of microseconds that have elapsed since the beginning of the Unix epoch (for example, January 1, 1970). Nearly any front-end HTTP server or load balancer can be configured to add this header. Additional details depend on your specific agent and server configuration. For more information, see the request queue configuration examples. C SDK The C SDK does not support request queuing. Go agent With the Go agent, set either header to record a metric for it. Java, Node.js, Python, Ruby agents The most recent versions of the Java, Node.js, Python, and Ruby agents provide more flexibility in the format of the X-Request-Start or X-Queue-Start header. These agents allow the timestamp to be submitted in seconds, milliseconds, or microseconds as an integer or floating point value. These agents also allow the leading t= in the header value to be omitted. Based on the order of magnitude, these agents automatically interpret the time unit as seconds, milliseconds, or microseconds. New Relic can do this reliably since a millisecond timestamp, interpreted as microseconds, would result in a queue time over 40 years. Python agent only: When using Apache/mod_wsgi 3.4 or higher, mod_wsgi will automatically insert an equivalent to the X-Queue-Start header into the WSGI environ dictionary for each request. This will mark the specific point in time where Apache first accepted the request. The value set by mod_wsgi will be picked up and used by the Python agent if no separate X-Request-Start or X-Queue-Start header has been manually configured into a web server's front end or in Apache itself. .NET agent The .NET agent does not require (and will ignore) any configuration of HTTP headers to calculate queue time. It works by instrumenting the IIS-queuing mechanism directly and reports queue time as the difference between when the HttpContext constructor executes and when the HttpApplication.BeginRequest event fires. Request queue time is only reported for .NET Framework applications hosted on IIS (for example: ASP.NET applications). It is not reported for ASP .NET Core applications (targeting .NET Core or Framework), nor for self-hosted OWIN applications. PHP agent The PHP agent only supports the X-Request-Start header. This identifies the timestamp in microseconds as an integer, with an optional t= in the header value. To ensure that the header is read properly, check your phpinfo() under the PHP Variables section, and verify that _SERVER[\"HTTP_X_REQUEST_START\"] exists and is in the expected format. If you are using Nginx, see Request queue server configuration examples for additional information on setting the header.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>"
      },
      "id": "603eb8ba28ccbc4b1deba769"
    },
    {
      "sections": [
        "Request queuing and tracking front-end time",
        "Use request queuing to identify scaling problems",
        "Apdex calculations",
        "Clock skew"
      ],
      "title": "Request queuing and tracking front-end time",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Features"
      ],
      "external_id": "73285326db3b9d5e7d6477e83e45aeac1b541efa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/features/request-queuing-tracking-front-end-time/",
      "published_at": "2021-07-02T12:41:06Z",
      "updated_at": "2021-03-16T06:46:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM tracks the time after a request enters your production systems and before it reaches your application. We call this portion of your request's life cycle request queuing. Depending on the specifics of your production systems, this measurement of time may or may not include an actual queue that requests enter. It may also represent other functions (such as load balancing or internal network latency). Use request queuing to identify scaling problems Tracking time spent in request queuing is useful for identifying certain types of performance and scaling problems; for example: When your front-end web server is spending time waiting for application workers to become available When extra time is spent warming up application workers after a deploy or restart You must configure your New Relic agent and server to report request queuing. Then the information will appear in the selected application's Requests time chart for web transactions (from APM's Applications list, select the app), as well as other places in the user interface. The chart's legend indicates which color represents request queueing. Apdex calculations Request queuing is the time from when the browser requests content to the time it receives the content. Since your Apdex score will reflect these calculations, you can select whether to report request queue time separately or not. For more information, see Agent configuration. Clock skew If the front-end web server (such as Nginx) and your application do not reside on the same physical server, reported request queuing may be affected by clock skew. NTP provides an excellent way to keep server clocks in sync. However, they still will drift relative to each other. Since New Relic agents rely on a timestamp set by the front-end server, it may over- or under-report request queuing if the clock on that server is not closely synchronized with the clock on the app server. This may seem like a major problem with the feature; however, clock skew is unlikely to result in sudden spikes in reported request queuing. Sudden spikes generally occur when an app is restarted or becomes overloaded with requests. Our experience is that request queue reporting can be useful to identify real performance problems, but be sure to consider clock skew when interpreting this data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.86223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em> <em>UI</em> <em>pages</em>",
        "body": "<em>APM</em> tracks the time after a request enters your production systems and before it reaches your application. We call this portion of your request&#x27;s life cycle request queuing. Depending on the specifics of your production systems, this measurement of time may or may not include an actual queue"
      },
      "id": "603eb84a196a678358a83dcc"
    }
  ],
  "/docs/apm/distributed-tracing/trace-api/troubleshooting-missing-trace-api-data": [
    {
      "sections": [
        "Distributed tracing: Planning guide",
        "Impact to APM features",
        "External services page has less detail",
        "Transaction trace UI displays service URLs, not transaction links",
        "Cross-application tracing will be disabled",
        "Impacts related to mobile monitoring",
        "Plan your rollout",
        "Enable distributed tracing"
      ],
      "title": "Distributed tracing: Planning guide",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Get started"
      ],
      "external_id": "10263f2b6ec929f082153e28cbce07fe3a1f106a",
      "image": "https://docs.newrelic.com/static/7072dfa9e494767baabba420d78e7094/c1b63/distributed-trace-txn-trace-affects.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/concepts/distributed-tracing-planning-guide/",
      "published_at": "2021-07-01T18:50:44Z",
      "updated_at": "2021-07-01T18:50:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are new to New Relic distributed tracing, we recommend you read the following before you enable distributed tracing. Impact to APM features Our distributed tracing improves on APM's previous cross application tracing feature. Here are some key benefits: See more cross-service activity details and more complete end-to-end traces. Filter and query traces, as well as make custom charts. See the complete trace even when calls cross an organization's account boundaries. See Introduction to distributed tracing for more features. Enabling distributed tracing may affect some APM features you currently use. These changes affect only applications monitored by agents that have distributed tracing enabled—they don't apply on an account-level. We may provide backward compatibility with some or all of the affected features in future releases. For now, you should understand the following changes before enabling distributed tracing: External services page has less detail When distributed tracing is enabled for an application, external calls do not have internal transaction details at one.newrelic.com > APM > (select an app) > Monitor > External services > (select external service). To find that information, you would instead go to the Distributed tracing UI page, find the external call URLs, and see what their child spans are. Transaction trace UI displays service URLs, not transaction links When distributed tracing is enabled for an application, the transaction trace UI will no longer have the transaction name and link for the called service (see screenshot below). This will be replaced with the called service's URL. one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace): This shows the transaction trace UI before distributed tracing is enabled, with a link to the associated transaction. With distributed tracing enabled, it will display the service's URL. If you wanted to get more detail about trace activity, you would go to the Distributed tracing UI page and examine that trace. Cross-application tracing will be disabled Enabling distributed tracing will disable the cross application tracing feature. Distributed tracing is an improved version of cross-application tracing and only one can be enabled at a time. Impacts related to mobile monitoring APM-related impacts include: When distributed tracing is enabled for an APM-monitored entity, legacy service maps will not show applications monitored by mobile. The App server drill-down feature of the legacy Mobile HTTP requests UI page is not available. Plan your rollout If you're enabling distributed tracing for a large, distributed system, here are some tips: If you are a current APM user, see Impact to APM features. Determine the requests that are the most important for your business, or the most likely to require analysis and troubleshooting, and enable distributed tracing for those services. Enable tracing for services at roughly the same time so you can more easily gauge how complete your end-to-end traces are. When you look at traces in the distributed tracing UI, you'll see spans in the trace for external calls to other services. Then, you can enable distributed tracing for any of those services you want. If a service is fairly standalone and not often used in context with other services, you may not want to enable distributed tracing for it. Here's a visual representation of such a phased roll-out: If you are using APM for a large, monolithic service, there may be many sub-process spans per trace and APM limits may result in fewer traces than expected. You can solve this by using APM agent instrumentation to disable the reporting of unimportant data. Distributed tracing works by propagating header information from service to service in a request path. Some services may communicate through a proxy or other intermediary service that does not automatically propagate the header. In that case, you will need to configure that proxy so that it allows the newrelic header value to be propagated from source to destination. Enable distributed tracing If you are aware of the impact to APM features and have thought about your rollout, you are ready to set up distributed tracing. See Overview: Enable distributed tracing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.18913,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Distributed</em> <em>tracing</em>: Planning guide",
        "sections": "<em>Distributed</em> <em>tracing</em>: Planning guide",
        "tags": "<em>Understand</em> <em>dependencies</em>",
        "body": " details and more complete end-to-end traces. Filter and query traces, as well as make custom charts. See the complete <em>trace</em> even when calls cross an organization&#x27;s account boundaries. See Introduction to <em>distributed</em> <em>tracing</em> for more features. Enabling <em>distributed</em> <em>tracing</em> may affect some APM features you"
      },
      "id": "6072a60564441f3a629d8535"
    },
    {
      "sections": [
        "Understand and use the distributed tracing UI",
        "Open the distributed tracing UI",
        "View traces for a specific service",
        "View traces across all accounts",
        "Tip",
        "Find traces that are useful",
        "Filter using the query bar",
        "Find traces that touch two services",
        "Find error spans using the like operator",
        "Trace groups",
        "Filter using the scatter plot",
        "Filters",
        "Trace histograms",
        "Important",
        "Trace details UI page",
        "Span details pane",
        "View related logs",
        "Additional UI details",
        "How to understand span errors",
        "Anomalous spans",
        "Client span duration: time differences between client and server spans",
        "Fragmented traces",
        "Trace details obfuscated based on account access",
        "Span limits and sampling",
        "Incomplete span names in waterfall view",
        "Missing spans and span/service count discrepancies"
      ],
      "title": "Understand and use the distributed tracing UI",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "UI and data"
      ],
      "external_id": "f5b66e03583e42613810f1390b4e5adab4ed2caa",
      "image": "https://docs.newrelic.com/static/ec08996f31e6586bb257c6f89b3c8f99/e5166/new-relic-distributed-tracing-client-span-time.jpg",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/ui-data/understand-use-distributed-tracing-ui/",
      "published_at": "2021-07-02T19:11:31Z",
      "updated_at": "2021-07-02T19:11:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Distributed tracing helps you monitor and analyze the behavior of your distributed system. After you enable distributed tracing, you can use our UI tools to search for traces and analyze them. For example, let's say you are an engineer troubleshooting errors in a complex transaction spanning many services. Here's what you can do in our UI: Open the distributed tracing UI page. Sort through your traces using a filter to find that specific request and show only traces containing errors. On the trace details page, you review the span along the request route that originated the error. Noting the error class and message, navigate to the service from its span in the trace so you can see that the error is occurring at a high rate. Read on to explore the options in the distributed tracing UI. Open the distributed tracing UI Here's how you can access the distributed tracing UI, depending on the type of search you want to do: View traces for a specific service The New Relic Explorer and APM are two menu options that help you navigate to a specific service so you can see traces that include that service. Go to one.newrelic.com. Click Explorer or APM in the top menu bar. Filter to the service you enabled for distributed tracing by typing the service name, and then press Enter. In the left navigation's Monitor section, click Distributed tracing. View traces across all accounts If you want to view traces from across all accounts you have access to, go to one.newrelic.com, click Browse data, and then Traces. Tip If you don't have access to accounts for some services in a trace, we'll obfuscate some details for those services. Find traces that are useful We have a variety of tools to help you find traces and spans so you can resolve issues. The opening distributed tracing page is populated with a default list of traces, and you can quickly refine this list using these tools: Query bar Trace groups Scatter plot chart Filters Interactive histograms Tip In addition to these tools, you can also use other options mentioned in Query distributed trace data. Filter using the query bar The Find traces query bar is a quick way to narrow your search for traces. You can either start typing in the query bar or use the dropdown to create a compound query. Query returns are based on span attributes, not on trace attributes. You define spans that have certain criteria, and the search displays traces that contain those spans. If you use a multi-attribute filter, it is affected by first attribute selected. Distributed tracing reports on two types of data: transaction events and spans. When you select an attribute in the filter, the data type that attribute is attached to dictates the available attributes. For example, if you filter on an attribute that is attached to a transaction event, only transaction event attributes are available when you attempt to add filter on additional attribute values. Queries for traces are similar to NRQL (our query language). Here are the main exceptions: String values don't require quote marks (for example, you can use either appName = MyApp or appName = 'MyApp') The like operator doesn’t require % (for example, you can use either appName like product or appName like %product%). Tip Some queries that return a large number of results may return false positives. The trace list limits these incorrect results to 10% of the returned results. False positives may also result in histogram chart results that are not displayed in the trace list. Here are two query bar examples: Find traces that touch two services The query in the image below finds traces that: Pass through both WebPortal and Inventory Service applications Have an Inventory Service datastore call that takes longer than 500 ms Contains an error in any span. Go to one.newrelic.com > Apps > Distributed tracing Find error spans using the like operator The query in the image below finds traces that: Contain spans that pass through the WebPortal application and where an error occurred on any span in the WebPortal application Contain spans where the customer_user_email attribute contains a value ending with hotmail.com anywhere in the trace. Go to one.newrelic.com > Apps > Distributed tracing Trace groups The default view of distributed tracing shows traces grouped by the same root entry span. In other words, traces are grouped by the span where New Relic began recording the request. You can slide the toggle Group similar traces to turn this on and off. With trace groups you get a high-level view of traces so you can understand request behavior for groups of similar traces. This helps you understand dips or spikes in trace count, duration, and errors. When you click on one of the trace groups, you get all the standard details in context of the specific trace group you selected. Filter using the scatter plot The trace scatter plot is a quick way to search for outlying traces. This is available on the opening page of distributed tracing if you turn off the Group similar traces toggle at the top of the page. In the scatter plot, you can move the cursor across the chart to view trace details and you can click individual points to get details: Here's how you can control what's displayed in the scatter plot: In the View by dropdown, select the duration type: Back-end duration Root span duration Trace duration In Group traces by, select one of these options: Errors: Group by whether or not traces contain errors. Root service: Group by the name of the first service in traces. In a trace where Service A calls Service B and Service B calls Service C, the root service would be Service A. Root entry span: Group by the root transaction, which is the root service's endpoint. In a trace where Service A calls Service B and Service B calls Service C, the root entry span is Service A's endpoint. For example: \"Service A - GET /user/%\". Service entry span: Group by the span name of the service currently being viewed in APM. For example, for a trace where Service A calls Service B and Service B calls Service C, if you're viewing Service B in APM and select this grouping, the traces will be represented by their Service B span names. If a service has multiple spans in a trace, this grouping option will use that service's first entry point. Filters In the left pane, you can filter traces by multi-span traces, specific entities, or error types. Once you select a filter, only traces associated with that specific type are displayed. This makes it much easier to view the traces you're most interested in so you can find and fix issues faster. Trace histograms The histogram charts give you a quick understanding of trace distribution for important values, such as duration. Click Show filters at the bottom of the left pane to display the histograms. When you move the histogram sliders, they change the data displayed in the scatterplot or the trace group charts. For example, you can drag the Trace duration chart slider to show only traces over 500 ms, as shown in the histogram example below. Important Some queries that produce many results may result in false positives in histograms. This could manifest as histograms showing trace results that are not in the trace list. Trace details UI page When you select a trace from the trace list, you see that trace's timeline and spans: one.newrelic.com > APM > (select an application) > Monitor > Distributed tracing > (select a trace) > (select a span): See the spans in a trace. Examine individual span details and see notifications for spans with anomalous behavior. The UI indicates some span properties with icons: Span property Indicator Description Service This icon represents a span that's a service's entry point. In-process This icon represents an in-process span, which is a span that takes place within a process (as opposed to a cross-process span). Examples: middleware instrumentation, user-created spans. Datastore This icon represents a span call to a datastore. External This icon represents category representing a call to an external service made via HTTP. Browser app This icon represents a browser application span. Lambda This icon represents a span from a Lambda function. Some spans will have additional indicators: Span property Indicator Description Type of connection Solid lines indicate a direct parent-child relationship; in other words, one process or function directly calling another. A dotted line indicates a non-direct relationship. For more on relationships between spans, see Trace structure. Errors A span with an error. See How to understand span errors. Anomalous This icon represents the detection of an anomalous span. Orphaned spans Some spans may be \"orphaned,\" or separated, from the trace. These spans will appear at the bottom of the trace. For more details, see Fragmented traces. Multiple app names When beside a span name, this represents an entity that has had multiple app names set. Select this to see all app names it reports to. To search trace data by alternate app names, use the appName attribute. Client/server time difference If a span's duration indicator is not completely colored in (like in this example), it means that there is a time discrepancy between the server-side duration and the client-side duration for that activity. For details on this, see Client/server time difference. For more on the trace structure and how span properties are determined, see Trace structure. Span details pane When you select a span, a pane opens up with span details. These details can be helpful for troubleshooting performance issues. Details include: Performance charts Span attributes The span's data source Anomalous span details The span's full name What a span displays is based on its span type. For example, a datastore span's name attribute will contain the datastore query. View related logs If you are using our logs in context feature together with our log management, you can see any logs that are linked to your traces: Go to the trace details page by clicking on a trace. Click See logs in the upper-right corner. For details related to an individual log message, click directly on the message. Additional UI details Here are some additional distributed tracing UI details, rules, and limits: How to understand span errors Span-level errors show you where errors originated in a process, how they bubbled up, and where they were handled. Every span that ends with an exception is shown with an error in the UI and contributes to the total error count for that trace. Here are some general tips about understanding span errors: Spans with errors are highlighted red in the distributed tracing UI. You can see more information on the Error Details pane for each span. All spans that exit with errors are counted in the span error count. When multiple errors occur on the same span, only one is written to the span in this order of precedence: A noticeError The most recent span exception This table describes how different span errors are handled: Error type Description Spans ending in exceptions An exception that leaves the boundary of a span results in an error on that span and on any ancestor spans that also exit with an error, until the exception is caught or exits the transaction. You can see if an exception is caught in an ancestor span. Notice errors Errors noticed by calls to the agent noticeError API or by the automatic agent instrumentation are attached to the currently executing span. Response code errors Response code errors are attached to the associated span, such as: Client span: External transactions prefixed with http or db. Entry span: In the case of a transaction ending in a response code error. The response code for these spans is captured as an attribute httpResponseCode and attached to that span. Anomalous spans If a span is displayed as anomalous in the UI, it means that the following are both true: The span is more than two standard deviations slower than the average of all spans with the same name from the same service over the last six hours. The span's duration is more than 10% of the trace's duration. Client span duration: time differences between client and server spans When a process calls another process, and both processes are instrumented by New Relic, the trace contains both a client-side representation of the call and a server-side representation. The client span (calling process) can have time-related differences when compared to the server span (called process). These differences could be due to: Clock skew, due to system clock time differences Differences in duration, due to things like network latency or DNS resolution delay The UI shows these time-related differences by displaying an outline of the client span in the same space as the server span. This span represents the duration of the client span. It isn't possible to determine every factor contributing to these time-related discrepancies, but here are some common span patterns and tips for understanding them: When a client span is longer than the server span, this could be due to latency in a number of areas, such as: network time, queue time, DNS resolution time, or from a load balancer that we cannot see. When a client span starts and ends before a server span begins, this could be due to clock skew, or due to the server doing asynchronous work that continues after sending the response. When a client span starts after a server span, this is most likely clock skew. Fragmented traces Fragmented traces are traces with missing spans. When a span is missing or has invalid parent span IDs, its children spans become separated from the rest of the trace, which we refer to as \"orphaned.\" Orphaned spans appear at the bottom of the trace, and they will lack connecting lines to the rest of the trace. Types of orphaned span properties indicated in the UI: No root span. Missing the root span, which is the first operation in the request. When this happens, the span with the earliest timestamp is displayed as the root. Orphaned span. A single span with a missing parent span. This could be due to the parent span having an ID that doesn't match its child span. Orphaned trace fragment. A group of connected spans where the first span in the group is an orphan span. This can happen for a number of reasons, including: Collection limits. Some high-throughput applications may exceed collection limits (for example, APM agent collection limits, or API limits). When this happens, it may result in traces having missing spans. One way to remedy this is to turn off some reporting, so that the limit is not reached. Incorrect instrumentation. If an application is instrumented incorrectly, it won't pass trace context correctly and this will result in fragmented traces. To remedy this, examine the data source that is generating orphan spans to ensure instrumentation is done correctly. To discover a span's data source, select it and examine its span details. Spans still arriving. If some parent spans haven't been collected yet, this can result in temporary gaps until the entire trace has reported. UI display limits. Orphaned spans may result if a trace exceeds the 10K span display limit. Trace details obfuscated based on account access If you don’t have access to the New Relic accounts that monitor other services, some of the span and service details will be obfuscated in the UI. Obfuscation can include: Span name concealed by asterisks Service name replaced with New Relic account ID and app ID For more information on the factors affecting your access to accounts, see Account access. Span limits and sampling See Sampling. Incomplete span names in waterfall view When viewing the span waterfall, span names may be displayed in an incomplete form that is more human-readable than the complete span name. To find the complete name, select that span and look for the Full span name. Knowing the complete name can be valuable for querying that data with NRQL. Missing spans and span/service count discrepancies A trace may sometimes have (or seem to have) missing spans or services. This can manifest as a discrepancy between the count of a trace's spans or services displayed in the trace list and the count displayed on the trace details page. Reasons for missing spans and count discrepancies include: An APM agent may have hit its 1K span collection limit. A span may be initially counted but not make it into a trace display, for reasons such as network latency or a query issue. The UI may have hit its 10K span display limit. All spans collected, including those not displayed, can be queried with NRQL.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 211.97769,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Understand</em> and use the <em>distributed</em> <em>tracing</em> UI",
        "sections": "<em>Understand</em> and use the <em>distributed</em> <em>tracing</em> UI",
        "tags": "<em>Understand</em> <em>dependencies</em>",
        "body": " services. Here&#x27;s what you can do in our UI: Open the <em>distributed</em> <em>tracing</em> UI page. Sort through your traces using a filter to find that specific request and show only traces containing errors. On the <em>trace</em> details page, you review the span along the request route that originated the error. Noting"
      },
      "id": "6072a70028ccbc265a51c13d"
    },
    {
      "sections": [
        "How New Relic distributed tracing works",
        "Tip",
        "Trace sampling",
        "Head-based sampling (standard distributed tracing)",
        "Language agents: adaptive sampling",
        "Language agents: limits and sampling",
        "Trace rate limiting",
        "Lambda trace sampling",
        "Tail-based sampling (Infinite Tracing)",
        "Architecture",
        "Tail-based sampling algorithms",
        "No sampling",
        "Browser and Mobile trace reporting",
        "Trace API",
        "How trace data is structured",
        "How trace data is stored",
        "How trace context is passed between applications",
        "Important",
        "Scenario 1: Trace touching three agent types",
        "Scenario 2: Trace with W3C New Relic and middleware",
        "Scenario 3: Trace with any W3C-compliant agent and a New Relic agent."
      ],
      "title": "How New Relic distributed tracing works",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Get started"
      ],
      "external_id": "4dbe0119017f78ad4db2a2b8a9ca2d287222753a",
      "image": "https://docs.newrelic.com/static/406c9f3af4012dab16df681c8feab256/c1b63/new-relic-distributed-tracing-trace-structure.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works/",
      "published_at": "2021-07-02T19:56:18Z",
      "updated_at": "2021-06-25T20:20:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some technical details about how New Relic distributed tracing works: How trace sampling works How we structure trace data How we store trace data How trace context is passed between applications Tip For instructions about setting up distributed tracing, see Overview: Enable distributed tracing. Trace sampling How your traces are sampled will depend on your setup and the New Relic tracing tool you're using. For example, you may be using a third-party telemetry service (like OpenTelemetry) to implement sampling of traces before your data gets to us or, if you're using Infinite Tracing, you'd probably send us all your trace data and use our sampling. We have a few sampling strategies available: Head-based sampling (standard distributed tracing) Tail-based sampling (Infinite Tracing) No sampling Head-based sampling (standard distributed tracing) With the exception of our Infinite Tracing feature, most of our tracing tools use a head-based sampling approach. This applies filters to individual spans before all spans in a trace arrive, which means decisions about whether to accept spans is made at the beginning (the \"head\") of the filtering process. We use this sampling strategy to capture a representative sample of activity while avoiding storage and performance issues. Here are some details about how head-based sampling is implemented in our standard distributed tracing tools: Language agents: adaptive sampling Our APM language agents use adaptive sampling to capture a representative sample of system activity. The following is an explanation of how adaptive sampling works. For the first service in a distributed trace, 10 requests are chosen to be sampled. The throughput to that service is used to adjust how frequently requests are sampled. This is explained in more detail below. The first service we monitor in a distributed trace is called the trace origin. The trace origin chooses requests at random to be traced. That decision propagates to the downstream services touched by that request. When the request has completed, all of the spans touched by that request that we've detected are made available in the UI as a complete trace (though agent limits may result in fragmented traces). APM agents have a limit on the number of transactions collected per minute (this can vary, depending on agent) and a limit on the number of spans collected per minute (1000 per agent instance). To adhere to these limits, the default number of traces at the trace origin is 10 traces per minute. An APM agent spreads out the collection of these 10 traces over a minute in order to get a representative sample over time. The exact sampling rate depends on the number of transactions in the previous minute. The rate responds to changes in transaction throughput, going up or down. For example, if the previous minute had 100 transactions, the agent would anticipate a similar number of transactions and select 1 out of every 10 transactions to be traced. Language agents: limits and sampling An APM language agent instance using head-based sampling has a limit of 1000 spans per minute. The agent attempts to keep all spans that are marked to be sampled as part of a distributed trace. In many distributed systems, the average microservice may generate 10 to 20 spans per request. In those cases, the agent span limit can accommodate all spans chosen, and that service will have full detail in a trace. However, some requests to services will generate many spans, and the agent span limit will be reached. As a result, some traces will not have full detail for that service. One solution to this would be to custom instrument an agent to report less activity and therefore report fewer spans. To read about how browser monitoring of trace data may vary from our language agents, see Browser traces. Trace rate limiting If the above sampling methods still result in too much trace data, we may limit incoming data by sampling traces after they're received. By making this decision at the trace level, it avoids fragmenting traces (accepting only part of a trace). This process works similarly to adaptive sampling. The total spans received in a minute are totaled. If too many spans are received, fewer spans may be accepted in the following minute, in order to achieve a floating-average throughput rate. Lambda trace sampling Our AWS Lambda monitoring uses its own sampling process. Tail-based sampling (Infinite Tracing) Our Infinite Tracing feature uses a tail-based sampling approach. \"Tail-based sampling\" means that trace-retention decisions are done at the tail end of processing after all the spans in a trace have arrived. With Infinite Tracing, you can send us 100% of your trace data from your application or third-party telemetry service, and Infinite Tracing will figure out which trace data is most important. And you can configure the sampling to ensure the traces important to you are retained. Architecture For Infinite Tracing, agents or integrations send 100% of all instrumented spans to a trace observer. The trace observer is a distributed tracing service residing in a cluster of services on AWS called New Relic Edge. Tip Only your spans go to the trace observer—all other data such as metrics, custom events, and transaction traces are sent the normal route to New Relic and are subject to local sampling. You configure a unique trace observer endpoint for the AWS region you want to send data to. You can request multiple endpoints, one per AWS region. The endpoint represents a trace observer for a particular workload. For example, all spans from a single trace (request) must go to that endpoint. Here are two architectural diagrams: one showing how data flows if you use APM agents and another if you use New Relic integrations like OpenTelemetry exporters: The trace observer holds traces open while spans for that trace arrive. Once the first span in a trace arrives, a session is kept open for 10 seconds. Each time a new span for that trace arrives, the expiration time is reset to 10 seconds. Traces that haven't seen a span arrive within the last 10 seconds will automatically expire. Tail-based sampling algorithms By default, each trace observer offers traces to three samplers: one looking for duration outliers, one looking for traces with errors, and one trying to randomly sample across all trace types. Each sampler keeps a target percentage of traces that match their criteria. Here are details about each sampler: Sampler Matching criteria Target percent Duration Traces with an outlier duration, using two algorithms: Gaussian (Assumes a normal distribution and a threshold at the 99th percentile) Eccentricity (Assumes no distribution and a threshold based on cluster) 100% Error Traces having at least one span with an error 100% Random All traces 1% (This is configurable. See Infinite Tracing: Random trace filter) If the matching criteria matches the trace, each sampler looks at the trace’s shape. A trace’s shape is the unique combination of the root span’s entity name and span name. This is a simple way to separate traces using the entry point of the request. Once the shape is determined, the sampler makes a decision to keep or reject the trace based on its target sampling percent. If it’s 100%, the trace is automatically kept. If it’s anything less, the probability the sampler keeps a given trace is determined by the target percent. For example, the default target percent is 1 for random traces, so 1% of those traces are kept. If you prefer, you can change the random filter percentage. Because the trace observer uses percentages of throughput, the number of traces selected will vary with that throughput. No sampling Some of our tools don't use sampling. Sampling details for these tools: Browser and Mobile trace reporting Browser monitoring distributed tracing and Mobile monitoring report all spans. Our APM language agents are often used in conjunction with browser and mobile monitoring, and our language agents use sampling. This means that there will likely be many more browser and mobile spans than back-end spans, which can result in browser and mobile app spans disconnected from back-end spans. For tips on querying for traces that contain front and back-end spans, see Find browser span data. Trace API If you don't have Infinite Tracing enabled, our Trace API does no sampling (unless the default data limits are exceeded). It's expected that you set up the Trace API to send us the traces you think are important. How trace data is structured Understanding the structure of a distributed trace can help you: Understand how traces are displayed in our UI Help you query trace data A distributed trace has a tree-like structure, with \"child\" spans that refer to one \"parent\" span. This diagram shows some important span relationships in a trace: This diagram shows how spans in a distributed trace relate to each other. This diagram shows several important concepts: Trace root. The first service or process in a trace is referred to as the root service or process. Process boundaries. A process represents the execution of a logical piece of code. Examples of a process include a backend service or Lambda function. Spans within a process are categorized as one of the following: Entry span: the first span in a process. Exit span: a span is a considered an exit span if it a) is the parent of an entry span, or b) has http. or db. attributes and therefore represents an external call. In-process span: a span that represents an internal method call or function and that is not an exit or entry span. Client spans. A client span represents a call to another entity or external dependency. Currently, there are two client span types: Datastore. If a client span has any attributes prefixed with db. (like db.statement), it's categorized as a datastore span. External. If a client span has any attributes prefixed with http. (like http.url) or has a child span in another process, it's categorized as an external span. This is a general category for any external calls that are not datastore queries. Trace duration. A trace's total duration is determined by the length of time from the start of the earliest span to the completion of the last span. You can query span relationship data with the NerdGraph GraphiQL explorer at api.newrelic.com/graphiql. How trace data is stored Understanding how we store trace data can help you query your trace data. We save trace data as: Span: A span represents operations that are part of a distributed trace. The operations that a span can represent include browser-side interactions, datastore queries, calls to other services, method-level timing, and Lambda functions. One example: in an HTTP service, a span is created at the start of an HTTP request and completed when the HTTP server returns a response. Span attributes contain important information about that operation (such as duration, host data, etc.), including trace-relationship details (such as traceId, guid). For span-related data, see span attributes. Transaction: If an entity in a trace is monitored by an agent, a request to that entity generates a single Transaction event. Transactions allow trace data to be tied to other New Relic features. For transaction-related data, see transaction attributes. Contextual metadata. We store metadata that shows calculations about a trace and the relationships between its spans. To query this data, use the NerdGraph GraphiQL explorer. How trace context is passed between applications We support the W3C Trace Context standard, which makes it easier to trace transactions across networks and services. When you enable distributed tracing, New Relic agents add HTTP headers to a service's outbound requests. HTTP headers act like passports on an international trip: They identify your software traces and carry important information as they travel through various networks, processes, and security systems. The headers also contain information that helps us link the spans together later: metadata like the trace ID, span ID, the New Relic account ID, and sampling information. See the table below for more details on the header: Item Description accountId This is your New Relic account ID. However, only those on your account and New Relic Admins can associate this Id with your account information in any way. appId This is the application ID of the application generating the trace header. Much like accountId, this identifier is not going to provide any information unless you're a user on the account. guid With Distributed Tracing, each segment of work in a trace is represented by a span, and each span has a guid attribute. The guid of the last span within the process is sent with the outgoing request so that the first segment of work in the receiving service can add this guid as the parentId attribute which connects data within the trace. Parent type The source of the trace header, as in Mobile, Browser, Ruby app, etc. This becomes the parent.type attribute on the Transaction triggered by the request this header is attached to. Priority A randomly generated priority ranking value that helps determine which data is sampled when sampling limits are reached. This is a float value set by the first New Relic agent that’s part of the request so all data in the trace will have the same priority value. Sampled A boolean value that tells the agent if traced data should be collected for the request. This is also added as an attribute on any span and transaction data collected. If you want to read more about this sampling process, this guide goes into more detail. Timestamp Unix timestamp in milliseconds when the payload was created. traceId The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. This also is added as an attribute on the span and transaction data. transactionId The unique identifier for the transaction event. Trusted acount key This is a key that helps identify any other accounts associated with your account. So if you have multiple sub-accounts that the trace crosses, we can confirm that any data included in the trace is coming from a trusted source, and tells us what users should have access to the data. Version and data key This identifies major/minor versions, so if an agent receives a trace header from a version with breaking changes from the one it is on, it can reject that header and report the rejection and reason. This header information is passed along each span of a trace, unless the progress is stopped by something like middleware or agents that don't recognize the header format (see Figure 1). Figure 1 To address the problem of header propagation, we support the W3C Trace Context specification that requires two standardized headers. Our latest W3C New Relic agents send and receive these two required headers, and by default, they also send and receive the header of the prior New Relic agent: W3C (traceparent): The primary header that identifies the entire trace (trace ID) and the calling service (span id). W3C (tracestate): A required header that carries vendor-specific information and tracks where a trace has been. New Relic (newrelic): The original, proprietary header that is still sent to maintain backward compatibility with prior New Relic agents. This combination of three headers allows traces to be propagated across services instrumented with these types of agents: W3C New Relic agents Non-W3C New Relic agents W3C Trace Context-compatible agents Important If your requests only touch W3C Trace Context-compatible agents, you can opt to turn off the New Relic header. See the agent configuration documentation for details about turning off the newrelic header. The scenarios below show various types of successful header propagation. Scenario 1: Trace touching three agent types This shows the flow of headers when a request touches three different agent types: Scenario 2: Trace with W3C New Relic and middleware This shows the combination of headers sent by a W3C New Relic agent to some middleware. Scenario 3: Trace with any W3C-compliant agent and a New Relic agent. This shows the two required W3C headers from another vendor accepted by a W3C New Relic agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.88846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How New Relic <em>distributed</em> <em>tracing</em> works",
        "sections": "How New Relic <em>distributed</em> <em>tracing</em> works",
        "tags": "<em>Understand</em> <em>dependencies</em>",
        "body": " the default data limits are exceeded). It&#x27;s expected that you set up the <em>Trace</em> <em>API</em> to send us the traces you think are important. How <em>trace</em> data is structured Understanding the structure of a <em>distributed</em> <em>trace</em> can help you: <em>Understand</em> how traces are displayed in our UI Help you query <em>trace</em> data"
      },
      "id": "6072a66664441f14089d856c"
    }
  ],
  "/docs/apm/index": [
    {
      "sections": [
        "High security mode",
        "Requirements",
        "Account level",
        "Enable high security mode (version 2)",
        "Caution",
        "Results of enabling high security mode (version 2)",
        "Results of enabling high security mode v1 (deprecated)",
        "Migrate from version 1 to version 2"
      ],
      "title": "High security mode",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Configuration"
      ],
      "external_id": "128d0e140cf1d5cf849640c070f1f9b0b2beb84e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/configuration/high-security-mode/",
      "published_at": "2021-07-01T17:19:02Z",
      "updated_at": "2021-07-01T17:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's default APM agent settings provide a high level of security. However, you may need to guarantee that even if the default APM agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on APM's high security mode (also known as enterprise security mode). For more information about our security measures, see our security and privacy documentation, or visit the New Relic security website. Requirements Customers on our New Relic One pricing plan require Enterprise edition. Customers on our original pricing plan have access depending on their subscription level. Account level If you choose to turn on high security, you must enable high security for all applications reporting to the account. High security must be set on each individual account. For organizations that have a parent/child account structure, child accounts don't automatically inherit the high security setting when enabled on the parent account. Currently there are two versions of high security mode. Version 1 is deprecated and is only available if you already have it. If you are enabling high security mode for the first time, the only option is version 2 (v2). Agent Version 2 support C SDK n/a Go All versions Java 3.7 or higher (enabled by default) .NET 3.3 or higher Node.js 1.7.0 or higher PHP 4.9 or higher Python 2.22.0.0 or higher Ruby 3.9.1 or higher Enable high security mode (version 2) To enable high security, you must update both the local configuration on your server and the remote configuration in the UI. Caution Once you enable high security for an account, high security cannot be turned off without assistance from New Relic Support. Setting location Description Set in UI To set high security in the UI: Go to one.newrelic.com, click the account dropdown and select Account settings. On that page, select High security mode. If you are on our original pricing plan, only the account owner can view this option. If the agent is configured for high security via the UI but not locally, then the agent connections will be rejected, and the agent will shut down. However, this won't shut down your application. Local, via agent Enable high security mode in your agent configuration file. High security mode is disabled by default, and the exact procedure to enable it varies by agent: C SDK: n/a Go Java .NET Node.js PHP Python Ruby If the agent is configured for high security locally but not via the UI, then the agent connections will be rejected, and the agent will shut down. This will not shut down your application. Results of enabling high security mode (version 2) Once enabled, high security mode (v2) ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires a secure (HTTPS) connection. Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure all data in transit per the latest industry standards. Prevents HTTP param capture High security mode does not allow HTTP params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send HTTP params locally or through server-side configuration, high security mode will override the configuration to never capture HTTP params. Prevents message queue param capture High security mode does not allow message queue params, which may contain sensitive customer data, to be sent to the New Relic collector. If the agent is configured to send message queue params locally or through server-side configuration, then high security mode will override the configuration to never capture message queue params. Prevents raw query statement capture High security mode does not allow raw database query statements, which may contain sensitive customer data, to be captured. If the agent is configured to capture raw queries locally or through server-side configuration, then high security mode will override the configuration to never capture raw queries. Prevents user attribute capture High security mode does not allow attributes set using each agent's API to be captured, as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.addCustomParameter(String key, String value) Copy NewRelic.addCustomParameter(String key, Number value) Copy NewRelic.setUserName(String name) Copy NewRelic.setAccountName(String name) Copy NewRelic.setProductName(String name) Copy Prevents noticeError attribute capture High security mode does not allow attributes set using each agent's noticeError API call to be captured as these may contain sensitive customer data. For example, in the Java agent, attributes passed in through the following NewRelic agent API calls will be blocked: NewRelic.noticeError(String message, Map<String, String> params) Copy NewRelic.noticeError(Throwable throwable, Map<String, String> params) Copy Prevents custom events High security mode does not allow custom events to be created using the agent API, as these may contain sensitive customer data. For example, in the .NET agent, the API call RecordCustomEvent will be blocked. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Results of enabling high security mode v1 (deprecated) High security mode version 1 is deprecated and only available if you enabled it prior to version 2 being available. High security mode version 1 ensures the following for your account: Feature Comments Requires agents to use a secure connection (HTTPS) High security mode requires an encrypted connection (HTTPS). Non-secure connection attempts will be rejected. The latest version of all New Relic agents support HTTPS. If the configuration is not set appropriately, the agent will override the property to ensure that all data in transit is encrypted as per the latest industry standards. Prevents HTTP param capture Agents configured to capture HTTP params, which may contain sensitive customer data, are not allowed to connect to New Relic. If the local configuration is set to capture request parameters, then New Relic's collector will reject the connection, and the agent will shut down. Prevents raw query statement capture Agents configured to capture raw database query statements, which may contain sensitive customer data, are not allowed to connect to New Relic. If the agent is configured to capture raw queries locally or through server-side configuration, New Relic's collector will reject the connection and the agent will shut down. Prevents deploying Custom Instrumentation via CIE High security mode does not allow deploying custom instrumentation when using the Custom Instrumentation Editor. If you have high security mode enabled, you must export the instrumentation and manually import it to your app server. Migrate from version 1 to version 2 These are the main differences between the two versions of high security: In order to make high security even more secure, high security must be enabled in the New Relic user interface and in the local New Relic configuration file. High security v1 only required high security to be set in the New Relic UI. User attributes, noticeError attributes, and message queue parameters are turned off with high security in version 2, but not in version 1. To update from v1 to v2, add high_security: true to your local agent configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 41.156754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Manage <em>APM</em> agents",
        "body": "New Relic&#x27;s default <em>APM</em> agent settings provide a high level of security. However, you may need to guarantee that even if the default <em>APM</em> agent settings are overridden to be more permissive, no sensitive data will ever be sent to New Relic. If this is the case, then you will want to turn on <em>APM</em>"
      },
      "id": "6043c83be7b9d290e1579a04"
    },
    {
      "sections": [
        "Remove applications from New Relic",
        "Before attempting to remove an app",
        "Remove an application from New Relic",
        "APM applications",
        "Browser",
        "Tip",
        "Mobile",
        "Troubleshooting",
        "You are not an admin on your full user account",
        "You have not waited long enough",
        "Not all agents are disabled",
        "You have problems removing your PHP app",
        "You don't know where the app's data is coming from",
        "Browser data is still reporting",
        "For more help"
      ],
      "title": "Remove applications from New Relic",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "f457af939892708a477895093f97b65d08ff015a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic/",
      "published_at": "2021-07-02T09:20:58Z",
      "updated_at": "2021-05-21T18:31:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applications are automatically removed from New Relic after 93 days without sending data to our platform. You can also remove an application using the UI, once it has stopped sending data. Key metrics will continue to be available via the New Relic REST API, with the application name remaining reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an APM, browser, or mobile app from the New Relic UI, keep in mind: You can downgrade your account to pay less or make it entirely free. To remove an app, you must have a user role with that capability. If an agent is still sending data from an app, you cannot remove an app. Remove an application from New Relic Before removing an APM, browser, or mobile application from New Relic, stop the application from sending data either by disabling the agent or by uninstalling it completely. APM applications Disable the APM agent: C SDK: Do a quick recompile and deploy. For example, surround your instrumentation in #ifdef, and set the value of YOURNAMESPACE_NEWRELIC_ENABLED with your build system. Go: Set Enabled to false. Java: Set agent_enabled to false. .NET: Set Newrelic.AgentEnabled to false. Node.js: Set agent_enabled to false. PHP: Remove or disable both the newrelic.so and newrelic-daemon components. Set newrelic.enabled to false. Python: Set monitor_mode to false. Ruby: Set agent_enabled to false. Restart the application server and wait up to ten minutes. Verify the color-coded health status for the app has turned to gray and is no longer reporting data. To remove the APM application and any browser applications linked to it, you have two options: Click the Delete application button on the APM application/service's Settings page. Go to one.newrelic.com > APM > (select an app/service) > Settings > Application. Or, call the /applications/delete endpoint of the New Relic REST API. For example: curl -X DELETE 'https://api.newrelic.com/v2/applications/YOUR_APP_ID.json' \\ -H 'X-Api-Key:YOUR_API_KEY' -i Copy Browser If you've used the copy/paste method to install the browser agent, remove the JavaScript snippet from your application's pages. After 93 days, the application will be removed from New Relic. Tip If browser data continues to be reported, see our suggestions below. Once your browser application has stopped reporting, you have two ways to remove it: If your browser application is linked to an APM application, deleting the APM application also removes the browser application. See the instructions for deleting an APM application/service above for details. Or, click the Delete application button on the browser application's Application settings page. Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings . Mobile Remove all references/dependencies to the New Relic's mobile SDK/frameworks, then rebuild the application. For more information, see the iOS and Android install docs. After 93 days, the application will be removed from New Relic. Or, once your mobile application has stopped reporting, you can also remove it manually: Click the Delete application button on the mobile application's Settings page. Go to one.newrelic.com > Mobile > (select an app) > Settings > Application . Troubleshooting If you have problems removing an app, here are some possible causes and suggested solutions: You are not an admin on your full user account If you don't have proper permissions, you won't be able to remove an application. You have not waited long enough All app data must stop reporting to New Relic before you can remove that entity from New Relic. In most cases, this takes between 10-15 minutes. In rare cases, it can take a few minutes longer. Not all agents are disabled If you have multiple agents reporting data under the same UI name, then you must make sure you disable or uninstall all of the agents associated with that entity. You have problems removing your PHP app If you have a PHP app and aren't able to remove it from the UI, possible causes include: You have not disabled both components of the PHP agent. You must stop or uninstall both newrelic.so and newrelic-daemon in order to be able to remove a PHP app. For more information, see New Relic daemon processes. You have set up per-directory monitoring of your PHP app, and unexpected PHP data is reporting as the default PHP application in the New Relic UI. To fix this, change the default app name in the PHP agent config. You don't know where the app's data is coming from If you don't know where an app's data is coming from, it may be because the app's name has been changed. When an app name is changed in the UI, it does not change the underlying app name being reported; it only changes how the app name appears in the UI. To see if there is a difference between the reported name and the displayed name: From one.newrelic.com, select APM, then select an application. Scroll down to Settings and select Application. Compare the name in the Application alias field to the name in the Your application still reports as message directly beneath it. To get host information about an app you are not familiar with: From one.newrelic.com, select APM, then select an application. From the summary view, review the Servers list. Once you have identified where app data is coming from, you can remove the app from New Relic. Browser data is still reporting To remove an app from New Relic, all data must have stopped reporting, including browser monitoring data. To verify that you have disabled or uninstalled the APM agent associated with the app: Ensure that browser monitoring is disabled. If your browser monitoring script is inserted by the APM agent, turn it off from inside the UI, in the agent's config file, or in both. If you copied and pasted the monitoring JavaScript snippet in certain pages, remove that JavaScript snippet manually. Ensure all caches have been cleared that the application uses, such as host caches, CDNs, or anything else that caches built pages. Optional: To see a count of how many page views report from each domain, use this NRQL query: SELECT count(*) FROM PageView WHERE appName = 'YOUR_BROWSER_APP_NAME' FACET domain Copy If these steps don't resolve the issue, it is likely due to an end-user's browser cache that hasn't yet cleared. Wait until those caches clear. If your app has internal users, you may be able to identify the users and clear those caches. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 36.778694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APM</em> applications",
        "tags": "<em>APM</em>",
        "body": " reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an <em>APM</em>, browser, or mobile app from the New Relic UI, keep in mind: You can downgrade your account to pay less or make it entirely free"
      },
      "id": "603ebbef28ccbc48d1eba78d"
    },
    {
      "sections": [
        "Record and monitor deployments",
        "Options for tracking deployments",
        "Tip",
        "Record deployments with the REST API",
        "Record a deployment with POST",
        "Record a deployment with PowerShell",
        "View a list of deployments with GET",
        "Sample output from GET",
        "Delete a deployment with DELETE",
        "Character limits and JSON parameters",
        "Important",
        "Record deployments using the New Relic agent",
        "Notify your team of deployments",
        "End of life notification: Hipchat, Campfire"
      ],
      "title": "Record and monitor deployments",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "00b24338386fd261daea0733fe03c01639cce083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-monitor-deployments/",
      "published_at": "2021-07-02T08:38:45Z",
      "updated_at": "2021-04-22T09:32:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app's performance. Tracking deployments creates deployment markers that appear in APM charts. Options for tracking deployments You can use the New Relic REST API v2 to record new deployments, retrieve a list of past deployments, and delete past deployments on your APM application. In addition, some APM agents have agent-specific methods to record deployments automatically. You can use your Slack integration with New Relic, or a simple webhook, to notify your team in real time of deployments for applications monitored by APM. Slack provides a webhook URL that allows you to post generic JSON that will appear formatted in a chosen Slack channel. There are a few places where you can view deployments in the New Relic UI after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, New Relic One Service summary, and entity summary pages. On APM performance charts as a chart marker. On the Deployments page for summary performance. Tip Deployment markers are not available for Browser applications, but see Browser releases for a way to tag errors with release versions. Record deployments with the REST API You can use the New Relic REST API v2 to record deployments, get a list of past deployments, and delete deployments. The examples in this document use curl as a command line tool. However, you can use any method to make your REST requests. You can also create, view, and delete deployments with the API Explorer. JSON uses double quotes \" for element names and content. Using single quotes ' will cause errors. Record a deployment with POST To record a new deployment, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. For example: curl -X POST \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i \\ -H \"Content-Type: application/json\" \\ -d \\ '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy Record a deployment with PowerShell To record a deployment with PowerShell, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. This example uses PowerShell version 3 or higher: Invoke-WebRequest -Uri https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json -Method POST -Headers @{'Api-Key'='$API_KEY'} -ContentType 'application/json' -Body '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy This example uses PowerShell version 2 (requires .NET framework 3.5 or higher): $encoding = [System.Text.Encoding]::GetEncoding(\"ASCII\") $data ='{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' $postData = $encoding.GetBytes($data) $request = [System.Net.WebRequest]::Create('https://api.newrelic.com/v2/applications/$APP_ID/deployments.json') $request.Method = 'POST' $request.Headers.add('Api-Key','$API_KEY') $request.ContentType='application/json' $stream = $request.GetRequestStream() $stream.Write($postData,0,$postData.Length) $request.GetResponse() Copy View a list of deployments with GET To retrieve a list of all past deployments for your app, send a GET request that includes your API key to the deployments endpoint. GET requests do not use a JSON payload. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Sample output from GET This example requests a list of deployments for app ID 9999999: curl -X GET \"https://api.newrelic.com/v2/applications/9999999/deployments.json\" \\ -H \"Api-Key:ABCDEFGHIJKLMNOPQRSTUVWXabcdefghijklmnopqrstuvwx\" \\ -i Copy The API returns this list of deployments: HTTP/1.1 200 OK ETag: \"ABCDEFGHIJKabcdefghijk0123456789\" Cache-Control: max-age=0, private, must-revalidate Content-Type: application/json { \"deployments\": [ { \"id\": 1234567, \"revision\": \"1234123412341234123412341234123412341234\", \"changelog\": \"Fixed the bugs for real this time\", \"description\": \"Example description two\", \"user\": \"Data Nerd\", \"timestamp\": \"2016-02-24T10:09:27-08:00\", \"links\": { \"application\": 9999999 } }, { \"id\": 2345678, \"revision\": \"7890789078907890789078907890789078907890\", \"changelog\": \"Think I fixed all the bugs\", \"description\": null, \"user\": \"Dren Atad\", \"timestamp\": \"2014-10-22T12:23:47-07:00\", \"links\": { \"application\": 9999999 } } ], \"links\": { \"deployment.agent\": \"/v2/applications/{application_id}\" } } Copy Delete a deployment with DELETE To delete a deployment, send a DELETE request that includes your API key to the deployments endpoint. DELETE requests do not use a JSON payload, but you must specify the ID for the deployment you want to delete. To retrieve the ID for a deployment, use the GET request. For example: curl -X DELETE \"https://api.newrelic.com/v2/applications/$APP_ID/deployments/$DEPLOYMENT_ID.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Character limits and JSON parameters The JSON payload can include the following parameters. Important UTF-8 4 byte characters, such as Emojis and some non-Latin language glyphs, cannot be used in the deployment text. Parameter Data type Description revision String, 127 character maximum Required. A unique ID for this deployment, visible in the Summary page and on the Deployments page. Can be any string, but is usually a version number or a Git checksum. changelog String, 65535 character maximum Optional. A summary of what changed in this deployment, visible in the Deployments page when you select (selected deployment) > Change log. description String, 65535 character maximum Optional. A high-level description of this deployment, visible in the Summary page and on the Deployments page when you select an individual deployment. user String, 31 character maximum Optional. A username to associate with the deployment, visible in the Summary page and on the Deployments page. timestamp ISO 8601 Optional. When the deployment occurred, down to the second. If not specified, the deployment will be recorded at the time when the API call was received. Timestamp requirements: Must be in UTC time. Must be after the most recent deployment timestamp. Cannot be in the future. Must be in ISO8601 format; for example, \"2019-10-08T00:15:36Z\". Record deployments using the New Relic agent Some agents have additional methods to record deployments: All agents: Use the New Relic REST API v2. C: No SDK-specific methods. Use the REST API. Go: No agent-specific methods. Use the REST API. Java: Call the Java agent jar. .NET: Use PowerShell and the REST API. Node.js: No agent-specific methods. Use the REST API. PHP: Use a PHP script. Python: Use the record-deploy subcommand of the newrelic-admin script. Ruby: Use a Capistrano recipe. Notify your team of deployments After a deployment is recorded using the REST API, you can optionally notify a webhook endpoint of the deployment. The destination of the webhook can be your Slack instance. To use webhooks to set up a deployment notification for a Slack channel: Log in to your Slack account as an admin, then go to App directory > Manage > Apps. Search for your New Relic app, then select Add configuration. From Post to channel, select an existing Slack channel or add a new channel, then Add configuration. From the list of options, copy the webhook URL. Go to one.newrelic.com > (account dropdown) > Account settings > Integrations > Deploy notifications > Webhook. Paste the Slack webhook URL, then save. Optional: Send a test message. Tip You can also use webhooks, Slack channels, and other options for alert notifications with New Relic Alerts. End of life notification: Hipchat, Campfire As of September 9, 2019, integrations with Hipchat and Campfire for APM deployment notifications will no longer be available. Recommendation: If you are still using Hipchat or Campfire, use webhooks with Slack channels instead. For more information, see the New Relic Explorers Hub post.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 34.620907,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>APM</em>",
        "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app&#x27;s performance. Tracking deployments creates deployment markers that appear in <em>APM</em> charts. Options for tracking"
      },
      "id": "603eb1c364441fd58b4e888b"
    }
  ],
  "/docs/apm/new-relic-apm/apdex/apdex-measure-user-satisfaction": [
    {
      "sections": [
        "View your Apdex score",
        "Tip",
        "View Apdex score in APM",
        "View transactions with highest Apdex dissatisfaction",
        "View Apdex score in Browser",
        "Visualize Apdex data in query builder"
      ],
      "title": "View your Apdex score",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Apdex"
      ],
      "external_id": "b34782101a020897a16b6201cc9552afc298f2d9",
      "image": "https://docs.newrelic.com/static/812f8a389bc5e177470348dbe79dc536/01bf6/apdex_question_mark.png",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/view-your-apdex-score/",
      "published_at": "2021-07-02T08:43:04Z",
      "updated_at": "2021-03-30T09:22:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your Apdex score measures users' satisfaction with the response time of your web applications and services. The dissatisfaction score is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score based on your Apdex settings. To help identify and troubleshoot Apdex level changes that indicate poor customer experiences with your site, use any of these resources: New Relic's user interface (explained in this document) New Relic REST API Alert notifications Tip Apdex applies only to web apps or services. The Apdex chart in the UI appears blank for non-web transactions. To get a high-level overview of all your applications and services, use the New Relic Explorer. View Apdex score in APM Apdex dissatisfaction levels of Tolerating (apdex_t) and Frustrated (apdex_f) indicate how slow site performance contributes to poor customer experiences in your app. For example: 1.0: All responses are satisfactory. Tolerating responses half satisfy a user. For example, if all responses are Tolerating, then the Apdex score will be 0.50. 0.0: None of the responses are satisfactory. To view the Apdex score for your web apps or services: Go to one.newrelic.com > (select an app) > Summary. From the APM Summary page, review the Apdex score chart. If you want to... Do this... View your Apdex T value Mouse over the Apdex icon. View summary information for any point in time on the chart Mouse over the Apdex score chart. View detailed information about any point in time on the chart Click or drag anywhere on the Apdex score chart. View the corresponding Apdex score for browsers Select the Apdex chart's End user link. Go directly to detailed Apdex information Go to one.newrelic.com > (select an app) > Transactions > See transactions table, and then sort by Apdex. View transactions with highest Apdex dissatisfaction Transactions at the top of APM's Transactions page often are good candidates for performance tuning or fixing errors. To view transactions with the highest Apdex dissatisfaction percentage: Go to one.newrelic.com > APM > (select an app) > Transactions > See transactions table. Sort Apdex to find the most dissatisfying. Specific web transaction: To view details about a specific transaction, select its row. By definition, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in this column is 100%. To focus on Apdex levels for specific transactions, you can also: Configure transaction traces to capture apdex_f, which is four times your app server's apdex_t. Create key transactions to track changes in Apdex values for specific transactions that are important to your business, such as signups, purchase confirmations, searches, site logins, etc. View Apdex score in Browser Use Browser to: Set Apdex levels for browser monitoring. Review Apdex levels from the perspective of real-user browser performance of your app. Track browser performance levels for selected countries you want to monitor. Visualize Apdex data in query builder Use query builder to: Create dashboards to analyze and share your Apdex data. Analyze your Apdex data with NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.4258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View your <em>Apdex</em> score",
        "sections": "View <em>Apdex</em> score in <em>APM</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " transactions. To get a high-level overview of all your applications and services, use the <em>New</em> <em>Relic</em> Explorer. View <em>Apdex</em> score in <em>APM</em> <em>Apdex</em> dissatisfaction levels of Tolerating (<em>apdex</em>_t) and Frustrated (<em>apdex</em>_f) indicate how slow site performance contributes to poor customer experiences in your app"
      },
      "id": "603ebe19e7b9d22a5f2f91d0"
    },
    {
      "sections": [
        "Change your Apdex settings",
        "Tip",
        "App server Apdex settings",
        "End-user (Browser) Apdex settings",
        "Key transaction Apdex settings",
        "Apdex alerting"
      ],
      "title": "Change your Apdex settings",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Apdex"
      ],
      "external_id": "8dfaa2e3566cb82aff0fa6f9bd7943aae25d148d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/change-your-apdex-settings/",
      "published_at": "2021-07-02T12:46:58Z",
      "updated_at": "2021-03-30T09:22:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Apdex T is the central value for Apdex. Apdex T is the response time above which a transaction is considered \"tolerable.\" You can define Apdex T values for each application, with separate values for app server and end-user browser performance. You can also define individual Apdex T thresholds for key transactions. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. App server Apdex settings The default Apdex T threshold for an application server is 0.5 seconds. To change the default application server threshold for web transactions: Go to one.newrelic.com > (select an app) > Settings > Application > Application settings. From the Application server section, set the Apdex T value (in seconds) for this application. Select Save application settings. After you change Apdex settings, a black vertical bar appears in the main chart on the APM Summary page. End-user (Browser) Apdex settings The default Apdex T threshold for browser monitoring is 7.0 seconds. To change the default end user threshold for Apdex T: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. From the Settings page, set the end user Apdex T value (in seconds). Select Save application settings. Key transaction Apdex settings You can set custom Apdex values for your key transactions. These values are independent of the APM and Browser Apdex values for the key transaction's parent application. Key transactions will contribute to the overall Apdex score based on their own Apdex T values. The default values are inherited from the parent application. Apdex alerting You can also configure alert conditions for Apdex. When the Apdex score passes the threshold you define, New Relic sends an alert to the notification mechanism (channel). Tip For Apdex scores, set Warning (yellow) conditions higher than Critical (red) conditions for Apdex scores. This will help you monitor your customers' experience before the Apdex level falls below an unsatisfactory level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.4258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change your <em>Apdex</em> settings",
        "sections": "Change your <em>Apdex</em> settings",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " for key transactions. Tip To get a high-level overview of all your applications and services, use the <em>New</em> <em>Relic</em> Explorer. App server <em>Apdex</em> settings The default <em>Apdex</em> T threshold for an application server is 0.5 seconds. To change the default application server threshold for web transactions: Go"
      },
      "id": "60440808e7b9d21339579a00"
    },
    {
      "sections": [
        "Introduction to APM",
        "Tip",
        "Identify problems before your users do",
        "Monitor all aspects of your business",
        "Ready to get started?",
        "What's next?"
      ],
      "title": "Introduction to APM",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "317c07d4b32daa51186fd7d2cb857c392b595b5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-apm/",
      "published_at": "2021-07-02T08:37:17Z",
      "updated_at": "2021-03-30T09:24:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application performance monitoring (APM) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. Our APM agents give you real-time observability matched with trending data about your application's performance and the user experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Tip To use APM and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Identify problems before your users do Our APM agents report and store the state of your application so you can quickly identify potential problems before they affect your end users. With APM, your DevOps teams don't need to guess whether a performance blocker comes from the app itself, CPU availability, database loads, or something entirely unexpected. Use our APM solutions to gather both current and historical information about memory usage, CPU utilization, database query performance, web browser rendering performance, app availability, error analysis, external services, and other useful metrics. We have agents for Go, Java, .NET, Node.js, PHP, Python, and Ruby, as well as a C SDK. Monitor all aspects of your business Tip To get a high-level overview of all your applications and services, use our New Relic Explorer. Take advantage of these APM features, and more: Features Description App performance at a glance When you sign in to APM and select an app for your account, use the Summary page to quickly examine relationships across different aspects of your environment; for example: Web transactions response time: Where is the most time being spent? In the request queue, during different stages of page rendering and execution, from external services, or something else? Transaction traces: Which transactions are the slowest, and why? Error rate and throughput: What relationship is there between a spike in errors or slower throughput for a particular time period? Was there a deployment or outage at that time? Hosts: What kind of impact does this have on CPU usage, memory, etc.? Apdex: How are these events affecting customers' satisfaction with the site? Web and non-web transactions Start by comparing the top twenty web transactions or non-web transactions in terms of most time consuming, slowest average response time, highest throughput, or worst Apdex. From there, drill down into deeper trace levels for individual transactions, which in turn break down into smaller segments and components, from HTTPS requests on down to SQL queries. Want to explore even deeper? Set up distributed tracing to see how requests move across a distributed system. Select the transactions that are most important to your business (key transactions). APM and Infrastructure When your APM and Infrastructure accounts are linked, you will have access to APM data charts on these Infrastructure UI pages: Hosts, Network, Storage, and Processes. Distributed tracing Distributed tracing gives you visibility across distributed systems, showing you the path of a request as it travels between services. This feature is especially valuable for large, distributed systems that rely on many small services and microservices. Logs Bring your logs and APM agent data together to see logs associated with various objects in the New Relic UI such as applications, APM errors, APM traces, and Kubernetes containers. Service maps APM's service maps show your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. You can create and customize service maps to visualize and monitor your complex architectures. Query your data You can query and visualize your data: Sample and search APM transaction and error data to gain full understanding of the data being collected. Browse your data visually with the data explorer. Create custom SQL-like queries of your data using the New Relic Query Language (NRQL), or using our PromQL-style queries. Use dashboards to build advanced data visualizations, contextualize data, and understand what's going on in your system, real-time. These are just a few of APM's features. To find out more, see the table of contents for APM. Ready to get started? Start benefiting from APM in 5 simple steps (and just a few minutes!). Sign up for a New Relic account. Install and customize the language agent for your app. Generate some traffic for your app. Wait a few minutes for New Relic to start receiving your data. Log in to your account, and start exploring New Relic! If data does not appear after waiting a few minutes, follow the troubleshooting tips for your APM agent. What's next? Learn some more! For a library of videos and other resources about New Relic, visit newrelic.com/resources. New Relic One is our Full-Stack Observability platform which allows you to easily access, visualize, and troubleshoot your entire software stack in one unified experience. Use New Relic as the single source of truth for Infrastructure monitoring, Serverless monitoring, APM agents, Browser monitoring, and Logs. Our Telemetry Data Platform collects, explores, and alerts on all your metrics, events, logs, and traces from any source with our unified telemetry database. Check out our site for pricing details.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.02286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>APM</em>",
        "sections": "Introduction to <em>APM</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Tip To use <em>APM</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up"
      },
      "id": "60440835e7b9d29c2f5799e0"
    }
  ],
  "/docs/apm/new-relic-apm/apdex/change-your-apdex-settings": [
    {
      "sections": [
        "View your Apdex score",
        "Tip",
        "View Apdex score in APM",
        "View transactions with highest Apdex dissatisfaction",
        "View Apdex score in Browser",
        "Visualize Apdex data in query builder"
      ],
      "title": "View your Apdex score",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Apdex"
      ],
      "external_id": "b34782101a020897a16b6201cc9552afc298f2d9",
      "image": "https://docs.newrelic.com/static/812f8a389bc5e177470348dbe79dc536/01bf6/apdex_question_mark.png",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/view-your-apdex-score/",
      "published_at": "2021-07-02T08:43:04Z",
      "updated_at": "2021-03-30T09:22:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your Apdex score measures users' satisfaction with the response time of your web applications and services. The dissatisfaction score is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score based on your Apdex settings. To help identify and troubleshoot Apdex level changes that indicate poor customer experiences with your site, use any of these resources: New Relic's user interface (explained in this document) New Relic REST API Alert notifications Tip Apdex applies only to web apps or services. The Apdex chart in the UI appears blank for non-web transactions. To get a high-level overview of all your applications and services, use the New Relic Explorer. View Apdex score in APM Apdex dissatisfaction levels of Tolerating (apdex_t) and Frustrated (apdex_f) indicate how slow site performance contributes to poor customer experiences in your app. For example: 1.0: All responses are satisfactory. Tolerating responses half satisfy a user. For example, if all responses are Tolerating, then the Apdex score will be 0.50. 0.0: None of the responses are satisfactory. To view the Apdex score for your web apps or services: Go to one.newrelic.com > (select an app) > Summary. From the APM Summary page, review the Apdex score chart. If you want to... Do this... View your Apdex T value Mouse over the Apdex icon. View summary information for any point in time on the chart Mouse over the Apdex score chart. View detailed information about any point in time on the chart Click or drag anywhere on the Apdex score chart. View the corresponding Apdex score for browsers Select the Apdex chart's End user link. Go directly to detailed Apdex information Go to one.newrelic.com > (select an app) > Transactions > See transactions table, and then sort by Apdex. View transactions with highest Apdex dissatisfaction Transactions at the top of APM's Transactions page often are good candidates for performance tuning or fixing errors. To view transactions with the highest Apdex dissatisfaction percentage: Go to one.newrelic.com > APM > (select an app) > Transactions > See transactions table. Sort Apdex to find the most dissatisfying. Specific web transaction: To view details about a specific transaction, select its row. By definition, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in this column is 100%. To focus on Apdex levels for specific transactions, you can also: Configure transaction traces to capture apdex_f, which is four times your app server's apdex_t. Create key transactions to track changes in Apdex values for specific transactions that are important to your business, such as signups, purchase confirmations, searches, site logins, etc. View Apdex score in Browser Use Browser to: Set Apdex levels for browser monitoring. Review Apdex levels from the perspective of real-user browser performance of your app. Track browser performance levels for selected countries you want to monitor. Visualize Apdex data in query builder Use query builder to: Create dashboards to analyze and share your Apdex data. Analyze your Apdex data with NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.4258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View your <em>Apdex</em> score",
        "sections": "View <em>Apdex</em> score in <em>APM</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " transactions. To get a high-level overview of all your applications and services, use the <em>New</em> <em>Relic</em> Explorer. View <em>Apdex</em> score in <em>APM</em> <em>Apdex</em> dissatisfaction levels of Tolerating (<em>apdex</em>_t) and Frustrated (<em>apdex</em>_f) indicate how slow site performance contributes to poor customer experiences in your app"
      },
      "id": "603ebe19e7b9d22a5f2f91d0"
    },
    {
      "sections": [
        "Apdex: Measure user satisfaction",
        "Apdex measurements",
        "Important",
        "Apdex levels",
        "Apdex score",
        "Errors pages",
        "Dissatisfaction percentage"
      ],
      "title": "Apdex: Measure user satisfaction",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Apdex"
      ],
      "external_id": "3f7e1ebbbef09db3079aabff3374b10568f84268",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/apdex-measure-user-satisfaction/",
      "published_at": "2021-07-02T12:46:58Z",
      "updated_at": "2021-03-11T06:58:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Apdex is an industry standard to measure users' satisfaction with the response time of web applications and services. It's a simplified Service Level Agreement (SLA) solution that helps you see how satisfied users are with your app through metrics such as Apdex score and dissatisfaction percentage instead of easily skewed traditional metrics such as average response time. Apdex measurements Apdex is a measure of response time based against a set threshold. It measures the ratio of satisfactory response times to unsatisfactory response times. The response time is measured from an asset request to completed delivery back to the requestor. After you define a response time threshold T, all responses handled in T or less time satisfy the user. For example, if T is 1.2 seconds and a response completes in 0.5 seconds, then the user is satisfied. All responses greater than 1.2 seconds dissatisfy the user. Responses greater than 4.8 seconds frustrate the user. You can define multiple Apdex T values for each of these: Apdex measurements Comments APM apps APM monitors the performance of these apps. To define their Apdex settings, use the APM UI. You can find Apdex on the APM Summary page and the Browser Summary page. Browser apps Browser monitors the end-user experience for these apps. To define end-user Apdex settings for these apps, use the Browser UI. New Relic labels them as End user on the APM Overview page and the Browser Overview page. Key transactions These are transactions important to your business that you choose to monitor. You can define Apdex settings for key transactions on the Key transactions page. Important The key transaction Apdex setting overrides the T value of that app. For details, see Key transaction Apdex. Apdex levels Apdex tracks three response counts: Satisfied: The response time is less than or equal to T. Tolerating: The response time is greater than T and less than or equal to 4T. In this example, 4 x 1.2 = 4.8 seconds is the maximum tolerable response time. Frustrated: The response time is greater than 4T or the request returns a server-side error. A high error rate can cause you to have a satisfying average response time, yet a poor Apdex score. Your configuration file's apdex_f value is four times your app server's Apdex T value. This threshold is useful, for example, with transaction traces. For more information, see the configuration file documentation for your New Relic agent. The time calculation will change based on your own app's T setting. In the following example, T = 1.2 seconds. Level Multiplier Time (T Example = 1.2) Satisfied T or less < = 1.2 seconds Tolerated > T, < = 4T Between 1.2 and 4.8 seconds Frustrated > 4T Greater than 4.8 seconds After you define your Apdex levels, use any of New Relic's resources to help identify and troubleshoot changes that indicate poor customer experiences with your app. Apdex score The Apdex score is a ratio value of the number of satisfied and tolerating requests to the total requests made. Each satisfied request counts as one request, while each tolerating request counts as half a satisfied request. An Apdex score varies from 0 to 1, with 0 as the worst possible score (100% of response times were Frustrated), and 1 as the best possible score (100% of response times were Satisfied). Example Apdex score: During a 2 minute period a host handles 200 requests. The Apdex threshold T = 0.5 seconds (500ms). This value is arbitrary and is selected by the user. 170 of the requests were handled within 500ms, so they are classified as Satisfied. 20 of the requests were handled between 500ms and 2 seconds (2000 ms), so they are classified as Tolerating. The remaining 10 were not handled properly or took longer than 2 seconds, so they are classified as Frustrated. The resulting Apdex score is 0.9: (170 + (20/2))/200 = 0.9. Important The formula used for calculating the Apdex score is designed for high-throughput apps. If your app's throughput is less than 100 RPM, not enough data is collected to determine a stable score. The instability may result in Apdex alert conditions behaving unexpectedly. Errors pages Any request that returns a server-side error such as 500: Application Error is a frustrating response, regardless of its return speed. You can use Apdex to visualize the impact of these errors, and then identify and resolve these errors with New Relic's built-in error analytics and error profile tools. Dissatisfaction percentage The dissatisfaction percentage is the percentage of the total dissatisfaction experienced by the app's users that is contributed by this transaction. Example Apdex dissatisfaction calculation: Frustrations(Transaction) + Tolerations(Transaction)/2 Frustrations(App) + Tolerations(App)/2 To visualize dissatisfaction percentage, you can sort your transactions by most dissatisfying. If a transaction is always frustratingly slow but rarely visited, it will not contribute much to the app's total dissatisfaction. Conversely, if a transaction is normally fast, but has high throughput, this may contribute a large proportion of the app's dissatisfaction simply because it contributes a large proportion of your app's traffic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.34412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Apdex</em>: Measure user satisfaction",
        "sections": "<em>Apdex</em>: Measure user satisfaction",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " and the Browser Summary page. Browser apps Browser monitors the end-user experience for these apps. To define end-user <em>Apdex</em> settings for these apps, use the Browser UI. <em>New</em> <em>Relic</em> labels them as End user on the <em>APM</em> Overview page and the Browser Overview page. Key transactions These are transactions"
      },
      "id": "6044080828ccbc83192c60d8"
    },
    {
      "sections": [
        "Introduction to APM",
        "Tip",
        "Identify problems before your users do",
        "Monitor all aspects of your business",
        "Ready to get started?",
        "What's next?"
      ],
      "title": "Introduction to APM",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "317c07d4b32daa51186fd7d2cb857c392b595b5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-apm/",
      "published_at": "2021-07-02T08:37:17Z",
      "updated_at": "2021-03-30T09:24:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application performance monitoring (APM) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. Our APM agents give you real-time observability matched with trending data about your application's performance and the user experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Tip To use APM and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Identify problems before your users do Our APM agents report and store the state of your application so you can quickly identify potential problems before they affect your end users. With APM, your DevOps teams don't need to guess whether a performance blocker comes from the app itself, CPU availability, database loads, or something entirely unexpected. Use our APM solutions to gather both current and historical information about memory usage, CPU utilization, database query performance, web browser rendering performance, app availability, error analysis, external services, and other useful metrics. We have agents for Go, Java, .NET, Node.js, PHP, Python, and Ruby, as well as a C SDK. Monitor all aspects of your business Tip To get a high-level overview of all your applications and services, use our New Relic Explorer. Take advantage of these APM features, and more: Features Description App performance at a glance When you sign in to APM and select an app for your account, use the Summary page to quickly examine relationships across different aspects of your environment; for example: Web transactions response time: Where is the most time being spent? In the request queue, during different stages of page rendering and execution, from external services, or something else? Transaction traces: Which transactions are the slowest, and why? Error rate and throughput: What relationship is there between a spike in errors or slower throughput for a particular time period? Was there a deployment or outage at that time? Hosts: What kind of impact does this have on CPU usage, memory, etc.? Apdex: How are these events affecting customers' satisfaction with the site? Web and non-web transactions Start by comparing the top twenty web transactions or non-web transactions in terms of most time consuming, slowest average response time, highest throughput, or worst Apdex. From there, drill down into deeper trace levels for individual transactions, which in turn break down into smaller segments and components, from HTTPS requests on down to SQL queries. Want to explore even deeper? Set up distributed tracing to see how requests move across a distributed system. Select the transactions that are most important to your business (key transactions). APM and Infrastructure When your APM and Infrastructure accounts are linked, you will have access to APM data charts on these Infrastructure UI pages: Hosts, Network, Storage, and Processes. Distributed tracing Distributed tracing gives you visibility across distributed systems, showing you the path of a request as it travels between services. This feature is especially valuable for large, distributed systems that rely on many small services and microservices. Logs Bring your logs and APM agent data together to see logs associated with various objects in the New Relic UI such as applications, APM errors, APM traces, and Kubernetes containers. Service maps APM's service maps show your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. You can create and customize service maps to visualize and monitor your complex architectures. Query your data You can query and visualize your data: Sample and search APM transaction and error data to gain full understanding of the data being collected. Browse your data visually with the data explorer. Create custom SQL-like queries of your data using the New Relic Query Language (NRQL), or using our PromQL-style queries. Use dashboards to build advanced data visualizations, contextualize data, and understand what's going on in your system, real-time. These are just a few of APM's features. To find out more, see the table of contents for APM. Ready to get started? Start benefiting from APM in 5 simple steps (and just a few minutes!). Sign up for a New Relic account. Install and customize the language agent for your app. Generate some traffic for your app. Wait a few minutes for New Relic to start receiving your data. Log in to your account, and start exploring New Relic! If data does not appear after waiting a few minutes, follow the troubleshooting tips for your APM agent. What's next? Learn some more! For a library of videos and other resources about New Relic, visit newrelic.com/resources. New Relic One is our Full-Stack Observability platform which allows you to easily access, visualize, and troubleshoot your entire software stack in one unified experience. Use New Relic as the single source of truth for Infrastructure monitoring, Serverless monitoring, APM agents, Browser monitoring, and Logs. Our Telemetry Data Platform collects, explores, and alerts on all your metrics, events, logs, and traces from any source with our unified telemetry database. Check out our site for pricing details.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.02286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>APM</em>",
        "sections": "Introduction to <em>APM</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Tip To use <em>APM</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up"
      },
      "id": "60440835e7b9d29c2f5799e0"
    }
  ],
  "/docs/apm/new-relic-apm/apdex/view-your-apdex-score": [
    {
      "sections": [
        "Change your Apdex settings",
        "Tip",
        "App server Apdex settings",
        "End-user (Browser) Apdex settings",
        "Key transaction Apdex settings",
        "Apdex alerting"
      ],
      "title": "Change your Apdex settings",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Apdex"
      ],
      "external_id": "8dfaa2e3566cb82aff0fa6f9bd7943aae25d148d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/change-your-apdex-settings/",
      "published_at": "2021-07-02T12:46:58Z",
      "updated_at": "2021-03-30T09:22:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Apdex T is the central value for Apdex. Apdex T is the response time above which a transaction is considered \"tolerable.\" You can define Apdex T values for each application, with separate values for app server and end-user browser performance. You can also define individual Apdex T thresholds for key transactions. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. App server Apdex settings The default Apdex T threshold for an application server is 0.5 seconds. To change the default application server threshold for web transactions: Go to one.newrelic.com > (select an app) > Settings > Application > Application settings. From the Application server section, set the Apdex T value (in seconds) for this application. Select Save application settings. After you change Apdex settings, a black vertical bar appears in the main chart on the APM Summary page. End-user (Browser) Apdex settings The default Apdex T threshold for browser monitoring is 7.0 seconds. To change the default end user threshold for Apdex T: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. From the Settings page, set the end user Apdex T value (in seconds). Select Save application settings. Key transaction Apdex settings You can set custom Apdex values for your key transactions. These values are independent of the APM and Browser Apdex values for the key transaction's parent application. Key transactions will contribute to the overall Apdex score based on their own Apdex T values. The default values are inherited from the parent application. Apdex alerting You can also configure alert conditions for Apdex. When the Apdex score passes the threshold you define, New Relic sends an alert to the notification mechanism (channel). Tip For Apdex scores, set Warning (yellow) conditions higher than Critical (red) conditions for Apdex scores. This will help you monitor your customers' experience before the Apdex level falls below an unsatisfactory level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.4258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change your <em>Apdex</em> settings",
        "sections": "Change your <em>Apdex</em> settings",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " for key transactions. Tip To get a high-level overview of all your applications and services, use the <em>New</em> <em>Relic</em> Explorer. App server <em>Apdex</em> settings The default <em>Apdex</em> T threshold for an application server is 0.5 seconds. To change the default application server threshold for web transactions: Go"
      },
      "id": "60440808e7b9d21339579a00"
    },
    {
      "sections": [
        "Apdex: Measure user satisfaction",
        "Apdex measurements",
        "Important",
        "Apdex levels",
        "Apdex score",
        "Errors pages",
        "Dissatisfaction percentage"
      ],
      "title": "Apdex: Measure user satisfaction",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Apdex"
      ],
      "external_id": "3f7e1ebbbef09db3079aabff3374b10568f84268",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/apdex-measure-user-satisfaction/",
      "published_at": "2021-07-02T12:46:58Z",
      "updated_at": "2021-03-11T06:58:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Apdex is an industry standard to measure users' satisfaction with the response time of web applications and services. It's a simplified Service Level Agreement (SLA) solution that helps you see how satisfied users are with your app through metrics such as Apdex score and dissatisfaction percentage instead of easily skewed traditional metrics such as average response time. Apdex measurements Apdex is a measure of response time based against a set threshold. It measures the ratio of satisfactory response times to unsatisfactory response times. The response time is measured from an asset request to completed delivery back to the requestor. After you define a response time threshold T, all responses handled in T or less time satisfy the user. For example, if T is 1.2 seconds and a response completes in 0.5 seconds, then the user is satisfied. All responses greater than 1.2 seconds dissatisfy the user. Responses greater than 4.8 seconds frustrate the user. You can define multiple Apdex T values for each of these: Apdex measurements Comments APM apps APM monitors the performance of these apps. To define their Apdex settings, use the APM UI. You can find Apdex on the APM Summary page and the Browser Summary page. Browser apps Browser monitors the end-user experience for these apps. To define end-user Apdex settings for these apps, use the Browser UI. New Relic labels them as End user on the APM Overview page and the Browser Overview page. Key transactions These are transactions important to your business that you choose to monitor. You can define Apdex settings for key transactions on the Key transactions page. Important The key transaction Apdex setting overrides the T value of that app. For details, see Key transaction Apdex. Apdex levels Apdex tracks three response counts: Satisfied: The response time is less than or equal to T. Tolerating: The response time is greater than T and less than or equal to 4T. In this example, 4 x 1.2 = 4.8 seconds is the maximum tolerable response time. Frustrated: The response time is greater than 4T or the request returns a server-side error. A high error rate can cause you to have a satisfying average response time, yet a poor Apdex score. Your configuration file's apdex_f value is four times your app server's Apdex T value. This threshold is useful, for example, with transaction traces. For more information, see the configuration file documentation for your New Relic agent. The time calculation will change based on your own app's T setting. In the following example, T = 1.2 seconds. Level Multiplier Time (T Example = 1.2) Satisfied T or less < = 1.2 seconds Tolerated > T, < = 4T Between 1.2 and 4.8 seconds Frustrated > 4T Greater than 4.8 seconds After you define your Apdex levels, use any of New Relic's resources to help identify and troubleshoot changes that indicate poor customer experiences with your app. Apdex score The Apdex score is a ratio value of the number of satisfied and tolerating requests to the total requests made. Each satisfied request counts as one request, while each tolerating request counts as half a satisfied request. An Apdex score varies from 0 to 1, with 0 as the worst possible score (100% of response times were Frustrated), and 1 as the best possible score (100% of response times were Satisfied). Example Apdex score: During a 2 minute period a host handles 200 requests. The Apdex threshold T = 0.5 seconds (500ms). This value is arbitrary and is selected by the user. 170 of the requests were handled within 500ms, so they are classified as Satisfied. 20 of the requests were handled between 500ms and 2 seconds (2000 ms), so they are classified as Tolerating. The remaining 10 were not handled properly or took longer than 2 seconds, so they are classified as Frustrated. The resulting Apdex score is 0.9: (170 + (20/2))/200 = 0.9. Important The formula used for calculating the Apdex score is designed for high-throughput apps. If your app's throughput is less than 100 RPM, not enough data is collected to determine a stable score. The instability may result in Apdex alert conditions behaving unexpectedly. Errors pages Any request that returns a server-side error such as 500: Application Error is a frustrating response, regardless of its return speed. You can use Apdex to visualize the impact of these errors, and then identify and resolve these errors with New Relic's built-in error analytics and error profile tools. Dissatisfaction percentage The dissatisfaction percentage is the percentage of the total dissatisfaction experienced by the app's users that is contributed by this transaction. Example Apdex dissatisfaction calculation: Frustrations(Transaction) + Tolerations(Transaction)/2 Frustrations(App) + Tolerations(App)/2 To visualize dissatisfaction percentage, you can sort your transactions by most dissatisfying. If a transaction is always frustratingly slow but rarely visited, it will not contribute much to the app's total dissatisfaction. Conversely, if a transaction is normally fast, but has high throughput, this may contribute a large proportion of the app's dissatisfaction simply because it contributes a large proportion of your app's traffic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.34412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Apdex</em>: Measure user satisfaction",
        "sections": "<em>Apdex</em>: Measure user satisfaction",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " and the Browser Summary page. Browser apps Browser monitors the end-user experience for these apps. To define end-user <em>Apdex</em> settings for these apps, use the Browser UI. <em>New</em> <em>Relic</em> labels them as End user on the <em>APM</em> Overview page and the Browser Overview page. Key transactions These are transactions"
      },
      "id": "6044080828ccbc83192c60d8"
    },
    {
      "sections": [
        "Introduction to APM",
        "Tip",
        "Identify problems before your users do",
        "Monitor all aspects of your business",
        "Ready to get started?",
        "What's next?"
      ],
      "title": "Introduction to APM",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "317c07d4b32daa51186fd7d2cb857c392b595b5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-apm/",
      "published_at": "2021-07-02T08:37:17Z",
      "updated_at": "2021-03-30T09:24:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application performance monitoring (APM) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. Our APM agents give you real-time observability matched with trending data about your application's performance and the user experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Tip To use APM and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Identify problems before your users do Our APM agents report and store the state of your application so you can quickly identify potential problems before they affect your end users. With APM, your DevOps teams don't need to guess whether a performance blocker comes from the app itself, CPU availability, database loads, or something entirely unexpected. Use our APM solutions to gather both current and historical information about memory usage, CPU utilization, database query performance, web browser rendering performance, app availability, error analysis, external services, and other useful metrics. We have agents for Go, Java, .NET, Node.js, PHP, Python, and Ruby, as well as a C SDK. Monitor all aspects of your business Tip To get a high-level overview of all your applications and services, use our New Relic Explorer. Take advantage of these APM features, and more: Features Description App performance at a glance When you sign in to APM and select an app for your account, use the Summary page to quickly examine relationships across different aspects of your environment; for example: Web transactions response time: Where is the most time being spent? In the request queue, during different stages of page rendering and execution, from external services, or something else? Transaction traces: Which transactions are the slowest, and why? Error rate and throughput: What relationship is there between a spike in errors or slower throughput for a particular time period? Was there a deployment or outage at that time? Hosts: What kind of impact does this have on CPU usage, memory, etc.? Apdex: How are these events affecting customers' satisfaction with the site? Web and non-web transactions Start by comparing the top twenty web transactions or non-web transactions in terms of most time consuming, slowest average response time, highest throughput, or worst Apdex. From there, drill down into deeper trace levels for individual transactions, which in turn break down into smaller segments and components, from HTTPS requests on down to SQL queries. Want to explore even deeper? Set up distributed tracing to see how requests move across a distributed system. Select the transactions that are most important to your business (key transactions). APM and Infrastructure When your APM and Infrastructure accounts are linked, you will have access to APM data charts on these Infrastructure UI pages: Hosts, Network, Storage, and Processes. Distributed tracing Distributed tracing gives you visibility across distributed systems, showing you the path of a request as it travels between services. This feature is especially valuable for large, distributed systems that rely on many small services and microservices. Logs Bring your logs and APM agent data together to see logs associated with various objects in the New Relic UI such as applications, APM errors, APM traces, and Kubernetes containers. Service maps APM's service maps show your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. You can create and customize service maps to visualize and monitor your complex architectures. Query your data You can query and visualize your data: Sample and search APM transaction and error data to gain full understanding of the data being collected. Browse your data visually with the data explorer. Create custom SQL-like queries of your data using the New Relic Query Language (NRQL), or using our PromQL-style queries. Use dashboards to build advanced data visualizations, contextualize data, and understand what's going on in your system, real-time. These are just a few of APM's features. To find out more, see the table of contents for APM. Ready to get started? Start benefiting from APM in 5 simple steps (and just a few minutes!). Sign up for a New Relic account. Install and customize the language agent for your app. Generate some traffic for your app. Wait a few minutes for New Relic to start receiving your data. Log in to your account, and start exploring New Relic! If data does not appear after waiting a few minutes, follow the troubleshooting tips for your APM agent. What's next? Learn some more! For a library of videos and other resources about New Relic, visit newrelic.com/resources. New Relic One is our Full-Stack Observability platform which allows you to easily access, visualize, and troubleshoot your entire software stack in one unified experience. Use New Relic as the single source of truth for Infrastructure monitoring, Serverless monitoring, APM agents, Browser monitoring, and Logs. Our Telemetry Data Platform collects, explores, and alerts on all your metrics, events, logs, and traces from any source with our unified telemetry database. Check out our site for pricing details.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.02286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>APM</em>",
        "sections": "Introduction to <em>APM</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Tip To use <em>APM</em> and the rest of our observability platform, join the <em>New</em> <em>Relic</em> family! Sign up to create your free account in only a few seconds. Then ingest up"
      },
      "id": "60440835e7b9d29c2f5799e0"
    }
  ],
  "/docs/apm/new-relic-apm/getting-started/apm-agent-data-security": [
    {
      "sections": [
        "Introduction to APM",
        "Tip",
        "Identify problems before your users do",
        "Monitor all aspects of your business",
        "Ready to get started?",
        "What's next?"
      ],
      "title": "Introduction to APM",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "317c07d4b32daa51186fd7d2cb857c392b595b5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/introduction-apm/",
      "published_at": "2021-07-02T08:37:17Z",
      "updated_at": "2021-03-30T09:24:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Application performance monitoring (APM) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. Our APM agents give you real-time observability matched with trending data about your application's performance and the user experience. Agents reveal what is happening deep in your code with end to end transaction tracing and a variety of color-coded charts and reports. Tip To use APM and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Identify problems before your users do Our APM agents report and store the state of your application so you can quickly identify potential problems before they affect your end users. With APM, your DevOps teams don't need to guess whether a performance blocker comes from the app itself, CPU availability, database loads, or something entirely unexpected. Use our APM solutions to gather both current and historical information about memory usage, CPU utilization, database query performance, web browser rendering performance, app availability, error analysis, external services, and other useful metrics. We have agents for Go, Java, .NET, Node.js, PHP, Python, and Ruby, as well as a C SDK. Monitor all aspects of your business Tip To get a high-level overview of all your applications and services, use our New Relic Explorer. Take advantage of these APM features, and more: Features Description App performance at a glance When you sign in to APM and select an app for your account, use the Summary page to quickly examine relationships across different aspects of your environment; for example: Web transactions response time: Where is the most time being spent? In the request queue, during different stages of page rendering and execution, from external services, or something else? Transaction traces: Which transactions are the slowest, and why? Error rate and throughput: What relationship is there between a spike in errors or slower throughput for a particular time period? Was there a deployment or outage at that time? Hosts: What kind of impact does this have on CPU usage, memory, etc.? Apdex: How are these events affecting customers' satisfaction with the site? Web and non-web transactions Start by comparing the top twenty web transactions or non-web transactions in terms of most time consuming, slowest average response time, highest throughput, or worst Apdex. From there, drill down into deeper trace levels for individual transactions, which in turn break down into smaller segments and components, from HTTPS requests on down to SQL queries. Want to explore even deeper? Set up distributed tracing to see how requests move across a distributed system. Select the transactions that are most important to your business (key transactions). APM and Infrastructure When your APM and Infrastructure accounts are linked, you will have access to APM data charts on these Infrastructure UI pages: Hosts, Network, Storage, and Processes. Distributed tracing Distributed tracing gives you visibility across distributed systems, showing you the path of a request as it travels between services. This feature is especially valuable for large, distributed systems that rely on many small services and microservices. Logs Bring your logs and APM agent data together to see logs associated with various objects in the New Relic UI such as applications, APM errors, APM traces, and Kubernetes containers. Service maps APM's service maps show your app's connections and dependencies, including databases and external services. Health indicators and performance metrics show you the current operational status for every part of your architecture. You can create and customize service maps to visualize and monitor your complex architectures. Query your data You can query and visualize your data: Sample and search APM transaction and error data to gain full understanding of the data being collected. Browse your data visually with the data explorer. Create custom SQL-like queries of your data using the New Relic Query Language (NRQL), or using our PromQL-style queries. Use dashboards to build advanced data visualizations, contextualize data, and understand what's going on in your system, real-time. These are just a few of APM's features. To find out more, see the table of contents for APM. Ready to get started? Start benefiting from APM in 5 simple steps (and just a few minutes!). Sign up for a New Relic account. Install and customize the language agent for your app. Generate some traffic for your app. Wait a few minutes for New Relic to start receiving your data. Log in to your account, and start exploring New Relic! If data does not appear after waiting a few minutes, follow the troubleshooting tips for your APM agent. What's next? Learn some more! For a library of videos and other resources about New Relic, visit newrelic.com/resources. New Relic One is our Full-Stack Observability platform which allows you to easily access, visualize, and troubleshoot your entire software stack in one unified experience. Use New Relic as the single source of truth for Infrastructure monitoring, Serverless monitoring, APM agents, Browser monitoring, and Logs. Our Telemetry Data Platform collects, explores, and alerts on all your metrics, events, logs, and traces from any source with our unified telemetry database. Check out our site for pricing details.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.04305,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>APM</em>",
        "sections": "Ready to <em>get</em> <em>started</em>?",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "), or using our PromQL-style queries. Use dashboards to build advanced data visualizations, contextualize data, and understand what&#x27;s going on in your system, real-time. These are just a few of <em>APM</em>&#x27;s features. To find out more, see the table of contents for <em>APM</em>. Ready to <em>get</em> <em>started</em>? <em>Start</em> benefiting from <em>APM</em>"
      },
      "id": "60440835e7b9d29c2f5799e0"
    },
    {
      "sections": [
        "View app alert information in APM",
        "View policies and conditions from APM",
        "View events and activities from APM",
        "Tip",
        "View alert violations from APM"
      ],
      "title": "View app alert information in APM",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "47a0c5db9ebb97a1c945d44c16ab468c901f43e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/view-app-alert-information-apm/",
      "published_at": "2021-07-02T08:37:15Z",
      "updated_at": "2021-03-30T08:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Good alerts help notify individuals or teams about changes in their systems. Alerts provides a single, coordinated alerting tool across New Relic products. This allows you to manage alert policies and conditions that focus on the metrics for entities (such as apps or key transactions in APM) that you care about the most. After you set up one or more alert policies and define alert conditions for your New Relic product entities (targets), you can view that information in the Alerts UI. You can also view alert policy information in the UI for individual New Relic products. View policies and conditions from APM To view alert policy and condition information for a specific app or key transaction directly from APM: Do one of the following: App: Go to one.newrelic.com > (select an app) > Settings > Alert conditions. Key transaction: Go to one.newrelic.com > More > Key transactions > (select a key transaction) > Settings > Alert conditions. From the Alert conditions page, use the available tools to search, sort, view, or update the alert conditions and their associated policies. View events and activities from APM Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To view summary information about events and other activity directly from APM: Do one of the following: App: Go to one.newrelic.com. Key transaction: Go to one.newrelic.com > More > Key transactions. From the index, mouse over the entity's color-coded health status, select a link from the Application activity list, or select a specific browser app or key transaction to view additional details. For example, if a Critical alert violation occurs: The health status indicator turns red on the APM index and on the selected app. The background color for various charts changes to pink. The Application activity list on the APM index and on the selected app's Summary page shows Warning (yellow) and Critical (red) violations as applicable. To learn more about the violation in Alerts, mouse over or select any pink area on a chart. For more information and examples, see View events from their products. View alert violations from APM If an alert condition has thresholds set up for Warning (yellow) or Critical (red) violations, the color-coded health status for an entity will change to indicate a violation. You can view the violations directly from the page for the app or key transaction in APM: Do one of the following: App: Go to one.newrelic.com > (select an app) > Events > Violations. Key transaction: Go to one.newrelic.com > More > Key transactions > (select a key transaction) > Events > Violations. From the Violations index, use the available tools to search, sort, or view violations for the selected app or key transaction. Optional: To view or update the alert policies, conditions, or thresholds that triggered the violations, select the corresponding link. Tip You can also view Warning and Critical violations from the Alerts UI for specific incidents or for incidents and events across all products. Alerts sends alert notifications only for Critical (red) violations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.03737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View app alert information in <em>APM</em>",
        "sections": "View app alert information in <em>APM</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "Good alerts help notify individuals or teams about changes in their systems. Alerts provides a single, coordinated alerting tool across <em>New</em> <em>Relic</em> products. This allows you to manage alert policies and conditions that focus on the metrics for entities (such as apps or key transactions in <em>APM</em>"
      },
      "id": "6044083564441f1863378f10"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "1b20f81fa22784c5d22e4e51eb7c0bf26cbdb0b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-07-01T17:17:17Z",
      "updated_at": "2021-07-01T17:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.24478,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", infrastructure monitoring, or any of our wide array of integrations, by default you&#x27;ll receive data from your monitored applications, hosts, services, or other entities. Some options for <em>getting</em> <em>started</em>: Log into one.newrelic.com and click Add more data to <em>get</em> some guidance on setting up <em>New</em> <em>Relic</em> solutions"
      },
      "id": "603eae7b196a671ea3a83dc7"
    }
  ],
  "/docs/apm/new-relic-apm/getting-started/introduction-apm": [
    {
      "sections": [
        "APM agent data security",
        "Disclosure and audit",
        "Data collection",
        "Security settings",
        "Default security settings",
        "High security mode",
        "Custom security settings",
        "Data received by New Relic",
        "Important",
        "TLS and SSL",
        "Data transmission",
        "Proxies"
      ],
      "title": "APM agent data security",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "13a81c4a9a04e42bd4493768be3bfc42f769e1e5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/apm-agent-data-security/",
      "published_at": "2021-07-02T08:28:10Z",
      "updated_at": "2021-05-05T01:45:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The APM agent that you installed receives data from your applications. The default data retention is based on your pricing edition. New Relic's default security settings automatically work to ensure data privacy and to limit the kind of information New Relic receives. You can also change these settings. Disclosure and audit Our APM agent is a publicly accessible plugin for web applications. The agent does not do any dynamic code generation while communicating with your app, so using the agent will not introduce any code into your application without your knowledge. Most of our agents are open source, so you can see what our code does: C SDK Go .NET Node.js Python Ruby Data collection Using a JSON message format, data the agent receives from your app is posted once a minute to the New Relic user interface. The website returns a JSON response to the agent, indicating if the data was correctly received or if there was an error. New Relic collects the following aggregate metric data: Database activity External web service calls Controller and dispatch activity View activity Uncaught exceptions and counts Process memory and CPU usage This aggregate metric data summarizes calls to specific methods in your application: how many times each one was called and various response time statistics (average, minimum, maximum, and standard deviation). In New Relic, you will see the class and method names along with their aggregate numbers. New Relic optionally collects: Data collection Comments Uncaught errors New Relic captures the error as well as a runtime stack trace of the offending code. Transaction traces These are snapshots of a single transaction. As an option, the agent can also collect the query statements called within the transaction. The default collection uses obfuscation to hide any strings or numbers from the query. For transactions slower than a threshold you set, New Relic also collects data from SQL EXPLAIN. For database calls slower than a configured threshold, New Relic optionally collects runtime stack traces, which are helpful to pinpoint where in the code a database call is made. Custom parameters You can add custom parameters to your application code and record them with transaction traces to provide additional context while you are examining profiling information. Optional: For both errors and transaction traces, the HTTP request parameters can also be recorded. Security settings If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. Default security settings Depending on the agent, the default settings provide security for request parameters, HTTPS usage, and SQL: C SDK default security settings Go default security settings Java default security settings .NET default security settings Node.js default security settings PHP default security settings Python default security settings Ruby default security settings High security mode When the agent is in high security mode, default settings are locked so that users cannot change them. In addition, high security mode applies restrictions to custom events, custom instrumentation, user attributes, exception messages, or message queue parameters, depending on the agent: C SDK: n/a Go high security mode settings Java high security mode settings .NET high security mode settings Node.js high security mode settings PHP high security mode settings Python high security mode settings Ruby high security mode settings Custom security settings If you want custom security settings, you can customize the configuration file, change custom attribute settings, or use the API, depending on your agent: C SDK custom security settings Go custom security settings Java custom security settings .NET custom security mode settings Node.js custom security settings PHP custom security settings Python custom security settings Ruby custom security settings Data received by New Relic This information applies to all APM agents no matter what security settings you have applied. Important Other data that New Relic receives is specific to the security settings for each agent. Data Captured? APM agent language version OS type and version System properties Average response time of transactions in your app URL hits Client IP address Not captured TLS and SSL Our preferred protocol for all domains is TLS 1.2. APM agents enable SSL by default. To verify which release includes SSL by default and to ensure that you have the most up-to-date version, refer to your agent's release notes: C SDK Go Java .NET Node.js PHP Python Ruby The configuration file also includes an optional flag (ssl) to enable or disable SSL using HTTPS. New Relic does not do host authentication with HTTPS, just communication encryption. Exception: You cannot disable SSL for the C SDK. The C SDK daemon can only connect with SSL. New Relic requires HTTPS for all traffic to APM and the REST API. This includes both inbound and outbound traffic. If your REST API call uses HTTP, or if you have disabled SSL in your configuration file, change your script or program to HTTPS. Data transmission Under Java, .NET and PHP, New Relic uses JSON to serialize data. The Ruby agent uses either Ruby marshaling or JSON serialization to send data to New Relic, depending on whether a native JSON encoder is available in under the Ruby version the agent is running on. For required changes when you want to create firewall rules to allow the agent to communicate, see Networks. For more information about security measures for your data in transit to New Relic or at rest in our storage, see Data encryption. Proxies Optional settings are available so that you can configure the agent to communicate through a proxy. To define proxy settings for host, port, domain, user, or password, refer to your agent's configuration file documentation: Agent Proxy settings C SDK -proxy at daemon startup Go transport Java Use proxy settings, including: proxy_host proxy_password proxy_port proxy_user .NET proxy element Node.js proxy PHP newrelic.daemon.proxy or the daemon's proxy setting Python proxy settings Ruby Use proxy settings, including: proxy_host proxy_port proxy_user proxy_pass",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.4108,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>APM</em> agent data security",
        "sections": "Data received by <em>New</em> <em>Relic</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The <em>APM</em> agent that you installed receives data from your applications. The default data retention is based on your pricing edition. <em>New</em> <em>Relic</em>&#x27;s default security settings automatically work to ensure data privacy and to limit the kind of information <em>New</em> <em>Relic</em> receives. You can also change"
      },
      "id": "6043ffe7196a67cdd1960f67"
    },
    {
      "sections": [
        "View app alert information in APM",
        "View policies and conditions from APM",
        "View events and activities from APM",
        "Tip",
        "View alert violations from APM"
      ],
      "title": "View app alert information in APM",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Getting started"
      ],
      "external_id": "47a0c5db9ebb97a1c945d44c16ab468c901f43e9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/getting-started/view-app-alert-information-apm/",
      "published_at": "2021-07-02T08:37:15Z",
      "updated_at": "2021-03-30T08:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Good alerts help notify individuals or teams about changes in their systems. Alerts provides a single, coordinated alerting tool across New Relic products. This allows you to manage alert policies and conditions that focus on the metrics for entities (such as apps or key transactions in APM) that you care about the most. After you set up one or more alert policies and define alert conditions for your New Relic product entities (targets), you can view that information in the Alerts UI. You can also view alert policy information in the UI for individual New Relic products. View policies and conditions from APM To view alert policy and condition information for a specific app or key transaction directly from APM: Do one of the following: App: Go to one.newrelic.com > (select an app) > Settings > Alert conditions. Key transaction: Go to one.newrelic.com > More > Key transactions > (select a key transaction) > Settings > Alert conditions. From the Alert conditions page, use the available tools to search, sort, view, or update the alert conditions and their associated policies. View events and activities from APM Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. To view summary information about events and other activity directly from APM: Do one of the following: App: Go to one.newrelic.com. Key transaction: Go to one.newrelic.com > More > Key transactions. From the index, mouse over the entity's color-coded health status, select a link from the Application activity list, or select a specific browser app or key transaction to view additional details. For example, if a Critical alert violation occurs: The health status indicator turns red on the APM index and on the selected app. The background color for various charts changes to pink. The Application activity list on the APM index and on the selected app's Summary page shows Warning (yellow) and Critical (red) violations as applicable. To learn more about the violation in Alerts, mouse over or select any pink area on a chart. For more information and examples, see View events from their products. View alert violations from APM If an alert condition has thresholds set up for Warning (yellow) or Critical (red) violations, the color-coded health status for an entity will change to indicate a violation. You can view the violations directly from the page for the app or key transaction in APM: Do one of the following: App: Go to one.newrelic.com > (select an app) > Events > Violations. Key transaction: Go to one.newrelic.com > More > Key transactions > (select a key transaction) > Events > Violations. From the Violations index, use the available tools to search, sort, or view violations for the selected app or key transaction. Optional: To view or update the alert policies, conditions, or thresholds that triggered the violations, select the corresponding link. Tip You can also view Warning and Critical violations from the Alerts UI for specific incidents or for incidents and events across all products. Alerts sends alert notifications only for Critical (red) violations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.03737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View app alert information in <em>APM</em>",
        "sections": "View app alert information in <em>APM</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "Good alerts help notify individuals or teams about changes in their systems. Alerts provides a single, coordinated alerting tool across <em>New</em> <em>Relic</em> products. This allows you to manage alert policies and conditions that focus on the metrics for entities (such as apps or key transactions in <em>APM</em>"
      },
      "id": "6044083564441f1863378f10"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "1b20f81fa22784c5d22e4e51eb7c0bf26cbdb0b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-07-01T17:17:17Z",
      "updated_at": "2021-07-01T17:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.24474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "sections": "<em>Get</em> data into <em>New</em> <em>Relic</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", infrastructure monitoring, or any of our wide array of integrations, by default you&#x27;ll receive data from your monitored applications, hosts, services, or other entities. Some options for <em>getting</em> <em>started</em>: Log into one.newrelic.com and click Add more data to <em>get</em> some guidance on setting up <em>New</em> <em>Relic</em> solutions"
      },
      "id": "603eae7b196a671ea3a83dc7"
    }
  ]
}