{
  "/docs/apm/new-relic-apm/apdex/view-your-apdex-score": [
    {
      "sections": [
        "Change your Apdex settings",
        "Important",
        "App server Apdex settings",
        "End-user (Browser) Apdex settings",
        "Key transaction Apdex settings",
        "Apdex alerting",
        "Tip"
      ],
      "title": "Change your Apdex settings",
      "type": "docs",
      "tags": [
        "APM",
        "Apdex"
      ],
      "external_id": "8dfaa2e3566cb82aff0fa6f9bd7943aae25d148d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/change-your-apdex-settings/",
      "published_at": "2021-10-07T05:11:45Z",
      "updated_at": "2021-08-26T15:59:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Apdex T is the central value for Apdex. Apdex T is the response time above which a transaction is considered \"tolerable.\" You can define Apdex T values for each application, with separate values for app server and end-user browser performance. You can also define individual Apdex T thresholds for key transactions. Important You can only change Apdex thresholds for apps that are actively reporting data. For example, if one of your apps is not reporting, you won't see its Apdex setting options. App server Apdex settings The default Apdex T threshold for an application server is 0.5 seconds. To change the default application server threshold for web transactions: Go to one.newrelic.com > (select an app) > Settings > Application > Application settings. From the Application server section, set the Apdex T value (in seconds) for this application. Select Save application settings. After you change Apdex settings, a black vertical bar appears in the main chart on the APM Summary page. End-user (Browser) Apdex settings The default Apdex T threshold for browser monitoring is 7.0 seconds. To change the default end user threshold for Apdex T: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. From the Settings page, set the end user Apdex T value (in seconds). Select Save application settings. Key transaction Apdex settings You can set custom Apdex values for your key transactions. These values are independent of the APM and browser Apdex values for the key transaction's parent application. Key transactions will contribute to the overall Apdex score based on their own Apdex T values. The default values are inherited from the parent application. Apdex alerting You can also configure alert conditions for Apdex. When the Apdex score passes the threshold you define, New Relic sends an alert to the notification mechanism (channel). Tip For Apdex scores, set Warning (yellow) conditions higher than Critical (red) conditions for Apdex scores. This will help you monitor your customers' experience before the Apdex level falls below an unsatisfactory level.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.54244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change your <em>Apdex</em> settings",
        "sections": "Change your <em>Apdex</em> settings",
        "tags": "<em>APM</em>",
        "body": " change <em>Apdex</em> settings, a black vertical bar appears in the main chart on the <em>APM</em> Summary page. End-user (Browser) <em>Apdex</em> settings The default <em>Apdex</em> T threshold for browser monitoring is 7.0 seconds. To change the default end user threshold for <em>Apdex</em> T: Go to one.newrelic.com &gt; Browser &gt; (select an app"
      },
      "id": "60440808e7b9d21339579a00"
    },
    {
      "sections": [
        "Apdex: Measure user satisfaction",
        "Apdex measurements",
        "Important",
        "Apdex levels",
        "Apdex score",
        "Errors pages",
        "Dissatisfaction percentage"
      ],
      "title": "Apdex: Measure user satisfaction",
      "type": "docs",
      "tags": [
        "APM",
        "Apdex"
      ],
      "external_id": "3f7e1ebbbef09db3079aabff3374b10568f84268",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/apdex-measure-user-satisfaction/",
      "published_at": "2021-10-07T06:33:32Z",
      "updated_at": "2021-07-09T08:00:21Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Apdex is an industry standard to measure users' satisfaction with the response time of web applications and services. It's a simplified Service Level Agreement (SLA) solution that helps you see how satisfied users are with your app through metrics such as Apdex score and dissatisfaction percentage instead of easily skewed traditional metrics such as average response time. Apdex measurements Apdex is a measure of response time based against a set threshold. It measures the ratio of satisfactory response times to unsatisfactory response times. The response time is measured from an asset request to completed delivery back to the requestor. After you define a response time threshold T, all responses handled in T or less time satisfy the user. For example, if T is 1.2 seconds and a response completes in 0.5 seconds, then the user is satisfied. All responses greater than 1.2 seconds dissatisfy the user. Responses greater than 4.8 seconds frustrate the user. You can define multiple Apdex T values for each of these: Apdex measurements Comments APM apps APM monitors the performance of these apps. To define their Apdex settings, use the APM UI. You can find Apdex on the APM Summary page and the browser Summary page. Browser apps Browser monitors the end-user experience for these apps. To define end-user Apdex settings for these apps, use the browser UI. New Relic labels them as End user on the APM Overview page and the browser Overview page. Key transactions These are transactions important to your business that you choose to monitor. You can define Apdex settings for key transactions on the Key transactions page. Important The key transaction Apdex setting overrides the T value of that app. For details, see Key transaction Apdex. Apdex levels Apdex tracks three response counts: Satisfied: The response time is less than or equal to T. Tolerating: The response time is greater than T and less than or equal to 4T. In this example, 4 x 1.2 = 4.8 seconds is the maximum tolerable response time. Frustrated: The response time is greater than 4T or the request returns a server-side error. A high error rate can cause you to have a satisfying average response time, yet a poor Apdex score. Your configuration file's apdex_f value is four times your app server's Apdex T value. This threshold is useful, for example, with transaction traces. For more information, see the configuration file documentation for your New Relic agent. The time calculation will change based on your own app's T setting. In the following example, T = 1.2 seconds. Level Multiplier Time (T Example = 1.2) Satisfied T or less < = 1.2 seconds Tolerated > T, < = 4T Between 1.2 and 4.8 seconds Frustrated > 4T Greater than 4.8 seconds After you define your Apdex levels, use any of New Relic's resources to help identify and troubleshoot changes that indicate poor customer experiences with your app. Apdex score The Apdex score is a ratio value of the number of satisfied and tolerating requests to the total requests made. Each satisfied request counts as one request, while each tolerating request counts as half a satisfied request. An Apdex score varies from 0 to 1, with 0 as the worst possible score (100% of response times were Frustrated), and 1 as the best possible score (100% of response times were Satisfied). Example Apdex score: During a 2 minute period a host handles 200 requests. The Apdex threshold T = 0.5 seconds (500ms). This value is arbitrary and is selected by the user. 170 of the requests were handled within 500ms, so they are classified as Satisfied. 20 of the requests were handled between 500ms and 2 seconds (2000 ms), so they are classified as Tolerating. The remaining 10 were not handled properly or took longer than 2 seconds, so they are classified as Frustrated. The resulting Apdex score is 0.9: (170 + (20/2))/200 = 0.9. Important The formula used for calculating the Apdex score is designed for high-throughput apps. If your app's throughput is less than 100 RPM, not enough data is collected to determine a stable score. The instability may result in Apdex alert conditions behaving unexpectedly. Errors pages Any request that returns a server-side error such as 500: Application Error is a frustrating response, regardless of its return speed. You can use Apdex to visualize the impact of these errors, and then identify and resolve these errors with New Relic's built-in error analytics and error profile tools. Dissatisfaction percentage The dissatisfaction percentage is the percentage of the total dissatisfaction experienced by the app's users that is contributed by this transaction. Example Apdex dissatisfaction calculation: Frustrations(Transaction) + Tolerations(Transaction)/2 Frustrations(App) + Tolerations(App)/2 To visualize dissatisfaction percentage, you can sort your transactions by most dissatisfying. If a transaction is always frustratingly slow but rarely visited, it will not contribute much to the app's total dissatisfaction. Conversely, if a transaction is normally fast, but has high throughput, this may contribute a large proportion of the app's dissatisfaction simply because it contributes a large proportion of your app's traffic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.15386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Apdex</em>: Measure user satisfaction",
        "sections": "<em>Apdex</em>: Measure user satisfaction",
        "tags": "<em>APM</em>",
        "body": " dissatisfy the user. Responses greater than 4.8 seconds frustrate the user. You can define multiple <em>Apdex</em> T values for each of these: <em>Apdex</em> measurements Comments <em>APM</em> apps <em>APM</em> monitors the performance of these apps. To define their <em>Apdex</em> settings, use the <em>APM</em> UI. You can find <em>Apdex</em> on the <em>APM</em> Summary page"
      },
      "id": "6044080828ccbc83192c60d8"
    },
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "account switcher",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation delay",
        "aggregation function",
        "aggregation method",
        "aggregation_timer",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "child account",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "Full-Stack Observability",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "parent account",
        "permalink",
        "pinger",
        "Plugins",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "Telemetry Data Platform",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/44172b3e07c1f24191825360676b9d99/c1b63/account-dropdown.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-10-07T05:14:06Z",
      "updated_at": "2021-10-07T05:14:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown In the upper right of the New Relic UI, the account dropdown gives you access to your account settings. If you're trying to switch between accounts, use the account switcher. account switcher If you have access to more than one account in a multi-account organization, you can use the account switcher to switch between accounts. This is located in the top right of most New Relic UI pages. For more on factors that affect access to accounts, see Factors affecting access. To find account settings, use the account dropdown. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation delay The length of time in seconds to wait for the aggregation window to fill with data. Required when using CADENCE or EVENT_FLOW aggreation_method types. aggregation function You can use NRQL query functions, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation method New Relic aggregates data into windows, and needs to determine when the current window ends and the next one begins. The aggregation_method is the logic that tells us when we have all the data for a given aggregation window. Once the window is closed, the data is aggregated into a single point and evaluated against the threshold. This field is optional. One of the following three values can be specified: *EVENT_FLOW: (Default) Each aggregation window will wait until it starts to see timestamps arrive that are past its own delay setting. Once this occurs, the data is published. Relies on the timestamps of arriving data, so wall-clock time is no longer relevant. Works best for sources that come in frequently and with low event spread (high througput metrics) *CADENCE: Classic New Relic logic where each evaluation window waits exactly as long as the aggregation_delay setting, using the wall-clock time as a timer. aggregation_delay is required when using this option. Data arriving too late will be dropped, which can cause false alerts. *EVENT_TIMER: Each aggregation window has a timer on it, set to the aggregation_timer setting. The Timer starts running as soon as the first data point appears for that aggregation window (based on the data point’s timestamp). The aggregation_timer is reset for each new data point that arrives for that window. Once the aggregation_timer reaches 0, the aggregation window is published. Ideal for sparse and batched data, such as cloud integrations and infrequent error logs. aggregation_timer The length of time in seconds to wait after each data point received, to ensure the entire batch is processed. Required when using EVENT_TIMER aggregation_method type. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. child account See parent account. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, the browser monitoring agent, the mobile monitoring agents, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure monitoring By connecting changes in host performance to changes in your configuration, infrastructure monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, as well as the ability to query and chart your New Relic data. These features are now a fundamental part of the New Relic One platform and are no longer governed by the Insights product or name. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some places. For example: Some APM agents still have Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For New Relic organizations on our original pricing plan, Insights Pro is still the product name governing custom event data ingest and retention. There is an API key called the Insights insert key. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our mobile monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. You can see much of the data included in an interaction in the BrowserInteraction event. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account See parent account. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, mobile monitoring, and browser monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile monitoring Mobile monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. parent account New Relic organizations can have a parent/child account structure. This structure was much more important for organizations on our original user model, but is still used for some features for organizations on the New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as \"master accounts\", and child accounts were previously referred to as \"sub-accounts\". permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our Full Stack Observability pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.69033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>apdex</em>",
        "body": " information, see <em>Apdex</em>: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic&#x27;s APIs. <em>APM</em> New Relic&#x27;s <em>APM</em> (application performance monitoring) provides monitoring of your web or non-web"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    }
  ],
  "/docs/apm/new-relic-apm/getting-started/apm-agent-data-security": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Target framework version",
        "Important",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "ce9a62a0c6a2d98442118333f39152c38bf9fdda",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-10-07T08:42:12Z",
      "updated_at": "2021-10-07T08:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0. Table of minimum agent versions required per .NET Core version .NET Core Version Minimum Required .NET Agent Version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and NET 5.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5 runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as 64-bit (x64) on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, and 5.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.66869,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": ". To request instance-level information from datastores not currently listed, <em>get</em> support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods"
      },
      "id": "603e8e7e196a675c41a83d9f"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Framework",
        "Requirements",
        ".NET Framework version",
        "App/web servers",
        "CLRs",
        "Operating system",
        "Use of other monitoring software",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Code Access Security",
        "Network requirements",
        "Application lifespan",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "Messaging",
        "CMS",
        "External call libraries",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Framework",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "9fada40fe709392d7080cc1b5bc873039501d455",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework/",
      "published_at": "2021-10-07T04:52:19Z",
      "updated_at": "2021-10-07T04:52:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent supports both .NET Framework and .NET Core. Here we describe the compatibility and support for .NET Framework applications. For .NET Core, see Compatibility and requirements for .NET Core. The agent includes built-in instrumentation for some of the most popular parts of the .NET Framework ecosystem, including frameworks, databases, and message queuing systems. After you download and install the agent, it runs within the monitored process. The agent does not create a separate process or service. For frameworks and libraries that are not automatically instrumented, you can extend the agent with .NET custom instrumentation. Want to try out New Relic's .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install New Relic's .NET agent, make sure your system meets these requirements: .NET Framework version .NET Framework 4.5 or higher .NET Framework 4.5 or higher requires the New Relic .NET agent version 7.0 or higher. .NET Framework 4.0 or lower To instrument applications running on .NET Framework version 4.0 and lower, you must run a version of the New Relic .NET agent earlier than 7.0. For more information and download procedures, see Technical support for .NET frameworks 4.0 or earlier. Here are additional details about .NET Framework versions 4.0 and lower: .NET Framework version Notes .NET Framework 2.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.5 Fully supported by .NET agent versions below 7.0. .NET Framework 4.0 Fully supported by .NET agent versions below 7.0. If you use .NET Framework 1.1 for any app on your target system, you must disable instrumentation of that app with applicationPool set to instrument=\"false\". The .NET agent can cause crashes in .NET 1.1 apps. App/web servers You must use one of these app/web servers: IIS Self-hosted OWIN Self-hosted WCF Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 The agent automatically creates transactions for apps hosted in IIS. If you self-host with WCF and OWIN version 3 or higher, the agent also automatically creates transactions. For other self-hosted services, you will need to create transactions via custom instrumentation. CLRs The agent requires CLR version 4.0. Legacy applications running on CLR 2.0 can be instrumented with agent versions earlier than 7.0. Operating system The agent requires one of these operating systems: Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 Windows Server 2019 Windows 10 Windows Azure (OS Family 1, 2, and 3) Windows containers running on Windows 2016 (NanoServer based images are not supported) Use of other monitoring software The .NET Common Language Runtime (CLR) only allows one profiler to access the profiling API of a process at any given time. Running our .NET agent alongside other monitoring software will result in a profiler conflict. For more information, see Errors while using other APM software. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both a 32-bit and 64-bit version. On 64-bit systems, the 64-bit agent can instrument both 32-bit and 64-bit applications. Permissions Installation requires elevated privileges (Administrator). For example, you can: Be logged in as an administrator user. Be a member of the Administrators group. On newer operating systems, provide elevation credentials when prompted. The monitored process must have read/write access to the directory in which the agent is installed. The agent runs as a part of the monitored process and relies on those permissions to function. Recommendation: Restrict permissions for the newrelic.config file and give read/write access only to the owner of the monitored process. Review permissions for the logs created by the agent to minimize the number of users with access and their privileges. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Code Access Security The use of Code Access Security is compatible with the .NET agent only when Full Trust is provided. The agent is not compatible with more restrictive trust levels. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Application lifespan The .NET agent uploads data at the end of each harvest cycle (once per minute). If your .NET app doesn't run that long, you can set the service element's sendDataOnExit attribute to true in the newrelic.config file. Automatic instrumentation If your application is hosted in ASP.NET or another fully supported framework, the .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. The .NET agent does not directly monitor datastore processes. Also, by default the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collection of the SQL query parameters can be enabled in the agent configuration. App frameworks The agent automatically instruments some application frameworks; we refer to these frameworks as fully supported. Compatibility status .NET app frameworks Fully supported These frameworks are fully supported: ASP.NET MVC 2 ASP.NET MVC 3 ASP.NET MVC 4 ASP.NET MVC 5 ASP.NET Web API v2 ASP.NET Core MVC 2.0 ASP.NET Core 2.1 ASP.NET Core 2.2 ASP.NET Web Forms Castle MonoRail v2 (not the same as Mono) OWIN-hosted web API applications on .NET framework using: Microsoft.Owin.Host.HttpListener v2.x Microsoft.Owin.Host.HttpListener v3.x Microsoft.Owin.Host.HttpListener v4.x SOAP-based web services WCF Hosting Models IIS Hosted (with and without ASP Compatibility) Self Hosted Binding Types (both client and service) WCF Instrumentation has been tested for the following common binding types. Varying levels of support are available for distributed tracing (DT) and cross application tracing (CAT): Binding Distributed Tracing (DT) Support Cross Application Tracing (CAT) Support BasicHTTP supported supported WebHTTP supported supported WSHTTP supported supported NetTCP supported supported NetNamedPipe not supported * not supported * NetMSMQ not supported * not supported * * Distributed tracing may be manually implemented using these Distributed Tracing API methods. Invocation Methods (both client and service) Synchronous Asynchronous Processing Model (APM) Begin/End Task Asynchronous Processing (TAP) Event-based Asynchronous Processing (EAP) Client support only. Not fully supported These frameworks are not fully supported: ASP.NET Web API v1: See the troubleshooting information about using ASP.NET Web API v1 with New Relic's .NET agent 5.0 or higher for apps targeting .NET Framework 4.0. (This does not affect .NET Framework 4.5 or higher.) Mono: New Relic does not support Mono, an open-source .NET framework that runs on Linux. This is because there is no Profiler API to inject into the .NET agent as a profiler into Mono-based .NET applications. The Profiler API is a Component Object Model (COM)-based interface and is not supported on Linux. Not supported Classic ASP is not supported, because the agent can only instrument .NET Framework-based apps. Sharepoint is not supported. Datastores Collecting instance details for supported datastores requires .NET agent version 6.5.29.0 or higher and is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. In order to automatically instrument the performance of .NET Framework application calls to these datastores, make sure you have the .NET agent version 8.14 or higher: Datastore Instance details Other notes Couchbase SDK version 2.x.x (2.4.0 or higher is not supported). With Couchbase, the following are not instrumented by default in favor of their multi-document counterparts: Get(string key) GetDocument(string key) Remove(string key) Remove(string key, ulong cas) Upsert<T>(string key, T value) IBM DB2 Microsoft SQL Server MongoDB We support both the modern and legacy MongoDB drivers. Legacy - mongocsharpdriver Driver versions 1.10.0 or earlier: Instance details are not available in these driver versions. Modern - MongoDB.Driver Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector Oracle PostgreSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. ServiceStack.Redis StackExchange.Redis Messaging The agent automatically instruments these message systems: MSMQ: Puts and takes on messages NServiceBus 5.0 (6.0 or higher not supported): Puts and takes on messages and cross application tracing RabbitMQ 3.5 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver CMS The agent automatically instruments the EPiServer content management system. External call libraries The agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestSharp The agent instruments these RestSharp methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync Execute ExecuteAsGet ExecuteAsPost DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: GetResponse Connect the agent to other New Relic products In addition to APM, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET applications, the .NET agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the .NET agent. Automatic browser injection is not supported for ASP.NET core applications. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.45258,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: <em>Get</em>Response Connect the agent to other New Relic products In addition to <em>APM</em>, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET"
      },
      "id": "603ea02e196a671b92a83ddc"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-07T06:57:20Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.26155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in <em>APM</em> depends on your New Relic agent"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/apm/new-relic-apm/getting-started/introduction-apm": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Target framework version",
        "Important",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "ce9a62a0c6a2d98442118333f39152c38bf9fdda",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-10-07T08:42:12Z",
      "updated_at": "2021-10-07T08:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0. Table of minimum agent versions required per .NET Core version .NET Core Version Minimum Required .NET Agent Version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and NET 5.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5 runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as 64-bit (x64) on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, and 5.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.66864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": ". To request instance-level information from datastores not currently listed, <em>get</em> support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods"
      },
      "id": "603e8e7e196a675c41a83d9f"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Framework",
        "Requirements",
        ".NET Framework version",
        "App/web servers",
        "CLRs",
        "Operating system",
        "Use of other monitoring software",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Code Access Security",
        "Network requirements",
        "Application lifespan",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "Messaging",
        "CMS",
        "External call libraries",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Framework",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "9fada40fe709392d7080cc1b5bc873039501d455",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework/",
      "published_at": "2021-10-07T04:52:19Z",
      "updated_at": "2021-10-07T04:52:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent supports both .NET Framework and .NET Core. Here we describe the compatibility and support for .NET Framework applications. For .NET Core, see Compatibility and requirements for .NET Core. The agent includes built-in instrumentation for some of the most popular parts of the .NET Framework ecosystem, including frameworks, databases, and message queuing systems. After you download and install the agent, it runs within the monitored process. The agent does not create a separate process or service. For frameworks and libraries that are not automatically instrumented, you can extend the agent with .NET custom instrumentation. Want to try out New Relic's .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install New Relic's .NET agent, make sure your system meets these requirements: .NET Framework version .NET Framework 4.5 or higher .NET Framework 4.5 or higher requires the New Relic .NET agent version 7.0 or higher. .NET Framework 4.0 or lower To instrument applications running on .NET Framework version 4.0 and lower, you must run a version of the New Relic .NET agent earlier than 7.0. For more information and download procedures, see Technical support for .NET frameworks 4.0 or earlier. Here are additional details about .NET Framework versions 4.0 and lower: .NET Framework version Notes .NET Framework 2.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.5 Fully supported by .NET agent versions below 7.0. .NET Framework 4.0 Fully supported by .NET agent versions below 7.0. If you use .NET Framework 1.1 for any app on your target system, you must disable instrumentation of that app with applicationPool set to instrument=\"false\". The .NET agent can cause crashes in .NET 1.1 apps. App/web servers You must use one of these app/web servers: IIS Self-hosted OWIN Self-hosted WCF Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 The agent automatically creates transactions for apps hosted in IIS. If you self-host with WCF and OWIN version 3 or higher, the agent also automatically creates transactions. For other self-hosted services, you will need to create transactions via custom instrumentation. CLRs The agent requires CLR version 4.0. Legacy applications running on CLR 2.0 can be instrumented with agent versions earlier than 7.0. Operating system The agent requires one of these operating systems: Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 Windows Server 2019 Windows 10 Windows Azure (OS Family 1, 2, and 3) Windows containers running on Windows 2016 (NanoServer based images are not supported) Use of other monitoring software The .NET Common Language Runtime (CLR) only allows one profiler to access the profiling API of a process at any given time. Running our .NET agent alongside other monitoring software will result in a profiler conflict. For more information, see Errors while using other APM software. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both a 32-bit and 64-bit version. On 64-bit systems, the 64-bit agent can instrument both 32-bit and 64-bit applications. Permissions Installation requires elevated privileges (Administrator). For example, you can: Be logged in as an administrator user. Be a member of the Administrators group. On newer operating systems, provide elevation credentials when prompted. The monitored process must have read/write access to the directory in which the agent is installed. The agent runs as a part of the monitored process and relies on those permissions to function. Recommendation: Restrict permissions for the newrelic.config file and give read/write access only to the owner of the monitored process. Review permissions for the logs created by the agent to minimize the number of users with access and their privileges. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Code Access Security The use of Code Access Security is compatible with the .NET agent only when Full Trust is provided. The agent is not compatible with more restrictive trust levels. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Application lifespan The .NET agent uploads data at the end of each harvest cycle (once per minute). If your .NET app doesn't run that long, you can set the service element's sendDataOnExit attribute to true in the newrelic.config file. Automatic instrumentation If your application is hosted in ASP.NET or another fully supported framework, the .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. The .NET agent does not directly monitor datastore processes. Also, by default the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collection of the SQL query parameters can be enabled in the agent configuration. App frameworks The agent automatically instruments some application frameworks; we refer to these frameworks as fully supported. Compatibility status .NET app frameworks Fully supported These frameworks are fully supported: ASP.NET MVC 2 ASP.NET MVC 3 ASP.NET MVC 4 ASP.NET MVC 5 ASP.NET Web API v2 ASP.NET Core MVC 2.0 ASP.NET Core 2.1 ASP.NET Core 2.2 ASP.NET Web Forms Castle MonoRail v2 (not the same as Mono) OWIN-hosted web API applications on .NET framework using: Microsoft.Owin.Host.HttpListener v2.x Microsoft.Owin.Host.HttpListener v3.x Microsoft.Owin.Host.HttpListener v4.x SOAP-based web services WCF Hosting Models IIS Hosted (with and without ASP Compatibility) Self Hosted Binding Types (both client and service) WCF Instrumentation has been tested for the following common binding types. Varying levels of support are available for distributed tracing (DT) and cross application tracing (CAT): Binding Distributed Tracing (DT) Support Cross Application Tracing (CAT) Support BasicHTTP supported supported WebHTTP supported supported WSHTTP supported supported NetTCP supported supported NetNamedPipe not supported * not supported * NetMSMQ not supported * not supported * * Distributed tracing may be manually implemented using these Distributed Tracing API methods. Invocation Methods (both client and service) Synchronous Asynchronous Processing Model (APM) Begin/End Task Asynchronous Processing (TAP) Event-based Asynchronous Processing (EAP) Client support only. Not fully supported These frameworks are not fully supported: ASP.NET Web API v1: See the troubleshooting information about using ASP.NET Web API v1 with New Relic's .NET agent 5.0 or higher for apps targeting .NET Framework 4.0. (This does not affect .NET Framework 4.5 or higher.) Mono: New Relic does not support Mono, an open-source .NET framework that runs on Linux. This is because there is no Profiler API to inject into the .NET agent as a profiler into Mono-based .NET applications. The Profiler API is a Component Object Model (COM)-based interface and is not supported on Linux. Not supported Classic ASP is not supported, because the agent can only instrument .NET Framework-based apps. Sharepoint is not supported. Datastores Collecting instance details for supported datastores requires .NET agent version 6.5.29.0 or higher and is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. In order to automatically instrument the performance of .NET Framework application calls to these datastores, make sure you have the .NET agent version 8.14 or higher: Datastore Instance details Other notes Couchbase SDK version 2.x.x (2.4.0 or higher is not supported). With Couchbase, the following are not instrumented by default in favor of their multi-document counterparts: Get(string key) GetDocument(string key) Remove(string key) Remove(string key, ulong cas) Upsert<T>(string key, T value) IBM DB2 Microsoft SQL Server MongoDB We support both the modern and legacy MongoDB drivers. Legacy - mongocsharpdriver Driver versions 1.10.0 or earlier: Instance details are not available in these driver versions. Modern - MongoDB.Driver Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector Oracle PostgreSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. ServiceStack.Redis StackExchange.Redis Messaging The agent automatically instruments these message systems: MSMQ: Puts and takes on messages NServiceBus 5.0 (6.0 or higher not supported): Puts and takes on messages and cross application tracing RabbitMQ 3.5 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver CMS The agent automatically instruments the EPiServer content management system. External call libraries The agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestSharp The agent instruments these RestSharp methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync Execute ExecuteAsGet ExecuteAsPost DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: GetResponse Connect the agent to other New Relic products In addition to APM, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET applications, the .NET agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the .NET agent. Automatic browser injection is not supported for ASP.NET core applications. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.45253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: <em>Get</em>Response Connect the agent to other New Relic products In addition to <em>APM</em>, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET"
      },
      "id": "603ea02e196a671b92a83ddc"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-07T06:57:20Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.261505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in <em>APM</em> depends on your New Relic agent"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/apm/new-relic-apm/getting-started/view-app-alert-information-apm": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Target framework version",
        "Important",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "ce9a62a0c6a2d98442118333f39152c38bf9fdda",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-10-07T08:42:12Z",
      "updated_at": "2021-10-07T08:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0. Table of minimum agent versions required per .NET Core version .NET Core Version Minimum Required .NET Agent Version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and NET 5.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5 runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as 64-bit (x64) on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, and 5.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.66864,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": ". To request instance-level information from datastores not currently listed, <em>get</em> support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods"
      },
      "id": "603e8e7e196a675c41a83d9f"
    },
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Framework",
        "Requirements",
        ".NET Framework version",
        "App/web servers",
        "CLRs",
        "Operating system",
        "Use of other monitoring software",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Code Access Security",
        "Network requirements",
        "Application lifespan",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "Messaging",
        "CMS",
        "External call libraries",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Framework",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "9fada40fe709392d7080cc1b5bc873039501d455",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework/",
      "published_at": "2021-10-07T04:52:19Z",
      "updated_at": "2021-10-07T04:52:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent supports both .NET Framework and .NET Core. Here we describe the compatibility and support for .NET Framework applications. For .NET Core, see Compatibility and requirements for .NET Core. The agent includes built-in instrumentation for some of the most popular parts of the .NET Framework ecosystem, including frameworks, databases, and message queuing systems. After you download and install the agent, it runs within the monitored process. The agent does not create a separate process or service. For frameworks and libraries that are not automatically instrumented, you can extend the agent with .NET custom instrumentation. Want to try out New Relic's .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install New Relic's .NET agent, make sure your system meets these requirements: .NET Framework version .NET Framework 4.5 or higher .NET Framework 4.5 or higher requires the New Relic .NET agent version 7.0 or higher. .NET Framework 4.0 or lower To instrument applications running on .NET Framework version 4.0 and lower, you must run a version of the New Relic .NET agent earlier than 7.0. For more information and download procedures, see Technical support for .NET frameworks 4.0 or earlier. Here are additional details about .NET Framework versions 4.0 and lower: .NET Framework version Notes .NET Framework 2.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.0 Unless you have installed only .NET Framework 4.0 or higher, you must have .NET Framework version 3.5 installed on the target host, in addition to any other .NET Framework versions you have installed. .NET Framework 3.5 Fully supported by .NET agent versions below 7.0. .NET Framework 4.0 Fully supported by .NET agent versions below 7.0. If you use .NET Framework 1.1 for any app on your target system, you must disable instrumentation of that app with applicationPool set to instrument=\"false\". The .NET agent can cause crashes in .NET 1.1 apps. App/web servers You must use one of these app/web servers: IIS Self-hosted OWIN Self-hosted WCF Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 The agent automatically creates transactions for apps hosted in IIS. If you self-host with WCF and OWIN version 3 or higher, the agent also automatically creates transactions. For other self-hosted services, you will need to create transactions via custom instrumentation. CLRs The agent requires CLR version 4.0. Legacy applications running on CLR 2.0 can be instrumented with agent versions earlier than 7.0. Operating system The agent requires one of these operating systems: Windows Server 2008 Windows Server 2008 R2 Windows Server 2012 Windows Server 2012 R2 Windows Server 2016 Windows Server 2019 Windows 10 Windows Azure (OS Family 1, 2, and 3) Windows containers running on Windows 2016 (NanoServer based images are not supported) Use of other monitoring software The .NET Common Language Runtime (CLR) only allows one profiler to access the profiling API of a process at any given time. Running our .NET agent alongside other monitoring software will result in a profiler conflict. For more information, see Errors while using other APM software. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both a 32-bit and 64-bit version. On 64-bit systems, the 64-bit agent can instrument both 32-bit and 64-bit applications. Permissions Installation requires elevated privileges (Administrator). For example, you can: Be logged in as an administrator user. Be a member of the Administrators group. On newer operating systems, provide elevation credentials when prompted. The monitored process must have read/write access to the directory in which the agent is installed. The agent runs as a part of the monitored process and relies on those permissions to function. Recommendation: Restrict permissions for the newrelic.config file and give read/write access only to the owner of the monitored process. Review permissions for the logs created by the agent to minimize the number of users with access and their privileges. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Code Access Security The use of Code Access Security is compatible with the .NET agent only when Full Trust is provided. The agent is not compatible with more restrictive trust levels. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Application lifespan The .NET agent uploads data at the end of each harvest cycle (once per minute). If your .NET app doesn't run that long, you can set the service element's sendDataOnExit attribute to true in the newrelic.config file. Automatic instrumentation If your application is hosted in ASP.NET or another fully supported framework, the .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. The .NET agent does not directly monitor datastore processes. Also, by default the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collection of the SQL query parameters can be enabled in the agent configuration. App frameworks The agent automatically instruments some application frameworks; we refer to these frameworks as fully supported. Compatibility status .NET app frameworks Fully supported These frameworks are fully supported: ASP.NET MVC 2 ASP.NET MVC 3 ASP.NET MVC 4 ASP.NET MVC 5 ASP.NET Web API v2 ASP.NET Core MVC 2.0 ASP.NET Core 2.1 ASP.NET Core 2.2 ASP.NET Web Forms Castle MonoRail v2 (not the same as Mono) OWIN-hosted web API applications on .NET framework using: Microsoft.Owin.Host.HttpListener v2.x Microsoft.Owin.Host.HttpListener v3.x Microsoft.Owin.Host.HttpListener v4.x SOAP-based web services WCF Hosting Models IIS Hosted (with and without ASP Compatibility) Self Hosted Binding Types (both client and service) WCF Instrumentation has been tested for the following common binding types. Varying levels of support are available for distributed tracing (DT) and cross application tracing (CAT): Binding Distributed Tracing (DT) Support Cross Application Tracing (CAT) Support BasicHTTP supported supported WebHTTP supported supported WSHTTP supported supported NetTCP supported supported NetNamedPipe not supported * not supported * NetMSMQ not supported * not supported * * Distributed tracing may be manually implemented using these Distributed Tracing API methods. Invocation Methods (both client and service) Synchronous Asynchronous Processing Model (APM) Begin/End Task Asynchronous Processing (TAP) Event-based Asynchronous Processing (EAP) Client support only. Not fully supported These frameworks are not fully supported: ASP.NET Web API v1: See the troubleshooting information about using ASP.NET Web API v1 with New Relic's .NET agent 5.0 or higher for apps targeting .NET Framework 4.0. (This does not affect .NET Framework 4.5 or higher.) Mono: New Relic does not support Mono, an open-source .NET framework that runs on Linux. This is because there is no Profiler API to inject into the .NET agent as a profiler into Mono-based .NET applications. The Profiler API is a Component Object Model (COM)-based interface and is not supported on Linux. Not supported Classic ASP is not supported, because the agent can only instrument .NET Framework-based apps. Sharepoint is not supported. Datastores Collecting instance details for supported datastores requires .NET agent version 6.5.29.0 or higher and is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. In order to automatically instrument the performance of .NET Framework application calls to these datastores, make sure you have the .NET agent version 8.14 or higher: Datastore Instance details Other notes Couchbase SDK version 2.x.x (2.4.0 or higher is not supported). With Couchbase, the following are not instrumented by default in favor of their multi-document counterparts: Get(string key) GetDocument(string key) Remove(string key) Remove(string key, ulong cas) Upsert<T>(string key, T value) IBM DB2 Microsoft SQL Server MongoDB We support both the modern and legacy MongoDB drivers. Legacy - mongocsharpdriver Driver versions 1.10.0 or earlier: Instance details are not available in these driver versions. Modern - MongoDB.Driver Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector Oracle PostgreSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. ServiceStack.Redis StackExchange.Redis Messaging The agent automatically instruments these message systems: MSMQ: Puts and takes on messages NServiceBus 5.0 (6.0 or higher not supported): Puts and takes on messages and cross application tracing RabbitMQ 3.5 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver CMS The agent automatically instruments the EPiServer content management system. External call libraries The agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestSharp The agent instruments these RestSharp methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync Execute ExecuteAsGet ExecuteAsPost DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: GetResponse Connect the agent to other New Relic products In addition to APM, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET applications, the .NET agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the .NET agent. Automatic browser injection is not supported for ASP.NET core applications. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.45253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " DownloadData HttpWebRequest The agent instruments these HttpWebRequest methods: <em>Get</em>Response Connect the agent to other New Relic products In addition to <em>APM</em>, the agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring For ASP.NET"
      },
      "id": "603ea02e196a671b92a83ddc"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-10-07T06:57:20Z",
      "updated_at": "2021-10-07T06:57:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Java 16 Agent v7.3.0 to current Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 15.4 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest GraphQL 16.0 - 16.2 S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.261505,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in <em>APM</em> depends on your New Relic agent"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/apm/new-relic-apm/maintenance/disable-apm-agent": [
    {
      "sections": [
        "Remove applications from New Relic",
        "Before attempting to remove an app",
        "Remove an application from New Relic",
        "APM applications",
        "Browser",
        "Mobile",
        "Troubleshooting",
        "You lack permissions",
        "You have not waited long enough",
        "Not all agents are disabled",
        "You have problems removing your PHP app",
        "You don't know where the app's data is coming from",
        "Browser data is still reporting",
        "For more help"
      ],
      "title": "Remove applications from New Relic",
      "type": "docs",
      "tags": [
        "APM",
        "Maintenance"
      ],
      "external_id": "f457af939892708a477895093f97b65d08ff015a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic/",
      "published_at": "2021-10-07T09:49:30Z",
      "updated_at": "2021-09-20T19:22:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applications are automatically removed from New Relic after 93 days without sending data to our platform. You can also remove an application using the UI, once it has stopped sending data. Key metrics will continue to be available via the New Relic REST API, with the application name remaining reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an app monitored by New Relic APM, browser monitoring, or mobile monitoring from the UI, keep in mind: You can downgrade your account to pay less or make it entirely free. The ability to remove an app from the UI may be dependent on permissions. If an agent is still sending data from an app, you cannot remove that app. Remove an application from New Relic Before you can remove an application monitored by New Relic APM, browser monitoring, or mobile monitoring, the app must first stop reporting data. Do this by disabling the agent (explained below) or by uninstalling the agent completely. APM applications Disable an APM agent using these instructions: C SDK: Do a quick recompile and deploy. For example, surround your instrumentation in #ifdef, and set the value of YOURNAMESPACE_NEWRELIC_ENABLED with your build system. Go: Set Enabled to false. Java: Set agent_enabled to false. .NET: Set Newrelic.AgentEnabled to false. Node.js: Set agent_enabled to false. PHP: Remove or disable both the newrelic.so and newrelic-daemon components. Set newrelic.enabled to false. Python: Set monitor_mode to false. Ruby: Set agent_enabled to false. Restart the application server and wait up to ten minutes. Verify the color-coded health status for the app has turned to gray and is no longer reporting data. To remove the APM application from the UI (and any associated apps in browser monitoring), you have a few options: Delete the app from the UI. Go to one.newrelic.com > APM > (select an app/service) > Settings > Application, and click the Delete application button. Use NerdGraph to delete an entity. If you've done the above and are still seeing that app in the UI, you can use NerdGraph to delete the relevant entities. For how to find entity IDs, see Entities. Browser If you've used the copy/paste method to install the browser agent, remove the JavaScript snippet from your application's pages. After 93 days, that app will be removed from the UI. If you want to remove it sooner than that, you have several options: Delete an associated APM app. If your browser app is linked to an APM application, deleting the APM application also removes the browser application. See the instructions for deleting an APM app. Delete it from the UI. Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings, and click the Delete application button. Use NerdGraph to delete an entity. If you've done the above and are still seeing that app in the UI, you can use NerdGraph to delete the relevant entities. For how to find entity IDs, see Entities. Mobile Remove all references/dependencies to New Relic's mobile monitoring SDK/frameworks, then rebuild the application. For more information, see the iOS and Android install docs. After 93 days, the app will be removed from the UI. If you want to remove it sooner than that, you have several options: Remove it using the UI. Go to one.newrelic.com > Mobile > (select an app) > Settings > Application, and click Delete application. Use NerdGraph to delete an entity. If you've done the above and are still seeing that app in the UI, you can use NerdGraph to delete the relevant entities. For how to find entity IDs, see Entities. Troubleshooting If you have problems removing an app, here are some possible causes and suggested solutions: You lack permissions If you don't have relevant permissions, you won't be able to remove an application. You have not waited long enough All app data must stop reporting to New Relic before you can remove that entity from New Relic. In most cases, this takes between 10-15 minutes. In rare cases, it can take a few minutes longer. Not all agents are disabled If you have multiple agents reporting data under the same UI name, then you must make sure you disable or uninstall all of the agents associated with that entity. You have problems removing your PHP app If you have a PHP app and aren't able to remove it from the UI, possible causes include: You have not disabled both components of the PHP agent. You must stop or uninstall both newrelic.so and newrelic-daemon in order to be able to remove a PHP app. For more information, see New Relic daemon processes. You have set up per-directory monitoring of your PHP app, and unexpected PHP data is reporting as the default PHP application in the New Relic UI. To fix this, change the default app name in the PHP agent config. You don't know where the app's data is coming from If you don't know where an app's data is coming from, it may be because the app's name has been changed. When an app name is changed in the UI, it does not change the underlying app name being reported; it only changes how the app name appears in the UI. To see if there is a difference between the reported name and the displayed name: From one.newrelic.com, select APM, then select an application. Scroll down to Settings and select Application. Compare the name in the Application alias field to the name in the Your application still reports as message directly beneath it. To get host information about an app you are not familiar with: From one.newrelic.com, select APM, then select an application. From the summary view, review the Servers list. Once you have identified where app data is coming from, you can remove the app from New Relic. Browser data is still reporting To remove an app from New Relic, all data must have stopped reporting, including browser monitoring data. To verify that you have disabled or uninstalled the APM agent associated with the app: Ensure that browser monitoring is disabled. If your browser monitoring script is inserted by the APM agent, turn it off from inside the UI, in the agent's config file, or in both. If you copied and pasted the monitoring JavaScript snippet in certain pages, remove that JavaScript snippet manually. Ensure all caches have been cleared that the application uses, such as host caches, CDNs, or anything else that caches built pages. Optional: To see a count of how many page views report from each domain, use this NRQL query: SELECT count(*) FROM PageView WHERE appName = 'YOUR_BROWSER_APP_NAME' FACET domain Copy If these steps don't resolve the issue, it is likely due to an end-user's browser cache that hasn't yet cleared. Wait until those caches clear. If your app has internal users, you may be able to identify the users and clear those caches. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.48601,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APM</em> applications",
        "tags": "<em>Maintenance</em>",
        "body": " reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an app monitored by New Relic <em>APM</em>, browser monitoring, or mobile monitoring from the UI, keep in mind: You can downgrade your account"
      },
      "id": "603ebbef28ccbc48d1eba78d"
    },
    {
      "sections": [
        "Record and monitor deployments",
        "Options for tracking deployments",
        "Tip",
        "Record deployments with the REST API",
        "Record a deployment with POST",
        "Record a deployment with PowerShell",
        "View a list of deployments with GET",
        "Sample output from GET",
        "Delete a deployment with DELETE",
        "Character limits and JSON parameters",
        "Important",
        "Record deployments using the New Relic agent",
        "Notify your team of deployments",
        "End of life notification: Hipchat, Campfire"
      ],
      "title": "Record and monitor deployments",
      "type": "docs",
      "tags": [
        "APM",
        "Maintenance"
      ],
      "external_id": "00b24338386fd261daea0733fe03c01639cce083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-monitor-deployments/",
      "published_at": "2021-10-07T06:34:29Z",
      "updated_at": "2021-07-09T10:02:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app's performance. Tracking deployments creates deployment markers that appear in APM charts. Options for tracking deployments You can use the New Relic REST API v2 to record new deployments, retrieve a list of past deployments, and delete past deployments on your APM application. In addition, some APM agents have agent-specific methods to record deployments automatically. You can use your Slack integration with New Relic, or a simple webhook, to notify your team in real time of deployments for applications monitored by APM. Slack provides a webhook URL that allows you to post generic JSON that will appear formatted in a chosen Slack channel. There are a few places where you can view deployments in the New Relic UI after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, New Relic One Service summary, and entity summary pages. On APM performance charts as a chart marker. On the Deployments page for summary performance. Tip Deployment markers are not available for browser applications, but see browser releases for a way to tag errors with release versions. Record deployments with the REST API You can use the New Relic REST API v2 to record deployments, get a list of past deployments, and delete deployments. The examples in this document use curl as a command line tool. However, you can use any method to make your REST requests. You can also create, view, and delete deployments with the API Explorer. JSON uses double quotes \" for element names and content. Using single quotes ' will cause errors. Record a deployment with POST To record a new deployment, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. For example: curl -X POST \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i \\ -H \"Content-Type: application/json\" \\ -d \\ '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy Record a deployment with PowerShell To record a deployment with PowerShell, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. This example uses PowerShell version 3 or higher: Invoke-WebRequest -Uri https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json -Method POST -Headers @{'Api-Key'='$API_KEY'} -ContentType 'application/json' -Body '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy This example uses PowerShell version 2 (requires .NET framework 3.5 or higher): $encoding = [System.Text.Encoding]::GetEncoding(\"ASCII\") $data ='{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' $postData = $encoding.GetBytes($data) $request = [System.Net.WebRequest]::Create('https://api.newrelic.com/v2/applications/$APP_ID/deployments.json') $request.Method = 'POST' $request.Headers.add('Api-Key','$API_KEY') $request.ContentType='application/json' $stream = $request.GetRequestStream() $stream.Write($postData,0,$postData.Length) $request.GetResponse() Copy View a list of deployments with GET To retrieve a list of all past deployments for your app, send a GET request that includes your API key to the deployments endpoint. GET requests do not use a JSON payload. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Sample output from GET This example requests a list of deployments for app ID 9999999: curl -X GET \"https://api.newrelic.com/v2/applications/9999999/deployments.json\" \\ -H \"Api-Key:ABCDEFGHIJKLMNOPQRSTUVWXabcdefghijklmnopqrstuvwx\" \\ -i Copy The API returns this list of deployments: HTTP/1.1 200 OK ETag: \"ABCDEFGHIJKabcdefghijk0123456789\" Cache-Control: max-age=0, private, must-revalidate Content-Type: application/json { \"deployments\": [ { \"id\": 1234567, \"revision\": \"1234123412341234123412341234123412341234\", \"changelog\": \"Fixed the bugs for real this time\", \"description\": \"Example description two\", \"user\": \"Data Nerd\", \"timestamp\": \"2016-02-24T10:09:27-08:00\", \"links\": { \"application\": 9999999 } }, { \"id\": 2345678, \"revision\": \"7890789078907890789078907890789078907890\", \"changelog\": \"Think I fixed all the bugs\", \"description\": null, \"user\": \"Dren Atad\", \"timestamp\": \"2014-10-22T12:23:47-07:00\", \"links\": { \"application\": 9999999 } } ], \"links\": { \"deployment.agent\": \"/v2/applications/{application_id}\" } } Copy Delete a deployment with DELETE To delete a deployment, send a DELETE request that includes your API key to the deployments endpoint. DELETE requests do not use a JSON payload, but you must specify the ID for the deployment you want to delete. To retrieve the ID for a deployment, use the GET request. For example: curl -X DELETE \"https://api.newrelic.com/v2/applications/$APP_ID/deployments/$DEPLOYMENT_ID.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Character limits and JSON parameters The JSON payload can include the following parameters. Important UTF-8 4 byte characters, such as Emojis and some non-Latin language glyphs, cannot be used in the deployment text. Parameter Data type Description revision String, 127 character maximum Required. A unique ID for this deployment, visible in the Summary page and on the Deployments page. Can be any string, but is usually a version number or a Git checksum. changelog String, 65535 character maximum Optional. A summary of what changed in this deployment, visible in the Deployments page when you select (selected deployment) > Change log. description String, 65535 character maximum Optional. A high-level description of this deployment, visible in the Summary page and on the Deployments page when you select an individual deployment. user String, 31 character maximum Optional. A username to associate with the deployment, visible in the Summary page and on the Deployments page. timestamp ISO 8601 Optional. When the deployment occurred, down to the second. If not specified, the deployment will be recorded at the time when the API call was received. Timestamp requirements: Must be in UTC time. Must be after the most recent deployment timestamp. Cannot be in the future. Must be in ISO8601 format; for example, \"2019-10-08T00:15:36Z\". Record deployments using the New Relic agent Some agents have additional methods to record deployments: All agents: Use the New Relic REST API v2. C: No SDK-specific methods. Use the REST API. Go: No agent-specific methods. Use the REST API. Java: Call the Java agent jar. .NET: Use PowerShell and the REST API. Node.js: No agent-specific methods. Use the REST API. PHP: Use a PHP script. Python: Use the record-deploy subcommand of the newrelic-admin script. Ruby: Use a Capistrano recipe. Notify your team of deployments After a deployment is recorded using the REST API, you can optionally notify a webhook endpoint of the deployment. The destination of the webhook can be your Slack instance. To use webhooks to set up a deployment notification for a Slack channel: Log in to your Slack account as an admin, then go to App directory > Manage > Apps. Search for your New Relic app, then select Add configuration. From Post to channel, select an existing Slack channel or add a new channel, then Add configuration. From the list of options, copy the webhook URL. Go to one.newrelic.com > (account dropdown) > Account settings > Integrations > Deploy notifications > Webhook. Paste the Slack webhook URL, then save. Optional: Send a test message. Tip You can also use webhooks, Slack channels, and other options for alert notifications with New Relic Alerts. End of life notification: Hipchat, Campfire As of September 9, 2019, integrations with Hipchat and Campfire for APM deployment notifications will no longer be available. Recommendation: If you are still using Hipchat or Campfire, use webhooks with Slack channels instead. For more information, see the New Relic Explorers Hub post.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.42777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Maintenance</em>",
        "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app&#x27;s performance. Tracking deployments creates deployment markers that appear in <em>APM</em> charts. Options for tracking"
      },
      "id": "603eb1c364441fd58b4e888b"
    },
    {
      "sections": [
        "Regulatory audits for New Relic services",
        "Customer FedRAMP obligations",
        "Time frames",
        "Services in Scope by compliance program",
        "Customer risk management"
      ],
      "title": "Regulatory audits for New Relic services",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "30dc1bcd07cce70ead8896f1c2f2a95b5da85120",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/regulatory-audits-new-relic-services/",
      "published_at": "2021-10-07T05:35:57Z",
      "updated_at": "2021-10-07T05:35:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This list is current. Last updated 9 Sept 2021. This document describes New Relic's products and services as they relate to regulatory framework compliance status. For more information, download the New Relic FedRAMP Customer Responsibility Matrix (CRM) Worksheet as a PDF|87K. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features. Time frames New Relic's time frames for supported regulatory frameworks and annual audits include: SOC2 Type 2 audit: Reviews New Relic's implementation and maintenance of controls for the previous 12 months. The annual audit spans August 1 of the previous year through July 31 of the current year (for example, August 1, 2019 through July 31, 2020). FedRAMP Agency (Moderate): Reviews New Relic's implementation and maintenance of NIST 800-53 rev. 4 controls for the previous 12 months. The annual audit spans November 28 of the previous year through November 28 of the current year (for example, November 28, 2019 through November 28, 2020). Services in Scope by compliance program The following table describes New Relic's Services in Scope of New Relic's assurance programs. A check indicates that this service in scope of the most recent assessment and current reports. A caution icon indicates the service is on the roadmap for regulatory framework compliance at a time frame to be determined. New Relic service SOC2 FedRAMP Moderate HIPAA-enabled capabilities Alerts APM AWS Metric Streams Browser monitoring Errors inbox Incident Intelligence (Applied Intelligence) Infrastructure agent (and associated on-host integrations) Cloud integrations (AWS, Azure, and GCP) Insights Logs (with exception of log patterns) Log patterns Metric API Mobile agents Network Performance Monitoring Pixie: Community Cloud for Pixie Community Cloud for Pixie has completed a SOC 2 Type 1 audit. Pixie: Auto-telemetry with Pixie Plugins Proactive Detection (Applied Intelligence) Programmability: New Relic One apps Serverless Synthetic monitoring Trace API Customer risk management All New Relic services are intended to be covered by our compliance programs. However, a new service may not be covered by one or more of our compliance programs at any given time throughout the year. This is primarily dependent on the timing when the service achieved General Availability (GA) status and the timing of the specific compliance program's annual authorization, certification, or assessment. You can use any New Relic service regardless of its compliance program status. However, if a service is not yet in scope of our compliance programs, we encourage you to consider your risk appetite in the decision to use the specific New Relic product or service. If you choose to use New Relic services that are not yet in our compliance program scope, you assume the responsibility to review, understand, and risk-manage your security controls as you deem appropriate. You also have the option to wait for New Relic to authorize these services before you use them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.54442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Type 2 audit: Reviews New Relic&#x27;s implementation and <em>maintenance</em> of controls for the previous 12 months. The annual audit spans August 1 of the previous year through July 31 of the current year (for example, August 1, 2019 through July 31, 2020). FedRAMP Agency (Moderate): Reviews New Relic"
      },
      "id": "603e81e728ccbc68bfeba794"
    }
  ],
  "/docs/apm/new-relic-apm/maintenance/record-monitor-deployments": [
    {
      "sections": [
        "Remove applications from New Relic",
        "Before attempting to remove an app",
        "Remove an application from New Relic",
        "APM applications",
        "Browser",
        "Mobile",
        "Troubleshooting",
        "You lack permissions",
        "You have not waited long enough",
        "Not all agents are disabled",
        "You have problems removing your PHP app",
        "You don't know where the app's data is coming from",
        "Browser data is still reporting",
        "For more help"
      ],
      "title": "Remove applications from New Relic",
      "type": "docs",
      "tags": [
        "APM",
        "Maintenance"
      ],
      "external_id": "f457af939892708a477895093f97b65d08ff015a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic/",
      "published_at": "2021-10-07T09:49:30Z",
      "updated_at": "2021-09-20T19:22:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applications are automatically removed from New Relic after 93 days without sending data to our platform. You can also remove an application using the UI, once it has stopped sending data. Key metrics will continue to be available via the New Relic REST API, with the application name remaining reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an app monitored by New Relic APM, browser monitoring, or mobile monitoring from the UI, keep in mind: You can downgrade your account to pay less or make it entirely free. The ability to remove an app from the UI may be dependent on permissions. If an agent is still sending data from an app, you cannot remove that app. Remove an application from New Relic Before you can remove an application monitored by New Relic APM, browser monitoring, or mobile monitoring, the app must first stop reporting data. Do this by disabling the agent (explained below) or by uninstalling the agent completely. APM applications Disable an APM agent using these instructions: C SDK: Do a quick recompile and deploy. For example, surround your instrumentation in #ifdef, and set the value of YOURNAMESPACE_NEWRELIC_ENABLED with your build system. Go: Set Enabled to false. Java: Set agent_enabled to false. .NET: Set Newrelic.AgentEnabled to false. Node.js: Set agent_enabled to false. PHP: Remove or disable both the newrelic.so and newrelic-daemon components. Set newrelic.enabled to false. Python: Set monitor_mode to false. Ruby: Set agent_enabled to false. Restart the application server and wait up to ten minutes. Verify the color-coded health status for the app has turned to gray and is no longer reporting data. To remove the APM application from the UI (and any associated apps in browser monitoring), you have a few options: Delete the app from the UI. Go to one.newrelic.com > APM > (select an app/service) > Settings > Application, and click the Delete application button. Use NerdGraph to delete an entity. If you've done the above and are still seeing that app in the UI, you can use NerdGraph to delete the relevant entities. For how to find entity IDs, see Entities. Browser If you've used the copy/paste method to install the browser agent, remove the JavaScript snippet from your application's pages. After 93 days, that app will be removed from the UI. If you want to remove it sooner than that, you have several options: Delete an associated APM app. If your browser app is linked to an APM application, deleting the APM application also removes the browser application. See the instructions for deleting an APM app. Delete it from the UI. Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings, and click the Delete application button. Use NerdGraph to delete an entity. If you've done the above and are still seeing that app in the UI, you can use NerdGraph to delete the relevant entities. For how to find entity IDs, see Entities. Mobile Remove all references/dependencies to New Relic's mobile monitoring SDK/frameworks, then rebuild the application. For more information, see the iOS and Android install docs. After 93 days, the app will be removed from the UI. If you want to remove it sooner than that, you have several options: Remove it using the UI. Go to one.newrelic.com > Mobile > (select an app) > Settings > Application, and click Delete application. Use NerdGraph to delete an entity. If you've done the above and are still seeing that app in the UI, you can use NerdGraph to delete the relevant entities. For how to find entity IDs, see Entities. Troubleshooting If you have problems removing an app, here are some possible causes and suggested solutions: You lack permissions If you don't have relevant permissions, you won't be able to remove an application. You have not waited long enough All app data must stop reporting to New Relic before you can remove that entity from New Relic. In most cases, this takes between 10-15 minutes. In rare cases, it can take a few minutes longer. Not all agents are disabled If you have multiple agents reporting data under the same UI name, then you must make sure you disable or uninstall all of the agents associated with that entity. You have problems removing your PHP app If you have a PHP app and aren't able to remove it from the UI, possible causes include: You have not disabled both components of the PHP agent. You must stop or uninstall both newrelic.so and newrelic-daemon in order to be able to remove a PHP app. For more information, see New Relic daemon processes. You have set up per-directory monitoring of your PHP app, and unexpected PHP data is reporting as the default PHP application in the New Relic UI. To fix this, change the default app name in the PHP agent config. You don't know where the app's data is coming from If you don't know where an app's data is coming from, it may be because the app's name has been changed. When an app name is changed in the UI, it does not change the underlying app name being reported; it only changes how the app name appears in the UI. To see if there is a difference between the reported name and the displayed name: From one.newrelic.com, select APM, then select an application. Scroll down to Settings and select Application. Compare the name in the Application alias field to the name in the Your application still reports as message directly beneath it. To get host information about an app you are not familiar with: From one.newrelic.com, select APM, then select an application. From the summary view, review the Servers list. Once you have identified where app data is coming from, you can remove the app from New Relic. Browser data is still reporting To remove an app from New Relic, all data must have stopped reporting, including browser monitoring data. To verify that you have disabled or uninstalled the APM agent associated with the app: Ensure that browser monitoring is disabled. If your browser monitoring script is inserted by the APM agent, turn it off from inside the UI, in the agent's config file, or in both. If you copied and pasted the monitoring JavaScript snippet in certain pages, remove that JavaScript snippet manually. Ensure all caches have been cleared that the application uses, such as host caches, CDNs, or anything else that caches built pages. Optional: To see a count of how many page views report from each domain, use this NRQL query: SELECT count(*) FROM PageView WHERE appName = 'YOUR_BROWSER_APP_NAME' FACET domain Copy If these steps don't resolve the issue, it is likely due to an end-user's browser cache that hasn't yet cleared. Wait until those caches clear. If your app has internal users, you may be able to identify the users and clear those caches. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.48601,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APM</em> applications",
        "tags": "<em>Maintenance</em>",
        "body": " reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an app monitored by New Relic <em>APM</em>, browser monitoring, or mobile monitoring from the UI, keep in mind: You can downgrade your account"
      },
      "id": "603ebbef28ccbc48d1eba78d"
    },
    {
      "sections": [
        "Disable the APM agent",
        "C SDK",
        "Go",
        "Tip",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby"
      ],
      "title": "Disable the APM agent",
      "type": "docs",
      "tags": [
        "APM",
        "Maintenance"
      ],
      "external_id": "86abf4b21d23156a566b9cf171c8eb8a36385518",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/disable-apm-agent/",
      "published_at": "2021-10-07T05:49:28Z",
      "updated_at": "2021-03-16T07:13:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You may want to temporarily disable an APM agent for the purposes of testing or troubleshooting. This document explains procedures for temporarily turning off the APM agent. Related procedures: To permanently disable APM, uninstall the agent. To configure an agent to monitor some things but not others, use custom instrumentation. Disable the APM agent Select your agent type for instructions: C SDK The C SDK cannot be turned on or off directly. However, you can write your code for the SDK so that a quick recompile and deploy can enable or disable your instrumentation. Follow standard procedures to disable or uninstall the C SDK. Go There are two main ways to disable the Go agent: Remove the import of the github.com/newrelic/go-agent package from your application, and remove or comment out any calls to the newrelic namespace. Then, recompile and restart your app. Use the enabled configuration setting. Then, recompile and restart your app. (This will not reduce overhead because the instrumentation is still running; it will only prevent the sending of data to the New Relic collector.) Tip After you disable the agent, it may take several minutes for data to stop showing up. Java There are three main ways to disable the Java agent: Set agent_enabled to false, then restart the JVM. Use the JVM command line flag: -Dnewrelic.config.agent_enabled=false Copy Then restart the JVM. Remove the newrelic.jar or newrelic.yml file, then restart the JVM. Tip After you disable the agent, it may take several minutes for data to stop showing up. .NET The method to disable the agent depends on if you are using Framework or Core: .NET Framework: Set agentEnabled to false in the global newrelic.config file, found in C:\\ProgramData\\New Relic\\.NET Agent\\. If the application is IIS-hosted, restart IIS. If it's self-hosted (non-IIS), restart the application. .NET Core: Set agentEnabled to false in the newrelic.config file found in the Core agent’s installation directory (for Windows alongside NewRelic.Profiler.dll and for Linux alongside NewRelic.Profiler.so). If you use the ASP.NET Core Module, reset IIS. Otherwise, restart your Core application. Tip After you disable the agent, it may take several minutes for data to stop showing up. Node.js There are two main ways to disable the Node.js agent: Set agent_enabled to false in your agent config file, then restart the app server. Set the NEW_RELIC_ENABLED environment variable to false. Tip After you disable the agent, it may take several minutes for data to stop showing up. PHP To disable the PHP agent, set the enabled config setting to false, then restart the web server or PHP. Tip After you disable the agent, it may take several minutes for data to stop showing up. Python There are three main ways to disable the Python agent, depending on your preference and setup: Standard install: Use the monitor_mode configuration setting. This can be done by editing the config file or by using an environment variable. Standard install with newrelic-admin script: Remove reference to that script in your application. Manual instrumentation: Remove the initialization script from your application. Tip After you disable the agent, it may take several minutes for data to stop showing up. Ruby There are several ways to disable the Ruby agent, depending on your preference and setup. These methods will remove most instrumentation but there will still be a small amount of activity and overhead: Use the agent_enabled configuration setting. This can be done in the configuration file or in the per-environment stanzas. Restart your app server afterward. Do the same via an environment variable, then restart the app server. The following methods will remove all instrumentation and overhead: Remove newrelic_rpm from the Gemfile and bundle install. Set the following in the Gemfile and bundle install: gem 'newrelic_rpm', :require => false Copy This option ensures the gem is installed if it's required somewhere in the app, but doesn't install it when bundling. Tip After you disable the agent, it may take several minutes for data to stop showing up.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.2193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable the <em>APM</em> agent",
        "sections": "Disable the <em>APM</em> agent",
        "tags": "<em>Maintenance</em>",
        "body": "You may want to temporarily disable an <em>APM</em> agent for the purposes of testing or troubleshooting. This document explains procedures for temporarily turning off the <em>APM</em> agent. Related procedures: To permanently disable <em>APM</em>, uninstall the agent. To configure an agent to monitor some things"
      },
      "id": "603e83ac196a67266ea83dda"
    },
    {
      "sections": [
        "Regulatory audits for New Relic services",
        "Customer FedRAMP obligations",
        "Time frames",
        "Services in Scope by compliance program",
        "Customer risk management"
      ],
      "title": "Regulatory audits for New Relic services",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "30dc1bcd07cce70ead8896f1c2f2a95b5da85120",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/regulatory-audits-new-relic-services/",
      "published_at": "2021-10-07T05:35:57Z",
      "updated_at": "2021-10-07T05:35:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This list is current. Last updated 9 Sept 2021. This document describes New Relic's products and services as they relate to regulatory framework compliance status. For more information, download the New Relic FedRAMP Customer Responsibility Matrix (CRM) Worksheet as a PDF|87K. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features. Time frames New Relic's time frames for supported regulatory frameworks and annual audits include: SOC2 Type 2 audit: Reviews New Relic's implementation and maintenance of controls for the previous 12 months. The annual audit spans August 1 of the previous year through July 31 of the current year (for example, August 1, 2019 through July 31, 2020). FedRAMP Agency (Moderate): Reviews New Relic's implementation and maintenance of NIST 800-53 rev. 4 controls for the previous 12 months. The annual audit spans November 28 of the previous year through November 28 of the current year (for example, November 28, 2019 through November 28, 2020). Services in Scope by compliance program The following table describes New Relic's Services in Scope of New Relic's assurance programs. A check indicates that this service in scope of the most recent assessment and current reports. A caution icon indicates the service is on the roadmap for regulatory framework compliance at a time frame to be determined. New Relic service SOC2 FedRAMP Moderate HIPAA-enabled capabilities Alerts APM AWS Metric Streams Browser monitoring Errors inbox Incident Intelligence (Applied Intelligence) Infrastructure agent (and associated on-host integrations) Cloud integrations (AWS, Azure, and GCP) Insights Logs (with exception of log patterns) Log patterns Metric API Mobile agents Network Performance Monitoring Pixie: Community Cloud for Pixie Community Cloud for Pixie has completed a SOC 2 Type 1 audit. Pixie: Auto-telemetry with Pixie Plugins Proactive Detection (Applied Intelligence) Programmability: New Relic One apps Serverless Synthetic monitoring Trace API Customer risk management All New Relic services are intended to be covered by our compliance programs. However, a new service may not be covered by one or more of our compliance programs at any given time throughout the year. This is primarily dependent on the timing when the service achieved General Availability (GA) status and the timing of the specific compliance program's annual authorization, certification, or assessment. You can use any New Relic service regardless of its compliance program status. However, if a service is not yet in scope of our compliance programs, we encourage you to consider your risk appetite in the decision to use the specific New Relic product or service. If you choose to use New Relic services that are not yet in our compliance program scope, you assume the responsibility to review, understand, and risk-manage your security controls as you deem appropriate. You also have the option to wait for New Relic to authorize these services before you use them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.54442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Type 2 audit: Reviews New Relic&#x27;s implementation and <em>maintenance</em> of controls for the previous 12 months. The annual audit spans August 1 of the previous year through July 31 of the current year (for example, August 1, 2019 through July 31, 2020). FedRAMP Agency (Moderate): Reviews New Relic"
      },
      "id": "603e81e728ccbc68bfeba794"
    }
  ],
  "/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic": [
    {
      "sections": [
        "Record and monitor deployments",
        "Options for tracking deployments",
        "Tip",
        "Record deployments with the REST API",
        "Record a deployment with POST",
        "Record a deployment with PowerShell",
        "View a list of deployments with GET",
        "Sample output from GET",
        "Delete a deployment with DELETE",
        "Character limits and JSON parameters",
        "Important",
        "Record deployments using the New Relic agent",
        "Notify your team of deployments",
        "End of life notification: Hipchat, Campfire"
      ],
      "title": "Record and monitor deployments",
      "type": "docs",
      "tags": [
        "APM",
        "Maintenance"
      ],
      "external_id": "00b24338386fd261daea0733fe03c01639cce083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-monitor-deployments/",
      "published_at": "2021-10-07T06:34:29Z",
      "updated_at": "2021-07-09T10:02:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app's performance. Tracking deployments creates deployment markers that appear in APM charts. Options for tracking deployments You can use the New Relic REST API v2 to record new deployments, retrieve a list of past deployments, and delete past deployments on your APM application. In addition, some APM agents have agent-specific methods to record deployments automatically. You can use your Slack integration with New Relic, or a simple webhook, to notify your team in real time of deployments for applications monitored by APM. Slack provides a webhook URL that allows you to post generic JSON that will appear formatted in a chosen Slack channel. There are a few places where you can view deployments in the New Relic UI after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, New Relic One Service summary, and entity summary pages. On APM performance charts as a chart marker. On the Deployments page for summary performance. Tip Deployment markers are not available for browser applications, but see browser releases for a way to tag errors with release versions. Record deployments with the REST API You can use the New Relic REST API v2 to record deployments, get a list of past deployments, and delete deployments. The examples in this document use curl as a command line tool. However, you can use any method to make your REST requests. You can also create, view, and delete deployments with the API Explorer. JSON uses double quotes \" for element names and content. Using single quotes ' will cause errors. Record a deployment with POST To record a new deployment, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. For example: curl -X POST \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i \\ -H \"Content-Type: application/json\" \\ -d \\ '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy Record a deployment with PowerShell To record a deployment with PowerShell, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. This example uses PowerShell version 3 or higher: Invoke-WebRequest -Uri https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json -Method POST -Headers @{'Api-Key'='$API_KEY'} -ContentType 'application/json' -Body '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy This example uses PowerShell version 2 (requires .NET framework 3.5 or higher): $encoding = [System.Text.Encoding]::GetEncoding(\"ASCII\") $data ='{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' $postData = $encoding.GetBytes($data) $request = [System.Net.WebRequest]::Create('https://api.newrelic.com/v2/applications/$APP_ID/deployments.json') $request.Method = 'POST' $request.Headers.add('Api-Key','$API_KEY') $request.ContentType='application/json' $stream = $request.GetRequestStream() $stream.Write($postData,0,$postData.Length) $request.GetResponse() Copy View a list of deployments with GET To retrieve a list of all past deployments for your app, send a GET request that includes your API key to the deployments endpoint. GET requests do not use a JSON payload. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Sample output from GET This example requests a list of deployments for app ID 9999999: curl -X GET \"https://api.newrelic.com/v2/applications/9999999/deployments.json\" \\ -H \"Api-Key:ABCDEFGHIJKLMNOPQRSTUVWXabcdefghijklmnopqrstuvwx\" \\ -i Copy The API returns this list of deployments: HTTP/1.1 200 OK ETag: \"ABCDEFGHIJKabcdefghijk0123456789\" Cache-Control: max-age=0, private, must-revalidate Content-Type: application/json { \"deployments\": [ { \"id\": 1234567, \"revision\": \"1234123412341234123412341234123412341234\", \"changelog\": \"Fixed the bugs for real this time\", \"description\": \"Example description two\", \"user\": \"Data Nerd\", \"timestamp\": \"2016-02-24T10:09:27-08:00\", \"links\": { \"application\": 9999999 } }, { \"id\": 2345678, \"revision\": \"7890789078907890789078907890789078907890\", \"changelog\": \"Think I fixed all the bugs\", \"description\": null, \"user\": \"Dren Atad\", \"timestamp\": \"2014-10-22T12:23:47-07:00\", \"links\": { \"application\": 9999999 } } ], \"links\": { \"deployment.agent\": \"/v2/applications/{application_id}\" } } Copy Delete a deployment with DELETE To delete a deployment, send a DELETE request that includes your API key to the deployments endpoint. DELETE requests do not use a JSON payload, but you must specify the ID for the deployment you want to delete. To retrieve the ID for a deployment, use the GET request. For example: curl -X DELETE \"https://api.newrelic.com/v2/applications/$APP_ID/deployments/$DEPLOYMENT_ID.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Character limits and JSON parameters The JSON payload can include the following parameters. Important UTF-8 4 byte characters, such as Emojis and some non-Latin language glyphs, cannot be used in the deployment text. Parameter Data type Description revision String, 127 character maximum Required. A unique ID for this deployment, visible in the Summary page and on the Deployments page. Can be any string, but is usually a version number or a Git checksum. changelog String, 65535 character maximum Optional. A summary of what changed in this deployment, visible in the Deployments page when you select (selected deployment) > Change log. description String, 65535 character maximum Optional. A high-level description of this deployment, visible in the Summary page and on the Deployments page when you select an individual deployment. user String, 31 character maximum Optional. A username to associate with the deployment, visible in the Summary page and on the Deployments page. timestamp ISO 8601 Optional. When the deployment occurred, down to the second. If not specified, the deployment will be recorded at the time when the API call was received. Timestamp requirements: Must be in UTC time. Must be after the most recent deployment timestamp. Cannot be in the future. Must be in ISO8601 format; for example, \"2019-10-08T00:15:36Z\". Record deployments using the New Relic agent Some agents have additional methods to record deployments: All agents: Use the New Relic REST API v2. C: No SDK-specific methods. Use the REST API. Go: No agent-specific methods. Use the REST API. Java: Call the Java agent jar. .NET: Use PowerShell and the REST API. Node.js: No agent-specific methods. Use the REST API. PHP: Use a PHP script. Python: Use the record-deploy subcommand of the newrelic-admin script. Ruby: Use a Capistrano recipe. Notify your team of deployments After a deployment is recorded using the REST API, you can optionally notify a webhook endpoint of the deployment. The destination of the webhook can be your Slack instance. To use webhooks to set up a deployment notification for a Slack channel: Log in to your Slack account as an admin, then go to App directory > Manage > Apps. Search for your New Relic app, then select Add configuration. From Post to channel, select an existing Slack channel or add a new channel, then Add configuration. From the list of options, copy the webhook URL. Go to one.newrelic.com > (account dropdown) > Account settings > Integrations > Deploy notifications > Webhook. Paste the Slack webhook URL, then save. Optional: Send a test message. Tip You can also use webhooks, Slack channels, and other options for alert notifications with New Relic Alerts. End of life notification: Hipchat, Campfire As of September 9, 2019, integrations with Hipchat and Campfire for APM deployment notifications will no longer be available. Recommendation: If you are still using Hipchat or Campfire, use webhooks with Slack channels instead. For more information, see the New Relic Explorers Hub post.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.42777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Maintenance</em>",
        "body": "Deploying an app can be a risky event—when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app&#x27;s performance. Tracking deployments creates deployment markers that appear in <em>APM</em> charts. Options for tracking"
      },
      "id": "603eb1c364441fd58b4e888b"
    },
    {
      "sections": [
        "Disable the APM agent",
        "C SDK",
        "Go",
        "Tip",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby"
      ],
      "title": "Disable the APM agent",
      "type": "docs",
      "tags": [
        "APM",
        "Maintenance"
      ],
      "external_id": "86abf4b21d23156a566b9cf171c8eb8a36385518",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/disable-apm-agent/",
      "published_at": "2021-10-07T05:49:28Z",
      "updated_at": "2021-03-16T07:13:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You may want to temporarily disable an APM agent for the purposes of testing or troubleshooting. This document explains procedures for temporarily turning off the APM agent. Related procedures: To permanently disable APM, uninstall the agent. To configure an agent to monitor some things but not others, use custom instrumentation. Disable the APM agent Select your agent type for instructions: C SDK The C SDK cannot be turned on or off directly. However, you can write your code for the SDK so that a quick recompile and deploy can enable or disable your instrumentation. Follow standard procedures to disable or uninstall the C SDK. Go There are two main ways to disable the Go agent: Remove the import of the github.com/newrelic/go-agent package from your application, and remove or comment out any calls to the newrelic namespace. Then, recompile and restart your app. Use the enabled configuration setting. Then, recompile and restart your app. (This will not reduce overhead because the instrumentation is still running; it will only prevent the sending of data to the New Relic collector.) Tip After you disable the agent, it may take several minutes for data to stop showing up. Java There are three main ways to disable the Java agent: Set agent_enabled to false, then restart the JVM. Use the JVM command line flag: -Dnewrelic.config.agent_enabled=false Copy Then restart the JVM. Remove the newrelic.jar or newrelic.yml file, then restart the JVM. Tip After you disable the agent, it may take several minutes for data to stop showing up. .NET The method to disable the agent depends on if you are using Framework or Core: .NET Framework: Set agentEnabled to false in the global newrelic.config file, found in C:\\ProgramData\\New Relic\\.NET Agent\\. If the application is IIS-hosted, restart IIS. If it's self-hosted (non-IIS), restart the application. .NET Core: Set agentEnabled to false in the newrelic.config file found in the Core agent’s installation directory (for Windows alongside NewRelic.Profiler.dll and for Linux alongside NewRelic.Profiler.so). If you use the ASP.NET Core Module, reset IIS. Otherwise, restart your Core application. Tip After you disable the agent, it may take several minutes for data to stop showing up. Node.js There are two main ways to disable the Node.js agent: Set agent_enabled to false in your agent config file, then restart the app server. Set the NEW_RELIC_ENABLED environment variable to false. Tip After you disable the agent, it may take several minutes for data to stop showing up. PHP To disable the PHP agent, set the enabled config setting to false, then restart the web server or PHP. Tip After you disable the agent, it may take several minutes for data to stop showing up. Python There are three main ways to disable the Python agent, depending on your preference and setup: Standard install: Use the monitor_mode configuration setting. This can be done by editing the config file or by using an environment variable. Standard install with newrelic-admin script: Remove reference to that script in your application. Manual instrumentation: Remove the initialization script from your application. Tip After you disable the agent, it may take several minutes for data to stop showing up. Ruby There are several ways to disable the Ruby agent, depending on your preference and setup. These methods will remove most instrumentation but there will still be a small amount of activity and overhead: Use the agent_enabled configuration setting. This can be done in the configuration file or in the per-environment stanzas. Restart your app server afterward. Do the same via an environment variable, then restart the app server. The following methods will remove all instrumentation and overhead: Remove newrelic_rpm from the Gemfile and bundle install. Set the following in the Gemfile and bundle install: gem 'newrelic_rpm', :require => false Copy This option ensures the gem is installed if it's required somewhere in the app, but doesn't install it when bundling. Tip After you disable the agent, it may take several minutes for data to stop showing up.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.2193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable the <em>APM</em> agent",
        "sections": "Disable the <em>APM</em> agent",
        "tags": "<em>Maintenance</em>",
        "body": "You may want to temporarily disable an <em>APM</em> agent for the purposes of testing or troubleshooting. This document explains procedures for temporarily turning off the <em>APM</em> agent. Related procedures: To permanently disable <em>APM</em>, uninstall the agent. To configure an agent to monitor some things"
      },
      "id": "603e83ac196a67266ea83dda"
    },
    {
      "sections": [
        "Regulatory audits for New Relic services",
        "Customer FedRAMP obligations",
        "Time frames",
        "Services in Scope by compliance program",
        "Customer risk management"
      ],
      "title": "Regulatory audits for New Relic services",
      "type": "docs",
      "tags": [
        "Security",
        "Security and Privacy",
        "Compliance"
      ],
      "external_id": "30dc1bcd07cce70ead8896f1c2f2a95b5da85120",
      "image": "",
      "url": "https://docs.newrelic.com/docs/security/security-privacy/compliance/regulatory-audits-new-relic-services/",
      "published_at": "2021-10-07T05:35:57Z",
      "updated_at": "2021-10-07T05:35:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This list is current. Last updated 9 Sept 2021. This document describes New Relic's products and services as they relate to regulatory framework compliance status. For more information, download the New Relic FedRAMP Customer Responsibility Matrix (CRM) Worksheet as a PDF|87K. Customer FedRAMP obligations New Relic customers must meet all of the following requirements for New Relic’s FedRAMP environment: New Relic-approved customers: New Relic’s FedRAMP-Moderate authorized environment is only available to New Relic-approved customers. For more information, contact your New Relic account representative. Order form: Customer’s order form with New Relic must include customer’s eligibility for FedRAMP. Subscription level: Customer must have a current and valid subscription to New Relic Full-Stack Observability Enterprise or New Relic-approved subscription. Authorized New Relic endpoints: Customer must send its data only to New Relic’s FedRAMP-designated endpoints. Authorized services and features: Customer must use only FedRAMP audited and authorized New Relic services and features. Time frames New Relic's time frames for supported regulatory frameworks and annual audits include: SOC2 Type 2 audit: Reviews New Relic's implementation and maintenance of controls for the previous 12 months. The annual audit spans August 1 of the previous year through July 31 of the current year (for example, August 1, 2019 through July 31, 2020). FedRAMP Agency (Moderate): Reviews New Relic's implementation and maintenance of NIST 800-53 rev. 4 controls for the previous 12 months. The annual audit spans November 28 of the previous year through November 28 of the current year (for example, November 28, 2019 through November 28, 2020). Services in Scope by compliance program The following table describes New Relic's Services in Scope of New Relic's assurance programs. A check indicates that this service in scope of the most recent assessment and current reports. A caution icon indicates the service is on the roadmap for regulatory framework compliance at a time frame to be determined. New Relic service SOC2 FedRAMP Moderate HIPAA-enabled capabilities Alerts APM AWS Metric Streams Browser monitoring Errors inbox Incident Intelligence (Applied Intelligence) Infrastructure agent (and associated on-host integrations) Cloud integrations (AWS, Azure, and GCP) Insights Logs (with exception of log patterns) Log patterns Metric API Mobile agents Network Performance Monitoring Pixie: Community Cloud for Pixie Community Cloud for Pixie has completed a SOC 2 Type 1 audit. Pixie: Auto-telemetry with Pixie Plugins Proactive Detection (Applied Intelligence) Programmability: New Relic One apps Serverless Synthetic monitoring Trace API Customer risk management All New Relic services are intended to be covered by our compliance programs. However, a new service may not be covered by one or more of our compliance programs at any given time throughout the year. This is primarily dependent on the timing when the service achieved General Availability (GA) status and the timing of the specific compliance program's annual authorization, certification, or assessment. You can use any New Relic service regardless of its compliance program status. However, if a service is not yet in scope of our compliance programs, we encourage you to consider your risk appetite in the decision to use the specific New Relic product or service. If you choose to use New Relic services that are not yet in our compliance program scope, you assume the responsibility to review, understand, and risk-manage your security controls as you deem appropriate. You also have the option to wait for New Relic to authorize these services before you use them.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.54438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Type 2 audit: Reviews New Relic&#x27;s implementation and <em>maintenance</em> of controls for the previous 12 months. The annual audit spans August 1 of the previous year through July 31 of the current year (for example, August 1, 2019 through July 31, 2020). FedRAMP Agency (Moderate): Reviews New Relic"
      },
      "id": "603e81e728ccbc68bfeba794"
    }
  ],
  "/docs/apm/new-relic-apm/troubleshooting/charts-missing-or-do-not-render": [
    {
      "sections": [
        "Python: Configure logs in context",
        "Set up your Python app",
        "Python StreamHandler example",
        "What's next?"
      ],
      "title": "Python: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for Python"
      ],
      "external_id": "a51497a54dbdd8c6ee16e8cf097a090347166d1f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-python/",
      "published_at": "2021-10-07T10:44:13Z",
      "updated_at": "2021-10-06T21:52:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Python agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Python app To enable logs in context for APM apps monitored by Python: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Python agent version, and enable distributed tracing. Use Python agent version 5.4.0 or higher for logs in context. Configure logs in context for your log handler. Python StreamHandler example Enabling logs in Python is as simple as instantiating a log formatter and adding it to your log handler. This example uses a StreamHandler which by default writes logs to sys.stderr, but any handler can be used. For more information about configuring log handlers, see the Python.org documentation. # Import the logging module and the New Relic log formatter import logging from newrelic.agent import NewRelicContextFormatter # Instantiate a new log handler handler = logging.StreamHandler() # Instantiate the log formatter and add it to the log handler formatter = NewRelicContextFormatter() handler.setFormatter(formatter) # Get the root logger and add the handler to it root_logger = logging.getLogger() root_logger.addHandler(handler) Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.260273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don&#x27;t see log data in the UI, follow the <em>troubleshooting</em> procedures. What&#x27;s next? After you set up <em>APM</em> logs in context, make the most of your logging data: Explore the logging data across your platform"
      },
      "id": "612d463564441f2c8042434e"
    },
    {
      "sections": [
        "Node.js: Configure logs in context",
        "Set up your Node.js app",
        "Node.js configuration with Winston",
        "What's next?"
      ],
      "title": "Node.js: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for Node.js"
      ],
      "external_id": "25a42c104600852e6c71dc7747b2e1a3c4439dcd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-nodejs/",
      "published_at": "2021-10-07T17:23:46Z",
      "updated_at": "2021-10-06T21:51:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Node.js agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Node.js app To enable logs in context for APM apps monitored by Node.js: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Node.js agent version, and enable distributed tracing. Use Node.js agent version 6.2.0 or higher for logs in context. Install the Winston logging framework version 3.0.0 or higher to enrich your log data. Configure logs in context for Node.js using the Winston extension. Node.js configuration with Winston To install the Winston log enricher, enter the following command into your terminal or command line interface: npm install @newrelic/winston-enricher Copy In your application code, update your logging configuration to add the newrelicFormatter: // index.js require('newrelic') const newrelicFormatter = require('@newrelic/winston-enricher') Copy The New Relic formatter can be used individually or combined with other formatters as the final format. format: winston.format.combine( winston.format.label({label: 'test'}), newrelicFormatter() ) Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.258045,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " fields. If you don&#x27;t see log data in the UI, follow the <em>troubleshooting</em> procedures. What&#x27;s next? After you set up <em>APM</em> logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app&#x27;s performance in the <em>APM</em> UI"
      },
      "id": "612b7a7ee7b9d2d42bb6f24b"
    },
    {
      "sections": [
        "Errors while using other APM software",
        "Problem",
        "Solution"
      ],
      "title": "Errors while using other APM software",
      "type": "docs",
      "tags": [
        "APM",
        "Troubleshooting"
      ],
      "external_id": "585c393ba05316bfb72d665760e1cb2d7e0e0631",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/troubleshooting/errors-while-using-other-apm-software/",
      "published_at": "2021-10-07T11:24:31Z",
      "updated_at": "2021-09-14T10:19:00Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When other monitoring software is running alongside one of our APM agents, we cannot guarantee that our agents will work correctly. In some cases, running more than one type of APM software can cause issues such as unreliable metrics and agent crashes. For specifics, see the requirements and compatibility documentation for a specific APM agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the APM agent you're using. To troubleshoot if this is causing an issue, temporarily disable or uninstall other APM software to see if the issue is still present.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.3898,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Errors while using other <em>APM</em> software",
        "sections": "Errors while using other <em>APM</em> software",
        "tags": "<em>APM</em>",
        "body": " and compatibility documentation for a specific <em>APM</em> agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the <em>APM</em> agent you&#x27;re using. To <em>troubleshoot</em> if this is causing an issue, temporarily disable or uninstall other <em>APM</em> software to see if the issue is still present."
      },
      "id": "603ea87828ccbc65f2eba74a"
    }
  ],
  "/docs/apm/new-relic-apm/troubleshooting/cpu-usage-mismatch-or-usage-over-100": [
    {
      "sections": [
        "Python: Configure logs in context",
        "Set up your Python app",
        "Python StreamHandler example",
        "What's next?"
      ],
      "title": "Python: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for Python"
      ],
      "external_id": "a51497a54dbdd8c6ee16e8cf097a090347166d1f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-python/",
      "published_at": "2021-10-07T10:44:13Z",
      "updated_at": "2021-10-06T21:52:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Python agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Python app To enable logs in context for APM apps monitored by Python: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Python agent version, and enable distributed tracing. Use Python agent version 5.4.0 or higher for logs in context. Configure logs in context for your log handler. Python StreamHandler example Enabling logs in Python is as simple as instantiating a log formatter and adding it to your log handler. This example uses a StreamHandler which by default writes logs to sys.stderr, but any handler can be used. For more information about configuring log handlers, see the Python.org documentation. # Import the logging module and the New Relic log formatter import logging from newrelic.agent import NewRelicContextFormatter # Instantiate a new log handler handler = logging.StreamHandler() # Instantiate the log formatter and add it to the log handler formatter = NewRelicContextFormatter() handler.setFormatter(formatter) # Get the root logger and add the handler to it root_logger = logging.getLogger() root_logger.addHandler(handler) Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.260242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don&#x27;t see log data in the UI, follow the <em>troubleshooting</em> procedures. What&#x27;s next? After you set up <em>APM</em> logs in context, make the most of your logging data: Explore the logging data across your platform"
      },
      "id": "612d463564441f2c8042434e"
    },
    {
      "sections": [
        "Node.js: Configure logs in context",
        "Set up your Node.js app",
        "Node.js configuration with Winston",
        "What's next?"
      ],
      "title": "Node.js: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for Node.js"
      ],
      "external_id": "25a42c104600852e6c71dc7747b2e1a3c4439dcd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-nodejs/",
      "published_at": "2021-10-07T17:23:46Z",
      "updated_at": "2021-10-06T21:51:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Node.js agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Node.js app To enable logs in context for APM apps monitored by Node.js: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Node.js agent version, and enable distributed tracing. Use Node.js agent version 6.2.0 or higher for logs in context. Install the Winston logging framework version 3.0.0 or higher to enrich your log data. Configure logs in context for Node.js using the Winston extension. Node.js configuration with Winston To install the Winston log enricher, enter the following command into your terminal or command line interface: npm install @newrelic/winston-enricher Copy In your application code, update your logging configuration to add the newrelicFormatter: // index.js require('newrelic') const newrelicFormatter = require('@newrelic/winston-enricher') Copy The New Relic formatter can be used individually or combined with other formatters as the final format. format: winston.format.combine( winston.format.label({label: 'test'}), newrelicFormatter() ) Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.258015,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " fields. If you don&#x27;t see log data in the UI, follow the <em>troubleshooting</em> procedures. What&#x27;s next? After you set up <em>APM</em> logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app&#x27;s performance in the <em>APM</em> UI"
      },
      "id": "612b7a7ee7b9d2d42bb6f24b"
    },
    {
      "sections": [
        "Errors while using other APM software",
        "Problem",
        "Solution"
      ],
      "title": "Errors while using other APM software",
      "type": "docs",
      "tags": [
        "APM",
        "Troubleshooting"
      ],
      "external_id": "585c393ba05316bfb72d665760e1cb2d7e0e0631",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/troubleshooting/errors-while-using-other-apm-software/",
      "published_at": "2021-10-07T11:24:31Z",
      "updated_at": "2021-09-14T10:19:00Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When other monitoring software is running alongside one of our APM agents, we cannot guarantee that our agents will work correctly. In some cases, running more than one type of APM software can cause issues such as unreliable metrics and agent crashes. For specifics, see the requirements and compatibility documentation for a specific APM agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the APM agent you're using. To troubleshoot if this is causing an issue, temporarily disable or uninstall other APM software to see if the issue is still present.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.389797,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Errors while using other <em>APM</em> software",
        "sections": "Errors while using other <em>APM</em> software",
        "tags": "<em>APM</em>",
        "body": " and compatibility documentation for a specific <em>APM</em> agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the <em>APM</em> agent you&#x27;re using. To <em>troubleshoot</em> if this is causing an issue, temporarily disable or uninstall other <em>APM</em> software to see if the issue is still present."
      },
      "id": "603ea87828ccbc65f2eba74a"
    }
  ],
  "/docs/apm/new-relic-apm/troubleshooting/errors-while-using-other-apm-software": [
    {
      "sections": [
        "Python: Configure logs in context",
        "Set up your Python app",
        "Python StreamHandler example",
        "What's next?"
      ],
      "title": "Python: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for Python"
      ],
      "external_id": "a51497a54dbdd8c6ee16e8cf097a090347166d1f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-python/",
      "published_at": "2021-10-07T10:44:13Z",
      "updated_at": "2021-10-06T21:52:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Python agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Python app To enable logs in context for APM apps monitored by Python: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Python agent version, and enable distributed tracing. Use Python agent version 5.4.0 or higher for logs in context. Configure logs in context for your log handler. Python StreamHandler example Enabling logs in Python is as simple as instantiating a log formatter and adding it to your log handler. This example uses a StreamHandler which by default writes logs to sys.stderr, but any handler can be used. For more information about configuring log handlers, see the Python.org documentation. # Import the logging module and the New Relic log formatter import logging from newrelic.agent import NewRelicContextFormatter # Instantiate a new log handler handler = logging.StreamHandler() # Instantiate the log formatter and add it to the log handler formatter = NewRelicContextFormatter() handler.setFormatter(formatter) # Get the root logger and add the handler to it root_logger = logging.getLogger() root_logger.addHandler(handler) Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.260242,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don&#x27;t see log data in the UI, follow the <em>troubleshooting</em> procedures. What&#x27;s next? After you set up <em>APM</em> logs in context, make the most of your logging data: Explore the logging data across your platform"
      },
      "id": "612d463564441f2c8042434e"
    },
    {
      "sections": [
        "Node.js: Configure logs in context",
        "Set up your Node.js app",
        "Node.js configuration with Winston",
        "What's next?"
      ],
      "title": "Node.js: Configure logs in context",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Logs in context for Node.js"
      ],
      "external_id": "25a42c104600852e6c71dc7747b2e1a3c4439dcd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/logs-context/configure-logs-context-nodejs/",
      "published_at": "2021-10-07T17:23:46Z",
      "updated_at": "2021-10-06T21:51:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Logs in context for the Node.js agent connects your logs and APM data in New Relic. Bringing all of this data together in a single tool helps you quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. Set up your Node.js app To enable logs in context for APM apps monitored by Node.js: Make sure you have already set up logging in New Relic. This includes configuring a supported log forwarder that collects your application logs and extends the metadata that is forwarded to New Relic. Install or update to the latest Node.js agent version, and enable distributed tracing. Use Node.js agent version 6.2.0 or higher for logs in context. Install the Winston logging framework version 3.0.0 or higher to enrich your log data. Configure logs in context for Node.js using the Winston extension. Node.js configuration with Winston To install the Winston log enricher, enter the following command into your terminal or command line interface: npm install @newrelic/winston-enricher Copy In your application code, update your logging configuration to add the newrelicFormatter: // index.js require('newrelic') const newrelicFormatter = require('@newrelic/winston-enricher') Copy The New Relic formatter can be used individually or combined with other formatters as the final format. format: winston.format.combine( winston.format.label({label: 'test'}), newrelicFormatter() ) Copy To verify that you have configured the log appender correctly, run your application, then check your logs data in New Relic One using the query operator has:span.id has:trace.id. If everything is configured correctly and your data is being forwarded to New Relic with the enriched metadata, your logs should now be emitted as JSON and contain trace.id and span.id fields. If you don't see log data in the UI, follow the troubleshooting procedures. What's next? After you set up APM logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data by forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 62.258015,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " fields. If you don&#x27;t see log data in the UI, follow the <em>troubleshooting</em> procedures. What&#x27;s next? After you set up <em>APM</em> logs in context, make the most of your logging data: Explore the logging data across your platform with our Logs UI. See your logs in context of your app&#x27;s performance in the <em>APM</em> UI"
      },
      "id": "612b7a7ee7b9d2d42bb6f24b"
    },
    {
      "sections": [
        "CPU usage mismatch or usage over 100%",
        "Problem",
        "Cause",
        "APM",
        "New Relic Infrastructure"
      ],
      "title": "CPU usage mismatch or usage over 100%",
      "type": "docs",
      "tags": [
        "APM",
        "Troubleshooting"
      ],
      "external_id": "e4d59a87ba5fc7667a1b5defaba41f0112c9762c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/troubleshooting/cpu-usage-mismatch-or-usage-over-100/",
      "published_at": "2021-10-07T06:47:45Z",
      "updated_at": "2021-09-14T10:16:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem CPU percent usage data between APM and infrastructure seems contradictory, or your CPU usage exceeds 100%. Cause CPU usage data for APM is different than CPU usage data for infrastructure. In APM, CPU percent usage measures aggregate usage of all instances of an application or service on a given server. In Infrastructure, CPU percent usage is measured differently depending on if you are viewing CPU usage in relation to hosts, or to processes. APM To view your app's CPU usage: Go to one.newrelic.com > (select an app) and see the CPU usage in the hosts list. The number of instances is listed under each host name (for example, 55 instances). APM CPU percent usage measures aggregate CPU usage of all instances of your app or service on a given server. This percentage is affected by the number of instances running across cores on the server. Multiple instances of a service running on one server or in a multi-core environment can produce CPU usage percentages well above 100%. APM calculates the percentage by aggregating CPU time and dividing by clock time: CPU usage = (instance CPU time + instance CPU time + [...]) / (clock time) Copy Example: Upgrading to a quad core processor If you upgrade from a dual processor to a quad processor under the same architecture, you should see roughly the same CPU numbers for the same loads and applications. If New Relic normalized the calculation, the upgrade would appear to produce an abrupt decrease in your CPU usage, even if the number of cycles you are using would be the same. Adding more instances does not make your code more efficient. New Relic Infrastructure To view your individual host CPU usage: Go to one.newrelic.com > Infrastructure and see CPU %. See individual CPU usage in the hosts list. The exact calculation for CPU usage is measured differently depending on if you are viewing CPU usage in relation to hosts, or to processes: Page Calculation details Hosts On the Hosts page, CPU Percent is a derived metric that is part of the SystemSample event. The CPU percentage is not collected by New Relic, but derived from several other metrics. Specifically, the cpuPercent attribute is an aggregation of cpuUserPercent, cpuSystemPercent, cpuIoWaitPercent and cpuStealPercent. The Hosts page shows metrics from a perspective of your whole system. For example, if a server has 32 cores installed and is showing cpuPercent of 50%, 16 of the 32 cores are being used. Processes On the Processes page, CPU percent is scoped to individual processes, rather than hosts. Because of this, the CPU percent metric does not take into account the resources of the entire system. Instead, it shows how much of a single CPU core each process is taking. For example, with a 32-core server, a process showing cpuPercent of 50% is only taking half of a single core, or about 1.5625% of the CPU cycles available on the whole server. This can result in cpuPercent exceeding 100% on the Processes page. When this occurs, the process is demanding more than a single core’s worth of CPU cycles.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.389194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APM</em>",
        "tags": "<em>APM</em>",
        "body": "Problem CPU percent usage data between <em>APM</em> and infrastructure seems contradictory, or your CPU usage exceeds 100%. Cause CPU usage data for <em>APM</em> is different than CPU usage data for infrastructure. In <em>APM</em>, CPU percent usage measures aggregate usage of all instances of an application or service"
      },
      "id": "604427ca28ccbcccc02c6062"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-10-07T06:53:16Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-10-07T12:41:17Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Database analysis report",
        "View the database analysis report",
        "Analyze your data"
      ],
      "title": "Database analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2627a588c2c730695f87d497407630fbd525ed16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/database-analysis-report/",
      "published_at": "2021-10-07T12:46:28Z",
      "updated_at": "2021-03-16T07:15:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's database analysis report allows you to analyze your application's performance from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute or rpm), total time spent in the operation, and average time to execute it. View the database analysis report To view the database analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Database. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Type the value in the Filter text box; for example, to show only transactions for Model operations that contain the value User. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to APM's Database and slow queries page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Database <em>analysis</em> <em>report</em>",
        "sections": "Database <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "<em>APM</em>&#x27;s database <em>analysis</em> <em>report</em> allows you to analyze your application&#x27;s <em>performance</em> from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute"
      },
      "id": "603ebf8964441fd4df4e887a"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/capacity-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-10-07T06:53:16Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-10-07T12:41:17Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-10-07T11:25:26Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/database-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-10-07T06:53:16Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-10-07T12:41:17Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-10-07T11:25:26Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/scalability-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-10-07T06:53:16Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-10-07T12:41:17Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-10-07T11:25:26Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-10-07T06:53:16Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-10-07T11:25:26Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    },
    {
      "sections": [
        "Database analysis report",
        "View the database analysis report",
        "Analyze your data"
      ],
      "title": "Database analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2627a588c2c730695f87d497407630fbd525ed16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/database-analysis-report/",
      "published_at": "2021-10-07T12:46:28Z",
      "updated_at": "2021-03-16T07:15:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's database analysis report allows you to analyze your application's performance from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute or rpm), total time spent in the operation, and average time to execute it. View the database analysis report To view the database analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Database. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Type the value in the Filter text box; for example, to show only transactions for Model operations that contain the value User. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to APM's Database and slow queries page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Database <em>analysis</em> <em>report</em>",
        "sections": "Database <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "<em>APM</em>&#x27;s database <em>analysis</em> <em>report</em> allows you to analyze your application&#x27;s <em>performance</em> from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute"
      },
      "id": "603ebf8964441fd4df4e887a"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/weekly-performance-report": [
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-10-07T12:41:17Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.2758,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-10-07T11:25:26Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    },
    {
      "sections": [
        "Database analysis report",
        "View the database analysis report",
        "Analyze your data"
      ],
      "title": "Database analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2627a588c2c730695f87d497407630fbd525ed16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/database-analysis-report/",
      "published_at": "2021-10-07T12:46:28Z",
      "updated_at": "2021-03-16T07:15:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's database analysis report allows you to analyze your application's performance from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute or rpm), total time spent in the operation, and average time to execute it. View the database analysis report To view the database analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Database. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Type the value in the Filter text box; for example, to show only transactions for Model operations that contain the value User. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to APM's Database and slow queries page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 200.27576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Database <em>analysis</em> <em>report</em>",
        "sections": "Database <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "<em>APM</em>&#x27;s database <em>analysis</em> <em>report</em> allows you to analyze your application&#x27;s <em>performance</em> from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute"
      },
      "id": "603ebf8964441fd4df4e887a"
    }
  ],
  "/docs/apm/reports/service-level-agreements/api-examples-sla-reports": [
    {
      "sections": [
        "APM SLA reports",
        "View SLA reports",
        "View metric trends",
        "Analyze your data"
      ],
      "title": "APM SLA reports",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Service level agreements"
      ],
      "external_id": "f66a2ccdfd774a7befcd9df4bd8a9d7f633e234c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/service-level-agreements/apm-sla-reports/",
      "published_at": "2021-10-07T09:03:59Z",
      "updated_at": "2021-03-16T08:21:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM provides service level agreement (SLA) reports. SLA reports help you better understand your application performance by showing application downtime and trends over time. SLA reports for an application only include web transactions. If your application creates only non-web transactions, New Relic does not produce SLA reports for that app. SLA reports can be viewed in APM or downloaded as comma-separated value (.csv) files. Depending on your account level's data retention policy, you can view daily, weekly, or monthly reports. View SLA reports To view the SLA reports for your app: Go to one.newrelic.com > Applications > (select an app) > Reports > SLA. The report defaults to the Weekly SLA report tab. SLA report data shows the account owner's time zone, with periods beginning and ending at midnight in that time zone. If you have not enabled browser for your app, the SLA report shows links to requests, response time, and Apdex only for your application server. If you want to... Do this Show or hide details Select the End user tier (if available) or Application server heading. View another time period Select the tab for daily, weekly, or monthly SLA reports if available. Save or export the report Select Download this report as .csv to create a report file with comma-separated values. View metric trends To drill down into detailed information, select the link. This includes: End users (from browser): Page views, load time, and Apdex Application server (from APM agents, such as Java or Ruby): Requests, response time, and Apdex The metric detail window below the report list shows trends over the selected period (12 days, weeks, or months). Use any of New Relic's available standard page functions to drill down into detailed information. In addition: To view other details, select its link. To clear the details and return to the main SLA report, select the tab. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.5769,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>APM</em> SLA <em>reports</em>",
        "sections": "<em>APM</em> SLA <em>reports</em>",
        "tags": "<em>Service</em> <em>level</em> <em>agreements</em>",
        "body": "<em>APM</em> provides <em>service</em> <em>level</em> <em>agreement</em> (SLA) <em>reports</em>. SLA <em>reports</em> help you better understand your application performance by showing application downtime and trends over time. SLA <em>reports</em> for an application only include web transactions. If your application creates only non-web transactions, New"
      },
      "id": "603ebe4d196a679981a83dc0"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-10-08T01:22:31Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.98256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "1. Assemble a cross-functional team to review <em>service</em> delivery",
        "body": " to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key <em>service</em> delivery stakeholders to assess your team&#x27;s progress against <em>service</em> <em>level</em> objectives (SLOs) and <em>service</em> <em>level</em> <em>agreements</em> (SLAs), while facilitating further optimizations"
      },
      "id": "60440e5364441fb0c6378ef6"
    },
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-10-07T06:53:16Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.27559,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly performance <em>report</em> ",
        "sections": "Weekly performance <em>report</em>",
        "tags": "<em>Reports</em>",
        "body": " than <em>APM</em>&#x27;s <em>Service</em> <em>Level</em> <em>Agreement</em> (SLA) <em>reports</em>. Important At this time, weekly performance <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly performance <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    }
  ],
  "/docs/apm/reports/service-level-agreements/apm-sla-reports": [
    {
      "sections": [
        "API examples for SLA reports",
        "Tip",
        "Browser metrics for SLAs",
        "App server metrics for SLAs",
        "Tips for collecting metrics",
        "Examples",
        "REST API v2 commands",
        "Browser load time and page view count (v2)",
        "App response time and request count (v2)",
        "Apdex SLA data (v2)",
        "REST API v1 commands (deprecated)",
        "Browser load time and page view count (v1)",
        "App response time and request count (v1)",
        "Apdex SLA data (v1)",
        "Analyze your data"
      ],
      "title": "API examples for SLA reports",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Service level agreements"
      ],
      "external_id": "3b4dafc002932fc100b6375a3ae87b01350d57fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/service-level-agreements/api-examples-sla-reports/",
      "published_at": "2021-10-07T12:40:33Z",
      "updated_at": "2021-09-14T10:19:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic stores SLA data forever for eligible accounts, so you can use the New Relic REST API to generate service level agreement reports over any time period. For example, you can create SLA reports going back more than 12 days, weeks, or months. Tip Access to this feature depends on your subscription level. Browser metrics for SLAs Browser metrics for the End user tier are available only if you have installed the browser agent. Browser (End user tier) SLA metric name:value (and formula) Page Views thousands EndUser : call_count Load time sec EndUser : average_response_time Apdex EndUser/Apdex : score % Satisfied EndUser/Apdex : s divided by EndUser : call_count % Tolerating EndUser/Apdex : t divided by Enduser : call_count % Frustrated EndUser/Apdex : f divided by Enduser : call_count App server metrics for SLAs Here are the SLA metrics for application servers. App server SLA metric name:value (and formula) Requests millions HttpDispatcher : call_count (scaled appropriately) Resp. time ms HttpDispatcher : average_response_time (multiplied by 1000) Apdex Apdex : score % Satisfied Apdex : s divided by Apdex : count % Tolerating Apdex : t divided by Apdex : count % Frustrated Apdex : f divided by Apdex : count Tips for collecting metrics Here are some tips for planning which metrics to collect. SLA tips Comments Requirements When using the cURL command examples, be sure to replace the placeholder text with your account ID, an API key, and the application ID. Time ranges You are not limited to standard day, week, or month time ranges. For example, you can extract metric data for a \"holiday weekend\" from 12/23 to 12/26 or \"the 20 minutes after our site had problems\" or whatever other period interests you. UTC XML time format You must specify the time in UTC XML format, so be sure to adjust for your time zone compared to UTC. For example, New Relic starts at 16:00:00 on the day before the selected data, since New Relic headquarters are in UTC-8. Summary reports When requesting metrics to use with summary reports, include the query string parameter summarize=true (v2) or summary=1 (v1) as shown in the examples. Scaled statistics Your report has some statistics that are scaled in the SLA reports in New Relic's user interface. New Relic changes the scale of page views in your report to show small numbers. Depending on your traffic, typically it might be displayed in thousands, millions, or billions. Recommendation: To avoid a string of zeroes, divide this number appropriately for your own purposes. End user statistics End user statistics will reflect only the calls in which the agent gathered browser data. For example, end user stats may not appear in situations such as: Browser types Clients (they might have disabled the JavaScript agent, or blocked traffic to New Relic sites for JavaScript code's location Transactions not in one of those categories, in case the page load did not complete for any reason This is why there are fewer (sometimes many fewer) page views in the End User (browser) data section than in the App server data section. Examples The following sections contain code examples to acquire the data for values described above for the Daily (24hr) SLA statistics in the default GMT/UTC time zone. Adjust the from= and to= for your time range as desired. There are syntactical differences between New Relic's REST API v2 and v1. The examples show how to use each. REST API v2 commands Browser load time and page view count (v2) To obtain the browser (EndUser/RUM) load time and page view count for v2, from the command line, type: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml\"\\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=EndUser&values[]=call_count&values[]=average_response_time&from=2014-06-09T00:00:00+00:00&to=2014-06-09T23:00:00+00:00&summarize=true' Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.http_get(\"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml?names[]=EndUser&values[]=call_count&values[]=average_response_time&from=2012-01-01T00:00:00+00:00&to=2012-01-08T00:00:00+00:00&summarize=true\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" curl.header_in_body=true end puts response.body_str Copy App response time and request count (v2) To obtain the Application response time and request count for v2, from the command line, type: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_response_time&values[]=call_count&from=2014-06-09T00:00:00+00:00&to=2014-06-09T23:00:00+00:00&summarize=true' Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.http_get(\"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml?names[]=HttpDispatcher&values[]=average_response_time&values[]=call_count&from=2012-01-01T00:00:00+00:00&to=2012-01-08T00:00:00+00:00&summarize=true\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" curl.header_in_body=true end puts response.body_str Copy Apdex SLA data (v2) To obtain the Apdex related data for v2, from the command line, type: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00+00:00&to=2014-06-09T23:00:00+00:00&summarize=true' Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.http_get(\"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml?names[]=EndUser/Apdex&from=2012-01-01T00:00:00+00:00&to=2012-01-08T00:00:00+00:00&summarize=true\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" curl.header_in_body=true end puts response.body_str Copy REST API v1 commands (deprecated) REST API v1 is deprecated. Browser load time and page view count (v1) To obtain the browser (EndUser/RUM) load time and page view count for v1, from the command line, type: curl -gH \"api-key:$API_KEY\" \"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=EndUser&field=call_count&field=average_response_time&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\" Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.perform(\"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=EndUser&field=call_count&field=average_response_time&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" end puts response.body_str Copy App response time and request count (v1) To obtain the Application response time and request count for v1, from the command line, type: curl -gH \"api-key:$API_KEY\" \"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=HttpDispatcher&field=average_response_time&field=call_count&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\" Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.perform(\"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=HttpDispatcher&field=average_response_time&field=call_count&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" end puts response.body_str Copy Apdex SLA data (v1) To obtain the Apdex related data for v1, from the command line, type: curl -gH \"api-key:$API_KEY\" \"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=Apdex&metrics[]=EndUser/Apdex&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\" Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.perform(\"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=Apdex&metrics[]=EndUser/Apdex&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" end puts response.body_str Copy Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.2513,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "API examples for SLA <em>reports</em>",
        "sections": "API examples for SLA <em>reports</em>",
        "tags": "<em>Service</em> <em>level</em> <em>agreements</em>",
        "body": "New Relic stores SLA data forever for eligible accounts, so you can use the New Relic REST API to generate <em>service</em> <em>level</em> <em>agreement</em> <em>reports</em> over any time period. For example, you can create SLA <em>reports</em> going back more than 12 days, weeks, or months. Tip Access to this feature depends on your"
      },
      "id": "603ebe82196a67631fa83dd7"
    },
    {
      "sections": [
        "Operations review: assess and optimize team progress",
        "Prerequisites",
        "1. Assemble a cross-functional team to review service delivery",
        "Tip",
        "2. Review service records and note key metrics",
        "Daily uptime",
        "Device performance breakdown",
        "Top URL performance",
        "Memory usage",
        "Server CPU",
        "3. Summarize events related to application alerts, downtime, and errors",
        "4. Create follow-up tracking tickets"
      ],
      "title": "Operations review: assess and optimize team progress",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Measure DevOps success"
      ],
      "external_id": "d49e90d09db035b5685c49914cf645121b02de31",
      "image": "https://docs.newrelic.com/static/927c2719a1b7aebc3bb504582337219f/1fbe8/Insights-Devops-Catalyst-Example.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/operations-review-assess-optimize-team-progress/",
      "published_at": "2021-10-08T01:22:31Z",
      "updated_at": "2021-07-09T15:09:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a DevOps world, a deep understanding of customer expectations and your progress in meeting those expectations is vital to providing stability, maintaining goodwill with your users, and increasing business value. With New Relic you can measure the success of your DevOps initiatives and learn how to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key service delivery stakeholders to assess your team's progress against service level objectives (SLOs) and service level agreements (SLAs), while facilitating further optimizations. Prerequisites This tutorial assumes you’ve completed the Establish objectives and baseline tutorial. 1. Assemble a cross-functional team to review service delivery The first (and most important step) is assembling the right team. Identify the proper stakeholders and representatives to play active parts in the operations review process. This team should be comprised of individuals who develop applications, work with service delivery, maintain your ecosystem, and resolve problems for customers. While operations review teams often focus on technical members, the best teams have broad representation across the company, including representatives from Business Operations, Marketing, and Support. These cross-functional teams help ensure that the service delivery process is strongly integrated with customer expectations. If you can specifically identify how technical improvements meet customer expectations and positively impact the business’s bottom line, then your operations team is functioning at optimal levels. Tip Ideally, the cross-functional operations review team should also be the team that defines your SLOs. If this is not possible, try to ensure that some members of the operations review team are also on the team responsible for SLOs. 2. Review service records and note key metrics Create a regular meeting to track your service records. New Relic recommends reviewing your previous service records, and pinpointing specific metrics to analyze at every review. For example, start with application state, alert conditions, and runtime anomalies. Look at the same metrics on two separate occasions to identify and assess patterns, inconsistencies, and anomalies. Monitor these metrics using the service delivery Insights dashboards you created in the Establish objectives and baselines tutorial. The widgets on these dashboards provide a high-level overview of the relationships between different performance indicators and baselines: insights.newrelic.com > (select a dashboard): Use dashboards to visualize metrics related to service delivery. When conducting a thorough performance review, make several dashboards that have corresponding widgets. Use these dashboards to hone-in on two specific time periods that you want to compare. This comparative analysis could cover everything from Infrastructure or browser performance, to Synthetics testing or business impact. To get started with performance indicators in Insights, read the following example queries. These queries provide information that you can consider incorporating for the operations review. Daily uptime SELECT percentage(count(result), where result = 'SUCCESS') from SyntheticCheck since 1 Day ago Copy Create dashboards that are dedicated to the functionality that drives your software development process, such as testing. For example, collect related metrics on uptime, types of monitors, geo-locations, and other data points that are required for appropriately measuring SLAs. The following dashboard provides such an example: insights.newrelic.com > (select a dashboard): Track your relevant SLAs together in one dashboard. Device performance breakdown SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView FACET deviceType LIMIT 3 SINCE 1 day ago Copy Top URL performance SELECT count(*) as '# Pages',average(duration) as 'AVG',percentile(duration,50,75) as '%',average(duration - backendDuration) as 'Front',average(backendDuration) as 'Back',average(connectionSetupDuration) as 'Connection',average(domProcessingDuration) as 'DOM Processing',average(pageRenderingDuration) as 'Page Rendering' FROM PageView facet pageUrl SINCE 1 day ago limit 30 Copy Memory usage SELECT average(memoryUsedBytes) /1000000 AS 'Avg MB Used', average(memoryFreeBytes)/1000000 AS 'Avg MB Free', average(memoryFreeBytes/memoryTotalBytes)*100 as 'Memory used %' FROM SystemSample since 30 minutes ago Copy Server CPU SELECT average(cpuPercent) FROM SystemSample since 3 hours ago facet hostname limit 400 Copy Combine the results into a single dashboard to help drive decisions during your operations review. Dashboards that give a brief overview of performance across your entire application stack are invaluable for cross-functional team reviews. Tip Beyond Insights, the APM reports allow you to see how you’re performing on a daily, weekly, and monthly basis with built in SLA reports and other detailed reports. The out-of-the-box details from these reports give your operations team a launch pad for conversations about progress against objectives and overall performance. 3. Summarize events related to application alerts, downtime, and errors Now that you’ve gathered data about your service delivery, the next step is to dive deeper into specific incidents that warrant further investigation or surface a need for broader team action. For example, notable downtime and errors are key areas to investigate as a team. After completing the Setup proactive alerting tutorial, you can explore notifications of violations as they occur. Once these violations are brought to your attention, acknowledge the specific incident and have an ongoing record of both opened and closed incidents. Use the incident reports as a focal point for discussion of gaps. alerts.newrelic.com > Incidents: Identify performance issues and SLA gaps with New Relic Alerts incident reports. Ultimately, it’s important to solicit feedback from the cross-functional team on the causes of the incidents to determine how you can improve service delivery processes to prevent reoccurrences. One approach might be to focus on one or two notable incidents, use the New Relic UI to walk through the data points leading up to those incidents, and assess the actions that occurred. Summarize the incident and the cross-functional feedback on causes and potential solutions as succinctly as possible. Over time, you’ll notice patterns that will require deeper action. 4. Create follow-up tracking tickets With built-in or customizable integrations with ServiceNow and other common ticketing systems, New Relic helps you follow up on anomalies and performance shortfalls as they arise. Add the information provided by New Relic to the tracking system, and ensure that the team charged with solving the problem has all of the details they need to track down and resolve the issue.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 67.98256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "1. Assemble a cross-functional team to review <em>service</em> delivery",
        "body": " to identify, resolve, and decrease any gaps in your DevOps performance. In this tutorial, you’ll gather key <em>service</em> delivery stakeholders to assess your team&#x27;s progress against <em>service</em> <em>level</em> objectives (SLOs) and <em>service</em> <em>level</em> <em>agreements</em> (SLAs), while facilitating further optimizations"
      },
      "id": "60440e5364441fb0c6378ef6"
    },
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-10-07T06:53:16Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.27559,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly performance <em>report</em> ",
        "sections": "Weekly performance <em>report</em>",
        "tags": "<em>Reports</em>",
        "body": " than <em>APM</em>&#x27;s <em>Service</em> <em>Level</em> <em>Agreement</em> (SLA) <em>reports</em>. Important At this time, weekly performance <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly performance <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    }
  ],
  "/docs/apm/transactions/cross-application-traces/introduction-cross-application-traces": [
    {
      "sections": [
        "Troubleshoot cross application tracing",
        "Agent versions and protocols",
        "Config file requirements",
        "High throughput apps",
        "Proxies",
        "Multi-threaded processing (Java)",
        "Multiple accounts"
      ],
      "title": "Troubleshoot cross application tracing",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Cross application traces"
      ],
      "external_id": "fa4ecccd4906018947e6e36fbe96b78d6c005893",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/cross-application-traces/troubleshoot-cross-application-tracing/",
      "published_at": "2021-10-07T16:48:05Z",
      "updated_at": "2021-07-16T00:57:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are troubleshooting tips when using cross application traces. Note that this feature is not the same as distributed tracing, which is preferred over cross application tracing. Agent versions and protocols Make sure you meet these requirements for your agent's version, protocols, interfaces, or message queue libraries. If you are using a protocol that is not listed here, you will not see a connection between your applications. Agent version Notes C SDK Use distributed tracing. Go 1.11 or higher HTTP, HTTPS Java 3.9.0 or higher HTTP, HTTPs, JMS 1.1, RabbitMQ The Java agent also supports several message queue libraries, including those that use the JMS 1.1 interface. .NET 4.2 or higher HTTP, and supported .NET messaging systems Node.js 2.0.0 or higher HTTP, HTTPS, RabbitMQ PHP 4.19.0 or higher HTTP, HTTPS, and supported PHP message queuing systems Python 2.38.0.31 or higher HTTP, HTTPS, and supported Python message queuing systems Ruby 4.3.0 or higher HTTP, HTTPS, RabbitMQ Config file requirements In general, New Relic's cross application tracing feature is enabled by default. Requirements to change your configuration file vary, depending on your New Relic agent: C SDK (not supported) Go (not supported) Java .NET Node.js (no specific config file settings needed for Node.js) PHP Python Ruby High throughput apps Cross application traces rely on transaction events to associate related transactions. If you have a high throughput application, your agent may reach the maximum number of events that it can record in a minute and will fall back to sampling events. If a transaction’s events are sampled, you may see an incomplete cross application trace, including sometimes only the transactions that you are focused on. If your application has high throughput, some cross application traces will appear incomplete, sometimes with no links. Try viewing a different transaction trace. To reduce or eliminate sampling, you can also adjust the number of transaction events stored in your agent configuration. High throughput apps Troubleshooting tips Java From the transaction_events stanza, adjust the setting for max_samples_stored. Ruby Adjust the setting for analytics_events.max_samples_stored. Proxies If you expect to see a cross application trace link but it consistently does not appear, there may be a proxy or broker between your application’s communication. Cross application tracing relies on HTTP headers and JMS properties being passed from one application to other. HTTP proxies and message brokers sometimes strip those headers. Multi-threaded processing (Java) If one or more of your Java applications uses an async or \"reactive\" programming model, a transaction's activity may span across multiple threads. New Relic supports the Play framework and Servlet Async but not all async frameworks. For unsupported frameworks, activity on other threads is not reported as part of the transaction. Calls to other applications will not be traced. Multiple accounts Currently cross application traces do not cross New Relic accounts. If you have multiple New Relic accounts (including child accounts), you will only see traces for applications within one account. Our distributed tracing feature does cross account boundaries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.06189,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>cross</em> <em>application</em> <em>tracing</em>",
        "sections": "Troubleshoot <em>cross</em> <em>application</em> <em>tracing</em>",
        "tags": "<em>Cross</em> <em>application</em> <em>traces</em>",
        "body": " (not supported) Go (not supported) Java .NET Node.js (no specific config file settings needed for Node.js) PHP Python Ruby High throughput apps <em>Cross</em> <em>application</em> <em>traces</em> rely on transaction events to associate related <em>transactions</em>. If you have a high throughput <em>application</em>, your agent may reach the maximum"
      },
      "id": "603ec3cfe7b9d22f912a07af"
    },
    {
      "sections": [
        "Transactions in New Relic's APM",
        "What is a transaction?",
        "Types of transactions",
        "Transaction sub-types",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.JS",
        "PHP",
        "Python",
        "Ruby",
        "Transaction segments",
        "Transaction naming",
        "Monitoring transactions",
        "Tip",
        "Query transactions"
      ],
      "title": "Transactions in New Relic's APM",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "2a96f455cbf6dfdc5dda2363ba4e69b6f9dba159",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/",
      "published_at": "2021-10-07T08:48:24Z",
      "updated_at": "2021-09-14T02:55:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The word transaction can have several different meanings in the software industry. This document explains how the term is used by New Relic and how transactions are reported. What is a transaction? At New Relic, a transaction is defined as one logical unit of work in a software application. Specifically, it refers to the function calls and method calls that make up that unit of work. For APM, it will often refer to a web transaction, which represents activity that happens from when the application receives a web request to when the response is sent. When you install APM in a supported system, it begins automatically reporting web requests and other important functions and methods. To supplement the default level of monitoring, you can set up custom instrumentation to report additional transactions. Some frameworks do not have a natural concept of a transaction. In other words, there are no predefined pathways that can easily be recognized or monitored as transactions. To define transactions in such frameworks, you can use custom instrumentation. Types of transactions Cumulative transaction data appears in APM on the Transactions page. The two main categories of transactions are web and non-web: Web: Transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. Non-web: Non-web transactions are not initiated with a web request. They can include non-web worker processes, background processes, scripts, message queue activity, and other tasks. Transaction sub-types Our agents have these transaction sub-types: C SDK Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Function The invocation of the named function. Go Doesn't apply. Java Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. framework The invocation of a framework that is recognized by the agent. .NET Sub-type Description Action The invocation of the named framework action. Used when the agent is able to identify a framework-specific action name. ASP The invocation of an ASP.NET request. Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. MonoRail The invocation of a MonoRail request. MVC The invocation of a MVC request. OpenRasta The invocation of an OpenRasta request. StatusCode The HTTP status code returned for the transaction. Often used when a more specific transaction sub-type is unavailable. WCF The invocation of a WCF request. WebAPI The invocation of a WebAPI request. WebService The invocation of a WebService request. Node.JS Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Message Message broker or queue communication. PHP Sub-type Description Action The invocation of the named framework action. Used when the agent is able to identify a framework-specific action name. Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Function The invocation of the named function. PHP The invocation of a background PHP job. StatusCode The HTTP status code returned for the transaction. Often used when a more specific transaction sub-type is unavailable. unknown The invocation of an unknown web transaction or background job. URI The invocation of the named URI. Usually used when a framework or language level transaction name cannot be determined. Python Sub-type Description ASGIWeb WebTransaction from an ASGI application. Message Message broker or queue communication. WSGIWeb WebTransaction from a WSGI application. Ruby Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Transaction segments The individual functions and calls that make up a transaction are called segments. For example external service calls and database calls are segments, and both have their own UI pages in APM. The APM Transactions page displays aggregate transaction segment data. To add segments to a transaction, use custom instrumentation. To see the segments of a specific transaction, use transaction traces. Transaction naming For supported frameworks, transaction names can come from various sources, such as the name given to the transaction by the framework, function names detected during the transaction, or a web request's URL. For transactions that produce many names with a similar format, we consolidate those into general transaction categories. For example, a transaction might be displayed as /user/*/control_panel, where the * represents different user names. To rename transactions or adjust how names are consolidated, use custom instrumentation. Monitoring transactions Here are some other ways you can use APM to monitor transactions: If you want to monitor... Use this... Transactions important to your business Create key transactions, which emphasizes them in the UI and lets you set a custom level of monitoring for them. Async activity Follow the procedures to set up asynchronous activity for your specific APM language agent. Activity across applications Linking transactions across applications gives you more detail about business-relevant application activity. For more information, see the documentation about distributed tracing and cross application traces. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query transactions Transactions are available for querying with an in-depth set of default attributes attached. Using these attributes, you can run queries and create custom charts that APM does not provide by default. For information on how to query your data using our UI or NRQL, see Query New Relic data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.22589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transactions</em> in New Relic&#x27;s <em>APM</em>",
        "sections": "<em>Transactions</em> in New Relic&#x27;s <em>APM</em>",
        "tags": "<em>Transactions</em>",
        "body": ". For more information, see the documentation about distributed tracing and <em>cross</em> <em>application</em> <em>traces</em>. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query <em>transactions</em> <em>Transactions</em> are available for querying with an in-depth set of default attributes"
      },
      "id": "603e8774e7b9d2a6a42a07bc"
    },
    {
      "sections": [
        "Monitor background processes and other non-web transactions",
        "What are non-web transactions?",
        "Create non-web transactions",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Important",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "View non-web transactions"
      ],
      "title": "Monitor background processes and other non-web transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "aca55742ecc24a7f6bf212b853777224317d8924",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions/",
      "published_at": "2021-10-07T06:56:23Z",
      "updated_at": "2021-09-14T05:58:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains what non-web transactions are in APM, and how you can instrument background tasks and other arbitrary activity to be reported as non-web transactions. What are non-web transactions? The two main APM transaction categories are web and non-web. Web transactions are transactions we detect as being initiated by a web request; they are the most common type of transaction reported by APM. Non-web transactions are transactions that are not web transactions; we do not detect they were initiated by a web request. This includes processes and jobs that do not handle web requests, such as message processing and background tasks. For example, you might schedule something to run periodically on your server to do database work, send emails, etc. The source is not a web request but something on your server. Some non-web transactions from supported frameworks or services are detected automatically by New Relic; others may be created using custom instrumentation. We intentionally separate your web and non-web transactions in the UI. Non-web vs. web transactions Comments Less directly important Non-web transactions are often background processes and tasks, and they are less directly important to your application's users when compared to web transactions. Long running Non-web transactions are often long-running processes. Separating them from web transactions prevents those results from skewing your customer-facing response times. Omitted from Apdex score Combining your non-web transactions with your web transactions would hurt your Apdex score (a measure of satisfaction with load times). This is why Apdex data for non-web transactions does not appear in the UI. Create non-web transactions To create new non-web transactions, follow the procedures for your APM language agent. C SDK Follow the procedures for instrumenting a non-web transaction. Go Follow the procedures for instrumenting a non-web transaction. Java Follow the procedures for instrumenting a transaction (instrumenting a transaction without web request parameters creates a non-web transaction). .NET By default, the APM .NET agent instruments IIS ASP workers. To instrument other (non-IIS) .NET applications, such as standalone (WCF) services, console apps, and other Windows services, see Instrumenting custom applications and Instrumenting WCF applications. Important For IIS applications, you cannot change web transactions to non-web transactions. Node.js Use startBackgroundTransaction(). PHP To mark a transaction as non-web: use newrelic_background_job and set the flag to true. The PHP agent reports all command-line run scripts as non-web transactions. Python See Python agent non-web transactions. The Python agent also supports non-web transaction reporting from Celery and Gearman. Ruby See Ruby agent non-web transactions. View non-web transactions To view non-web transaction data in the New Relic UI, go to the main chart on the following pages, and then select the Non-web option in the dropdown: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Summary. APM: Go to one.newrelic.com > APM > (select an app) > Summary. Transactions: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.04912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Monitor background processes and other non-web <em>transactions</em>",
        "sections": "Monitor background processes and other non-web <em>transactions</em>",
        "tags": "<em>Transactions</em>",
        "body": "This document explains what non-web <em>transactions</em> are in <em>APM</em>, and how you can instrument background tasks and other arbitrary activity to be reported as non-web <em>transactions</em>. What are non-web <em>transactions</em>? The two main <em>APM</em> transaction categories are web and non-web. Web <em>transactions</em> are <em>transactions</em>"
      },
      "id": "6044288664441f124c378ec7"
    }
  ],
  "/docs/apm/transactions/cross-application-traces/troubleshoot-cross-application-tracing": [
    {
      "sections": [
        "Introduction to cross application traces",
        "What is cross application tracing?",
        "Important",
        "Security considerations"
      ],
      "title": "Introduction to cross application traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Cross application traces"
      ],
      "external_id": "54c3bf54fc29f6ea190f7cd3dc9e1e1c15a92193",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/cross-application-traces/introduction-cross-application-traces/",
      "published_at": "2021-10-07T09:38:45Z",
      "updated_at": "2021-09-14T10:20:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's cross application tracing lets you link transactions between your APM-monitored applications. What is cross application tracing? Important Instead of using cross application tracing, we recommend our distributed tracing features. Distributed tracing is an improvement on the cross application tracing feature and is recommended for large, distributed systems. APM's cross application traces link transactions between APM apps in your service-oriented architecture (SOA). This is useful, for example, to identify performance problems between your own application (the \"calling\" app) and any internal or external services (the \"called\" app), such as traffic to internal services. This helps you to: Spot bottlenecks in your cross application call flows. Understand from end to end how specific transactions are used by other applications and services. Diagnose problems faster and enhance collaboration across teams. Security considerations Cross application tracing relies on three HTTP headers in order to exchange information between the calling and called applications. The first two (X-NewRelic-ID and X-NewRelic-Transaction) appear as HTTP request headers in outgoing requests sent by an instrumented application. The remaining header (X-NewRelic-App-Data) is inserted into the HTTP response if the called application belongs to the same New Relic account as the calling application. New Relic obfuscates all of these headers using an obfuscation scheme identical to what we use for browser monitoring, but with a different key. HTTP header Description X-NewRelic-ID (in request header) Contains the account ID and application ID of the application making the call X-NewRelic-Transaction (in request header) Contains information about an individual transaction created by the call (a GUID unique to the calling transaction, along with information about upstream calls that spawned the transaction) X-NewRelic-App-Data (in the response if applicable) Contains information about the called application, including: Account ID Application ID Name of the called transaction Timing information for the called transaction GUID of the called transaction",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.23941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>cross</em> <em>application</em> <em>traces</em>",
        "sections": "Introduction to <em>cross</em> <em>application</em> <em>traces</em>",
        "tags": "<em>Cross</em> <em>application</em> <em>traces</em>",
        "body": " tracing feature and is recommended for large, distributed systems. <em>APM</em>&#x27;s <em>cross</em> <em>application</em> <em>traces</em> link <em>transactions</em> between <em>APM</em> apps in your service-oriented architecture (SOA). This is useful, for example, to identify performance problems between your own <em>application</em> (the &quot;calling&quot; app) and any"
      },
      "id": "603ebfc764441fcfd94e8873"
    },
    {
      "sections": [
        "Transactions in New Relic's APM",
        "What is a transaction?",
        "Types of transactions",
        "Transaction sub-types",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.JS",
        "PHP",
        "Python",
        "Ruby",
        "Transaction segments",
        "Transaction naming",
        "Monitoring transactions",
        "Tip",
        "Query transactions"
      ],
      "title": "Transactions in New Relic's APM",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "2a96f455cbf6dfdc5dda2363ba4e69b6f9dba159",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/",
      "published_at": "2021-10-07T08:48:24Z",
      "updated_at": "2021-09-14T02:55:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The word transaction can have several different meanings in the software industry. This document explains how the term is used by New Relic and how transactions are reported. What is a transaction? At New Relic, a transaction is defined as one logical unit of work in a software application. Specifically, it refers to the function calls and method calls that make up that unit of work. For APM, it will often refer to a web transaction, which represents activity that happens from when the application receives a web request to when the response is sent. When you install APM in a supported system, it begins automatically reporting web requests and other important functions and methods. To supplement the default level of monitoring, you can set up custom instrumentation to report additional transactions. Some frameworks do not have a natural concept of a transaction. In other words, there are no predefined pathways that can easily be recognized or monitored as transactions. To define transactions in such frameworks, you can use custom instrumentation. Types of transactions Cumulative transaction data appears in APM on the Transactions page. The two main categories of transactions are web and non-web: Web: Transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. Non-web: Non-web transactions are not initiated with a web request. They can include non-web worker processes, background processes, scripts, message queue activity, and other tasks. Transaction sub-types Our agents have these transaction sub-types: C SDK Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Function The invocation of the named function. Go Doesn't apply. Java Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. framework The invocation of a framework that is recognized by the agent. .NET Sub-type Description Action The invocation of the named framework action. Used when the agent is able to identify a framework-specific action name. ASP The invocation of an ASP.NET request. Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. MonoRail The invocation of a MonoRail request. MVC The invocation of a MVC request. OpenRasta The invocation of an OpenRasta request. StatusCode The HTTP status code returned for the transaction. Often used when a more specific transaction sub-type is unavailable. WCF The invocation of a WCF request. WebAPI The invocation of a WebAPI request. WebService The invocation of a WebService request. Node.JS Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Message Message broker or queue communication. PHP Sub-type Description Action The invocation of the named framework action. Used when the agent is able to identify a framework-specific action name. Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Function The invocation of the named function. PHP The invocation of a background PHP job. StatusCode The HTTP status code returned for the transaction. Often used when a more specific transaction sub-type is unavailable. unknown The invocation of an unknown web transaction or background job. URI The invocation of the named URI. Usually used when a framework or language level transaction name cannot be determined. Python Sub-type Description ASGIWeb WebTransaction from an ASGI application. Message Message broker or queue communication. WSGIWeb WebTransaction from a WSGI application. Ruby Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Transaction segments The individual functions and calls that make up a transaction are called segments. For example external service calls and database calls are segments, and both have their own UI pages in APM. The APM Transactions page displays aggregate transaction segment data. To add segments to a transaction, use custom instrumentation. To see the segments of a specific transaction, use transaction traces. Transaction naming For supported frameworks, transaction names can come from various sources, such as the name given to the transaction by the framework, function names detected during the transaction, or a web request's URL. For transactions that produce many names with a similar format, we consolidate those into general transaction categories. For example, a transaction might be displayed as /user/*/control_panel, where the * represents different user names. To rename transactions or adjust how names are consolidated, use custom instrumentation. Monitoring transactions Here are some other ways you can use APM to monitor transactions: If you want to monitor... Use this... Transactions important to your business Create key transactions, which emphasizes them in the UI and lets you set a custom level of monitoring for them. Async activity Follow the procedures to set up asynchronous activity for your specific APM language agent. Activity across applications Linking transactions across applications gives you more detail about business-relevant application activity. For more information, see the documentation about distributed tracing and cross application traces. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query transactions Transactions are available for querying with an in-depth set of default attributes attached. Using these attributes, you can run queries and create custom charts that APM does not provide by default. For information on how to query your data using our UI or NRQL, see Query New Relic data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.22589,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transactions</em> in New Relic&#x27;s <em>APM</em>",
        "sections": "<em>Transactions</em> in New Relic&#x27;s <em>APM</em>",
        "tags": "<em>Transactions</em>",
        "body": ". For more information, see the documentation about distributed tracing and <em>cross</em> <em>application</em> <em>traces</em>. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query <em>transactions</em> <em>Transactions</em> are available for querying with an in-depth set of default attributes"
      },
      "id": "603e8774e7b9d2a6a42a07bc"
    },
    {
      "sections": [
        "Monitor background processes and other non-web transactions",
        "What are non-web transactions?",
        "Create non-web transactions",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Important",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "View non-web transactions"
      ],
      "title": "Monitor background processes and other non-web transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "aca55742ecc24a7f6bf212b853777224317d8924",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions/",
      "published_at": "2021-10-07T06:56:23Z",
      "updated_at": "2021-09-14T05:58:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains what non-web transactions are in APM, and how you can instrument background tasks and other arbitrary activity to be reported as non-web transactions. What are non-web transactions? The two main APM transaction categories are web and non-web. Web transactions are transactions we detect as being initiated by a web request; they are the most common type of transaction reported by APM. Non-web transactions are transactions that are not web transactions; we do not detect they were initiated by a web request. This includes processes and jobs that do not handle web requests, such as message processing and background tasks. For example, you might schedule something to run periodically on your server to do database work, send emails, etc. The source is not a web request but something on your server. Some non-web transactions from supported frameworks or services are detected automatically by New Relic; others may be created using custom instrumentation. We intentionally separate your web and non-web transactions in the UI. Non-web vs. web transactions Comments Less directly important Non-web transactions are often background processes and tasks, and they are less directly important to your application's users when compared to web transactions. Long running Non-web transactions are often long-running processes. Separating them from web transactions prevents those results from skewing your customer-facing response times. Omitted from Apdex score Combining your non-web transactions with your web transactions would hurt your Apdex score (a measure of satisfaction with load times). This is why Apdex data for non-web transactions does not appear in the UI. Create non-web transactions To create new non-web transactions, follow the procedures for your APM language agent. C SDK Follow the procedures for instrumenting a non-web transaction. Go Follow the procedures for instrumenting a non-web transaction. Java Follow the procedures for instrumenting a transaction (instrumenting a transaction without web request parameters creates a non-web transaction). .NET By default, the APM .NET agent instruments IIS ASP workers. To instrument other (non-IIS) .NET applications, such as standalone (WCF) services, console apps, and other Windows services, see Instrumenting custom applications and Instrumenting WCF applications. Important For IIS applications, you cannot change web transactions to non-web transactions. Node.js Use startBackgroundTransaction(). PHP To mark a transaction as non-web: use newrelic_background_job and set the flag to true. The PHP agent reports all command-line run scripts as non-web transactions. Python See Python agent non-web transactions. The Python agent also supports non-web transaction reporting from Celery and Gearman. Ruby See Ruby agent non-web transactions. View non-web transactions To view non-web transaction data in the New Relic UI, go to the main chart on the following pages, and then select the Non-web option in the dropdown: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Summary. APM: Go to one.newrelic.com > APM > (select an app) > Summary. Transactions: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.04912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Monitor background processes and other non-web <em>transactions</em>",
        "sections": "Monitor background processes and other non-web <em>transactions</em>",
        "tags": "<em>Transactions</em>",
        "body": "This document explains what non-web <em>transactions</em> are in <em>APM</em>, and how you can instrument background tasks and other arbitrary activity to be reported as non-web <em>transactions</em>. What are non-web <em>transactions</em>? The two main <em>APM</em> transaction categories are web and non-web. Web <em>transactions</em> are <em>transactions</em>"
      },
      "id": "6044288664441f124c378ec7"
    }
  ],
  "/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions": [
    {
      "sections": [
        "Transactions in New Relic's APM",
        "What is a transaction?",
        "Types of transactions",
        "Transaction sub-types",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.JS",
        "PHP",
        "Python",
        "Ruby",
        "Transaction segments",
        "Transaction naming",
        "Monitoring transactions",
        "Tip",
        "Query transactions"
      ],
      "title": "Transactions in New Relic's APM",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "2a96f455cbf6dfdc5dda2363ba4e69b6f9dba159",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/",
      "published_at": "2021-10-07T08:48:24Z",
      "updated_at": "2021-09-14T02:55:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The word transaction can have several different meanings in the software industry. This document explains how the term is used by New Relic and how transactions are reported. What is a transaction? At New Relic, a transaction is defined as one logical unit of work in a software application. Specifically, it refers to the function calls and method calls that make up that unit of work. For APM, it will often refer to a web transaction, which represents activity that happens from when the application receives a web request to when the response is sent. When you install APM in a supported system, it begins automatically reporting web requests and other important functions and methods. To supplement the default level of monitoring, you can set up custom instrumentation to report additional transactions. Some frameworks do not have a natural concept of a transaction. In other words, there are no predefined pathways that can easily be recognized or monitored as transactions. To define transactions in such frameworks, you can use custom instrumentation. Types of transactions Cumulative transaction data appears in APM on the Transactions page. The two main categories of transactions are web and non-web: Web: Transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. Non-web: Non-web transactions are not initiated with a web request. They can include non-web worker processes, background processes, scripts, message queue activity, and other tasks. Transaction sub-types Our agents have these transaction sub-types: C SDK Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Function The invocation of the named function. Go Doesn't apply. Java Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. framework The invocation of a framework that is recognized by the agent. .NET Sub-type Description Action The invocation of the named framework action. Used when the agent is able to identify a framework-specific action name. ASP The invocation of an ASP.NET request. Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. MonoRail The invocation of a MonoRail request. MVC The invocation of a MVC request. OpenRasta The invocation of an OpenRasta request. StatusCode The HTTP status code returned for the transaction. Often used when a more specific transaction sub-type is unavailable. WCF The invocation of a WCF request. WebAPI The invocation of a WebAPI request. WebService The invocation of a WebService request. Node.JS Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Message Message broker or queue communication. PHP Sub-type Description Action The invocation of the named framework action. Used when the agent is able to identify a framework-specific action name. Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Function The invocation of the named function. PHP The invocation of a background PHP job. StatusCode The HTTP status code returned for the transaction. Often used when a more specific transaction sub-type is unavailable. unknown The invocation of an unknown web transaction or background job. URI The invocation of the named URI. Usually used when a framework or language level transaction name cannot be determined. Python Sub-type Description ASGIWeb WebTransaction from an ASGI application. Message Message broker or queue communication. WSGIWeb WebTransaction from a WSGI application. Ruby Sub-type Description Custom The execution of the named custom transaction. Usually recorded via manual instrumentation APIs. Transaction segments The individual functions and calls that make up a transaction are called segments. For example external service calls and database calls are segments, and both have their own UI pages in APM. The APM Transactions page displays aggregate transaction segment data. To add segments to a transaction, use custom instrumentation. To see the segments of a specific transaction, use transaction traces. Transaction naming For supported frameworks, transaction names can come from various sources, such as the name given to the transaction by the framework, function names detected during the transaction, or a web request's URL. For transactions that produce many names with a similar format, we consolidate those into general transaction categories. For example, a transaction might be displayed as /user/*/control_panel, where the * represents different user names. To rename transactions or adjust how names are consolidated, use custom instrumentation. Monitoring transactions Here are some other ways you can use APM to monitor transactions: If you want to monitor... Use this... Transactions important to your business Create key transactions, which emphasizes them in the UI and lets you set a custom level of monitoring for them. Async activity Follow the procedures to set up asynchronous activity for your specific APM language agent. Activity across applications Linking transactions across applications gives you more detail about business-relevant application activity. For more information, see the documentation about distributed tracing and cross application traces. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query transactions Transactions are available for querying with an in-depth set of default attributes attached. Using these attributes, you can run queries and create custom charts that APM does not provide by default. For information on how to query your data using our UI or NRQL, see Query New Relic data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.54126,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transactions</em> in New Relic&#x27;s <em>APM</em>",
        "sections": "<em>Transactions</em> in New Relic&#x27;s <em>APM</em>",
        "tags": "<em>Intro</em> <em>to</em> <em>transactions</em>",
        "body": ", there are no predefined pathways that can easily be recognized or monitored as <em>transactions</em>. To define <em>transactions</em> in such frameworks, you can use custom instrumentation. Types of <em>transactions</em> Cumulative transaction data appears in <em>APM</em> on the <em>Transactions</em> page. The two main categories of <em>transactions</em>"
      },
      "id": "603e8774e7b9d2a6a42a07bc"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.0472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> traces: Trace details page",
        "sections": "<em>Transaction</em> traces: Trace details page",
        "tags": "<em>Transactions</em>",
        "body": "In <em>APM</em>, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a transaction"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.967285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> traces",
        "sections": "No traces appear for any <em>transactions</em>.",
        "tags": "<em>Transactions</em>",
        "body": ". It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don&#x27;t see the transaction listed on the <em>APM</em> <em>Transactions</em> page, your <em>APM</em> agent is not capturing the activity as a transaction. In this situation, you must set up"
      },
      "id": "6044280ee7b9d260d35799d6"
    }
  ],
  "/docs/apm/transactions/intro-transactions/transactions-new-relic-apm": [
    {
      "sections": [
        "Monitor background processes and other non-web transactions",
        "What are non-web transactions?",
        "Create non-web transactions",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Important",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "View non-web transactions"
      ],
      "title": "Monitor background processes and other non-web transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "aca55742ecc24a7f6bf212b853777224317d8924",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions/",
      "published_at": "2021-10-07T06:56:23Z",
      "updated_at": "2021-09-14T05:58:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains what non-web transactions are in APM, and how you can instrument background tasks and other arbitrary activity to be reported as non-web transactions. What are non-web transactions? The two main APM transaction categories are web and non-web. Web transactions are transactions we detect as being initiated by a web request; they are the most common type of transaction reported by APM. Non-web transactions are transactions that are not web transactions; we do not detect they were initiated by a web request. This includes processes and jobs that do not handle web requests, such as message processing and background tasks. For example, you might schedule something to run periodically on your server to do database work, send emails, etc. The source is not a web request but something on your server. Some non-web transactions from supported frameworks or services are detected automatically by New Relic; others may be created using custom instrumentation. We intentionally separate your web and non-web transactions in the UI. Non-web vs. web transactions Comments Less directly important Non-web transactions are often background processes and tasks, and they are less directly important to your application's users when compared to web transactions. Long running Non-web transactions are often long-running processes. Separating them from web transactions prevents those results from skewing your customer-facing response times. Omitted from Apdex score Combining your non-web transactions with your web transactions would hurt your Apdex score (a measure of satisfaction with load times). This is why Apdex data for non-web transactions does not appear in the UI. Create non-web transactions To create new non-web transactions, follow the procedures for your APM language agent. C SDK Follow the procedures for instrumenting a non-web transaction. Go Follow the procedures for instrumenting a non-web transaction. Java Follow the procedures for instrumenting a transaction (instrumenting a transaction without web request parameters creates a non-web transaction). .NET By default, the APM .NET agent instruments IIS ASP workers. To instrument other (non-IIS) .NET applications, such as standalone (WCF) services, console apps, and other Windows services, see Instrumenting custom applications and Instrumenting WCF applications. Important For IIS applications, you cannot change web transactions to non-web transactions. Node.js Use startBackgroundTransaction(). PHP To mark a transaction as non-web: use newrelic_background_job and set the flag to true. The PHP agent reports all command-line run scripts as non-web transactions. Python See Python agent non-web transactions. The Python agent also supports non-web transaction reporting from Celery and Gearman. Ruby See Ruby agent non-web transactions. View non-web transactions To view non-web transaction data in the New Relic UI, go to the main chart on the following pages, and then select the Non-web option in the dropdown: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Summary. APM: Go to one.newrelic.com > APM > (select an app) > Summary. Transactions: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.74138,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Monitor background processes and other non-web <em>transactions</em>",
        "sections": "Monitor background processes and other non-web <em>transactions</em>",
        "tags": "<em>Intro</em> <em>to</em> <em>transactions</em>",
        "body": "This document explains what non-web <em>transactions</em> are in <em>APM</em>, and how you can instrument background tasks and other arbitrary activity to be reported as non-web <em>transactions</em>. What are non-web <em>transactions</em>? The two main <em>APM</em> transaction categories are web and non-web. Web <em>transactions</em> are <em>transactions</em>"
      },
      "id": "6044288664441f124c378ec7"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.0472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> traces: Trace details page",
        "sections": "<em>Transaction</em> traces: Trace details page",
        "tags": "<em>Transactions</em>",
        "body": "In <em>APM</em>, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a transaction"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.967285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> traces",
        "sections": "No traces appear for any <em>transactions</em>.",
        "tags": "<em>Transactions</em>",
        "body": ". It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don&#x27;t see the transaction listed on the <em>APM</em> <em>Transactions</em> page, your <em>APM</em> agent is not capturing the activity as a transaction. In this situation, you must set up"
      },
      "id": "6044280ee7b9d260d35799d6"
    }
  ],
  "/docs/apm/transactions/key-transactions/create-update-key-transactions": [
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-10-07T06:34:30Z",
      "updated_at": "2021-09-14T02:57:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.6055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Key transaction charts and data",
        "Overview page",
        "SLA report page",
        "Alerts"
      ],
      "title": "Key transaction charts and data",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "7eee1868178054d18f55452b0989d724546d8016",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/key-transaction-charts-data/",
      "published_at": "2021-10-07T17:55:36Z",
      "updated_at": "2021-09-14T02:56:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, every key transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the key transaction index, the key transaction's Overview page appears. The Overview page contains charts for response time, Apdex, throughput, and other data. It is similar to the main Overview page in APM, with standard New Relic page functions. SLA report page The SLA report page for a key transaction displays Service Level Agreement reports for that transaction. The SLA reports include daily and weekly data about throughput, response time, and Apdex. You can also download the report as a comma-separated value (CSV) spreadsheet. Alerts When you select a transaction from the key transaction index, you can also see options to view alert condition violations and set alert policies.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.60443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Key</em> <em>transaction</em> charts and data",
        "sections": "<em>Key</em> <em>transaction</em> charts and data",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, every <em>key</em> transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the <em>key</em> transaction index, the <em>key</em> transaction&#x27;s Overview page appears"
      },
      "id": "603ebd1128ccbc1ceaeba784"
    },
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-10-07T16:53:05Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.8985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    }
  ],
  "/docs/apm/transactions/key-transactions/introduction-key-transactions": [
    {
      "sections": [
        "Key transaction charts and data",
        "Overview page",
        "SLA report page",
        "Alerts"
      ],
      "title": "Key transaction charts and data",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "7eee1868178054d18f55452b0989d724546d8016",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/key-transaction-charts-data/",
      "published_at": "2021-10-07T17:55:36Z",
      "updated_at": "2021-09-14T02:56:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, every key transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the key transaction index, the key transaction's Overview page appears. The Overview page contains charts for response time, Apdex, throughput, and other data. It is similar to the main Overview page in APM, with standard New Relic page functions. SLA report page The SLA report page for a key transaction displays Service Level Agreement reports for that transaction. The SLA reports include daily and weekly data about throughput, response time, and Apdex. You can also download the report as a comma-separated value (CSV) spreadsheet. Alerts When you select a transaction from the key transaction index, you can also see options to view alert condition violations and set alert policies.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.60443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Key</em> <em>transaction</em> charts and data",
        "sections": "<em>Key</em> <em>transaction</em> charts and data",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, every <em>key</em> transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the <em>key</em> transaction index, the <em>key</em> transaction&#x27;s Overview page appears"
      },
      "id": "603ebd1128ccbc1ceaeba784"
    },
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-10-07T16:53:05Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.8985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    },
    {
      "sections": [
        "Create and update key transactions",
        "Create key transactions",
        "From the key transaction index",
        "From a specific transaction page",
        "Rename a key transaction",
        "Change Apdex settings",
        "Important",
        "Delete key transactions"
      ],
      "title": "Create and update key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "b62aaaec4cfc8c108262c4d310cecfd8f9cc081e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/create-update-key-transactions/",
      "published_at": "2021-10-07T17:55:36Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. Create key transactions There are two ways to create a key transaction: From the key transaction index Go to one.newrelic.com > More > Key transactions to view the key transactions index. Select Add more. From a specific transaction page Go to one.newrelic.com > APM > (select an app) > Summary In the center of the page under Transactions, select a record. Select Track as key transaction. Rename a key transaction Here's how to rename: Go to one.newrelic.com > More > Key transactions. From the index, select the gear icon for the key transaction you want to rename. Enter a new name for the transaction, then save. Change Apdex settings You can set a custom Apdex threshold for a key transaction if it is a web transaction. (Apdex is not applicable for non-web-transactions.) This is useful if the transaction is expected to be faster or slower than other transactions. Important Key transaction Apdex settings override the T value set for that app. This can mean, for example, that a key transaction could be reported as Satisfied but a different transaction in the same app with the same response time could be Frustrated. To change a key transaction's Apdex threshold: Go to one.newrelic.com > More > Key transactions. Select the icon for the transaction you want to edit. Enter a new value in seconds under the Apdex T heading, then save. The Apdex threshold affects how key transaction traces are created. Delete key transactions To delete a key transaction: Go to one.newrelic.com > More > Key transactions. Select the gear icon for the key transaction you want to delete. Select Stop tracking. New Relic automatically deletes any associated alerts and events for the deleted key transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.89676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and update <em>key</em> <em>transactions</em>",
        "sections": "Create and update <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a <em>key</em> transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web <em>transactions</em> can"
      },
      "id": "603ec83364441f03b44e888f"
    }
  ],
  "/docs/apm/transactions/key-transactions/key-transaction-alerts": [
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-10-07T06:34:30Z",
      "updated_at": "2021-09-14T02:57:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.6055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Key transaction charts and data",
        "Overview page",
        "SLA report page",
        "Alerts"
      ],
      "title": "Key transaction charts and data",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "7eee1868178054d18f55452b0989d724546d8016",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/key-transaction-charts-data/",
      "published_at": "2021-10-07T17:55:36Z",
      "updated_at": "2021-09-14T02:56:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, every key transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the key transaction index, the key transaction's Overview page appears. The Overview page contains charts for response time, Apdex, throughput, and other data. It is similar to the main Overview page in APM, with standard New Relic page functions. SLA report page The SLA report page for a key transaction displays Service Level Agreement reports for that transaction. The SLA reports include daily and weekly data about throughput, response time, and Apdex. You can also download the report as a comma-separated value (CSV) spreadsheet. Alerts When you select a transaction from the key transaction index, you can also see options to view alert condition violations and set alert policies.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.60443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Key</em> <em>transaction</em> charts and data",
        "sections": "<em>Key</em> <em>transaction</em> charts and data",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, every <em>key</em> transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the <em>key</em> transaction index, the <em>key</em> transaction&#x27;s Overview page appears"
      },
      "id": "603ebd1128ccbc1ceaeba784"
    },
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-10-07T16:53:05Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.8985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    }
  ],
  "/docs/apm/transactions/key-transactions/key-transaction-charts-data": [
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-10-07T06:34:30Z",
      "updated_at": "2021-09-14T02:57:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.6055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-10-07T16:53:05Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.8985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    },
    {
      "sections": [
        "Create and update key transactions",
        "Create key transactions",
        "From the key transaction index",
        "From a specific transaction page",
        "Rename a key transaction",
        "Change Apdex settings",
        "Important",
        "Delete key transactions"
      ],
      "title": "Create and update key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "b62aaaec4cfc8c108262c4d310cecfd8f9cc081e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/create-update-key-transactions/",
      "published_at": "2021-10-07T17:55:36Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. Create key transactions There are two ways to create a key transaction: From the key transaction index Go to one.newrelic.com > More > Key transactions to view the key transactions index. Select Add more. From a specific transaction page Go to one.newrelic.com > APM > (select an app) > Summary In the center of the page under Transactions, select a record. Select Track as key transaction. Rename a key transaction Here's how to rename: Go to one.newrelic.com > More > Key transactions. From the index, select the gear icon for the key transaction you want to rename. Enter a new name for the transaction, then save. Change Apdex settings You can set a custom Apdex threshold for a key transaction if it is a web transaction. (Apdex is not applicable for non-web-transactions.) This is useful if the transaction is expected to be faster or slower than other transactions. Important Key transaction Apdex settings override the T value set for that app. This can mean, for example, that a key transaction could be reported as Satisfied but a different transaction in the same app with the same response time could be Frustrated. To change a key transaction's Apdex threshold: Go to one.newrelic.com > More > Key transactions. Select the icon for the transaction you want to edit. Enter a new value in seconds under the Apdex T heading, then save. The Apdex threshold affects how key transaction traces are created. Delete key transactions To delete a key transaction: Go to one.newrelic.com > More > Key transactions. Select the gear icon for the key transaction you want to delete. Select Stop tracking. New Relic automatically deletes any associated alerts and events for the deleted key transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.89676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and update <em>key</em> <em>transactions</em>",
        "sections": "Create and update <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a <em>key</em> transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web <em>transactions</em> can"
      },
      "id": "603ec83364441f03b44e888f"
    }
  ],
  "/docs/apm/transactions/key-transactions/tag-key-transactions": [
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-10-07T06:34:30Z",
      "updated_at": "2021-09-14T02:57:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.6055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Key transaction charts and data",
        "Overview page",
        "SLA report page",
        "Alerts"
      ],
      "title": "Key transaction charts and data",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "7eee1868178054d18f55452b0989d724546d8016",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/key-transaction-charts-data/",
      "published_at": "2021-10-07T17:55:36Z",
      "updated_at": "2021-09-14T02:56:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, every key transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the key transaction index, the key transaction's Overview page appears. The Overview page contains charts for response time, Apdex, throughput, and other data. It is similar to the main Overview page in APM, with standard New Relic page functions. SLA report page The SLA report page for a key transaction displays Service Level Agreement reports for that transaction. The SLA reports include daily and weekly data about throughput, response time, and Apdex. You can also download the report as a comma-separated value (CSV) spreadsheet. Alerts When you select a transaction from the key transaction index, you can also see options to view alert condition violations and set alert policies.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 213.60442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Key</em> <em>transaction</em> charts and data",
        "sections": "<em>Key</em> <em>transaction</em> charts and data",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, every <em>key</em> transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the <em>key</em> transaction index, the <em>key</em> transaction&#x27;s Overview page appears"
      },
      "id": "603ebd1128ccbc1ceaeba784"
    },
    {
      "sections": [
        "Create and update key transactions",
        "Create key transactions",
        "From the key transaction index",
        "From a specific transaction page",
        "Rename a key transaction",
        "Change Apdex settings",
        "Important",
        "Delete key transactions"
      ],
      "title": "Create and update key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "b62aaaec4cfc8c108262c4d310cecfd8f9cc081e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/create-update-key-transactions/",
      "published_at": "2021-10-07T17:55:36Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. Create key transactions There are two ways to create a key transaction: From the key transaction index Go to one.newrelic.com > More > Key transactions to view the key transactions index. Select Add more. From a specific transaction page Go to one.newrelic.com > APM > (select an app) > Summary In the center of the page under Transactions, select a record. Select Track as key transaction. Rename a key transaction Here's how to rename: Go to one.newrelic.com > More > Key transactions. From the index, select the gear icon for the key transaction you want to rename. Enter a new name for the transaction, then save. Change Apdex settings You can set a custom Apdex threshold for a key transaction if it is a web transaction. (Apdex is not applicable for non-web-transactions.) This is useful if the transaction is expected to be faster or slower than other transactions. Important Key transaction Apdex settings override the T value set for that app. This can mean, for example, that a key transaction could be reported as Satisfied but a different transaction in the same app with the same response time could be Frustrated. To change a key transaction's Apdex threshold: Go to one.newrelic.com > More > Key transactions. Select the icon for the transaction you want to edit. Enter a new value in seconds under the Apdex T heading, then save. The Apdex threshold affects how key transaction traces are created. Delete key transactions To delete a key transaction: Go to one.newrelic.com > More > Key transactions. Select the gear icon for the key transaction you want to delete. Select Stop tracking. New Relic automatically deletes any associated alerts and events for the deleted key transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.89676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and update <em>key</em> <em>transactions</em>",
        "sections": "Create and update <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a <em>key</em> transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web <em>transactions</em> can"
      },
      "id": "603ec83364441f03b44e888f"
    }
  ],
  "/docs/apm/transactions/transaction-traces/configure-transaction-traces": [
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.36697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.20256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> <em>traces</em>",
        "sections": "No <em>traces</em> appear for any <em>transactions</em>.",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "Problem You do not see <em>transaction</em> <em>traces</em> in the <em>APM</em> UI. Solution If you are not seeing a <em>transaction</em> <em>trace</em> in <em>APM</em>, there are several possible reasons. <em>Transaction</em> tracing was disabled. <em>Transaction</em> <em>traces</em> are enabled by default, but the setting may have been manually disabled. To solve this problem"
      },
      "id": "6044280ee7b9d260d35799d6"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-10-06T23:59:07Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.96744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    }
  ],
  "/docs/apm/transactions/transaction-traces/introduction-transaction-traces": [
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.36697,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.20256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> <em>traces</em>",
        "sections": "No <em>traces</em> appear for any <em>transactions</em>.",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "Problem You do not see <em>transaction</em> <em>traces</em> in the <em>APM</em> UI. Solution If you are not seeing a <em>transaction</em> <em>trace</em> in <em>APM</em>, there are several possible reasons. <em>Transaction</em> tracing was disabled. <em>Transaction</em> <em>traces</em> are enabled by default, but the setting may have been manually disabled. To solve this problem"
      },
      "id": "6044280ee7b9d260d35799d6"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-10-07T17:04:08Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.48749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    }
  ],
  "/docs/apm/transactions/transaction-traces/security-transaction-traces": [
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.36696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.20255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> <em>traces</em>",
        "sections": "No <em>traces</em> appear for any <em>transactions</em>.",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "Problem You do not see <em>transaction</em> <em>traces</em> in the <em>APM</em> UI. Solution If you are not seeing a <em>transaction</em> <em>trace</em> in <em>APM</em>, there are several possible reasons. <em>Transaction</em> tracing was disabled. <em>Transaction</em> <em>traces</em> are enabled by default, but the setting may have been manually disabled. To solve this problem"
      },
      "id": "6044280ee7b9d260d35799d6"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-10-06T23:59:07Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.96744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    }
  ],
  "/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page": [
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.36696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.20255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> <em>traces</em>",
        "sections": "No <em>traces</em> appear for any <em>transactions</em>.",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "Problem You do not see <em>transaction</em> <em>traces</em> in the <em>APM</em> UI. Solution If you are not seeing a <em>transaction</em> <em>trace</em> in <em>APM</em>, there are several possible reasons. <em>Transaction</em> tracing was disabled. <em>Transaction</em> <em>traces</em> are enabled by default, but the setting may have been manually disabled. To solve this problem"
      },
      "id": "6044280ee7b9d260d35799d6"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-10-06T23:59:07Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.96744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    }
  ],
  "/docs/apm/transactions/transaction-traces/transaction-traces-summary-page": [
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.36696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.20255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> <em>traces</em>",
        "sections": "No <em>traces</em> appear for any <em>transactions</em>.",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "Problem You do not see <em>transaction</em> <em>traces</em> in the <em>APM</em> UI. Solution If you are not seeing a <em>transaction</em> <em>trace</em> in <em>APM</em>, there are several possible reasons. <em>Transaction</em> tracing was disabled. <em>Transaction</em> <em>traces</em> are enabled by default, but the setting may have been manually disabled. To solve this problem"
      },
      "id": "6044280ee7b9d260d35799d6"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-10-06T23:59:07Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.96744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    }
  ],
  "/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page": [
    {
      "sections": [
        "Troubleshooting: Not seeing transaction traces",
        "Problem",
        "Solution",
        "Transaction tracing was disabled.",
        "The transaction does not meet criteria for tracing.",
        "App activity is not being captured as a transaction.",
        "The custom transaction name includes brackets.",
        "Important",
        "No traces appear for any transactions."
      ],
      "title": "Troubleshooting: Not seeing transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "8941a8cde9cf0dac2eafbdc9427ca8223e9528f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-09-14T02:58:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You do not see transaction traces in the APM UI. Solution If you are not seeing a transaction trace in APM, there are several possible reasons. Transaction tracing was disabled. Transaction traces are enabled by default, but the setting may have been manually disabled. To solve this problem, change the setting back to enable transaction trace settings. The transaction does not meet criteria for tracing. The transaction is not meeting the criteria for being traced. For example: It is responding more quickly than the 4-times-Apdex threshold or a custom number-of-seconds threshold. It is not being selected as the slowest trace during the minute-long harvest cycle. App activity is not being captured as a transaction. If you don't see the transaction listed on the APM Transactions page, your APM agent is not capturing the activity as a transaction. In this situation, you must set up custom instrumentation to monitor the activity as a transaction. The custom transaction name includes brackets. If you used custom instrumentation to manually create a transaction, make sure you follow New Relic's naming rules. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. No traces appear for any transactions. Change the Threshold value temporarily to 0.0001 so that transactions will definitely exceed the threshold. Be sure to return this to your original setting after you start receiving transaction traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.20253,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshooting: Not seeing <em>transaction</em> <em>traces</em>",
        "sections": "No <em>traces</em> appear for any <em>transactions</em>.",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "Problem You do not see <em>transaction</em> <em>traces</em> in the <em>APM</em> UI. Solution If you are not seeing a <em>transaction</em> <em>trace</em> in <em>APM</em>, there are several possible reasons. <em>Transaction</em> tracing was disabled. <em>Transaction</em> <em>traces</em> are enabled by default, but the setting may have been manually disabled. To solve this problem"
      },
      "id": "6044280ee7b9d260d35799d6"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-10-06T23:59:07Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.96744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-10-07T17:04:08Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.48749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    }
  ],
  "/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces": [
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-10-07T05:15:16Z",
      "updated_at": "2021-09-14T05:54:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.36694,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-10-06T23:59:07Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.96744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-10-07T17:04:08Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.48749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    }
  ],
  "/docs/auto-telemetry-pixie/auto-telemetry-pixie-data-model": [
    {
      "sections": [
        "Auto-telemetry with Pixie for instant Kubernetes observability",
        "Quickly start observing and debugging Kubernetes clusters",
        "Important",
        "Explore your cluster",
        "Tip",
        "Investigate usage spikes with Flamegraph",
        "Debug live"
      ],
      "title": "Auto-telemetry with Pixie for instant Kubernetes observability",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "fcb7ee18f84381b6ac06911deb127f94d298b03b",
      "image": "https://docs.newrelic.com/static/1e793128e5d6019bbebd8123dbf943ab/c1b63/service-graph.png",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/get-started-auto-telemetry-pixie/",
      "published_at": "2021-10-10T01:47:45Z",
      "updated_at": "2021-09-16T01:47:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When we say auto-telemetry, we’re not talking about cars — we're talking about instant baseline visibility into your Kubernetes clusters. With the New Relic One integration with Pixie, you get similar data to traditional language agents, but without manually instrumenting your code or redeploying your application. Pixie auto-telemetry is powered by eBPF, a virtual machine-like construct that enables Pixie to seamlessly collect fine-grained telemetry data — service-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your Kubernetes clusters and workloads. No language agents required. Live debugging with Pixie shows a service graph listing the namespaces and the node that are available on the current cluster. Simply put, Auto-telemetry with Pixie offers the quickest option for getting observability into your Kubernetes services. Quickly start observing and debugging Kubernetes clusters Our Pixie integration gives you the best of both worlds: Pixie’s fast and simple Kubernetes observability coupled with New Relic One’s incident correlation, intelligent alerting, and long-term retention. You’ll get visibility into HTTP services using golden signals, HTTP transactions, database transactions, distributed tracing, and JVM metrics. You can operate, debug, and scale your Kubernetes clusters based on the information you learn about how your clusters and services are running. Using the New Relic Explorer, you can see key metrics and events at every level, starting with the cluster, and diving down into namespaces, deployments, and pods. You can quickly spot anomalous behavior, and where it’s happening. And then dive deeper using embedded visualizations of your Pixie data. Quickly identify hot spots with Flamegraph. On the Live debugging with Pixie tab, answer questions like what SQL requests your app is making or which services are talking to each other. Important Auto-Telemetry with Pixie leverages Community Cloud with Pixie, a separate platform from New Relic One. Use of Community Cloud with Pixie is subject to separate terms of service. Explore your cluster Access the Pixie UI via New Relic's Live debugging with Pixie area of your Kubernetes clusters. The cluster explorer provides a quick overview of the nodes in your cluster, including CPU, memory, and storage, as well as the status of each pod (healthy, warning, or critical). You can also find out what services are running in each container, their latency, throughput, and error rate. For more information about using the cluster explorer, see Navigate the Kubernetes cluster explorer. Note that you cannot log directly into the Pixie UI unless you have created a separate Pixie login. Tip Containers might be listed for up to four hours after they get decommissioned. You can query the Pixie data in New Relic One and create dashboards for at-a-glance monitoring. Find the data model and sample queries here. Investigate usage spikes with Flamegraph Debugging is orders of magnitude easier when you can quickly see what your application is doing. Flamegraph, a Pixie always-on visualization, requires no instrumentation, redeploying, or recompiling. It works for compiled languages like Go, C+, Rust, to name a few. And at a glance, Flamegraph tells you what functions your application is spending time on and where you have hot spots. Flamegraph is especially useful for hierarchical resource use, like disk usage and CPU utilization. For more information on how to read Flamegraph, see the Pixie documentation. Debug live On the Live debugging with Pixie tab, run PxL scripts — scripts written in Pixie's PxL language — to view live data captured through eBPF. Select the script drop-down and then select a script to run in the tab. (For best results, select a time range that is recent in the time picker.) Scripts enable you to debug: Traffic in multiple formats: HTTP and HTTPs (including encrypted), DNS, Postgres, MySQL, Cassandra, Redis (currently supporting SQL and HTTP in beta). Learn more: Request tracing tutorial. Database request performance. Learn more: Database Query Profiling tutorial. Service maps to learn which services are talking to each other. Learn more: Service Performance tutorial. Network traffic maps to learn which nodes are talking to each other. Learn more: Network Monitoring tutorial. Monitor resource usage by Node and Pod. Learn more: Infra health tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.6451,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> for instant <em>Kubernetes</em> observability",
        "sections": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> for instant <em>Kubernetes</em> observability",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": " your application. <em>Pixie</em> <em>auto</em>-<em>telemetry</em> is powered by <em>eBPF</em>, a virtual machine-like construct that enables <em>Pixie</em> to seamlessly collect fine-grained <em>telemetry</em> data — <em>service</em>-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your <em>Kubernetes</em> clusters"
      },
      "id": "60f07e20196a670a2d38adae"
    },
    {
      "sections": [
        "Install Auto-telemetry with Pixie",
        "General prerequisites for using Pixie",
        "Setup steps depend on your account status",
        "Install from the beginning of the guided install process",
        "Install from the Configure the HELM command/manifest (yaml) file",
        "Important",
        "Helm method",
        "manifest method",
        "If you link the wrong Pixie and New Relic account",
        "Reduce ingest during install with Helm"
      ],
      "title": "Install Auto-telemetry with Pixie",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "0950cfd46d2665325c85ef2acc22f1a84933743c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/install-auto-telemetry-pixie/",
      "published_at": "2021-10-07T10:40:06Z",
      "updated_at": "2021-09-27T15:20:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To get up and running with Auto-telemetry with Pixie, you start with our guided installation. The guided installation deploys Pixie with New Relic's Kubernetes integration on your cluster. You don't need to do any further configuration or installation to start using Pixie. If you want to install Auto-telemetry with Pixie on multiple clusters, re-run the guided install for each additional cluster. General prerequisites for using Pixie You must be a New Relic full platform user. Other user-related requirements: Users on our New Relic One user model must be assigned to a group that has a role with Pixie-related capabilities. Users on our original user model cannot be Restricted. Review this Pixie data security overview for actions to take to secure your data. Make sure you have sufficient memory: Pixie requires 2Gb of memory per node in your cluster. Review the other Pixie technical requirements. Setup steps depend on your account status Use the following table to find out where to start installing Auto-telemetry with Pixie. Where you start the installation depends on whether you already have a New Relic or Pixie account, or both. New Relic Pixie Next steps Start the guided install at the beginning of the process. If you already have both types of accounts, and used the same email address for each of them, click the New Relic icon in the Pixie UI. This brings you to the Configure the HELM command/manifest (yaml) file section of the guided installation. Then, follow the steps. If you're using different email addresses in Pixie and New Relic, create a new account for either Pixie or New Relic to match email addresses across both products. You can also contact New Relic support to manually link your existing New Relic account with your Pixie account. If you follow a link to New Relic from the Pixie UI and do not have a New Relic account, you must first create one. Click the New Relic icon in the Pixie UI, and follow the steps to create a New Relic account. When you do so, your Pixie account is linked to it. Then, continue the guided install process with these steps. Sign up for a free New Relic account. Then, start the guided install at the beginning of the process. Install from the beginning of the guided install process Open our New Relic One guided install. Select the account you want to use for the guided install, and click Continue. Note: if you have a single account, you won't see this option. Select Kubernetes and then continue with step one in the next section. Install from the Configure the HELM command/manifest (yaml) file If you arrived in the guided installation process by following a link from Pixie or from within New Relic, your steps begin here. Select the account and cluster for the install. If needed, select a namespace. Important Currently, Pixie performs best on clusters with up to 100 nodes (exceeding 100 nodes can lead to excessive memory usage and scripts failing to run). Friendly reminder: autoscaling can quickly drive up your node numbers. Click Continue. Select the data you want to gather, observe, and debug, and click Continue. On the Choose install method page, select either Helm or manifest. Helm method Run the provided Helm command on your command line. If you're concerned about the amount of Pixie data you'll ingest, find some parameters for reducing ingest below. Helm installs a bundle containing the New Relic infrastructure agent, an integration to gather Prometheus metrics and Kubernetes events, and the Pixie integration. The deployment takes a few minutes to complete. To see the status of the install to the cluster, run kubectl get pods -n newrelic. For general information about installing a Kubernetes integration, see this Helm install info. manifest method Run the provided command in your console, and insert the path to your downloaded manifest. If you're running your Kubernetes cluster in the cloud, see the additional steps in the Kubernetes docs. Click Continue to open the Listening for data page. When you get the message, See your data, click Kubernetes Cluster Explorer to see your cluster. Auto-telemetry with Pixie might restart after installation. This is caused by the auto update feature. If you link the wrong Pixie and New Relic account Contact support to unlink a Pixie account from your New Relic account. Be aware that if you unlink a Pixie account that was created automatically through the guided install, you'll lose access to that Pixie account. Reduce ingest during install with Helm If you want to reduce the amount of Pixie data that New Relic ingests, you can add the following parameters to your Helm chart during installation. Note that the data still exists in Pixie: excludeNamespacesRegex - use to identify the namespaces that you want to exclude from sending observability data to New Relic. If empty, data for all namespaces is sent to New Relic. Example: --set newrelic-pixie.excludeNamespacesRegex=\"examplenamespace-1|examplenamespace-2\" excludePodsRegex - use to identify pods across all namespaces that you want to exclude from sending observability data to New Relic. If empty, data for all pods (except those in excluded namespaces) is sent to New Relic. Example: --set newrelic-pixie.excludePodsRegex=\"examplepod-1|examplepod-2\" Learn more about the available parameters for the newrelic-pixie Helm chart here.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.31226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>",
        "sections": "Install <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": "To get up and running with <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>, you start with our guided installation. The guided installation deploys <em>Pixie</em> with New Relic&#x27;s <em>Kubernetes</em> integration on your cluster. You don&#x27;t need to do any further configuration or installation to start using <em>Pixie</em>. If you want to install"
      },
      "id": "614754c628ccbc38d556a84c"
    },
    {
      "sections": [
        "Auto-telemetry with Pixie data and security",
        "Control who has access to Pixie data",
        "Manage auto-update and two-way communication",
        "Helm option",
        "newrelic-manifest.yaml option"
      ],
      "title": "Auto-telemetry with Pixie data and security",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry data",
        "Service monitoring",
        "Kubernetes",
        "eBPF",
        "Pixie data"
      ],
      "external_id": "c970e938e3ad86ce9e12874821cb0c42dd3845df",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/pixie-data-security-overview/",
      "published_at": "2021-10-07T00:30:11Z",
      "updated_at": "2021-08-08T03:15:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Auto-telemetry with Pixie is New Relic One's integration of Community Cloud for Pixie, a managed version of Pixie open source software. Auto-telemetry with Pixie therefore benefits from Pixie's approach to keeping data secure. The data that Pixie collects is stored entirely within your Kubernetes cluster. This data does not persist outside of your environment, and will never be stored by Community Cloud for Pixie. This means that your sensitive data remains within your environment and control. Community Cloud for Pixie makes queries directly to your Kubernetes cluster to access the data. In order for the query results to be shown in the Community Cloud for Pixie UI, CLI, and API, the data is sent to the client from your cluster using a reverse proxy. Community Cloud for Pixie’s reverse proxy is designed to ensure: Data is ephemeral. It only passes through the Community Cloud for Pixie's cloud proxy in transit. This ensures data locality. Data is encrypted while in transit. Only you are able to read your data. New Relic One fetches and stores data that related to an application's performance. With Auto-telemetry with Pixie, a predefined subset of data persists outside of your cluster. This data is stored in Telemetry Data Platform, in the your selected region. This data persists in order to give you long-term storage, alerting, correlation with additional data, and the ability to use advanced New Relic platform capabilities, such as anomaly detection. The persisted performance metrics include, but are not limited to: Golden metrics (throughput, latency, error rate) for HTTP-based services HTTP transaction data Database transaction data (for MySQL & PostgreSQL) Distributed tracing JVM metrics The data you view on the Live debugging tab comes through Community Cloud for Pixie, and is therefore potentially sensitive. It is not stored by New Relic and is ephemeral and queryable for less than 24 hours. Control who has access to Pixie data If you want to manage which members of your organization can view Pixie data in New Relic One, as well as install and delete Pixie links, you can create a custom role. Note that this option is available only to Enterprise and Pro level customers. For more information, see New Relic's user model. Manage auto-update and two-way communication Pixie maintains an active two-way communication channel from your host system to Community Cloud with Pixie at withpixie.ai. Pixie uses this communication channel to query data, push updates, and retrieve metadata and health checks about Pixie and your Kubernetes cluster. By default, Pixie queries withpixie.ai to check if new updates have been pushed and then automatically installs them if they’re present. To disable auto updates, you must set a flag prior to the install process using either Helm or in the newrelic-manifest.yaml file. To disable automatic updates, choose one: Helm option Add --set pixie-chart.disableAutoUpdate=true to your Helm command. newrelic-manifest.yaml option in your newrelic-manifest.yaml file under the pl-cluster-config section, add PL_DISABLE_AUTO_UPDATE: \"true\" to the data directive. Example: --- apiVersion: v1 data: PL_CUSTOM_ANNOTATIONS: \"\" PL_CUSTOM_LABELS: \"\" PL_DISABLE_AUTO_UPDATE: \"true\" PL_ETCD_OPERATOR_ENABLED: \"false\" PL_MD_ETCD_SERVER: \"https://etcd.newrelic.svc:2379\" PX_MEMORY_LIMIT: \"\" kind: ConfigMap metadata: annotations: creationTimestamp: null labels: name: pl-cluster-config namespace: newrelic --- Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.80539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data and security",
        "sections": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data and security",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em> data",
        "body": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> is New Relic One&#x27;s integration of Community Cloud for <em>Pixie</em>, a managed version of <em>Pixie</em> open source software. <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> therefore benefits from <em>Pixie</em>&#x27;s approach to keeping data secure. The data that <em>Pixie</em> collects is stored entirely within your <em>Kubernetes</em>"
      },
      "id": "60f6b16728ccbc422b4b1149"
    }
  ],
  "/docs/auto-telemetry-pixie/get-started-auto-telemetry-pixie": [
    {
      "sections": [
        "Install Auto-telemetry with Pixie",
        "General prerequisites for using Pixie",
        "Setup steps depend on your account status",
        "Install from the beginning of the guided install process",
        "Install from the Configure the HELM command/manifest (yaml) file",
        "Important",
        "Helm method",
        "manifest method",
        "If you link the wrong Pixie and New Relic account",
        "Reduce ingest during install with Helm"
      ],
      "title": "Install Auto-telemetry with Pixie",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "0950cfd46d2665325c85ef2acc22f1a84933743c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/install-auto-telemetry-pixie/",
      "published_at": "2021-10-07T10:40:06Z",
      "updated_at": "2021-09-27T15:20:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To get up and running with Auto-telemetry with Pixie, you start with our guided installation. The guided installation deploys Pixie with New Relic's Kubernetes integration on your cluster. You don't need to do any further configuration or installation to start using Pixie. If you want to install Auto-telemetry with Pixie on multiple clusters, re-run the guided install for each additional cluster. General prerequisites for using Pixie You must be a New Relic full platform user. Other user-related requirements: Users on our New Relic One user model must be assigned to a group that has a role with Pixie-related capabilities. Users on our original user model cannot be Restricted. Review this Pixie data security overview for actions to take to secure your data. Make sure you have sufficient memory: Pixie requires 2Gb of memory per node in your cluster. Review the other Pixie technical requirements. Setup steps depend on your account status Use the following table to find out where to start installing Auto-telemetry with Pixie. Where you start the installation depends on whether you already have a New Relic or Pixie account, or both. New Relic Pixie Next steps Start the guided install at the beginning of the process. If you already have both types of accounts, and used the same email address for each of them, click the New Relic icon in the Pixie UI. This brings you to the Configure the HELM command/manifest (yaml) file section of the guided installation. Then, follow the steps. If you're using different email addresses in Pixie and New Relic, create a new account for either Pixie or New Relic to match email addresses across both products. You can also contact New Relic support to manually link your existing New Relic account with your Pixie account. If you follow a link to New Relic from the Pixie UI and do not have a New Relic account, you must first create one. Click the New Relic icon in the Pixie UI, and follow the steps to create a New Relic account. When you do so, your Pixie account is linked to it. Then, continue the guided install process with these steps. Sign up for a free New Relic account. Then, start the guided install at the beginning of the process. Install from the beginning of the guided install process Open our New Relic One guided install. Select the account you want to use for the guided install, and click Continue. Note: if you have a single account, you won't see this option. Select Kubernetes and then continue with step one in the next section. Install from the Configure the HELM command/manifest (yaml) file If you arrived in the guided installation process by following a link from Pixie or from within New Relic, your steps begin here. Select the account and cluster for the install. If needed, select a namespace. Important Currently, Pixie performs best on clusters with up to 100 nodes (exceeding 100 nodes can lead to excessive memory usage and scripts failing to run). Friendly reminder: autoscaling can quickly drive up your node numbers. Click Continue. Select the data you want to gather, observe, and debug, and click Continue. On the Choose install method page, select either Helm or manifest. Helm method Run the provided Helm command on your command line. If you're concerned about the amount of Pixie data you'll ingest, find some parameters for reducing ingest below. Helm installs a bundle containing the New Relic infrastructure agent, an integration to gather Prometheus metrics and Kubernetes events, and the Pixie integration. The deployment takes a few minutes to complete. To see the status of the install to the cluster, run kubectl get pods -n newrelic. For general information about installing a Kubernetes integration, see this Helm install info. manifest method Run the provided command in your console, and insert the path to your downloaded manifest. If you're running your Kubernetes cluster in the cloud, see the additional steps in the Kubernetes docs. Click Continue to open the Listening for data page. When you get the message, See your data, click Kubernetes Cluster Explorer to see your cluster. Auto-telemetry with Pixie might restart after installation. This is caused by the auto update feature. If you link the wrong Pixie and New Relic account Contact support to unlink a Pixie account from your New Relic account. Be aware that if you unlink a Pixie account that was created automatically through the guided install, you'll lose access to that Pixie account. Reduce ingest during install with Helm If you want to reduce the amount of Pixie data that New Relic ingests, you can add the following parameters to your Helm chart during installation. Note that the data still exists in Pixie: excludeNamespacesRegex - use to identify the namespaces that you want to exclude from sending observability data to New Relic. If empty, data for all namespaces is sent to New Relic. Example: --set newrelic-pixie.excludeNamespacesRegex=\"examplenamespace-1|examplenamespace-2\" excludePodsRegex - use to identify pods across all namespaces that you want to exclude from sending observability data to New Relic. If empty, data for all pods (except those in excluded namespaces) is sent to New Relic. Example: --set newrelic-pixie.excludePodsRegex=\"examplepod-1|examplepod-2\" Learn more about the available parameters for the newrelic-pixie Helm chart here.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.31226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>",
        "sections": "Install <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": "To get up and running with <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>, you start with our guided installation. The guided installation deploys <em>Pixie</em> with New Relic&#x27;s <em>Kubernetes</em> integration on your cluster. You don&#x27;t need to do any further configuration or installation to start using <em>Pixie</em>. If you want to install"
      },
      "id": "614754c628ccbc38d556a84c"
    },
    {
      "sections": [
        "Query Pixie data",
        "Metrics and specifications",
        "HTTP metrics",
        "JVM metrics",
        "HTTP server span"
      ],
      "title": "Query Pixie data",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "58f2e39ce330707aa446c99008ea08165dd1c4b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/auto-telemetry-pixie-data-model/",
      "published_at": "2021-10-07T10:40:06Z",
      "updated_at": "2021-07-20T11:21:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Auto-telemetry with Pixie pulls data from the Pixie Cloud API and sends it to the New Relic OpenTelemetry endpoint. You can build your own charts and query your Auto-telemetry with Pixie data using the query builder and the NerdGraph API. Find out more about getting started with Auto-telemetry with Pixie here. Metrics and specifications HTTP metrics Query for duration of inbound HTTP request. For example: FROM Metric SELECT average(http.server.duration) FACET service.name WHERE instrumentation.provider='pixie' Copy Event type Metric Metric name http.server.duration Spec OpenTelemetry HTTP metric spec Description Measures the duration of the inbound HTTP request. OTEL data type MetricDataTypeDoubleSummary with min(quantile=0) and max(quantile=1) Unit milliseconds Required attributes service.name Static attributes instrumentation.provider = pixie HTTP attributes http.status_code Entity attributes service.instance.id k8s.cluster.name k8s.namespace.name k8s.pod.name k8s.container.name JVM metrics Query to measure the time spent in a given JVM garbage collectors in milliseconds. For example: FROM Metric SELECT average(runtime.jvm.gc.collection) FACET service.name, gc WHERE instrumentation.provider='pixie' Copy Event type Metric Metric name runtime.jvm.gc.collection Spec opentelemetry.jvm.gc.collection Description Time spent in a given JVM garbage collector in milliseconds. Unit milliseconds Required attributes service.name Static attributes instrumentation.provider = pixie JVM attributes gc = young|full Entity attributes service.instance.id k8s.cluster.name k8s.namespace.name k8s.pod.name k8s.container.name Query to find out the number of bytes in a given JVM memory area. For example: FROM Metric SELECT average(runtime.jvm.memory.area) FACET service.name WHERE type='used' AND instrumentation.provider='pixie' Copy Event type Metric Metric name runtime.jvm.memory.area Spec opentelemetry-java-instrumentation Description Bytes of a given JVM memory area. Unit bytes Required attributes service.name Static attributes instrumentation.provider = pixie JVM attributes type = used|total|max area = heap Entity attributes service.instance.id k8s.cluster.name k8s.namespace.name k8s.pod.name k8s.container.name HTTP server span Example query: FROM Span SELECT uniques(name) WHERE span.kind='server' AND instrumentation.provider='pixie' AND service.name='orders' Copy Spec Semantic conventions for HTTP spans Event type Span Required attributes name = normalized HTTP path service.name trace.id span.id Static attributes span.kind = server instrumentation.provider = pixie HTTP attributes http.host http.method http.path http.status_code http.url http.user_agent",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.18332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query <em>Pixie</em> data",
        "sections": "Query <em>Pixie</em> data",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> pulls data from the <em>Pixie</em> Cloud API and sends it to the New Relic Open<em>Telemetry</em> endpoint. You can build your own charts and query your <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data using the query builder and the NerdGraph API. Find out more about getting started with <em>Auto</em>-<em>telemetry</em>"
      },
      "id": "60f6b1a0e7b9d23575fc109e"
    },
    {
      "sections": [
        "Auto-telemetry with Pixie data and security",
        "Control who has access to Pixie data",
        "Manage auto-update and two-way communication",
        "Helm option",
        "newrelic-manifest.yaml option"
      ],
      "title": "Auto-telemetry with Pixie data and security",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry data",
        "Service monitoring",
        "Kubernetes",
        "eBPF",
        "Pixie data"
      ],
      "external_id": "c970e938e3ad86ce9e12874821cb0c42dd3845df",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/pixie-data-security-overview/",
      "published_at": "2021-10-07T00:30:11Z",
      "updated_at": "2021-08-08T03:15:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Auto-telemetry with Pixie is New Relic One's integration of Community Cloud for Pixie, a managed version of Pixie open source software. Auto-telemetry with Pixie therefore benefits from Pixie's approach to keeping data secure. The data that Pixie collects is stored entirely within your Kubernetes cluster. This data does not persist outside of your environment, and will never be stored by Community Cloud for Pixie. This means that your sensitive data remains within your environment and control. Community Cloud for Pixie makes queries directly to your Kubernetes cluster to access the data. In order for the query results to be shown in the Community Cloud for Pixie UI, CLI, and API, the data is sent to the client from your cluster using a reverse proxy. Community Cloud for Pixie’s reverse proxy is designed to ensure: Data is ephemeral. It only passes through the Community Cloud for Pixie's cloud proxy in transit. This ensures data locality. Data is encrypted while in transit. Only you are able to read your data. New Relic One fetches and stores data that related to an application's performance. With Auto-telemetry with Pixie, a predefined subset of data persists outside of your cluster. This data is stored in Telemetry Data Platform, in the your selected region. This data persists in order to give you long-term storage, alerting, correlation with additional data, and the ability to use advanced New Relic platform capabilities, such as anomaly detection. The persisted performance metrics include, but are not limited to: Golden metrics (throughput, latency, error rate) for HTTP-based services HTTP transaction data Database transaction data (for MySQL & PostgreSQL) Distributed tracing JVM metrics The data you view on the Live debugging tab comes through Community Cloud for Pixie, and is therefore potentially sensitive. It is not stored by New Relic and is ephemeral and queryable for less than 24 hours. Control who has access to Pixie data If you want to manage which members of your organization can view Pixie data in New Relic One, as well as install and delete Pixie links, you can create a custom role. Note that this option is available only to Enterprise and Pro level customers. For more information, see New Relic's user model. Manage auto-update and two-way communication Pixie maintains an active two-way communication channel from your host system to Community Cloud with Pixie at withpixie.ai. Pixie uses this communication channel to query data, push updates, and retrieve metadata and health checks about Pixie and your Kubernetes cluster. By default, Pixie queries withpixie.ai to check if new updates have been pushed and then automatically installs them if they’re present. To disable auto updates, you must set a flag prior to the install process using either Helm or in the newrelic-manifest.yaml file. To disable automatic updates, choose one: Helm option Add --set pixie-chart.disableAutoUpdate=true to your Helm command. newrelic-manifest.yaml option in your newrelic-manifest.yaml file under the pl-cluster-config section, add PL_DISABLE_AUTO_UPDATE: \"true\" to the data directive. Example: --- apiVersion: v1 data: PL_CUSTOM_ANNOTATIONS: \"\" PL_CUSTOM_LABELS: \"\" PL_DISABLE_AUTO_UPDATE: \"true\" PL_ETCD_OPERATOR_ENABLED: \"false\" PL_MD_ETCD_SERVER: \"https://etcd.newrelic.svc:2379\" PX_MEMORY_LIMIT: \"\" kind: ConfigMap metadata: annotations: creationTimestamp: null labels: name: pl-cluster-config namespace: newrelic --- Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.80539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data and security",
        "sections": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data and security",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em> data",
        "body": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> is New Relic One&#x27;s integration of Community Cloud for <em>Pixie</em>, a managed version of <em>Pixie</em> open source software. <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> therefore benefits from <em>Pixie</em>&#x27;s approach to keeping data secure. The data that <em>Pixie</em> collects is stored entirely within your <em>Kubernetes</em>"
      },
      "id": "60f6b16728ccbc422b4b1149"
    }
  ],
  "/docs/auto-telemetry-pixie/install-auto-telemetry-pixie": [
    {
      "sections": [
        "Auto-telemetry with Pixie for instant Kubernetes observability",
        "Quickly start observing and debugging Kubernetes clusters",
        "Important",
        "Explore your cluster",
        "Tip",
        "Investigate usage spikes with Flamegraph",
        "Debug live"
      ],
      "title": "Auto-telemetry with Pixie for instant Kubernetes observability",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "fcb7ee18f84381b6ac06911deb127f94d298b03b",
      "image": "https://docs.newrelic.com/static/1e793128e5d6019bbebd8123dbf943ab/c1b63/service-graph.png",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/get-started-auto-telemetry-pixie/",
      "published_at": "2021-10-10T01:47:45Z",
      "updated_at": "2021-09-16T01:47:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When we say auto-telemetry, we’re not talking about cars — we're talking about instant baseline visibility into your Kubernetes clusters. With the New Relic One integration with Pixie, you get similar data to traditional language agents, but without manually instrumenting your code or redeploying your application. Pixie auto-telemetry is powered by eBPF, a virtual machine-like construct that enables Pixie to seamlessly collect fine-grained telemetry data — service-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your Kubernetes clusters and workloads. No language agents required. Live debugging with Pixie shows a service graph listing the namespaces and the node that are available on the current cluster. Simply put, Auto-telemetry with Pixie offers the quickest option for getting observability into your Kubernetes services. Quickly start observing and debugging Kubernetes clusters Our Pixie integration gives you the best of both worlds: Pixie’s fast and simple Kubernetes observability coupled with New Relic One’s incident correlation, intelligent alerting, and long-term retention. You’ll get visibility into HTTP services using golden signals, HTTP transactions, database transactions, distributed tracing, and JVM metrics. You can operate, debug, and scale your Kubernetes clusters based on the information you learn about how your clusters and services are running. Using the New Relic Explorer, you can see key metrics and events at every level, starting with the cluster, and diving down into namespaces, deployments, and pods. You can quickly spot anomalous behavior, and where it’s happening. And then dive deeper using embedded visualizations of your Pixie data. Quickly identify hot spots with Flamegraph. On the Live debugging with Pixie tab, answer questions like what SQL requests your app is making or which services are talking to each other. Important Auto-Telemetry with Pixie leverages Community Cloud with Pixie, a separate platform from New Relic One. Use of Community Cloud with Pixie is subject to separate terms of service. Explore your cluster Access the Pixie UI via New Relic's Live debugging with Pixie area of your Kubernetes clusters. The cluster explorer provides a quick overview of the nodes in your cluster, including CPU, memory, and storage, as well as the status of each pod (healthy, warning, or critical). You can also find out what services are running in each container, their latency, throughput, and error rate. For more information about using the cluster explorer, see Navigate the Kubernetes cluster explorer. Note that you cannot log directly into the Pixie UI unless you have created a separate Pixie login. Tip Containers might be listed for up to four hours after they get decommissioned. You can query the Pixie data in New Relic One and create dashboards for at-a-glance monitoring. Find the data model and sample queries here. Investigate usage spikes with Flamegraph Debugging is orders of magnitude easier when you can quickly see what your application is doing. Flamegraph, a Pixie always-on visualization, requires no instrumentation, redeploying, or recompiling. It works for compiled languages like Go, C+, Rust, to name a few. And at a glance, Flamegraph tells you what functions your application is spending time on and where you have hot spots. Flamegraph is especially useful for hierarchical resource use, like disk usage and CPU utilization. For more information on how to read Flamegraph, see the Pixie documentation. Debug live On the Live debugging with Pixie tab, run PxL scripts — scripts written in Pixie's PxL language — to view live data captured through eBPF. Select the script drop-down and then select a script to run in the tab. (For best results, select a time range that is recent in the time picker.) Scripts enable you to debug: Traffic in multiple formats: HTTP and HTTPs (including encrypted), DNS, Postgres, MySQL, Cassandra, Redis (currently supporting SQL and HTTP in beta). Learn more: Request tracing tutorial. Database request performance. Learn more: Database Query Profiling tutorial. Service maps to learn which services are talking to each other. Learn more: Service Performance tutorial. Network traffic maps to learn which nodes are talking to each other. Learn more: Network Monitoring tutorial. Monitor resource usage by Node and Pod. Learn more: Infra health tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 425.64508,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> for instant <em>Kubernetes</em> observability",
        "sections": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> for instant <em>Kubernetes</em> observability",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": " your application. <em>Pixie</em> <em>auto</em>-<em>telemetry</em> is powered by <em>eBPF</em>, a virtual machine-like construct that enables <em>Pixie</em> to seamlessly collect fine-grained <em>telemetry</em> data — <em>service</em>-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your <em>Kubernetes</em> clusters"
      },
      "id": "60f07e20196a670a2d38adae"
    },
    {
      "sections": [
        "Query Pixie data",
        "Metrics and specifications",
        "HTTP metrics",
        "JVM metrics",
        "HTTP server span"
      ],
      "title": "Query Pixie data",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "58f2e39ce330707aa446c99008ea08165dd1c4b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/auto-telemetry-pixie-data-model/",
      "published_at": "2021-10-07T10:40:06Z",
      "updated_at": "2021-07-20T11:21:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Auto-telemetry with Pixie pulls data from the Pixie Cloud API and sends it to the New Relic OpenTelemetry endpoint. You can build your own charts and query your Auto-telemetry with Pixie data using the query builder and the NerdGraph API. Find out more about getting started with Auto-telemetry with Pixie here. Metrics and specifications HTTP metrics Query for duration of inbound HTTP request. For example: FROM Metric SELECT average(http.server.duration) FACET service.name WHERE instrumentation.provider='pixie' Copy Event type Metric Metric name http.server.duration Spec OpenTelemetry HTTP metric spec Description Measures the duration of the inbound HTTP request. OTEL data type MetricDataTypeDoubleSummary with min(quantile=0) and max(quantile=1) Unit milliseconds Required attributes service.name Static attributes instrumentation.provider = pixie HTTP attributes http.status_code Entity attributes service.instance.id k8s.cluster.name k8s.namespace.name k8s.pod.name k8s.container.name JVM metrics Query to measure the time spent in a given JVM garbage collectors in milliseconds. For example: FROM Metric SELECT average(runtime.jvm.gc.collection) FACET service.name, gc WHERE instrumentation.provider='pixie' Copy Event type Metric Metric name runtime.jvm.gc.collection Spec opentelemetry.jvm.gc.collection Description Time spent in a given JVM garbage collector in milliseconds. Unit milliseconds Required attributes service.name Static attributes instrumentation.provider = pixie JVM attributes gc = young|full Entity attributes service.instance.id k8s.cluster.name k8s.namespace.name k8s.pod.name k8s.container.name Query to find out the number of bytes in a given JVM memory area. For example: FROM Metric SELECT average(runtime.jvm.memory.area) FACET service.name WHERE type='used' AND instrumentation.provider='pixie' Copy Event type Metric Metric name runtime.jvm.memory.area Spec opentelemetry-java-instrumentation Description Bytes of a given JVM memory area. Unit bytes Required attributes service.name Static attributes instrumentation.provider = pixie JVM attributes type = used|total|max area = heap Entity attributes service.instance.id k8s.cluster.name k8s.namespace.name k8s.pod.name k8s.container.name HTTP server span Example query: FROM Span SELECT uniques(name) WHERE span.kind='server' AND instrumentation.provider='pixie' AND service.name='orders' Copy Spec Semantic conventions for HTTP spans Event type Span Required attributes name = normalized HTTP path service.name trace.id span.id Static attributes span.kind = server instrumentation.provider = pixie HTTP attributes http.host http.method http.path http.status_code http.url http.user_agent",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 261.1833,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query <em>Pixie</em> data",
        "sections": "Query <em>Pixie</em> data",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> pulls data from the <em>Pixie</em> Cloud API and sends it to the New Relic Open<em>Telemetry</em> endpoint. You can build your own charts and query your <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data using the query builder and the NerdGraph API. Find out more about getting started with <em>Auto</em>-<em>telemetry</em>"
      },
      "id": "60f6b1a0e7b9d23575fc109e"
    },
    {
      "sections": [
        "Auto-telemetry with Pixie data and security",
        "Control who has access to Pixie data",
        "Manage auto-update and two-way communication",
        "Helm option",
        "newrelic-manifest.yaml option"
      ],
      "title": "Auto-telemetry with Pixie data and security",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry data",
        "Service monitoring",
        "Kubernetes",
        "eBPF",
        "Pixie data"
      ],
      "external_id": "c970e938e3ad86ce9e12874821cb0c42dd3845df",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/pixie-data-security-overview/",
      "published_at": "2021-10-07T00:30:11Z",
      "updated_at": "2021-08-08T03:15:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Auto-telemetry with Pixie is New Relic One's integration of Community Cloud for Pixie, a managed version of Pixie open source software. Auto-telemetry with Pixie therefore benefits from Pixie's approach to keeping data secure. The data that Pixie collects is stored entirely within your Kubernetes cluster. This data does not persist outside of your environment, and will never be stored by Community Cloud for Pixie. This means that your sensitive data remains within your environment and control. Community Cloud for Pixie makes queries directly to your Kubernetes cluster to access the data. In order for the query results to be shown in the Community Cloud for Pixie UI, CLI, and API, the data is sent to the client from your cluster using a reverse proxy. Community Cloud for Pixie’s reverse proxy is designed to ensure: Data is ephemeral. It only passes through the Community Cloud for Pixie's cloud proxy in transit. This ensures data locality. Data is encrypted while in transit. Only you are able to read your data. New Relic One fetches and stores data that related to an application's performance. With Auto-telemetry with Pixie, a predefined subset of data persists outside of your cluster. This data is stored in Telemetry Data Platform, in the your selected region. This data persists in order to give you long-term storage, alerting, correlation with additional data, and the ability to use advanced New Relic platform capabilities, such as anomaly detection. The persisted performance metrics include, but are not limited to: Golden metrics (throughput, latency, error rate) for HTTP-based services HTTP transaction data Database transaction data (for MySQL & PostgreSQL) Distributed tracing JVM metrics The data you view on the Live debugging tab comes through Community Cloud for Pixie, and is therefore potentially sensitive. It is not stored by New Relic and is ephemeral and queryable for less than 24 hours. Control who has access to Pixie data If you want to manage which members of your organization can view Pixie data in New Relic One, as well as install and delete Pixie links, you can create a custom role. Note that this option is available only to Enterprise and Pro level customers. For more information, see New Relic's user model. Manage auto-update and two-way communication Pixie maintains an active two-way communication channel from your host system to Community Cloud with Pixie at withpixie.ai. Pixie uses this communication channel to query data, push updates, and retrieve metadata and health checks about Pixie and your Kubernetes cluster. By default, Pixie queries withpixie.ai to check if new updates have been pushed and then automatically installs them if they’re present. To disable auto updates, you must set a flag prior to the install process using either Helm or in the newrelic-manifest.yaml file. To disable automatic updates, choose one: Helm option Add --set pixie-chart.disableAutoUpdate=true to your Helm command. newrelic-manifest.yaml option in your newrelic-manifest.yaml file under the pl-cluster-config section, add PL_DISABLE_AUTO_UPDATE: \"true\" to the data directive. Example: --- apiVersion: v1 data: PL_CUSTOM_ANNOTATIONS: \"\" PL_CUSTOM_LABELS: \"\" PL_DISABLE_AUTO_UPDATE: \"true\" PL_ETCD_OPERATOR_ENABLED: \"false\" PL_MD_ETCD_SERVER: \"https://etcd.newrelic.svc:2379\" PX_MEMORY_LIMIT: \"\" kind: ConfigMap metadata: annotations: creationTimestamp: null labels: name: pl-cluster-config namespace: newrelic --- Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.80539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data and security",
        "sections": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> data and security",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em> data",
        "body": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> is New Relic One&#x27;s integration of Community Cloud for <em>Pixie</em>, a managed version of <em>Pixie</em> open source software. <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> therefore benefits from <em>Pixie</em>&#x27;s approach to keeping data secure. The data that <em>Pixie</em> collects is stored entirely within your <em>Kubernetes</em>"
      },
      "id": "60f6b16728ccbc422b4b1149"
    }
  ],
  "/docs/auto-telemetry-pixie/pixie-data-security-overview": [
    {
      "sections": [
        "Auto-telemetry with Pixie for instant Kubernetes observability",
        "Quickly start observing and debugging Kubernetes clusters",
        "Important",
        "Explore your cluster",
        "Tip",
        "Investigate usage spikes with Flamegraph",
        "Debug live"
      ],
      "title": "Auto-telemetry with Pixie for instant Kubernetes observability",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "fcb7ee18f84381b6ac06911deb127f94d298b03b",
      "image": "https://docs.newrelic.com/static/1e793128e5d6019bbebd8123dbf943ab/c1b63/service-graph.png",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/get-started-auto-telemetry-pixie/",
      "published_at": "2021-10-10T01:47:45Z",
      "updated_at": "2021-09-16T01:47:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When we say auto-telemetry, we’re not talking about cars — we're talking about instant baseline visibility into your Kubernetes clusters. With the New Relic One integration with Pixie, you get similar data to traditional language agents, but without manually instrumenting your code or redeploying your application. Pixie auto-telemetry is powered by eBPF, a virtual machine-like construct that enables Pixie to seamlessly collect fine-grained telemetry data — service-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your Kubernetes clusters and workloads. No language agents required. Live debugging with Pixie shows a service graph listing the namespaces and the node that are available on the current cluster. Simply put, Auto-telemetry with Pixie offers the quickest option for getting observability into your Kubernetes services. Quickly start observing and debugging Kubernetes clusters Our Pixie integration gives you the best of both worlds: Pixie’s fast and simple Kubernetes observability coupled with New Relic One’s incident correlation, intelligent alerting, and long-term retention. You’ll get visibility into HTTP services using golden signals, HTTP transactions, database transactions, distributed tracing, and JVM metrics. You can operate, debug, and scale your Kubernetes clusters based on the information you learn about how your clusters and services are running. Using the New Relic Explorer, you can see key metrics and events at every level, starting with the cluster, and diving down into namespaces, deployments, and pods. You can quickly spot anomalous behavior, and where it’s happening. And then dive deeper using embedded visualizations of your Pixie data. Quickly identify hot spots with Flamegraph. On the Live debugging with Pixie tab, answer questions like what SQL requests your app is making or which services are talking to each other. Important Auto-Telemetry with Pixie leverages Community Cloud with Pixie, a separate platform from New Relic One. Use of Community Cloud with Pixie is subject to separate terms of service. Explore your cluster Access the Pixie UI via New Relic's Live debugging with Pixie area of your Kubernetes clusters. The cluster explorer provides a quick overview of the nodes in your cluster, including CPU, memory, and storage, as well as the status of each pod (healthy, warning, or critical). You can also find out what services are running in each container, their latency, throughput, and error rate. For more information about using the cluster explorer, see Navigate the Kubernetes cluster explorer. Note that you cannot log directly into the Pixie UI unless you have created a separate Pixie login. Tip Containers might be listed for up to four hours after they get decommissioned. You can query the Pixie data in New Relic One and create dashboards for at-a-glance monitoring. Find the data model and sample queries here. Investigate usage spikes with Flamegraph Debugging is orders of magnitude easier when you can quickly see what your application is doing. Flamegraph, a Pixie always-on visualization, requires no instrumentation, redeploying, or recompiling. It works for compiled languages like Go, C+, Rust, to name a few. And at a glance, Flamegraph tells you what functions your application is spending time on and where you have hot spots. Flamegraph is especially useful for hierarchical resource use, like disk usage and CPU utilization. For more information on how to read Flamegraph, see the Pixie documentation. Debug live On the Live debugging with Pixie tab, run PxL scripts — scripts written in Pixie's PxL language — to view live data captured through eBPF. Select the script drop-down and then select a script to run in the tab. (For best results, select a time range that is recent in the time picker.) Scripts enable you to debug: Traffic in multiple formats: HTTP and HTTPs (including encrypted), DNS, Postgres, MySQL, Cassandra, Redis (currently supporting SQL and HTTP in beta). Learn more: Request tracing tutorial. Database request performance. Learn more: Database Query Profiling tutorial. Service maps to learn which services are talking to each other. Learn more: Service Performance tutorial. Network traffic maps to learn which nodes are talking to each other. Learn more: Network Monitoring tutorial. Monitor resource usage by Node and Pod. Learn more: Infra health tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 295.25226,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> for instant <em>Kubernetes</em> observability",
        "sections": "<em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> for instant <em>Kubernetes</em> observability",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": " your application. <em>Pixie</em> <em>auto</em>-<em>telemetry</em> is powered by <em>eBPF</em>, a virtual machine-like construct that enables <em>Pixie</em> to seamlessly collect fine-grained <em>telemetry</em> <em>data</em> — <em>service</em>-level metrics, unsampled requests, and more. With one install command, you get deeper insight into your <em>Kubernetes</em> clusters"
      },
      "id": "60f07e20196a670a2d38adae"
    },
    {
      "sections": [
        "Install Auto-telemetry with Pixie",
        "General prerequisites for using Pixie",
        "Setup steps depend on your account status",
        "Install from the beginning of the guided install process",
        "Install from the Configure the HELM command/manifest (yaml) file",
        "Important",
        "Helm method",
        "manifest method",
        "If you link the wrong Pixie and New Relic account",
        "Reduce ingest during install with Helm"
      ],
      "title": "Install Auto-telemetry with Pixie",
      "type": "docs",
      "tags": [
        "Pixie Auto-telemetry",
        "Service monitoring",
        "Kubernetes",
        "eBPF"
      ],
      "external_id": "0950cfd46d2665325c85ef2acc22f1a84933743c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/auto-telemetry-pixie/install-auto-telemetry-pixie/",
      "published_at": "2021-10-07T10:40:06Z",
      "updated_at": "2021-09-27T15:20:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To get up and running with Auto-telemetry with Pixie, you start with our guided installation. The guided installation deploys Pixie with New Relic's Kubernetes integration on your cluster. You don't need to do any further configuration or installation to start using Pixie. If you want to install Auto-telemetry with Pixie on multiple clusters, re-run the guided install for each additional cluster. General prerequisites for using Pixie You must be a New Relic full platform user. Other user-related requirements: Users on our New Relic One user model must be assigned to a group that has a role with Pixie-related capabilities. Users on our original user model cannot be Restricted. Review this Pixie data security overview for actions to take to secure your data. Make sure you have sufficient memory: Pixie requires 2Gb of memory per node in your cluster. Review the other Pixie technical requirements. Setup steps depend on your account status Use the following table to find out where to start installing Auto-telemetry with Pixie. Where you start the installation depends on whether you already have a New Relic or Pixie account, or both. New Relic Pixie Next steps Start the guided install at the beginning of the process. If you already have both types of accounts, and used the same email address for each of them, click the New Relic icon in the Pixie UI. This brings you to the Configure the HELM command/manifest (yaml) file section of the guided installation. Then, follow the steps. If you're using different email addresses in Pixie and New Relic, create a new account for either Pixie or New Relic to match email addresses across both products. You can also contact New Relic support to manually link your existing New Relic account with your Pixie account. If you follow a link to New Relic from the Pixie UI and do not have a New Relic account, you must first create one. Click the New Relic icon in the Pixie UI, and follow the steps to create a New Relic account. When you do so, your Pixie account is linked to it. Then, continue the guided install process with these steps. Sign up for a free New Relic account. Then, start the guided install at the beginning of the process. Install from the beginning of the guided install process Open our New Relic One guided install. Select the account you want to use for the guided install, and click Continue. Note: if you have a single account, you won't see this option. Select Kubernetes and then continue with step one in the next section. Install from the Configure the HELM command/manifest (yaml) file If you arrived in the guided installation process by following a link from Pixie or from within New Relic, your steps begin here. Select the account and cluster for the install. If needed, select a namespace. Important Currently, Pixie performs best on clusters with up to 100 nodes (exceeding 100 nodes can lead to excessive memory usage and scripts failing to run). Friendly reminder: autoscaling can quickly drive up your node numbers. Click Continue. Select the data you want to gather, observe, and debug, and click Continue. On the Choose install method page, select either Helm or manifest. Helm method Run the provided Helm command on your command line. If you're concerned about the amount of Pixie data you'll ingest, find some parameters for reducing ingest below. Helm installs a bundle containing the New Relic infrastructure agent, an integration to gather Prometheus metrics and Kubernetes events, and the Pixie integration. The deployment takes a few minutes to complete. To see the status of the install to the cluster, run kubectl get pods -n newrelic. For general information about installing a Kubernetes integration, see this Helm install info. manifest method Run the provided command in your console, and insert the path to your downloaded manifest. If you're running your Kubernetes cluster in the cloud, see the additional steps in the Kubernetes docs. Click Continue to open the Listening for data page. When you get the message, See your data, click Kubernetes Cluster Explorer to see your cluster. Auto-telemetry with Pixie might restart after installation. This is caused by the auto update feature. If you link the wrong Pixie and New Relic account Contact support to unlink a Pixie account from your New Relic account. Be aware that if you unlink a Pixie account that was created automatically through the guided install, you'll lose access to that Pixie account. Reduce ingest during install with Helm If you want to reduce the amount of Pixie data that New Relic ingests, you can add the following parameters to your Helm chart during installation. Note that the data still exists in Pixie: excludeNamespacesRegex - use to identify the namespaces that you want to exclude from sending observability data to New Relic. If empty, data for all namespaces is sent to New Relic. Example: --set newrelic-pixie.excludeNamespacesRegex=\"examplenamespace-1|examplenamespace-2\" excludePodsRegex - use to identify pods across all namespaces that you want to exclude from sending observability data to New Relic. If empty, data for all pods (except those in excluded namespaces) is sent to New Relic. Example: --set newrelic-pixie.excludePodsRegex=\"examplepod-1|examplepod-2\" Learn more about the available parameters for the newrelic-pixie Helm chart here.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.3565,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>",
        "sections": "Install <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em>",
        "tags": "<em>Pixie</em> <em>Auto</em>-<em>telemetry</em>",
        "body": " in the cloud, see the additional steps in the <em>Kubernetes</em> docs. Click Continue to open the Listening for <em>data</em> page. When you get the message, See your <em>data</em>, click <em>Kubernetes</em> Cluster Explorer to see your cluster. <em>Auto</em>-<em>telemetry</em> with <em>Pixie</em> might restart after installation. This is caused by the <em>auto</em> update"
      },
      "id": "614754c628ccbc38d556a84c"
    },
    {
      "image": "https://docs.newrelic.com/static/3b7d4417336ed5ef2eb3beb02d4affea/ae694/kubernetes-cluster-explorer.png",
      "url": "https://docs.newrelic.com/whats-new/2021/05/pixie-kubernetes-post-5-26/",
      "sections": [
        "Instant Kubernetes observability with Pixie",
        "Get started today"
      ],
      "published_at": "2021-10-07T00:10:54Z",
      "title": "Instant Kubernetes observability with Pixie",
      "updated_at": "2021-05-28T15:26:33Z",
      "type": "docs",
      "external_id": "f132310e72ece8cefc9e318b433c15cddfafa389",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "We've removed the largest barriers to Kubernetes observability: The time and expertise required to manually instrument application code, by integrating Pixie Auto-Telemetry into our Kubernetes solution. Now, you can get visibility into your Kubernetes clusters and workloads instantly without installing language agents. Pixie data helps you debug faster than ever before, giving you access to everything on-cluster without sampling, then using AI/ML models to send the most relevant subset of your data to the Telemetry Data Platform for correlation with other services, intelligent alerting, and long term storage. Pixie Auto-Telemetry uses eBPF to automatically collect metrics, events, logs, and traces for your Kubernetes clusters, applications, OS, and network layers. Start fast: No code to update, new deployments, or lengthy monitoring standardization processes. Observe everything: Analyze data on-cluster using AI/ML without sampling, storing high-value telemetry data for alerting, correlation, and long term storage. Debug faster with Pixie’s developer-focused workflows, providing code-level insights. Get started today In New Relic One, choose Add more data. Choose Guided install or EU Guided install. Choose Kubernetes, and then follow the on-screen prompts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.4669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Instant <em>Kubernetes</em> observability with <em>Pixie</em>",
        "sections": "Instant <em>Kubernetes</em> observability with <em>Pixie</em>",
        "body": ", and long term storage. <em>Pixie</em> <em>Auto</em>-<em>Telemetry</em> uses <em>eBPF</em> to automatically collect metrics, events, logs, and traces for your <em>Kubernetes</em> clusters, applications, OS, and network layers. Start fast: No code to update, new deployments, or lengthy <em>monitoring</em> standardization processes. Observe everything: Analyze"
      },
      "id": "60aeed8a28ccbc146b77a392"
    }
  ],
  "/docs/browser/browser-monitoring/browser-pro-features/ajax-page-identify-time-consuming-calls": [
    {
      "sections": [
        "Use content types and text formats",
        "Docs meta content (frontmatter)",
        "Document body",
        "Page templates"
      ],
      "title": "Use content types and text formats",
      "type": "docs",
      "tags": [
        "Tech writer style guide",
        "Processes and procedures"
      ],
      "external_id": "22895e5a8b552b1cc2b278bf117f7269a539a61e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/use-content-types-text-formats/",
      "published_at": "2021-10-07T13:54:47Z",
      "updated_at": "2021-09-14T14:45:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our docs site is made up of different content types and templates. Most of the time, the default page content type and the basic template will have everything you'll need. Read on for more information about our page types. Docs meta content (frontmatter) Thr top of every doc begins with a set of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, \"AJAX page: Identify time-consuming calls.\" In general, use sentence case. Capitalize only the first word. Do not capitalize any other word in the title unless it's a proper noun, such as a specific product name, or it follows a colon (:). If you're looking for ideas on how to choose a title, browse the titles of similar docs. The title used in the sidebar (left navigation pane) is set in the nav file. type For the basicDoc template, use page or omit type. If omitted, the default type is page and the basicDoc template is used. template The template determines the basic layout and style of a page. Use basicDoc for more pages. tags Keywords related to your doc. Start each topic with a _* on a new line. A topic can include multiple words separated by spaces. japaneseVersion The URL to the Japanese language version of the doc. Leave this blank if there isn't a Japanese version. Document body The document body is where you edit the page content. Use the GitHub Markdown format when you write content. Page templates For most situations, use the basicDoc page template. Read on for information about our other page templates. Content type Description Basic page A standard HTML webpage without special fields. This content type is used for the majority of content on the site. API doc This format is for API reference documentation. For more information, see apiStyleGuidelines (for style guidelines) and Work with the API doc content type (for how to use and configure). Attribute definition This format is for defining attributes and event types. These definitions are shared with the UI via the data dictionary service. For more information, see Work with attribute definition content type. Landing pages This format is for a more user-friendly and readable landing page, which replaces the standard taxonomy list views. For more information, see Working with landing pages. Release notes This format includes specific fields for release notes. Users rely on release notes to keep up with smaller changes in the product, particularly for downloadble software like the agents. For more information, see Create release notes. What's New posts This format includes specific fields for product announcements. What's New posts are created by PMM for larger announcements. They're available in the docs site, but they're also visible in the New Relic One UI. For more information, see What's New style guidelines. Troubleshooting doc This format is for troubleshooting docs in a Problem-Solution-Cause format. For more information, see Troubleshooting docs guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2106.2715,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Page</em> templates",
        "body": " of metadata. Read on for more information about this metadata content: Meta content field Description Title Whenever possible, provide an action-oriented or task-oriented title; for example, &quot;<em>AJAX</em> <em>page</em>: <em>Identify</em> <em>time</em>-<em>consuming</em> <em>calls</em>.&quot; In general, use sentence case. Capitalize only the first word. Do"
      },
      "id": "6042220e64441f28b64e8843"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2021-10-10T01:50:04Z",
      "title": "New Relic data dictionary",
      "updated_at": "2021-10-07T02:00:01Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. BrowserInteraction ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Here’s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (e.g., a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute ‘timestamp’, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system. NetworkSample ipV4Address The IP version 4 address. NetworkSample ipV6Address The IP version 6 address. NetworkSample kernelVersion The Linux kernel version, in string format. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample linuxDistribution The name of the Linux distribution the server is using. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample operatingSystem The operating system on which the agent is installed. NetworkSample ProcessSample StorageSample SystemSample receiveBytesPerSecond bytes (B) The number of bytes per second received during the sampling period. NetworkSample receiveDroppedPerSecond count The number of received packets per second dropped during the sampling period. NetworkSample receiveErrorsPerSecond count The number of receive errors per second on the interface during the sampling period. NetworkSample receivePacketsPerSecond count The number of packets per second (",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 173.445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>AjaxRequest</em>",
        "body": "Request BrowserInteraction BrowserTiming JavaScriptError <em>Page</em>Action <em>Page</em>View <em>Page</em>ViewTiming Span <em>time</em>SinceBrowserInteractionStart seconds (s) The <em>time</em> in seconds between the start of the BrowserInteraction and the start of the request. <em>Ajax</em>Request BrowserTiming <em>time</em>ToLastCallbackEnd seconds (s) The duration"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/new-relic-browser-release-notes/browser-agent-release-notes/browser-agent-v1211/",
      "sections": [
        "Browser agent v1211",
        "Improvements",
        "AjaxRequest events for all XHR/fetch requests",
        "Span events are for all XHR/fetch requests",
        "Update to Cumulative Layout Shift calculation",
        "Bug Fixes",
        "Prevent duplicate session trace nodes"
      ],
      "published_at": "2021-10-09T00:21:25Z",
      "title": "Browser agent v1211",
      "updated_at": "2021-10-09T00:21:25Z",
      "type": "docs",
      "external_id": "81b8698293a99d7ec2803cc9fe24709917247c2b",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements AjaxRequest events for all XHR/fetch requests Previously, XHR/fetch requests were captured as AjaxRequest events only when they were part of a route change. With this change, all requests will be captured as events. This feature can be further configured by specifying which requests should not be collected. Span events are for all XHR/fetch requests Previously, Span events were generated only for XHR/fetch requests that were part of a route change. With this change, all requests will be captured as Spans. Update to Cumulative Layout Shift calculation The CLS calculation has been updated to use session windows in order to align with Google Chrome tooling (Lighthouse, PageSpeed Insights, CrUX). For more information, see the official blog post on web.dev. Bug Fixes Prevent duplicate session trace nodes The agent no longer calls the clearResourceTimings API, which had the potential to affect other scripts from accessing all resources. Instead, it now uses the PerformanceObserver API to collect information about resources.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.75237,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>AjaxRequest</em> events for all XHR&#x2F;fetch requests",
        "body": " updated to use session windows in order to align with Google Chrome tooling (Lighthouse, <em>Page</em>Speed Insights, CrUX). For more information, see the official blog post on web.dev. Bug Fixes Prevent duplicate session trace nodes The agent no longer <em>calls</em> the clearResourceTimings API, which had the potential to affect other scripts from accessing all resources. Instead, it now uses the PerformanceObserver API to collect information about resources."
      },
      "id": "6160e085196a6761b6b70da7"
    }
  ],
  "/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.66835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>addToTrace</em> (browser <em>agent</em> <em>API</em>)",
        "sections": "<em>addToTrace</em> (browser <em>agent</em> <em>API</em>)",
        "tags": "Browser <em>agent</em> <em>and</em> SPA <em>API</em>",
        "body": "Syntax newrelic.addTo<em>Trace</em>(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress <em>session</em> <em>trace</em>. Requirements Agent version nr-593 or higher. Description Custom events within browser <em>session</em> <em>traces</em> can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "Browser monitoring and performance impact",
        "Contents",
        "Overall impact",
        "Network impact",
        "For more help"
      ],
      "title": "Browser monitoring and performance impact",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "5504ef3846f4bcdae0ff4f58e8c745079d9a5cb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact/",
      "published_at": "2021-10-07T18:00:54Z",
      "updated_at": "2021-07-09T23:38:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JavaScript snippet introduces a nearly invisible impact on website performance and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins monitoring for errors and events as the rest of the webpage executes. The negligible amount of overhead required to load the JavaScript results in a significant return of actionable data. Contents Overall impact The JavaScript's overhead takes into consideration both the impact on the user and the impact on your systems' performance: User perception: Typically users cannot detect performance degradations on a website of less than 200ms. Browser's JavaScript adds less than 15ms in aggregated time per page load. This is split up over time, so at no point would a user be able to perceive any performance impact due to the JavaScript. Webserver and systems: Browser app monitoring occurs on the user's browser, not on the server. Processing time does not have an impact on your CPU consumption. In addition, we take additional steps to minimize any potential impact on the apps and webpages being monitored. For example, the \"loader\" script is loaded synchronously in the <HEAD> in order to ensure monitoring is enabled for the entire life cycle of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The \"loader\" comes with the initial page load. Later in the life cycle of the page, New Relic loads an additional monitoring script asynchronously. This script should not have any perceivable effect to the user and is included in the overall overhead of less than 15ms per page. Network impact Browser monitoring also minimizes network traffic for the end user by aggregating data locally (in the client) and sending it back to New Relic on load, at periodic intervals, on unload, or when data has been collected. (During the browser session's idle periods, transmissions may not be required.) For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Browser monitoring and search engine optimization (how browser ensures that the JavaScript has a negligible impact on SEO)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.46101,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring <em>and</em> performance impact",
        "sections": "Browser monitoring <em>and</em> performance impact",
        "body": ", the &quot;loader&quot; script is loaded synchronously in the &lt;HEAD&gt; in order to ensure monitoring is enabled for the entire <em>life</em> <em>cycle</em> of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The &quot;loader&quot; comes with the initial"
      },
      "id": "603ec318196a67a757a83dd1"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-08-27T07:49:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Full-Stack Observability Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.98744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Improve interactive <em>app</em> performance",
        "body": " of the load and interaction events during a <em>webpage&#x27;s</em> full <em>life</em> <em>cycle</em> AJAX requests indicating problems with timing, end points, and specific locations in the <em>webpage</em> Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/browser-monitoring/browser-pro-features/upload-source-maps-un-minify-js-errors": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/upload-source-maps-api/",
      "sections": [
        "Upload source maps via API",
        "Prepare for using the source map API",
        "What is the JavaScript URL?",
        "Is a release name and ID required?",
        "Are there limits to source map uploads?",
        "Push source maps to New Relic",
        "Use npm module via command line or client-side script",
        "Important",
        "npm command line: Publish",
        "npm command line: List published maps",
        "npm command line: Delete",
        "npm via Node.js script: Publish",
        "npm via Node.js script: List published maps",
        "npm via Node.js script: Delete",
        "Use API via curl",
        "curl: Upload maps",
        "curl: List existing maps",
        "curl: Delete map",
        "Troubleshoot source maps"
      ],
      "published_at": "2021-10-07T06:59:59Z",
      "title": "Upload source maps via API",
      "updated_at": "2021-07-10T02:41:25Z",
      "type": "docs",
      "external_id": "3c5a8467aa0c47e12cbe83080e701e3c7cee090c",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring supports the uploading of source maps, which are used to un-minify error stack traces on the JS errors page. This document explains how to use the API to publish (upload) source maps to browser. Prepare for using the source map API In order to upload source maps to browser via the API, you'll need this information: A user API key (before November 20, 2020, the Admin API key was required; that will still work if already in place) The New Relic application ID for the deployed app The full JavaScript file URL Optionally, if the JavaScript URL doesn't automatically have release info appended to it, the release name and ID What is the JavaScript URL? Every time the agent captures an error in your code, it's associated with the URL of the JavaScript in which it occurred. This is the src attribute of the script tag in your HTML. This full JavaScript URL is required when sending source maps to browser. You can find the URL for an error's JavaScript file in browser, on the JS errors page. See Browser monitoring source maps for more on finding these errors in the UI. Is a release name and ID required? Many organizations include a version number or hash in the JavaScript URL. This is generally added to \"bust\" caches to ensure your users get the most recent version of your code. This type of URL might look something like: https://example.com/assets/application-59.min.js https://example.com/assets/bundle-d6d031.min.js https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.js If your app's URLs automatically have the version info appended to it, the browser agent has everything it needs in order to match errors with your code. You can move ahead to generating source maps. If this doesn't apply to you, and JS URLs do not have version info appended, you’ll have to assist the agent by specifying a release name and ID with the API. Are there limits to source map uploads? There is no limit to the overall number of source maps you can upload. However, the API is rate-limited: You can upload a maximum of 100 source maps per minute You can upload a maximum of 5,000 source maps per day Source map files can be a maximum of 50Mb in size. Push source maps to New Relic Now that you have one or more source maps, you are ready to publish it to browser. You can use any of these methods to send source maps to browser: Use the New Relic npm module with the API via the command line or via a client-side JavaScript build/deploy script like Gulp or Grunt. Use API curl commands. Use the browser UI. Use npm module via command line or client-side script The easiest and recommended way to upload source maps to browser is to use the our new @newrelic/publish-sourcemap npm module. It provides a command line tool and Javascript API to accomplish this task. More documentation is available in the npm repo. Here are some examples of using the npm module via the command line. Important The following examples are for US accounts. For EU accounts, the endpoint is https://sourcemaps.service.eu.newrelic.com. For more information, see Introduction to the EU region data center. npm command line: Publish Here's an example of uploading source maps using the npm module via the command line. Note that the source map can come from a local file or a remote URL. npm install -g @newrelic/publish-sourcemap publish-sourcemap PATH_TO_SOURCE_MAP_FILE (local or remote) PATH_TO_ORIGINAL_FILE --apiKey=YOUR_NEW_RELIC_USER_API_KEY --applicationId=YOUR_NEW_RELIC_APP_ID Copy npm command line: List published maps Here's an example of listing published source maps: list-sourcemaps --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_KEY Options: --applicationId Browser application id --apiKey New Relic user API key Copy npm command line: Delete Here's an example of deleting a source map: delete-sourcemap --applicationId=YOUR_APP_ID --apiKey=YOUR_NEW_RELIC_USER_API_KEY --sourcemapId=YOUR_SOURCE_MAP_ID Options: --applicationId Browser application id --apiKey New Relic user API key --sourcemapId Unique id generated for a source map Copy Here are some examples of using the npm module to publish from client-side JavaScript: npm via Node.js script: Publish Here's an example of publishing a source map via a Node.js script: var publishSourcemap = require(‘@newrelic/publish-sourcemap’).publishSourcemap publishSourcemap({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY' }, function (err) { console.log(err || 'Sourcemap upload done')}) Copy npm via Node.js script: List published maps Here's an example of listing all published source maps: var listSourcemaps = require(‘@newrelic/publish-sourcemap’).listSourcemaps listSourcemaps({ sourcemapPath: 'SOURCE_MAP_FULL_PATH', javascriptUrl: 'JS_URL', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err, res) { console.log(err || res.body)}) Copy npm via Node.js script: Delete Here's an example of deleting a source map file via a Node.js script: var deleteSourcemap = require(‘@newrelic/publish-sourcemap’).deleteSourcemap deleteSourcemap({ sourcemapId: 'SOURCE_MAP_ID', applicationId: YOUR_NEW_RELIC_APP_ID, apiKey: 'YOUR_NEW_RELIC_USER_API_KEY', }, function (err) { console.log(err || 'Deleted source map')}) Copy When you're done, go to the JS errors page in browser, select an error grouping, and see if your error stack traces have been un-minified. Use API via curl Below are some examples of using curl to publish, list, and delete source maps: curl: Upload maps An example of using API via curl to publish maps to browser: curl -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ -F \"sourcemap=@SOURCE_MAP_PATH\" \\ -F \"javascriptUrl=JS_URL\" \\ -F \"releaseId=YOUR_RELEASE_ID\" \\ -F \"releaseName=YOUR_UI_PAGE\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps Copy curl: List existing maps Below is an example of how to get a list of source maps previously uploaded to New Relic via curl. New Relic returns the source map's unique SOURCEMAP_ID and its components: curl \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps Copy curl: Delete map To delete a source map: Use the GET endpoint to list existing source maps and locate the SOURCEMAP_ID. Run the following command via curl: curl -X DELETE \\ -H \"Api-Key: YOUR_NEW_RELIC_USER_API_KEY\" \\ https://sourcemaps.service.newrelic.com/v2/applications/YOUR_NEW_RELIC_APP_ID/sourcemaps/SOURCEMAP_ID Copy When you're done, go to the JS errors page in browser, select an error grouping, and see if your error stack traces have been un-minified. Troubleshoot source maps If you are having trouble generating source maps from your build system, or if your errors in browser are remaining minified, see the source maps troubleshooting documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.04572,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Upload</em> <em>source</em> <em>maps</em> via API",
        "sections": "<em>Upload</em> <em>source</em> <em>maps</em> via API",
        "body": "Browser monitoring supports the uploading of <em>source</em> <em>maps</em>, which are used to <em>un</em>-<em>minify</em> <em>error</em> stack traces on the <em>JS</em> <em>errors</em> page. This document explains how to use the API to publish (<em>upload</em>) <em>source</em> <em>maps</em> to browser. Prepare for using the <em>source</em> <em>map</em> API In order to <em>upload</em> <em>source</em> <em>maps</em> to browser via"
      },
      "id": "6043fea6196a672dec960f78"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/mobile-release-notes/android-release-notes/android-5251/",
      "sections": [
        "Android agent v5.25.1",
        "Fixed in this release"
      ],
      "published_at": "2021-10-07T22:27:45Z",
      "title": "Android agent v5.25.1",
      "updated_at": "2021-03-16T17:53:56Z",
      "type": "docs",
      "external_id": "cb82bb315a09a42a7699533e27f2388b2dfcd64d",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Fixed in this release Fixed detection of DexGuard-generated mapping.txt files (\"mappingFile is null\") Update OkHttp request transaction state when interceptors are used Improved visibility into obfuscation map uploads. Users can invoke the Gradle task newRelicMapUpload { Variant} (newRelicDexguardMapUpload { Variant} for DexGuard) to resend tagged obfuscation maps. { Variant} is dependent on configuration. Toned-down plugin debugging messages inadvertently emitted as errors",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.368416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "} (newRelicDexguard<em>MapUpload</em> { Variant} for DexGuard) to resend tagged obfuscation <em>maps</em>. { Variant} is dependent on configuration. Toned-down plugin debugging messages inadvertently emitted as <em>errors</em>"
      },
      "id": "603e93c0e7b9d2a4562a080c"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/mobile-release-notes/android-release-notes/android-5270/",
      "sections": [
        "Android agent v5.27.0",
        "New in this release",
        "Enhanced the New Relic Gradle plugin's build-time reporting of ProGuard/DexGuard maps",
        "Fixed in this release"
      ],
      "published_at": "2021-10-07T22:27:46Z",
      "title": "Android agent v5.27.0",
      "updated_at": "2021-03-16T17:53:57Z",
      "type": "docs",
      "external_id": "eed93e1a02f034b3fc1663d6958c20caa0311e91",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New in this release Enhanced the New Relic Gradle plugin's build-time reporting of ProGuard/DexGuard maps Maps will only be reported during select variant builds (i.e., Release) Build variants are assigned unique build IDs Maps can be compressed prior to upload Please refer to Android agent crash reporting for more detail regarding these features. These features are configurable through the New Relic Gradle Plugin extension and existing newrelic.properties. Fixed in this release Fixed build errors that occur when older (pre-3.0) versions of the Android Gradle Plugin is used Fixed 'IllegalStateException' crash that resulted when header queries were made to failed HttpsUrlConnection requests",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.973206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Enhanced the New Relic Gradle plugin&#x27;s build-time reporting of ProGuard&#x2F;DexGuard <em>maps</em>",
        "body": "New in this release Enhanced the New Relic Gradle plugin&#x27;s build-time reporting of ProGuard&#x2F;DexGuard <em>maps</em> <em>Maps</em> will only be reported during select variant builds (i.e., Release) Build variants are assigned unique build IDs <em>Maps</em> can be compressed prior to <em>upload</em> Please refer to Android agent crash"
      },
      "id": "603e7a9b28ccbc7ad2eba7a8"
    }
  ],
  "/docs/browser/browser-monitoring/configuration/browser-license-key-app-id": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.55057,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Monitor or block specific domains and subdomains",
        "Tip",
        "Configure domain conditions",
        "Turn off domain conditions"
      ],
      "title": "Monitor or block specific domains and subdomains",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Configuration"
      ],
      "external_id": "bf81374c9ec84ce08154a76b10f526fb5ee7e7ec",
      "image": "https://docs.newrelic.com/static/1bf47635bd1556e86b9019a47176e3b9/c1b63/browser_domain_conditions.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/monitor-or-block-specific-domains-subdomains/",
      "published_at": "2021-10-07T16:59:34Z",
      "updated_at": "2021-07-10T02:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser lets you choose which domains or subdomains that a browser app monitors. This is useful for limiting monitoring only to the application activity you consider important. For example, if you use the copy/paste method to deploy your browser app, you can set domain conditions to protect the security of your browser monitoring license key and app ID. Tip Domain conditions only filter data based on the url of the page that is reported. Domain condition filters do not apply to AJAX data reported to New Relic. Configure domain conditions To view or edit your domain condition settings: Go to one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Edit conditions. Select the option to build a list of allowed domains or to build a list of blocked/denied domains. Select the domain conditions (maximum 10 conditions). Select the domain conditions with the Starts with condition, then enter the URL with the subdomain (maximum 10 conditions). one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions: Use this feature to limit monitoring only to your important app activity, or to enhance security for your browser license key and app ID. Review and confirm your domain condition settings. A preview text box displays in real time what domains match the conditions you set. You will also see an estimate of the impact the proposed settings will have on your data. Turn off domain conditions To disable domain conditions and return to monitoring all domains: Go to one.newrelic.com > Browser > (select an app) > Settings > Domain conditions. Set the Enable domain conditions option to Off.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.66208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> or block specific domains and subdomains",
        "sections": "<em>Monitor</em> or block specific domains and subdomains",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> lets you choose which domains or subdomains that a <em>browser</em> app monitors. This is useful for limiting <em>monitoring</em> only to the application activity you consider important. For example, if you use the copy&#x2F;paste method to deploy your <em>browser</em> app, you can set domain conditions to protect"
      },
      "id": "6043fd41e7b9d240ca5799bb"
    }
  ],
  "/docs/browser/browser-monitoring/getting-started/browser-summary-page": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Target framework version",
        "Important",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "ce9a62a0c6a2d98442118333f39152c38bf9fdda",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-10-07T08:42:12Z",
      "updated_at": "2021-10-07T08:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0. Table of minimum agent versions required per .NET Core version .NET Core Version Minimum Required .NET Agent Version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and NET 5.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5 runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as 64-bit (x64) on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, and 5.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.02583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to <em>get</em> this information) Automatic brower <em>monitoring</em> script injection (API or manual instrumentation"
      },
      "id": "603e8e7e196a675c41a83d9f"
    },
    {
      "sections": [
        "Compatibility and requirements for browser monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-10-07T17:11:30Z",
      "updated_at": "2021-09-02T06:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the browser agent, make sure your system meets these requirements. Want to try out our browser monitoring? Create a New Relic account for free! No credit card required. Basic requirements To report data to browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the browser agent for apps monitored by APM, or you can deploy the browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying browser for an app using APM, make sure your agent supports browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use our SPA monitoring features, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with browser. In all cases, the browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our Pro+SPA agent due to the way this library wraps promises. If you're using this library, we recommend selecting the Pro agent type. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organization’s standard procedures in order to install the browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "sections": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> includes strict security measures to provide a robust, standalone product with <em>browser</em> <em>monitoring</em> features. Before you install the <em>browser</em> agent, make sure your system meets these requirements. Want to try out our <em>browser</em> <em>monitoring</em>? Create a New Relic account for free! No credit"
      },
      "id": "603ed6b664441f4a784e883f"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-08-27T07:49:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Full-Stack Observability Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.55649,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific <em>browser</em> type or platform, or whether the problem is more widespread. <em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em> Follow these basic steps, and you&#x27;ll quickly be up"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Target framework version",
        "Important",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "ce9a62a0c6a2d98442118333f39152c38bf9fdda",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-10-07T08:42:12Z",
      "updated_at": "2021-10-07T08:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0. Table of minimum agent versions required per .NET Core version .NET Core Version Minimum Required .NET Agent Version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and NET 5.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5 runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as 64-bit (x64) on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, and 5.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.02576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to <em>get</em> this information) Automatic brower <em>monitoring</em> script injection (API or manual instrumentation"
      },
      "id": "603e8e7e196a675c41a83d9f"
    },
    {
      "sections": [
        "Compatibility and requirements for browser monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-10-07T17:11:30Z",
      "updated_at": "2021-09-02T06:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the browser agent, make sure your system meets these requirements. Want to try out our browser monitoring? Create a New Relic account for free! No credit card required. Basic requirements To report data to browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the browser agent for apps monitored by APM, or you can deploy the browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying browser for an app using APM, make sure your agent supports browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use our SPA monitoring features, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with browser. In all cases, the browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our Pro+SPA agent due to the way this library wraps promises. If you're using this library, we recommend selecting the Pro agent type. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organization’s standard procedures in order to install the browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "sections": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> includes strict security measures to provide a robust, standalone product with <em>browser</em> <em>monitoring</em> features. Before you install the <em>browser</em> agent, make sure your system meets these requirements. Want to try out our <em>browser</em> <em>monitoring</em>? Create a New Relic account for free! No credit"
      },
      "id": "603ed6b664441f4a784e883f"
    },
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/d209fe2eab5c7d2da657e515ab49ae4a/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-10-07T17:58:05Z",
      "updated_at": "2021-08-27T06:56:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other browser UI pages View the Summary page To view a summary of browser performance for an app: Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL You'll also see summary versions of these metrics from the page load time page and JavaScript errors page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.53845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> Summary page",
        "sections": "<em>Browser</em> Summary page",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s Summary page summarizes the real-user <em>browser</em> performance of your app. Use the Summary page to: View trends in an app&#x27;s <em>browser</em>-side performance Quickly troubleshoot page load timing issues Navigate to other <em>browser</em> UI pages View the Summary page To view a summary of <em>browser</em>"
      },
      "id": "60440d9c196a674ac8960f5b"
    }
  ],
  "/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-07T11:16:32Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.22348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Additional <em>installation</em>",
        "body": " Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. <em>Browser</em> <em>monitoring</em> To use <em>browser</em> <em>monitoring</em> when running the Java agent on WebSphere, you must manually enable <em>browser</em> <em>monitoring</em>. WebSphere PMI metrics You can configure the Java agent"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.55049,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    }
  ],
  "/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.72134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.12744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-07T13:03:40Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    }
  ],
  "/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.72134,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.12744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-07T13:03:40Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    }
  ],
  "/docs/browser/browser-monitoring/troubleshooting/troubleshoot-your-browser-monitoring-installation": [
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.84671,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.64389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> agent API)",
        "sections": "addToTrace (<em>browser</em> agent API)",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    }
  ],
  "/docs/browser/index": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.896286,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em>",
        "body": "<em>Browser</em> monitoring&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.272156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> monitoring",
        "tags": "<em>Browser</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also monitor asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.949005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> agent API)",
        "sections": "addToTrace (<em>browser</em> agent API)",
        "tags": "<em>Browser</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    }
  ],
  "/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location": [
    {
      "sections": [
        "Page views: Examine page performance",
        "View summary information",
        "Examine timing details for page loads",
        "Examine page view details",
        "Use additional APM-monitored app options"
      ],
      "title": "Page views: Examine page performance",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "33b21f9b95742470a1dec53a56bc8d702a4be066",
      "image": "https://docs.newrelic.com/static/b772b5dac2873a9aa26c4f0848285b19/c1b63/pageview01_overview_1.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/page-views-examine-page-performance/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-07-10T02:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Page views page in browser monitoring provides insight into the performance of your site's pages. Sort options allow you to view details by percentage of page load time, average page load time, or throughput. Detailed information about the top webpages viewed, timing and throughput details, and links to browser traces or session traces also are available as applicable. Browser also offers single-page app (SPA) monitoring. If you have opted in to SPA monitoring, your SPA Page views page will be different. View summary information Browser monitoring lists page views as URLs. This makes it easy to identify specific front-end page views; for example, /browse/plans. In addition: For browser apps that are also monitored by APM, you can view the back-end transactions associated with the page view; for example, ApplicationsController#Show. For URLs that are also monitored by Synthetics, you can use New Relic's comparative charting feature. This provides a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetics monitors. one.newrelic.com > Browser > (select an app) > Page views: This page provides detailed information about page load time, throughput, top transactions, and traces. To view detailed information about which pages the end users are viewing for your app: Go to one.newrelic.com > Browser > (select an app) > Page views. Select the time period or sort order, or keep the defaults. If available, select the type of view for page load timing information as a chart (default), histogram, or percentile. To view summary information about a specific transaction, mouse over the transaction's name on the list. To compare page load time between real user (browser) interactions and trends appearing in Synthetic monitors, select a page monitored by Synthetics, then examine additional comparative charting details. Examine timing details for page loads The Browser page load time chart view shows the average page load time broken down into segments. This chart also appears on the Summary page and Browsers detail page. one.newrelic.com > Browser > (select an app) > Page views: The Browser page load time chart shows the average page load time broken down into segments indicating the end users' experience (sometimes referred to as real user monitoring or RUM). The page load timing process shows colored-coded details: Page load timing process Description Request queuing (black) Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple) Time spent in the application code. Network (brown) The network latency, or the time it takes for a request to make a round trip over the Internet. For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. DOM processing (yellow) In the browser, parsing and interpreting the HTML. Measured by the browser's DOMContent event. Page rendering (blue) In the browser, the time to display the HTML, run the inline JavaScript, and load images. Measured by the browser's Load event. \"Additional\" timing data If you are using the JavaScript API, your \"additional\" timing data appears in this chart. Examine page view details Use any of New Relic's standard user interface functions to drill down into detailed information. In addition, to view details about a specific page view, select its name from the list. To close an individual page view and return to the Page views page, select X (Close). Each page view listed in the list may include links to additional drill-down details: Page view details Comments Page load performance This includes page load timing breakdown data, throughput, session traces, and browser traces (if available). Historical performance This shows response time, Apdex comparisons, and throughput for the last selected time period, yesterday, and last week. AJAX calls Table with links to detailed information about endpoints, as well as sortable columns by endpoint, average response time, throughput, and total calls. APM transactions For browser apps that are also monitored by APM, this table shows the total call time, average response time, call count, and link to the APM Transactions page. one.newrelic.com > Browser > (select an app) > Page views > (select a transaction): Depending on the app, individual transactions may have links to additional drill-down details, including Page load performance, Historical performance, AJAX calls, and APM transactions. Use additional APM-monitored app options Browser apps that are also monitored by APM may have access to additional functions. To use these functions (if available): From the selected transaction's APM Transactions tab, select an APM transaction from the list. Then select any of these options (from APM): Track as key transaction (create a new key transaction) Key transaction (view existing) Transaction traces > (selected trace) (view)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.77403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>additional</em> APM-<em>monitored</em> app options",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": ") In the <em>browser</em>, the time to display the HTML, run the inline JavaScript, and load images. Measured by the <em>browser</em>&#x27;s Load event. &quot;<em>Additional</em>&quot; timing data If you are using the JavaScript API, your &quot;<em>additional</em>&quot; timing data appears in this chart. Examine page view details Use any of New Relic&#x27;s <em>standard</em>"
      },
      "id": "6044280d28ccbc697e2c60bb"
    },
    {
      "sections": [
        "Browsers: Problem patterns by type or platform",
        "Viewing browsers by type",
        "Viewing specific browser details"
      ],
      "title": "Browsers: Problem patterns by type or platform",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "275b49bb70dc8c016dd8d2cc03f5438f540780fe",
      "image": "https://docs.newrelic.com/static/28f8a0d40fe374ccd766b61d6b89e7a1/c1b63/browsers_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browsers-problem-patterns-type-or-platform/",
      "published_at": "2021-10-07T17:58:05Z",
      "updated_at": "2021-07-09T22:48:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Browsers page in browser monitoring provides information about your end users' experience with your app based on which browser they use, such as Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari. This page includes: Top browsers by throughput (pages per minute or ppm) Average page load time by platform type (mobile, tablet, desktop) Drill-down charts also segment the selected browser type by version; for example, Chrome 31, 32, 33, etc. This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Viewing browsers by type To view browser information: Go to one.newrelic.com, click Browser > (select an app) > Browsers. one.newrelic.com > Browser > (select an app) > Browsers: This page provides information about throughput (pages per minute) and average page load time for your end users' browser types. Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Browsers page: If you want to... Do this... View summary browser information for a specific time Mouse over any area on the chart. Hide (or return) data on the chart Select the corresponding color or title on the chart's legend. View detailed information about the browser Select its name on the list or a place on the chart. Close the detail window and return to the Browsers page Select X (Close). Viewing specific browser details The drill-down details include a breakdown by version and the average page load time. one.newrelic.com > Browser > (select an app) > Browsers > (select a browser type): This example shows a specific browser type selected (Firefox). The largest number of users have version 42.0, so by hiding this label (or any others) in the legend, you can easily examine details about other versions. Color-coded segments for Average page load time include: Request queuing (black): Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple): Time spent in the application code. Network (brown): The network latency, or time it takes for a request to make a round trip over the Internet. DOM processing (yellow): In the browser, parsing and interpreting the HTML and retrieving assets. Measured by the browser's DOMContentLoaded event. Page rendering (blue): In the browser, displaying the HTML, running in-line JavaScript, and loading images. Measured by the browser's Load event. Note: For apps that have been deployed using the copy/paste method, browser includes web app and queue time in Network time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.74284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browsers</em>: Problem patterns by type or platform",
        "sections": "<em>Browsers</em>: Problem patterns by type or platform",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": ") and average page load time for your end users&#x27; <em>browser</em> types. Use any of our <em>standard</em> user interface functions and page functions to drill down into detailed information. Here is a summary of <em>additional</em> options with the Browsers page: If you want to... Do this... View summary <em>browser</em> information"
      },
      "id": "6043f968e7b9d2bd425799d3"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    }
  ],
  "/docs/browser/new-relic-browser/additional-standard-features/browsers-problem-patterns-type-or-platform": [
    {
      "sections": [
        "Page views: Examine page performance",
        "View summary information",
        "Examine timing details for page loads",
        "Examine page view details",
        "Use additional APM-monitored app options"
      ],
      "title": "Page views: Examine page performance",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "33b21f9b95742470a1dec53a56bc8d702a4be066",
      "image": "https://docs.newrelic.com/static/b772b5dac2873a9aa26c4f0848285b19/c1b63/pageview01_overview_1.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/page-views-examine-page-performance/",
      "published_at": "2021-10-07T06:23:05Z",
      "updated_at": "2021-07-10T02:34:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Page views page in browser monitoring provides insight into the performance of your site's pages. Sort options allow you to view details by percentage of page load time, average page load time, or throughput. Detailed information about the top webpages viewed, timing and throughput details, and links to browser traces or session traces also are available as applicable. Browser also offers single-page app (SPA) monitoring. If you have opted in to SPA monitoring, your SPA Page views page will be different. View summary information Browser monitoring lists page views as URLs. This makes it easy to identify specific front-end page views; for example, /browse/plans. In addition: For browser apps that are also monitored by APM, you can view the back-end transactions associated with the page view; for example, ApplicationsController#Show. For URLs that are also monitored by Synthetics, you can use New Relic's comparative charting feature. This provides a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetics monitors. one.newrelic.com > Browser > (select an app) > Page views: This page provides detailed information about page load time, throughput, top transactions, and traces. To view detailed information about which pages the end users are viewing for your app: Go to one.newrelic.com > Browser > (select an app) > Page views. Select the time period or sort order, or keep the defaults. If available, select the type of view for page load timing information as a chart (default), histogram, or percentile. To view summary information about a specific transaction, mouse over the transaction's name on the list. To compare page load time between real user (browser) interactions and trends appearing in Synthetic monitors, select a page monitored by Synthetics, then examine additional comparative charting details. Examine timing details for page loads The Browser page load time chart view shows the average page load time broken down into segments. This chart also appears on the Summary page and Browsers detail page. one.newrelic.com > Browser > (select an app) > Page views: The Browser page load time chart shows the average page load time broken down into segments indicating the end users' experience (sometimes referred to as real user monitoring or RUM). The page load timing process shows colored-coded details: Page load timing process Description Request queuing (black) Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple) Time spent in the application code. Network (brown) The network latency, or the time it takes for a request to make a round trip over the Internet. For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. DOM processing (yellow) In the browser, parsing and interpreting the HTML. Measured by the browser's DOMContent event. Page rendering (blue) In the browser, the time to display the HTML, run the inline JavaScript, and load images. Measured by the browser's Load event. \"Additional\" timing data If you are using the JavaScript API, your \"additional\" timing data appears in this chart. Examine page view details Use any of New Relic's standard user interface functions to drill down into detailed information. In addition, to view details about a specific page view, select its name from the list. To close an individual page view and return to the Page views page, select X (Close). Each page view listed in the list may include links to additional drill-down details: Page view details Comments Page load performance This includes page load timing breakdown data, throughput, session traces, and browser traces (if available). Historical performance This shows response time, Apdex comparisons, and throughput for the last selected time period, yesterday, and last week. AJAX calls Table with links to detailed information about endpoints, as well as sortable columns by endpoint, average response time, throughput, and total calls. APM transactions For browser apps that are also monitored by APM, this table shows the total call time, average response time, call count, and link to the APM Transactions page. one.newrelic.com > Browser > (select an app) > Page views > (select a transaction): Depending on the app, individual transactions may have links to additional drill-down details, including Page load performance, Historical performance, AJAX calls, and APM transactions. Use additional APM-monitored app options Browser apps that are also monitored by APM may have access to additional functions. To use these functions (if available): From the selected transaction's APM Transactions tab, select an APM transaction from the list. Then select any of these options (from APM): Track as key transaction (create a new key transaction) Key transaction (view existing) Transaction traces > (selected trace) (view)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.77403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>additional</em> APM-<em>monitored</em> app options",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": ") In the <em>browser</em>, the time to display the HTML, run the inline JavaScript, and load images. Measured by the <em>browser</em>&#x27;s Load event. &quot;<em>Additional</em>&quot; timing data If you are using the JavaScript API, your &quot;<em>additional</em>&quot; timing data appears in this chart. Examine page view details Use any of New Relic&#x27;s <em>standard</em>"
      },
      "id": "6044280d28ccbc697e2c60bb"
    },
    {
      "sections": [
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Important",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "7b26e484a4645be8c580650fd7d71a159114bf50",
      "image": "https://docs.newrelic.com/static/793341e63f8e5b444d7cc98a1f5a7d90/c1b63/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location/",
      "published_at": "2021-10-07T13:33:07Z",
      "updated_at": "2021-03-11T07:31:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Important Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > B * *rowser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings * * , the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide < % throughput checkbox ( < 1% for global view, < 2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.87837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> Geography: Webpage performance by location",
        "sections": "<em>Browser</em> Geography: Webpage performance by location",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s Geography page provides a world view with color-coded Apdex scores and other performance information about your end users&#x27; experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load"
      },
      "id": "604429e7196a67193d960f75"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    }
  ],
  "/docs/browser/new-relic-browser/additional-standard-features/page-views-examine-page-performance": [
    {
      "sections": [
        "Browsers: Problem patterns by type or platform",
        "Viewing browsers by type",
        "Viewing specific browser details"
      ],
      "title": "Browsers: Problem patterns by type or platform",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "275b49bb70dc8c016dd8d2cc03f5438f540780fe",
      "image": "https://docs.newrelic.com/static/28f8a0d40fe374ccd766b61d6b89e7a1/c1b63/browsers_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browsers-problem-patterns-type-or-platform/",
      "published_at": "2021-10-07T17:58:05Z",
      "updated_at": "2021-07-09T22:48:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Browsers page in browser monitoring provides information about your end users' experience with your app based on which browser they use, such as Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari. This page includes: Top browsers by throughput (pages per minute or ppm) Average page load time by platform type (mobile, tablet, desktop) Drill-down charts also segment the selected browser type by version; for example, Chrome 31, 32, 33, etc. This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Viewing browsers by type To view browser information: Go to one.newrelic.com, click Browser > (select an app) > Browsers. one.newrelic.com > Browser > (select an app) > Browsers: This page provides information about throughput (pages per minute) and average page load time for your end users' browser types. Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Browsers page: If you want to... Do this... View summary browser information for a specific time Mouse over any area on the chart. Hide (or return) data on the chart Select the corresponding color or title on the chart's legend. View detailed information about the browser Select its name on the list or a place on the chart. Close the detail window and return to the Browsers page Select X (Close). Viewing specific browser details The drill-down details include a breakdown by version and the average page load time. one.newrelic.com > Browser > (select an app) > Browsers > (select a browser type): This example shows a specific browser type selected (Firefox). The largest number of users have version 42.0, so by hiding this label (or any others) in the legend, you can easily examine details about other versions. Color-coded segments for Average page load time include: Request queuing (black): Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple): Time spent in the application code. Network (brown): The network latency, or time it takes for a request to make a round trip over the Internet. DOM processing (yellow): In the browser, parsing and interpreting the HTML and retrieving assets. Measured by the browser's DOMContentLoaded event. Page rendering (blue): In the browser, displaying the HTML, running in-line JavaScript, and loading images. Measured by the browser's Load event. Note: For apps that have been deployed using the copy/paste method, browser includes web app and queue time in Network time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 201.74284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browsers</em>: Problem patterns by type or platform",
        "sections": "<em>Browsers</em>: Problem patterns by type or platform",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": ") and average page load time for your end users&#x27; <em>browser</em> types. Use any of our <em>standard</em> user interface functions and page functions to drill down into detailed information. Here is a summary of <em>additional</em> options with the Browsers page: If you want to... Do this... View summary <em>browser</em> information"
      },
      "id": "6043f968e7b9d2bd425799d3"
    },
    {
      "sections": [
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Important",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "7b26e484a4645be8c580650fd7d71a159114bf50",
      "image": "https://docs.newrelic.com/static/793341e63f8e5b444d7cc98a1f5a7d90/c1b63/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location/",
      "published_at": "2021-10-07T13:33:07Z",
      "updated_at": "2021-03-11T07:31:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Important Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > B * *rowser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings * * , the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide < % throughput checkbox ( < 1% for global view, < 2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.87837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> Geography: Webpage performance by location",
        "sections": "<em>Browser</em> Geography: Webpage performance by location",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s Geography page provides a world view with color-coded Apdex scores and other performance information about your end users&#x27; experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load"
      },
      "id": "604429e7196a67193d960f75"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/actiontext-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.1849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.1849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/add-release": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.1848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api": [
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    },
    {
      "sections": [
        "setName (browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "setName (browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "9a9af0c4b58f0cdc3a87d60d7239eca6b9af868b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setname-browser-spa-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:25Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a SPA's browser interaction that is not a route change or URL change. Requirements Agent version nr-963 or higher. Description This SPA monitoring method sets the name and trigger of a browser interaction. The name will be exposed as the browserInteractionName attribute in the BrowserInteraction event. It will also be used for grouping in the UI. By default, browserInteractionName is named after an associated URL or route. Use setName() when you want to record an interaction that is not a route change or URL change. The setCurrentRouteName() method also names the current route. When you use both: setName() takes precedence for naming the interaction. The previousRouteName and targetRouteName attributes are still set with values passed to setCurrentRouteName(). Using these methods together allows many options for filtering and grouping in the UI. For example, you can: Filter down to interactions of a certain type, such as LikeButtonClick. Then, group by targetRouteName to see what routes have the most LikeButtonClick interactions. Tip This API call applies to data in SPA page views in browser and the BrowserInteraction event type within New Relic One. To set a custom name for standard page views and the PageView event type, see setPageViewName. Using both calls together is recommended. Parameters Parameter Description $name string Required. If null, the name will be set using the targetGroupedUrl attribute. If not null, this will set the browserInteractionName attribute in the BrowserInteraction event. $trigger string Optional. If not null, this will set the TRIGGER attribute on the BrowserInteraction event. Return values This method returns the same API object created by interaction(). Examples document.getElementById('subscribe').addEventListener('submit', () => { newrelic.interaction().setName('createSubscription') createSubscription() }) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a <em>SPA</em>&#x27;s <em>browser</em> interaction that is not a route change or URL change. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> <em>monitoring</em> method sets the name and trigger of a <em>browser</em>"
      },
      "id": "6043fe38196a677688960f98"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/createtracer-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.1848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/end-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02852,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/finished": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.0285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/getcontext-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/ignore-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18454,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/index": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 3036.4224,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2320.292,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> monitoring with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setName (browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "setName (browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "9a9af0c4b58f0cdc3a87d60d7239eca6b9af868b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setname-browser-spa-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:25Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a SPA's browser interaction that is not a route change or URL change. Requirements Agent version nr-963 or higher. Description This SPA monitoring method sets the name and trigger of a browser interaction. The name will be exposed as the browserInteractionName attribute in the BrowserInteraction event. It will also be used for grouping in the UI. By default, browserInteractionName is named after an associated URL or route. Use setName() when you want to record an interaction that is not a route change or URL change. The setCurrentRouteName() method also names the current route. When you use both: setName() takes precedence for naming the interaction. The previousRouteName and targetRouteName attributes are still set with values passed to setCurrentRouteName(). Using these methods together allows many options for filtering and grouping in the UI. For example, you can: Filter down to interactions of a certain type, such as LikeButtonClick. Then, group by targetRouteName to see what routes have the most LikeButtonClick interactions. Tip This API call applies to data in SPA page views in browser and the BrowserInteraction event type within New Relic One. To set a custom name for standard page views and the PageView event type, see setPageViewName. Using both calls together is recommended. Parameters Parameter Description $name string Required. If null, the name will be set using the targetGroupedUrl attribute. If not null, this will set the browserInteractionName attribute in the BrowserInteraction event. $trigger string Optional. If not null, this will set the TRIGGER attribute on the BrowserInteraction event. Return values This method returns the same API object created by interaction(). Examples document.getElementById('subscribe').addEventListener('submit', () => { newrelic.interaction().setName('createSubscription') createSubscription() }) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2015.9231,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a <em>SPA</em>&#x27;s <em>browser</em> interaction that is not a route change or URL change. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> monitoring method sets the name and trigger of a <em>browser</em>"
      },
      "id": "6043fe38196a677688960f98"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.1844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/noticeerror-browser-agent-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02844,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/set-error-handler": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.1842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setattribute-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.1841,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02841,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setcurrentroutename-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.0284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setName (browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "setName (browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "9a9af0c4b58f0cdc3a87d60d7239eca6b9af868b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setname-browser-spa-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:25Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a SPA's browser interaction that is not a route change or URL change. Requirements Agent version nr-963 or higher. Description This SPA monitoring method sets the name and trigger of a browser interaction. The name will be exposed as the browserInteractionName attribute in the BrowserInteraction event. It will also be used for grouping in the UI. By default, browserInteractionName is named after an associated URL or route. Use setName() when you want to record an interaction that is not a route change or URL change. The setCurrentRouteName() method also names the current route. When you use both: setName() takes precedence for naming the interaction. The previousRouteName and targetRouteName attributes are still set with values passed to setCurrentRouteName(). Using these methods together allows many options for filtering and grouping in the UI. For example, you can: Filter down to interactions of a certain type, such as LikeButtonClick. Then, group by targetRouteName to see what routes have the most LikeButtonClick interactions. Tip This API call applies to data in SPA page views in browser and the BrowserInteraction event type within New Relic One. To set a custom name for standard page views and the PageView event type, see setPageViewName. Using both calls together is recommended. Parameters Parameter Description $name string Required. If null, the name will be set using the targetGroupedUrl attribute. If not null, this will set the browserInteractionName attribute in the BrowserInteraction event. $trigger string Optional. If not null, this will set the TRIGGER attribute on the BrowserInteraction event. Return values This method returns the same API object created by interaction(). Examples document.getElementById('subscribe').addEventListener('submit', () => { newrelic.interaction().setName('createSubscription') createSubscription() }) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a <em>SPA</em>&#x27;s <em>browser</em> interaction that is not a route change or URL change. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> <em>monitoring</em> method sets the name and trigger of a <em>browser</em>"
      },
      "id": "6043fe38196a677688960f98"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setName (browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "setName (browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "9a9af0c4b58f0cdc3a87d60d7239eca6b9af868b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setname-browser-spa-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:25Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a SPA's browser interaction that is not a route change or URL change. Requirements Agent version nr-963 or higher. Description This SPA monitoring method sets the name and trigger of a browser interaction. The name will be exposed as the browserInteractionName attribute in the BrowserInteraction event. It will also be used for grouping in the UI. By default, browserInteractionName is named after an associated URL or route. Use setName() when you want to record an interaction that is not a route change or URL change. The setCurrentRouteName() method also names the current route. When you use both: setName() takes precedence for naming the interaction. The previousRouteName and targetRouteName attributes are still set with values passed to setCurrentRouteName(). Using these methods together allows many options for filtering and grouping in the UI. For example, you can: Filter down to interactions of a certain type, such as LikeButtonClick. Then, group by targetRouteName to see what routes have the most LikeButtonClick interactions. Tip This API call applies to data in SPA page views in browser and the BrowserInteraction event type within New Relic One. To set a custom name for standard page views and the PageView event type, see setPageViewName. Using both calls together is recommended. Parameters Parameter Description $name string Required. If null, the name will be set using the targetGroupedUrl attribute. If not null, this will set the browserInteractionName attribute in the BrowserInteraction event. $trigger string Optional. If not null, this will set the TRIGGER attribute on the BrowserInteraction event. Return values This method returns the same API object created by interaction(). Examples document.getElementById('subscribe').addEventListener('submit', () => { newrelic.interaction().setName('createSubscription') createSubscription() }) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93578,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a <em>SPA</em>&#x27;s <em>browser</em> interaction that is not a route change or URL change. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> <em>monitoring</em> method sets the name and trigger of a <em>browser</em>"
      },
      "id": "6043fe38196a677688960f98"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setname-browser-spa-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18393,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02838,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02837,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setName (browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "setName (browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "9a9af0c4b58f0cdc3a87d60d7239eca6b9af868b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setname-browser-spa-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:25Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a SPA's browser interaction that is not a route change or URL change. Requirements Agent version nr-963 or higher. Description This SPA monitoring method sets the name and trigger of a browser interaction. The name will be exposed as the browserInteractionName attribute in the BrowserInteraction event. It will also be used for grouping in the UI. By default, browserInteractionName is named after an associated URL or route. Use setName() when you want to record an interaction that is not a route change or URL change. The setCurrentRouteName() method also names the current route. When you use both: setName() takes precedence for naming the interaction. The previousRouteName and targetRouteName attributes are still set with values passed to setCurrentRouteName(). Using these methods together allows many options for filtering and grouping in the UI. For example, you can: Filter down to interactions of a certain type, such as LikeButtonClick. Then, group by targetRouteName to see what routes have the most LikeButtonClick interactions. Tip This API call applies to data in SPA page views in browser and the BrowserInteraction event type within New Relic One. To set a custom name for standard page views and the PageView event type, see setPageViewName. Using both calls together is recommended. Parameters Parameter Description $name string Required. If null, the name will be set using the targetGroupedUrl attribute. If not null, this will set the browserInteractionName attribute in the BrowserInteraction event. $trigger string Optional. If not null, this will set the TRIGGER attribute on the BrowserInteraction event. Return values This method returns the same API object created by interaction(). Examples document.getElementById('subscribe').addEventListener('submit', () => { newrelic.interaction().setName('createSubscription') createSubscription() }) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "setName (<em>browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().setName(string $name[, string $trigger]) Copy Sets the name and trigger of a <em>SPA</em>&#x27;s <em>browser</em> interaction that is not a route change or URL change. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> <em>monitoring</em> method sets the name and trigger of a <em>browser</em>"
      },
      "id": "6043fe38196a677688960f98"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/spa-on-end": [
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.18375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "sections": [
        "setCustomAttribute (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-10-07T17:09:30Z",
      "updated_at": "2021-09-08T16:30:26Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description Adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on a Drupal-generated page: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    },
    {
      "sections": [
        "setPageViewName (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Tip",
        "Parameters",
        "Examples"
      ],
      "title": "setPageViewName (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "06753169e4112e9919b48cd7336a93cd677e9dd9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api/",
      "published_at": "2021-10-07T06:48:40Z",
      "updated_at": "2021-07-10T02:39:24Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setPageViewName(string $name[, string $host]) Copy Groups page views to help URL structure or to capture the URL's routing information. Requirements Agent version nr-593 or higher. Description Customized page names can help you more effectively group your page views if your URL structure does not provide useful groupings or if the browser agent doesn't capture the part of the URL where routing information is stored. When querying the PageView event, the custom name will be exposed as the browserTransactionName attribute. The custom name will also be visible in the browser monitoring UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This API call applies to data in standard page views in browser and the PageView event. To set a custom name for SPA page views and the BrowserInteraction event, see SPA: setName. Using both calls together is recommended. Parameters Parameter Description $name string Required. The page name you want to use. Use alphanumeric characters. $host string Optional. Default is http://custom.transaction. Typically set host to your site's domain URI. To further group these custom transactions, provide a custom host. Otherwise, the page views will be assigned the default domain custom.transaction. Segments within the name must be explicitly added to your URL allow list settings if they do not already appear. Examples newrelic.setPageViewName('/login') // Or newrelic.setPageViewName('/login', 'https://www.myapp.com') Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.93576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setPageViewName (<em>browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " <em>monitoring</em> UI. To use a customized page view name instead of the page URL, format the name as a slash-delimited string. Make this call before the window load event fires in order for it to appear correctly. Tip This <em>API</em> call applies to data in standard page views in <em>browser</em> and the PageView event"
      },
      "id": "6043fe3864441f6899378ec7"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/new-relic-browser-release-notes/browser-agent-release-notes/browser-agent-v1158/",
      "sections": [
        "Browser agent v1158",
        "Notes",
        "Agent release schedule Browser distributed tracing CORS support",
        "Distributed tracing for cross-origin AJAX calls"
      ],
      "published_at": "2021-10-07T23:38:08Z",
      "title": "Browser agent v1158",
      "updated_at": "2021-03-11T04:55:59Z",
      "type": "docs",
      "external_id": "c0401a8459b88dd2ce42f5c0415d7e873dd77e5d",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Notes This agent release includes functionality to support the addition of cross-origin resource sharing (CORS) for Browser's distributed tracing feature. This agent will be rolled out prior to the feature availability in the UI. Please note that the Browser-distributed-tracing feature is only supported with our Browser Pro + SPA agent. Full feature availability delivered on Jan. 2, 2019. Agent release schedule Browser distributed tracing CORS support APM auto-injected agents: 12/19/2019 Copy/Paste agent: 12/30/2019 Distributed tracing for cross-origin AJAX calls The agent can now add the newrelic distributed tracing header to outgoing cross-origin AJAX calls. The origins that the agent should add headers to must be defined in the distributed_tracing.allowed_origins configuration section. Users can now enable CORS from the Browser 'Application settings' page. For complete feature documentation, visit the Enable cross-origin resource sharing (CORS) section of our Browser data in distributed tracing documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 875.49207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> agent v1158",
        "sections": "Agent release schedule <em>Browser</em> <em>distributed</em> <em>tracing</em> CORS support",
        "body": " the newrelic <em>distributed</em> <em>tracing</em> header to outgoing cross-origin AJAX calls. The origins that the agent should add headers to must be defined in the <em>distributed_tracing</em>.allowed_origins configuration section. Users can now enable CORS from the <em>Browser</em> &#x27;Application settings&#x27; page. For complete feature documentation, visit the Enable cross-origin resource sharing (CORS) section of our <em>Browser</em> <em>data</em> in <em>distributed</em> <em>tracing</em> documentation."
      },
      "id": "60451be2196a6763df960f40"
    },
    {
      "sections": [
        "Missing trace data",
        "Problem",
        "Solution",
        "Important",
        "Problems with enabling or instrumenting",
        "Missing spans due to service not having distributed tracing enabled",
        "Missing apps/services may require manual instrumentation",
        "Problems with spans",
        "Infinite Tracing: missing spans",
        "Missing span not getting exported",
        "Missing spans due to sampling process",
        "Missing spans due to span limits maxed out",
        "Missing spans due to spans being sent late",
        "Problems with trace details",
        "Middleware doesn't recognize proprietary New Relic header",
        "An intermediary is missing or isn't passing trace context",
        "Tip",
        "Stitching together spans from mixed sources",
        "Trace details are obfuscated",
        "Trace list information and trace details don't match",
        "Long traces with short backend times",
        "Problems with browser applications",
        "Missing spans and transactions after enabling for a browser application",
        "Not seeing browser app end-user spans",
        "Browser spans are not connected to other spans",
        "Other problems",
        "Search by entity.name not finding associated app names",
        "Supporting OpenTelemetry"
      ],
      "title": "Missing trace data",
      "type": "docs",
      "tags": [
        "Understand dependencies",
        "Distributed tracing",
        "Troubleshooting"
      ],
      "external_id": "2997172d74563c4fa31d5a9fc05c562d62c1c790",
      "image": "https://docs.newrelic.com/static/ef51359ad9a7999f7fdaf812fab535bc/d7542/missing-exporter.png",
      "url": "https://docs.newrelic.com/docs/distributed-tracing/troubleshooting/missing-trace-data/",
      "published_at": "2021-10-07T03:25:56Z",
      "updated_at": "2021-07-08T22:10:20Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You have enabled distributed tracing but data you expected to see does not appear in New Relic's distributed tracing UI. Solution Important Before performing troubleshooting, we recommend reading How distributed tracing works. Here are some causes and solutions when you have problems finding expected data in the distributed tracing UI: Problems with enabling or instrumenting Missing spans due to service not having distributed tracing enabled In order for distributed tracing to report details for all nodes in a trace, each application must be monitored by a New Relic agent that has had distributed tracing enabled. If an application's New Relic account has not had distributed tracing enabled, it will have these issues: Its distributed tracing UI page won't have data. It won't report data to other accounts' distributed traces. Missing apps/services may require manual instrumentation When you enable distributed tracing for applications and services that New Relic automatically instruments, you'll usually see complete and detailed data for those nodes in the distributed tracing UI. However, you may notice that some services or applications are missing from traces, or that there are some internal spans you expect to see that are missing. If that's the case, you may want to implement custom instrumentation of applications or specific transactions to see more detail in traces. Some examples of when you may need to do this: Transactions not automatically instrumented. To ensure your application is automatically instrumented, read the compatibility and requirements documentation for the New Relic agent you're using. If an application isn't automatically instrumented, or if you'd like to add instrumentation of specific activity, see Custom instrumentation. All Go applications. The Go agent, unlike other agents, requires manual instrumentation of your code. For instructions, see Instrument a Go application. A service doesn't use HTTP. If a service doesn't communicate via HTTP, the New Relic agent won't send distributed tracing headers. This may be the case for some non-web applications or message queues. To remedy this, use the distributed tracing APIs to instrument either the calling or called application. Problems with spans Infinite Tracing: missing spans If your APM agent can’t write data fast enough to the trace observer, queue_size is an additional APM agent configuration to limit the number of spans the agent will hold. See the following examples for your agent: .NET configuration method Example Configuration file <configuration . . . > <infiniteTracing> <trace_observer> <span_events queue_size=\"100000\" /> </trace_observer> </infiniteTracing> </configuration> Copy Environment variable NEW_RELIC_INFINITE_TRACING_SPAN_EVENTS_QUEUE_SIZE=100000 Copy Python configuration method Example Configuration file infinite_tracing.span_queue_size = 100000 Environment Variable NEW_RELIC_INFINITE_TRACING_SPAN_QUEUE_SIZE = 100000 Missing span not getting exported Sometimes header propagation is successful, but the span information isn't getting sent to New Relic. For example, if OpenTelemetry is not instrumented with a New Relic exporter, the span details never make it to New Relic. In this diagram, notice that the header propagation is successful, but no exporter is set up in Service 2 to send the span to New Relic: The following diagram also shows successful header propagation, but it includes an exporter in Service 2 that sends the span details to New Relic (see Trace API): Missing spans due to sampling process Standard distributed tracing for APM uses adaptive sampling. This means that a percentage of calls to a service will be reported as part of a distributed trace. Specific calls to your service might not have been selected to be sampled. Missing spans due to span limits maxed out There are limits on the number of spans that can be collected and displayed. If an application generates a very large number of spans for a single call, it might exceed the APM agent's span-collection limit for that harvest cycle. This could result in missing spans and significantly limit the number of traces the agent can completely sample and report. We currently only show 10,000 spans at a time. Missing spans due to spans being sent late Spans must be sent within the last twenty minutes to be captured in a trace index. If you send any spans older than twenty minutes but newer than a day, the span data will still be written. However, it won't be rolled into the trace index, which controls the trace list in the distributed tracing UI. If a span has a timestamp older than a day, it will be dropped. This often occurs when there is clock skew (timing differences) between systems or long running background jobs. Problems with trace details Middleware doesn't recognize proprietary New Relic header If your transactions are only sending the proprietary New Relic header, some middleware might not recognize the format and then drop the information as shown in this diagram: One solution is to upgrade your New Relic agent to a version that supports W3C trace context. In the diagram below, the W3C-compliant New Relic agent passes the prior header along with two standardized headers: An intermediary is missing or isn't passing trace context Some potential problems with proxies and other intermediaries: Incomplete trace. Some intermediaries won't automatically propagate the distributed tracing header. In that case, you must configure that component to allow the header to be passed from source to destination. For instructions, consult the documentation for that intermediary component. Missing intermediary in trace. If the intermediary is New Relic-monitored, ensure that it propagates the newrelic header that is generated or updated by the New Relic agent running on that intermediary. This may manifest when an intermediary was previously visible in traces, but disappeared after distributed tracing was enabled for an upstream entity (for example, a browser-monitored application). Tip If some entities report trace data to another tracing system, you can use the trace ID from the New Relic UI to search other tracing systems for missing spans. Stitching together spans from mixed sources If each agent in a chain supports W3C Trace Context, then we can stitch the spans together into a complete trace. If part of the chain is from an agent, such as Zipkin, which doesn't support W3C Trace Context, then spans coming from that agent may not be included in the trace. Trace details are obfuscated If a trace contains data from applications monitored by multiple New Relic accounts, and your user permissions don't allow you to access those accounts, some of the span and service details will be obfuscated in the UI. For example, you may see a series of asterisks ( * * * * * ) instead of the service name in your distributed tracing list if you don't have access to the account linked with the service. Trace list information and trace details don't match The trace list is generated by trace indexes, which are captured in a twenty minute window from when the first spans are received. Usually, this is due to late spans. Long traces with short backend times If you're seeing unusually short backend times for long traces, this is likely an issue with the timestamps being sent. For example, the root span might be reposting microseconds as milliseconds. This can also happen if the root span is a browser application. When using an external client like a web browser, you may experience clock skew (timing differences) more often. Problems with browser applications Missing spans and transactions after enabling for a browser application Older versions of some APM agents are incompatible with distributed tracing for browser applications. If the browser application makes an AJAX request to an APM application running an incompatible agent, then the APM agent may not record transaction and span data for that request. If distributed tracing is enabled for a browser application and you are not seeing transaction or span data for downstream APM requests, review the browser data in distributed tracing requirements, and confirm that all applications are running supported versions of the APM agent. Not seeing browser app end-user spans If traces seem to be missing end-user spans, be sure you've read and understand the browser distributed tracing requirements and enable procedures. On the AJAX UI page, there are links to the distributed tracing UI regardless of whether there are end-user spans present in that trace. For details about what data generates spans, see Requirements. Browser spans are not connected to other spans Older versions of some APM agents are incompatible with distributed tracing for browser applications. If APM spans are missing consistently from traces that include browser applications, please refer to the browser data in distributed tracing requirements and confirm that all applications are running supported versions of the APM agent. For other causes of orphaned browser spans, see Browser span reporting. Other problems Search by entity.name not finding associated app names Potential cause: For applications that have multiple app names, the entity.name attribute will be associated only with the primary app name. To search by other app names, search using the appName attribute. Supporting OpenTelemetry Questions about integrating with OpenTelemetry should be taken to the Explorers Hub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 666.9205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Missing <em>trace</em> <em>data</em>",
        "sections": "Missing spans due to service not having <em>distributed</em> <em>tracing</em> enabled",
        "tags": "<em>Distributed</em> <em>tracing</em>",
        "body": " <em>distributed</em> <em>tracing</em> requirements and enable procedures. On the AJAX UI page, there are links to the <em>distributed</em> <em>tracing</em> UI regardless of whether there are end-user spans present in that <em>trace</em>. For details about what <em>data</em> generates spans, see Requirements. <em>Browser</em> spans are not connected to other"
      },
      "id": "6072a76764441f109b9d857b"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/new-relic-browser-release-notes/browser-agent-release-notes/browser-agent-v1153/",
      "sections": [
        "Browser agent v1153",
        "New features",
        "Support for End User Originated Spans in Distributed Tracing",
        "New PageViewTiming Event to capture User Centric Perceived Performance metrics in real time",
        "Improvements",
        "How to upgrade"
      ],
      "published_at": "2021-10-07T23:36:59Z",
      "title": "Browser agent v1153",
      "updated_at": "2021-03-11T04:55:59Z",
      "type": "docs",
      "external_id": "7c906e4e2be3219168d283ef8560a72be4f64c0f",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New features Support for End User Originated Spans in Distributed Tracing New Relic now supports end-to-end distributed tracing with this release. For our Browser & APM Pro customers, you can now enable the Browser spans for any app that uses our Browser Pro + SPA agent. This MVP includes support for same-origin AJAX requests that originate during a BrowserInteraction event. This AJAX request will be listed as the root entry span for a trace. Learn More For more details about APM & Browser agent version requirements and enablement, see our Browser Data in Distributed Tracing Page. Please note that not all APM agents are supported at this time. For more details about all supported Span attributes, visit our Event Data Dictionary Known Issues Enabling Browser in Distributed Tracing for use with current versions of these language agents, Java, PHP, and C, will result in disconnected traces (single span traces for all Browser requests) and potentially the loss of APM transaction traces and spans. Please see the APM compatibility requirements for supported versions and estimated release dates. New PageViewTiming Event to capture User Centric Perceived Performance metrics in real time With this release, we are tying together the visual and responsiveness performance for our customer's site. With every page view, the agent is now capturing the time of the first interaction along with FID (First Input Delay). The existing paint timing metrics (First Paint and First Contentful Paint) are now collected even when they occur after the load event. All of these new metrics are captured on the new PageViewTiming events, available in Insights. This new event type is available for all agents, but requires a Browser Pro subscription. Visit our New Relic Event Data Dictionary for a list of attributes and more details about the PageViewTiming event. First Interaction First Interaction timing captures the moment in time that a user first engages with a site. Within this timing, we also capture the type of interaction (click, key, mousedown, etc). This timing represents the first step in calculating the First Input Delay, which is the time from First Interaction to the moment that the site responds (is interactive). First Input Delay FID is a metric that tracks the delay between the time a user can attempt to interact with a part of the site (for example, when they click a link, tap on a button, or use a custom, JavaScript-powered control), and the time that the interface is able to respond to that interaction. We have all experienced situations where a webpage has visibly loaded, but when we try to click around on buttons or any JavaScript-powered interactive elements, nothing responds. This delay is what the FID metric tracks. The FID metric is in some ways an intersection of the First Contentful Paint and Time to Interactive metrics. It lies in the middle of those two points, measuring the time between the FCP (and therefore when a first input can be made) and when the browser’s main thread is able to respond to any interactions. One major point of FID that differentiates it from Time to Interactive is that it requires a user to interact! TTI can be calculated without user input, so it is somewhat less powerful in the sense that it isn't providing any new information about my user's active experience or frustration, we can only assume that slow = bad. Why only consider the first input Learn more For more information and query examples, see our PageViewTiming event documentation. For more information about the Paint Timing browser compatibility, see the Browser compatibility and requirements documentation. For more information about User-Centric Perceived Performance metrics, visit the Google Developers Web Fundamentals Guides on Performance. For more information about the difference between FID and TTI, see When Users Click: Tracking First Input Delay Improvements Browser interactions now wait on external scripts to finish loading: Browser interactions measure the time of all Javascript code that runs as a result of an interaction. The agent now includes the time it takes to load and execute external scripts. This is useful, for example, when the code started by an interaction must be loaded first (lazy loading). How to upgrade To upgrade your agent to the latest version, see Upgrade the Browser agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 574.03345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> agent v1153",
        "sections": "Support for End User Originated Spans <em>in</em> <em>Distributed</em> <em>Tracing</em>",
        "body": " for same-origin AJAX requests that originate during a <em>Browser</em>Interaction event. This AJAX request will be listed as the root entry span for a <em>trace</em>. Learn More For more details about APM &amp; <em>Browser</em> agent version requirements and enablement, see our <em>Browser</em> <em>Data</em> in <em>Distributed</em> <em>Tracing</em> Page. Please note"
      },
      "id": "60451ba664441f60ee378f2a"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/browser-error-profiles-find-error-causes": [
    {
      "sections": [
        "Manage error data",
        "Error data types: events and trace details",
        "Events",
        "Trace details",
        "Caps on error reporting",
        "Charting error rates and counts",
        "Report custom errors",
        "Ignore errors",
        "Reduce noise with expected errors",
        "Disable error traces",
        "Delete error traces",
        "Caution"
      ],
      "title": "Manage error data",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "29a2ebdc7b91029a1fada50791b90e9dc548f17e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/manage-error-data/",
      "published_at": "2021-10-07T16:45:10Z",
      "updated_at": "2021-09-08T19:58:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's APM Errors page helps you identify, triage, and fix errors in your services. The Errors page uses data collected by the APM agent to display stack traces, transaction attributes such as HTTP header values, and any other custom attributes, so you can understand the context of the error and fix it. Error data types: events and trace details By default, our APM agents collect two type of error data: Events Trace details Events The error event data type includes default attributes, as well as any custom attributes instrumented in your service. It doesn't include a stack trace. Find your events data in the Errors UI as follows: The Errors column in the Error traces table. The Top 5 errors chart. When you’ve drilled into a grouping of errors, those errors not displaying a stack trace are based on this type of data. You can disable Show only errors with stack trace to show errors that have this type of data collected, but no associated trace details. Events are subject to sampling (see Caps on error reporting and Charting error rates and counts). For more on error event data, see Events reported by APM. Trace details The trace details error data type includes stack traces and attributes, and supplements events with more data. It's expected that more events will be reported than trace details--see Caps on error reporting. Find your trace details data in the Errors UI as follows: The “Stack traces” column of the Error traces table. When you’ve drilled into a grouping of errors, those errors with a stack trace use this type of data: Show only errors with stack trace is enabled by default, to constrain the errors shown to just those that have this type of data collected. This data is governed by specific retention rules for Error details. Caps on error reporting New Relic caps error reporting at: 100 events per minute per agent instance 20 trace details per minute per agent instance These caps prevent error reporting from negatively impacting application performance. Examples: App running across five EC2 instances, one JVM each. New Relic caps error reporting at: 100 events per minute x 5 instances = 500 events per minute 20 trace details per minute x 5 instances = 100 trace details per minute App running on one host with ten instances. New Relic caps error reporting at: 100 events per minute x 10 instances = 1000 events per minute 20 trace details per minute x 10 instances = 200 events per minute Charting error rates and counts The Error rate chart is driven by a query on metric timeslice data, which is an unsampled aggregate data type that is accurate but has very limited dimensionality. This data can't be faceted or filtered as flexibly as error event data. You can reproduce this chart in a dashboard, or explore the metric timeslice data further by clicking the ... menu on the Error rate chart, and then using the View query or Add to dashboard options. To chart faceted error counts using event data, as in the Top 5 errors chart, use an NRQL event query. Click the ... menu on the Top 5 errors chart and choose View query for a starting point in creating your chart. Since event data can be sampled (see Caps on error reporting), you can use the EXTRAPOLATE keyword to get an accurate error count, even if sampling is occurring. Report custom errors You can report errors not collected by default with our agents using our agent APIs. For more, see the documentation on the API. Ignore errors You can prevent certain errors that would normally be reported to New Relic from being collected using our agent APIs or the server-side configuration UI. For more details, see Manage errors in APM. Reduce noise with expected errors Sometimes you want to collect error data, but not have those errors wake you up through alerts. Using the agent API, you can mark such errors as “expected”. They’ll still be visible in the Errors page, but won’t affect your service’s error rate or Apdex metrics. Disable error traces To prevent certain errors from being reported to New Relic, disable them in your agent's configuration file. For most agents, you can ignore certain error codes or disable errors completely. For more information, see your specific agent's configuration documentation: C SDK Go (not applicable; the agent only reports errors when configured to do so) Java .NET Node.js PHP Python Ruby Delete error traces Caution You cannot recover error traces after you delete them. Deleting errors is currently only available in the legacy Errors Classic UI. If you want to... Do this... Delete all error traces for your app If you have permissions to delete all error traces for an app: Go to one.newrelic.com > APM > (select an app) > More views > Errors (classic). Select Delete all errors. Delete all error traces for your account To delete all error traces for your New Relic account, get support at support.newrelic.com. Delete individual error traces To delete individual error traces, use APM's Errors (classic) page. Drill into an error from the table of errors, then click Delete this error. In addition to deleting error traces, you may also want to delete transaction traces or database/slow SQL traces. This will remove potentially sensitive data while retaining your other application data (such as Apdex, deployment information, etc.).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.05675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>error</em> data",
        "sections": "Manage <em>error</em> data",
        "tags": "<em>Error</em> analytics",
        "body": " and fix it. <em>Error</em> data types: events and trace details By default, our APM agents collect two type of <em>error</em> data: Events Trace details Events The <em>error</em> event data type includes default attributes, as well as any custom attributes instrumented in your service. It doesn&#x27;t include a stack trace. <em>Find</em>"
      },
      "id": "6044077e28ccbcab752c60d1"
    },
    {
      "sections": [
        "APM Error profiles: Troubleshoot trends",
        "Tip",
        "Error profile attribute examples",
        "Error profiles feature in APM",
        "Select error profile criteria",
        "Error profile criteria example",
        "Analyze error profile results",
        "Error and non-error distribution",
        "Top deviating values",
        "Other category",
        "No value category",
        "Filters"
      ],
      "title": "APM Error profiles: Troubleshoot trends",
      "type": "docs",
      "tags": [
        "APM",
        "APM UI pages",
        "Error analytics"
      ],
      "external_id": "14c286f0cf0f8cc14674c6422fdfa6286393ca6e",
      "image": "https://docs.newrelic.com/static/fcd404afa812236cf952f7861f28cca3/8c557/apm-error-profile-tab-demo.png",
      "url": "https://docs.newrelic.com/docs/apm/apm-ui-pages/error-analytics/apm-error-profiles-troubleshoot-trends/",
      "published_at": "2021-10-07T18:21:05Z",
      "updated_at": "2021-09-08T19:58:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When DevOps experts need to track down what causes errors in your app, it may not be easy to identify the cause. APM's error profiles automatically compare one set of events to another. Each error profile provides visual details about significant differences in the frequency of different values for the events. For each attribute, the error profile includes: A pie chart showing how the error's attribute is distributed for values that deviate the most A table comparing the error attribute's distribution to that of non-erroring transactions This helps you take more of the guesswork out of resolving your app errors. You can more easily determine if you can safely ignore the error, or if you should attempt to resolve the error with a new deployment, code edits, customer communications, or other actions. Tip To view error profiles, you must use the classic APM view in New Relic One. To get a high-level overview of all your applications and services, use the New Relic Explorer in New Relic One. Error profile attribute examples Error profiles appear as a separate tab on your APM Errors page. Error profiles feature in APM Use error profiles to troubleshoot trends and significant differences in the frequency of error events for your app. An error profile is a collection of attributes with significantly different traits compared to non-errors. An attribute is \"unusual\" if a set of events represent what is normal (for example, errors compared to all traffic for a given time window), or differences between similar criteria (for example, two different hosts). Errors may be related to events such as: Specific web transaction names or non-web transaction names, JVM thread names, etc. Unique types of error messages, classes, etc. Random customer interactions; for example, a particular error comes from a single customer's account, while normal traffic comes from a wide variety of accounts External call counts or duration Timing differences among hosts in your ecosystem, cluster agent IDs, etc. Other anomalies Select error profile criteria Based on criteria in your app's Errors page, New Relic analyzes and lists unusual trends by their significance. Your selected criteria includes: Time window Errors page filters Search criteria on the Errors page or the Error profiles tab As you examine error profile results and want to dig deeper, add or change your app's error profile criteria. The Error profile tab refreshes to show the traits that distinguish the errors that match the updated criteria. Error profile criteria example Your app's Error profile tab currently shows several error classes or messages. To filter to a specific error class or message, use any of these options: From the Errors page's time picker, change the time range. For example, change the default (30 minutes) to Last 24 hours, ending now. From the Errors page's filter section: Select Back to groupings list, then select other Error groups, Error attributes, or Custom attributes. From the Errors page's filter section: Click a specific item on the list to narrow the filter. For example, if several error messages are listed, click only the message you are interested in. From the Error profiles tab's search box, type class, message, or other search values. Analyze error profile results To examine details for the attribute results in your app's error profile, you must use the classic APM view in New Relic One. Go to one.newrelic.com/apm > APM > (select an app) > Events > Errors, then toggle Show new view so that APM shows the classic view of the Errors page. From the Errors page, select the Error profile tab. From the Error profile tab, review the list of error attributes that match the currently selected error profile criteria. To view a specific attribute's details, click it. To highlight specific error details, mouse over any pie chart segment or table row for the attribute. To investigate a specific attribute for your app's errors, type its name in the Error profiles tab's search window, or change the currently selected error profile criteria. Compare values with large differences to identify the traits that distinguish the errors for an attribute. The comparative data in the error profile results and the error trace details can help you decide what steps to take for additional troubleshooting and resolving the error. Error and non-error distribution Depending on an error's attributes, sometimes the attribute is distributed differently for errors than for non-errors. Top deviating values New Relic analyzes each attribute for your app's errors and compares the distribution for errors that match your criteria to transactions without errors. If the proportions between these errors are roughly the same compared to transactions without any errors, the attribute does not contain much useful information for debugging. New Relic limits the error profile's pie chart and table for each attribute to show only the top deviating values. When proportions are roughly the same, New Relic does not include them in the error profile. Other category After the top deviating values, the error profile groups the rest into an Other category. This helps you focus on the values that are different for these errors. No value category If values are unusually present or are not present in the errors, you may see a No value category on the list of error profiles. Filters If you do not have any filters selected, the profile shows any distinguishing traits your errors exhibit in aggregate. Example: A certain kind of transaction makes up 20% of all of your traffic and is responsible for 80% of your errors. The error profile will show the unexpected proportions in the Transaction attribute. Adjust your error profile criteria to drill down even deeper into the profile results, so you can more effectively troubleshoot and resolve specific error events.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.05673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>Error</em> <em>profiles</em>: Troubleshoot trends",
        "sections": "APM <em>Error</em> <em>profiles</em>: Troubleshoot trends",
        "tags": "<em>Error</em> analytics",
        "body": "When DevOps experts need to track down what <em>causes</em> errors in your app, it may not be easy to identify the cause. APM&#x27;s <em>error</em> <em>profiles</em> automatically compare one set of events to another. Each <em>error</em> profile provides visual details about significant differences in the frequency of different values"
      },
      "id": "6044074764441fe72a378f08"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/icon/",
      "sections": [
        "Icon",
        "Usage",
        "Examples",
        "Props"
      ],
      "published_at": "2021-10-09T01:50:24Z",
      "title": "Icon",
      "updated_at": "2021-09-30T18:37:39Z",
      "type": "developer",
      "external_id": "c6efdde9954d4b3df76ecab1c3326e5fd5bfe083",
      "document_type": "page",
      "popularity": 1,
      "body": "Usage import { Icon } from 'nr1' Copy Examples Props classNamestring Appends class names to the component. Should be used only for positioning and spacing purposes. colorstring Color of the icon. By default it gets the current value of the css color property of the element. spacingTypeenum[] Spacing property. Spacing is defined as a tuple of zero to four values, which follow the same conventions as CSS properties like margin or padding. To omit a value, use SPACING_TYPE.OMIT. <Array of <One of Icon.SPACING_TYPE.EXTRA_LARGE , Icon.SPACING_TYPE.LARGE , Icon.SPACING_TYPE.MEDIUM , Icon.SPACING_TYPE.NONE , Icon.SPACING_TYPE.OMIT , Icon.SPACING_TYPE.SMALL , > > styleobject Inline style for custom styling. Should be used only for positioning and spacing purposes. testIdstring Adds a data-test-id attribute. Use it to target the component in unit and e2e tests. typerequiredenum Name of the icon to display. <One of Icon.TYPE.DATAVIZ__DATAVIZ__AREA_CHART , Icon.TYPE.DATAVIZ__DATAVIZ__BAR_CHART , Icon.TYPE.DATAVIZ__DATAVIZ__CHART , Icon.TYPE.DATAVIZ__DATAVIZ__CHART__A_ADD , Icon.TYPE.DATAVIZ__DATAVIZ__CHART__A_EDIT , Icon.TYPE.DATAVIZ__DATAVIZ__CHART__A_REMOVE , Icon.TYPE.DATAVIZ__DATAVIZ__DASHBOARD , Icon.TYPE.DATAVIZ__DATAVIZ__DASHBOARD__A_ADD , Icon.TYPE.DATAVIZ__DATAVIZ__DASHBOARD__A_EDIT , Icon.TYPE.DATAVIZ__DATAVIZ__DASHBOARD__A_FILTER , Icon.TYPE.DATAVIZ__DATAVIZ__DASHBOARD__A_REMOVE , Icon.TYPE.DATAVIZ__DATAVIZ__LINE_CHART , Icon.TYPE.DATAVIZ__DATAVIZ__PIE_CHART , Icon.TYPE.DATE_AND_TIME__DATE_AND_TIME__DATE , Icon.TYPE.DATE_AND_TIME__DATE_AND_TIME__DATE__A_ADD , Icon.TYPE.DATE_AND_TIME__DATE_AND_TIME__DATE__A_REMOVE , Icon.TYPE.DATE_AND_TIME__DATE_AND_TIME__TIME , Icon.TYPE.DATE_AND_TIME__DATE_AND_TIME__TIME__A_ADD , Icon.TYPE.DATE_AND_TIME__DATE_AND_TIME__TIME__A_REMOVE , Icon.TYPE.DOCUMENTS__DOCUMENTS__ATTACHMENT , Icon.TYPE.DOCUMENTS__DOCUMENTS__DOCUMENTATION , Icon.TYPE.DOCUMENTS__DOCUMENTS__EMAIL , Icon.TYPE.DOCUMENTS__DOCUMENTS__EMAIL__V_ALTERNATE , Icon.TYPE.DOCUMENTS__DOCUMENTS__FILE , Icon.TYPE.DOCUMENTS__DOCUMENTS__FILE__A_ADD , Icon.TYPE.DOCUMENTS__DOCUMENTS__FILE__A_REMOVE , Icon.TYPE.DOCUMENTS__DOCUMENTS__FOLDER , Icon.TYPE.DOCUMENTS__DOCUMENTS__FOLDER__A_ADD , Icon.TYPE.DOCUMENTS__DOCUMENTS__FOLDER__A_REMOVE , Icon.TYPE.DOCUMENTS__DOCUMENTS__NOTES , Icon.TYPE.DOCUMENTS__DOCUMENTS__NOTES__A_ADD , Icon.TYPE.DOCUMENTS__DOCUMENTS__NOTES__A_EDIT , Icon.TYPE.DOCUMENTS__DOCUMENTS__NOTES__A_REMOVE , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__ANOMALIES , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__CLUSTER , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__CLUSTER__A_INSPECT , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__CLUSTER__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__CLUSTER__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__CLUSTER__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__CLUSTER__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__CPU , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__DESKTOP , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__DESKTOP__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__DESKTOP__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__DESKTOP__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__DESKTOP__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__MEMORY , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__MOBILE , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__MOBILE__A_CHECKED , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__MOBILE__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__MOBILE__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__MOBILE__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__MOBILE__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__NETWORK , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__NETWORK__A_INSPECT , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__NETWORK__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__NETWORK__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__NETWORK__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__NETWORK__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__A_ADD , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__A_CONFIGURE , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__A_EDIT , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__A_INSPECT , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__A_PAUSE , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__A_REMOVE , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__SERVER__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__HARDWARE__STORAGE , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_CLUSTER , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_CONTAINER , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_DEPLOYMENT , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_MASTER_NODE , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_NAMESPACE , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_NODE , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_POD , Icon.TYPE.HARDWARE_AND_SOFTWARE__KUBERNETES__K8S_SERVICE , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__ALL_ENTITIES , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__A_CHECKED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__BROWSER , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__BROWSER__A_CHECKED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__BROWSER__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__BROWSER__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__BROWSER__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__BROWSER__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__CLOUD , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__CODE , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__CONTAINER , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__CONTROL_CENTER , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__CORRELATION , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__CORRELATION_REASONING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DATABASE , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DATABASE__A_CHECKED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DATABASE__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DATABASE__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DATABASE__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DATABASE__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DECISIONS , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DESTINATIONS , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DOWNSTREAM_CONNECTION , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__DOWNSTREAM_DEPLOYMENT , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__EVENT , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__FEED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__LIVE_VIEW , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__LOGS , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__MOBILE_APPLICATION , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__MOBILE_APPLICATION__A_CHECKED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__MOBILE_APPLICATION__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__MOBILE_APPLICATION__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__MOBILE_APPLICATION__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__MOBILE_APPLICATION__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__MONITORING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__NODE , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__OVERVIEW , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__PATHWAY , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__PLUGIN , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__PLUGIN__A_CHECKED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__PLUGIN__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__PLUGIN__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__PLUGIN__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__PLUGIN__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__QUERY , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SERVICE , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SERVICE__A_CHECKED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SERVICE__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SERVICE__S_ERROR , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SERVICE__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SERVICE__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SOURCES , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__STACK_TRACE , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SYNTHESIZED_ENTITY , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SYNTHETICS_MONITOR , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__SYSTEM , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__TRACES , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__TRAFFIC , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__UPSTREAM_CONNECTION , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__UPSTREAM_DEPLOYMENT , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__WORKLOADS , Icon.TYPE.INTERFACE__ARROW__ARROW_BOTTOM , Icon.TYPE.INTERFACE__ARROW__ARROW_BOTTOM__V_ALTERNATE , Icon.TYPE.INTERFACE__ARROW__ARROW_BOTTOM__V_ALTERNATE__WEIGHT_BOLD , Icon.TYPE.INTERFACE__ARROW__ARROW_DIAGONAL_BOTTOM_LEFT , Icon.TYPE.INTERFACE__ARROW__ARROW_DIAGONAL_BOTTOM_RIGHT , Icon.TYPE.INTERFACE__ARROW__ARROW_DIAGONAL_TOP_LEFT , Icon.TYPE.INTERFACE__ARROW__ARROW_DIAGONAL_TOP_RIGHT , Icon.TYPE.INTERFACE__ARROW__ARROW_HORIZONTAL , Icon.TYPE.INTERFACE__ARROW__ARROW_LEFT , Icon.TYPE.INTERFACE__ARROW__ARROW_LEFT__V_ALTERNATE , Icon.TYPE.INTERFACE__ARROW__ARROW_LEFT__V_ALTERNATE__WEIGHT_BOLD , Icon.TYPE.INTERFACE__ARROW__ARROW_RIGHT , Icon.TYPE.INTERFACE__ARROW__ARROW_RIGHT__V_ALTERNATE , Icon.TYPE.INTERFACE__ARROW__ARROW_RIGHT__V_ALTERNATE__WEIGHT_BOLD , Icon.TYPE.INTERFACE__ARROW__ARROW_TOP , Icon.TYPE.INTERFACE__ARROW__ARROW_TOP__V_ALTERNATE , Icon.TYPE.INTERFACE__ARROW__ARROW_TOP__V_ALTERNATE__WEIGHT_BOLD , Icon.TYPE.INTERFACE__ARROW__ARROW_VERTICAL , Icon.TYPE.INTERFACE__ARROW__EXPAND , Icon.TYPE.INTERFACE__ARROW__GO_TO , Icon.TYPE.INTERFACE__ARROW__MOVE , Icon.TYPE.INTERFACE__ARROW__RESIZE , Icon.TYPE.INTERFACE__ARROW__RETURN_LEFT , Icon.TYPE.INTERFACE__ARROW__RETURN_RIGHT , Icon.TYPE.INTERFACE__ARROW__SHRINK , Icon.TYPE.INTERFACE__ARROW__SORT , Icon.TYPE.INTERFACE__CARET__CARET_BOTTOM , Icon.TYPE.INTERFACE__CARET__CARET_BOTTOM__SIZE_8 , Icon.TYPE.INTERFACE__CARET__CARET_BOTTOM__V_ALTERNATE , Icon.TYPE.INTERFACE__CARET__CARET_BOTTOM__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CARET__CARET_BOTTOM__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__CARET__CARET_LEFT , Icon.TYPE.INTERFACE__CARET__CARET_LEFT__SIZE_8 , Icon.TYPE.INTERFACE__CARET__CARET_LEFT__V_ALTERNATE , Icon.TYPE.INTERFACE__CARET__CARET_LEFT__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CARET__CARET_LEFT__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__CARET__CARET_RIGHT , Icon.TYPE.INTERFACE__CARET__CARET_RIGHT__SIZE_8 , Icon.TYPE.INTERFACE__CARET__CARET_RIGHT__V_ALTERNATE , Icon.TYPE.INTERFACE__CARET__CARET_RIGHT__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CARET__CARET_RIGHT__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__CARET__CARET_TOP , Icon.TYPE.INTERFACE__CARET__CARET_TOP__SIZE_8 , Icon.TYPE.INTERFACE__CARET__CARET_TOP__V_ALTERNATE , Icon.TYPE.INTERFACE__CARET__CARET_TOP__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CARET__CARET_TOP__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_BOTTOM , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_BOTTOM__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_BOTTOM__V_ALTERNATE , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_BOTTOM__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_BOTTOM__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_LEFT , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_LEFT__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_LEFT__V_ALTERNATE , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_LEFT__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_LEFT__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_RIGHT , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_RIGHT__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_RIGHT__V_ALTERNATE , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_RIGHT__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_RIGHT__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_TOP , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_TOP__SIZE_8 , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_TOP__V_ALTERNATE , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_TOP__WEIGHT_BOLD , Icon.TYPE.INTERFACE__CHEVRON__CHEVRON_TOP__WEIGHT_BOLD__SIZE_8 , Icon.TYPE.INTERFACE__INFO__ANNOUNCEMENT , Icon.TYPE.INTERFACE__INFO__HELP , Icon.TYPE.INTERFACE__INFO__INFO , Icon.TYPE.INTERFACE__INFO__INFO__WEIGHT_BOLD , Icon.TYPE.INTERFACE__OPERATIONS__ADJUST , Icon.TYPE.INTERFACE__OPERATIONS__ALERT , Icon.TYPE.INTERFACE__OPERATIONS__ALERT__A_REMOVE , Icon.TYPE.INTERFACE__OPERATIONS__ALERT__S_OFF , Icon.TYPE.INTERFACE__OPERATIONS__ALERT__S_ON , Icon.TYPE.INTERFACE__OPERATIONS__ARCHIVE , Icon.TYPE.INTERFACE__OPERATIONS__CENTER , Icon.TYPE.INTERFACE__OPERATIONS__CLOSE , Icon.TYPE.INTERFACE__OPERATIONS__CLOSE__SIZE_8 , Icon.TYPE.INTERFACE__OPERATIONS__CLOSE__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__CONFIGURE , Icon.TYPE.INTERFACE__OPERATIONS__COPY_TO , Icon.TYPE.INTERFACE__OPERATIONS__COPY_TO_CLIPBOARD , Icon.TYPE.INTERFACE__OPERATIONS__DOWNLOAD , Icon.TYPE.INTERFACE__OPERATIONS__DRAG , Icon.TYPE.INTERFACE__OPERATIONS__EDIT , Icon.TYPE.INTERFACE__OPERATIONS__EXPORT , Icon.TYPE.INTERFACE__OPERATIONS__EXTERNAL_LINK , Icon.TYPE.INTERFACE__OPERATIONS__FILTER , Icon.TYPE.INTERFACE__OPERATIONS__FILTER__A_ADD , Icon.TYPE.INTERFACE__OPERATIONS__FILTER__A_REMOVE , Icon.TYPE.INTERFACE__OPERATIONS__FILTER__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__FOLLOW , Icon.TYPE.INTERFACE__OPERATIONS__GROUP , Icon.TYPE.INTERFACE__OPERATIONS__GROUP__A_REMOVE , Icon.TYPE.INTERFACE__OPERATIONS__GROUP__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__HIDE , Icon.TYPE.INTERFACE__OPERATIONS__HIDE_OTHERS , Icon.TYPE.INTERFACE__OPERATIONS__HIGHLIGHT , Icon.TYPE.INTERFACE__OPERATIONS__IMPORT , Icon.TYPE.INTERFACE__OPERATIONS__MORE , Icon.TYPE.INTERFACE__OPERATIONS__PAUSE , Icon.TYPE.INTERFACE__OPERATIONS__PAUSE_ALTERNATE__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__PIN , Icon.TYPE.INTERFACE__OPERATIONS__PLAY , Icon.TYPE.INTERFACE__OPERATIONS__PLAY_ALTERNATE__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__REARRANGE , Icon.TYPE.INTERFACE__OPERATIONS__REDO , Icon.TYPE.INTERFACE__OPERATIONS__REFRESH , Icon.TYPE.INTERFACE__OPERATIONS__REMOVE__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__SEARCH , Icon.TYPE.INTERFACE__OPERATIONS__SEARCH__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__SELECTION , Icon.TYPE.INTERFACE__OPERATIONS__SELECTION__V_ALTERNATE , Icon.TYPE.INTERFACE__OPERATIONS__SHARE , Icon.TYPE.INTERFACE__OPERATIONS__SHARE_LINK , Icon.TYPE.INTERFACE__OPERATIONS__SHOW , Icon.TYPE.INTERFACE__OPERATIONS__SKIP_BACK , Icon.TYPE.INTERFACE__OPERATIONS__SKIP_FORWARD , Icon.TYPE.INTERFACE__OPERATIONS__TAG , Icon.TYPE.INTERFACE__OPERATIONS__TRASH , Icon.TYPE.INTERFACE__OPERATIONS__TV_MODE , Icon.TYPE.INTERFACE__OPERATIONS__TV_MODE__A_TV_MODE , Icon.TYPE.INTERFACE__OPERATIONS__UNDO , Icon.TYPE.INTERFACE__OPERATIONS__UNPIN , Icon.TYPE.INTERFACE__OPERATIONS__UPLOAD , Icon.TYPE.INTERFACE__PLACEHOLDERS__CUSTOM_PLACEHOLDER , Icon.TYPE.INTERFACE__PLACEHOLDERS__ICON_PLACEHOLDER , Icon.TYPE.INTERFACE__SIGN__ASTERISK , Icon.TYPE.INTERFACE__SIGN__CHECKMARK , Icon.TYPE.INTERFACE__SIGN__CHECKMARK__V_ALTERNATE , Icon.TYPE.INTERFACE__SIGN__CHECKMARK__V_ALTERNATE__WEIGHT_BOLD , Icon.TYPE.INTERFACE__SIGN__CLOSE , Icon.TYPE.INTERFACE__SIGN__DOLLAR_SIGN , Icon.TYPE.INTERFACE__SIGN__EXCLAMATION , Icon.TYPE.INTERFACE__SIGN__EXCLAMATION__V_ALTERNATE , Icon.TYPE.INTERFACE__SIGN__MINUS , Icon.TYPE.INTERFACE__SIGN__MINUS__V_ALTERNATE , Icon.TYPE.INTERFACE__SIGN__NUMBER , Icon.TYPE.INTERFACE__SIGN__PLUS , Icon.TYPE.INTERFACE__SIGN__PLUS__V_ALTERNATE , Icon.TYPE.INTERFACE__SIGN__TIMES , Icon.TYPE.INTERFACE__SIGN__TIMES__SIZE_8 , Icon.TYPE.INTERFACE__SIGN__TIMES__V_ALTERNATE , Icon.TYPE.INTERFACE__STATE__CLOSED , Icon.TYPE.INTERFACE__STATE__CRITICAL , Icon.TYPE.INTERFACE__STATE__CRITICAL__WEIGHT_BOLD , Icon.TYPE.INTERFACE__STATE__DISABLED , Icon.TYPE.INTERFACE__STATE__ENABLED , Icon.TYPE.INTERFACE__STATE__HEALTHY , Icon.TYPE.INTERFACE__STATE__LOADING , Icon.TYPE.INTERFACE__STATE__LOCK , Icon.TYPE.INTERFACE__STATE__OPEN , Icon.TYPE.INTERFACE__STATE__PRIVATE , Icon.TYPE.INTERFACE__STATE__PUBLIC , Icon.TYPE.INTERFACE__STATE__UNAVAILABLE , Icon.TYPE.INTERFACE__STATE__UNLOCK , Icon.TYPE.INTERFACE__STATE__WARNING , Icon.TYPE.INTERFACE__STATE__WARNING__WEIGHT_BOLD , Icon.TYPE.INTERFACE__VIEW__ENTER_FULL_SCREEN , Icon.TYPE.INTERFACE__VIEW__EXIT_FULL_SCREEN , Icon.TYPE.INTERFACE__VIEW__GRID_VIEW , Icon.TYPE.INTERFACE__VIEW__HIGH_DENSITY_VIEW , Icon.TYPE.INTERFACE__VIEW__LAYER_LIST , Icon.TYPE.INTERFACE__VIEW__LIST_VIEW , Icon.TYPE.INTERFACE__VIEW__SIXTH_SENSE , Icon.TYPE.INTERFACE__VIEW__THEME_TOGGLE , Icon.TYPE.INTERFACE__VIEW__THEME_TOGGLE__S_DARK , Icon.TYPE.INTERFACE__VIEW__THEME_TOGGLE__S_LIGHT , Icon.TYPE.LOCATION__LOCATION__HOME , Icon.TYPE.LOCATION__LOCATION__MAP , Icon.TYPE.LOCATION__LOCATION__PIN , Icon.TYPE.LOCATION__LOCATION__WORLD , Icon.TYPE.PROFILES__EVENTS__COMMENT , Icon.TYPE.PROFILES__EVENTS__COMMENT__A_EDIT , Icon.TYPE.PROFILES__EVENTS__FAVORITE , Icon.TYPE.PROFILES__EVENTS__FAVORITE__WEIGHT_BOLD , Icon.TYPE.PROFILES__EVENTS__LIKE , Icon.TYPE.PROFILES__USERS__ORGANIZATION , Icon.TYPE.PROFILES__USERS__ORGANIZATION__A_ADD , Icon.TYPE.PROFILES__USERS__ORGANIZATION__A_EDIT , Icon.TYPE.PROFILES__USERS__ORGANIZATION__A_REMOVE , Icon.TYPE.PROFILES__USERS__TEAM , Icon.TYPE.PROFILES__USERS__TEAM__A_ADD , Icon.TYPE.PROFILES__USERS__TEAM__A_EDIT , Icon.TYPE.PROFILES__USERS__TEAM__A_REMOVE , Icon.TYPE.PROFILES__USERS__USER , Icon.TYPE.PROFILES__USERS__USER__A_ADD , Icon.TYPE.PROFILES__USERS__USER__A_EDIT , Icon.TYPE.PROFILES__USERS__USER__A_REMOVE , >",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.34836,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_DISABLED , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_<em>ERROR</em> , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_OK , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__APPLICATION__S_WARNING , Icon.TYPE.HARDWARE_AND_SOFTWARE__SOFTWARE__<em>BROWSER</em>"
      },
      "id": "6091f874196a678161d52a63"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location": [
    {
      "sections": [
        "Browser settings: UI options for Apdex and geography",
        "Select Apdex and geography settings",
        "View end-user Apdex"
      ],
      "title": "Browser settings: UI options for Apdex and geography",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Configuration"
      ],
      "external_id": "36b483a11fe529bec2644f008679908aaab60162",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/browser-settings-ui-options-apdex-geography/",
      "published_at": "2021-10-07T17:00:37Z",
      "updated_at": "2021-07-10T02:41:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of the browser setup requirements, you must install the browser agent. Then you can use the your app's Applications settings page to update browser monitoring options for: Browser subscription levels Browser Apdex T values Cities, regions, or countries to be highlighted on the Filterable geography page Select Apdex and geography settings For apps that are also monitored by APM, you can set separate Apdex T values for browser (end users) and for APM. You can also select cities, regions, or countries to be highlighted on the Filterable geography page. Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. From Application settings, select an Apdex T value specifically for browser monitoring, or leave the default Apdex value. Select up to five countries or regions for browser monitoring to highlight on the Filterable geography page. If you are reporting data to multiple app names, select the same countries in both the primary and secondary apps. Select Save application settings. Whenever you change Apdex settings, a black vertical bar appears on the Page load timing chart on your browser app's Summary page. View end-user Apdex To view your Apdex score: Go to one.newrelic.com > Browser > (select an app) > Summary. OR Go to one.newrelic.com > Browser > (select an app) > Page views.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.611664,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser settings: UI options for Apdex and <em>geography</em>",
        "sections": "Browser settings: UI options for Apdex and <em>geography</em>",
        "body": " <em>geography</em> page Select Apdex and <em>geography</em> settings For apps that are also monitored by APM, you can set separate Apdex T values for browser (end users) and for APM. You can also select cities, regions, or countries to be highlighted on the <em>Filterable</em> <em>geography</em> page. Go to one.newrelic.com &gt; Browser"
      },
      "id": "6043fea6196a676128960f4b"
    },
    {
      "sections": [
        "Geography page for mobile apps",
        "Tip",
        "Viewing the Geography page",
        "Viewing drill-down details"
      ],
      "title": "Geography page for mobile apps",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "Mobile monitoring UI",
        "Network pages"
      ],
      "external_id": "ec64765f7b48034c3c6e666cd8f553b28be7ca06",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/geography-page-mobile-apps/",
      "published_at": "2021-10-07T20:05:39Z",
      "updated_at": "2021-07-09T12:27:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Geography page shows your mobile users' experience as a world view, including: Color-coded response times Network requests (calls per minute) Data transfer size Active devices Network failure rates You can also drill down to detailed information about each country. Tip The Geography feature is not the same as the Map feature. The Map page shows an architectural view of the relationship between a mobile app and its related services. Viewing the Geography page To view or sort the mobile response time by country: Go to one.newrelic.com > Mobile > (select an app) > Network > Geography. To change the information that appears (including response time, requests per minute, total transfer size, active devices, or network failure rate), select your choice from the Sort by menu. To adjust the amount of information that appears, select Hide < 1% throughput. To view summary information about a location, mouse over any area in color on the map, or mouse over the country's name on the list. Use any of our standard user interface functions and page functions to drill down into detailed information. Viewing drill-down details To view detailed information about a specific location (including average response time, calls per minute, active devices, and network failure by type), select its location on the Geography page's map, or select its name on the list.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.80021,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Geography</em> page for mobile apps",
        "sections": "<em>Geography</em> page for mobile apps",
        "body": " average response time, calls per minute, active devices, and network failure by type), select its <em>location</em> on the <em>Geography</em> page&#x27;s map, or select its name on the list."
      },
      "id": "6044165a196a67660d960f44"
    },
    {
      "sections": [
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Important",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "7b26e484a4645be8c580650fd7d71a159114bf50",
      "image": "https://docs.newrelic.com/static/793341e63f8e5b444d7cc98a1f5a7d90/c1b63/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location/",
      "published_at": "2021-10-07T13:33:07Z",
      "updated_at": "2021-03-11T07:31:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Important Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > B * *rowser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings * * , the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide < % throughput checkbox ( < 1% for global view, < 2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.58926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser <em>Geography</em>: <em>Webpage</em> performance <em>by</em> <em>location</em>",
        "sections": "Browser <em>Geography</em>: <em>Webpage</em> performance <em>by</em> <em>location</em>",
        "body": " to the main <em>Geography</em> page, select X (Close). one.newrelic.com &gt; B * *rowser &gt; (select an app) &gt; Geo &gt; (select a <em>location</em>): If you selected specific locations from Settings &gt; Application settings * * , the <em>Geography</em> page includes tabs to view their performance data directly. Use page functions Use any"
      },
      "id": "604429e7196a67193d960f75"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/intro-to-browser-pro-features": [
    {
      "sections": [
        "JavaScript errors page: Detect and analyze errors",
        "View JavaScript errors",
        "Query and visualize JS data",
        "Use API to monitor handled errors",
        "Review event logs",
        "Important",
        "Troubleshoot missing event logs",
        "View stack traces",
        "Troubleshoot missing stack traces",
        "Global and generic errors"
      ],
      "title": "JavaScript errors page: Detect and analyze errors",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "90edc523244dbf2bf9a9c23b0a00e3e09634e4df",
      "image": "https://docs.newrelic.com/static/2d5c8d1b43fe37ec696af0dbf8e1f7d4/c1b63/browser_jserrors_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/javascript-errors-page-detect-analyze-errors/",
      "published_at": "2021-10-07T02:54:32Z",
      "updated_at": "2021-07-10T02:40:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JS errors UI page shows you where your JavaScript errors are happening, and provides tools to help you figure out the root cause. You can also query and create dashboards of JS error data in the query builder, or use the browser API to monitor handled errors. View JavaScript errors To examine JavaScript errors: Go to one.newrelic.com > Browser > (select an app) > JS errors. Use the available options in the UI to examine what may be causing the errors. Optional: Review event logs or stack traces in the UI. Optional: Query and create dashboards for JS error data with the query builder, or use the API to monitor or log errors. Available options in the UI include: If you want to... Do this Search through long error lists Use the Search box so you can more quickly find and fix errors by keywords, URLs, etc. Group and filter attributes To change how your error data is grouped, use the Group by function. (The Page loads chart cannot be changed with grouping.) To filter the data by only showing errors with specific attributes, use the Filter dropdown. See notable anomalies and patterns The Error profiles table shows notable statistical variations, such as browser versions or devices that have errors occurring more frequently than normal. Examine error details Select an error from the main page to view detailed information about that error, such as the top five browsers that error occurred on, the top five devices it occurred on, and associated URIs. Select Error instances to see event logs and stack traces, if available. Examine events leading up to error The Event log shows the browser interactions, AJAX calls, and traces that led up to an error. Decode your minified JavaScript If your JavaScript is minified, the errors on the JS errors page may not be very useful. To decode minified JavaScript and make these error stack traces more useful, you can upload JavaScript source maps to New Relic. one.newrelic.com > Browser > (select an app) > JS errors: Use this page to group and filter errors, explore stack trace details, and examine trends. (If your UI page looks different, you may be using an older, deprecated UI.) Query and visualize JS data New Relic saves JS errors as event data. This allows you to query your error data in the query builder. To run NRQL queries and create dashboards to view or share, query the JavaScriptError event type in the query builder. Use API to monitor handled errors To notice or log your app's handled errors or other miscellaneous errors, use the browser API's noticeError call. Review event logs Important SPA monitoring must be enabled. The event log shows the browser interactions, AJAX calls, and traces that led up to a JS error. This can help you troubleshoot the root cause of errors. one.newrelic.com > Browser > (select an app) > JS errors > (select an error) > Error instances: With SPA monitoring enabled, the event log shows you the activity leading up to an error. To view the Event log (if available): Go to one.newrelic.com > Browser > (select an app) > JS errors > (select an error) > Error instances. The event log will not be visible if there are no events in the event log. For example, if a JS error is occurring after an AJAX request that provides an error message, it could be that your AJAX request doesn't contain the right information. This results in a JS error due to a failed AJAX call. Troubleshoot missing event logs Some reasons for events in the event log not being present: Agent version. To capture event log data your site must have SPA monitoring enabled (browser agent version 1071 or higher). JS error not part of a browser interaction. If the JS error occurs outside of an interaction, the related browser interaction details cannot be captured (for example: if an async JS file experiences an error). A click triggered the JS error. In some cases if the error is a direct result of a click, no associated interactions are captured. Without event logs or stack traces, you can use the error detail charts to analyze the impact the error has by browser type, device type, and URI. View stack traces Stack traces can show you if an error is breaking important functionality, or if it's a less important error. To view an error's stack trace (if available): go to one.newrelic.com > Browser > (select an app) > JS errors > (select an error) > Error instances. Troubleshoot missing stack traces Some reasons why you may not see a stack trace for an error: If errors are not thrown, they will not produce a stack trace. The JS script is hosted on a CDN or another external location, and New Relic can't see the errors originating from those scripts. This can be solved in some cases by using cross-origin resource sharing (CORS). It is an AngularJS error. For more on this, see Missing Angular errors. The error is a SyntaxError or Script error: These occur while the script is loading, so they do not produce a stack trace. Some older browsers may generate errors without a stack trace, or may provide a stack trace that is not usable. You've captured the error before the New Relic agent sees it. If the error occurs during multiple harvest cycles in the same user visit, only error events reported during the first harvest cycle will have a stack trace recorded. Some solutions for reporting stack traces: Use the noticeError API call. Enable development mode. Use the JS errors UI page to get more information, including the event log. The JS errors page is designed to give you actionable information even without a stack trace. Global and generic errors New Relic wraps JavaScript functions to get information about thrown errors via the stack trace. If errors aren't thrown, they won't be available. For example, if you have an AngularJS application, follow the troubleshooting procedures when AngularJS errors do not appear in the UI. For some older browsers, the following errors may be unavailable: SyntaxError or Script error: These occur while the script is loading, so they do not produce a stack trace. In-line JavaScript or event handler errors: These are unwrapped. Errors thrown from third-party scripts that reside on another domain are not available. Errors occurring on older browsers: These may not be able to provide a usable stack trace. In some cases, they may not provide a stack trace at all. Error collection is done by wrapping JavaScript functions, so errors thrown by the browser at a lower level (such as cross-origin resource sharing errors) also are not available.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.23001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " request doesn&#x27;t contain the right information. This results in a JS error due to a failed AJAX call. Troubleshoot missing event logs Some reasons for events in the event log not being present: <em>Agent</em> version. To capture event log data your site must have SPA monitoring enabled (<em>browser</em> <em>agent</em> version"
      },
      "id": "6043fcf228ccbc12062c6080"
    },
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.56848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> <em>agent</em> API)",
        "sections": "addToTrace (<em>browser</em> <em>agent</em> API)",
        "tags": "<em>Browser</em> <em>agent</em> and SPA API",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements <em>Agent</em> version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    },
    {
      "image": "https://docs.newrelic.com/static/565d4ebddf52a4592c594032696516b9/c1b63/New-Relic-capabilities-UI-screenshot.png",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/new-relic-one-user-management/new-relic-one-user-model-understand-user-structure/",
      "sections": [
        "Users, roles, permissions (New Relic One user model)",
        "Important",
        "Overview",
        "User type: basic and full",
        "Compare full vs basic capabilities",
        "Tips on choosing user type",
        "Understand user-related billing",
        "Have questions about why you can't access something?",
        "Default groups: Admin and User",
        "How do user type, roles, and groups relate to each other?",
        "Roles and capabilities",
        "Standard (default) roles",
        "Capabilities",
        "Manage users",
        "2020 user model changes"
      ],
      "published_at": "2021-10-07T00:05:31Z",
      "title": "Users, roles, permissions (New Relic One user model)",
      "updated_at": "2021-10-07T00:05:31Z",
      "type": "docs",
      "external_id": "169383c2678ce973404db07195b2dee6eda9163d",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic users can be on one of two user models: this doc explains the New Relic One user model. Important If your New Relic organization was created before July 30 2020 and you haven't gone through a user migration process, your users are likely on our original user model. For more on this, see User model changes. Overview This doc will explain the structure of the New Relic One user model, including: User type (basic user versus full user) Default user groups, including Admin and User Roles and capabilities For how to add and manage users in the UI, see User management. User type: basic and full Important This section is for users on our New Relic One user model. If you're on our original user model, see Original users. The user type (basic user or full user) determines whether a user has access to our Full Stack Observability features. A user's type is something you set long-term based on that user's expected New Relic responsibilities. Below are details on the two user types. Note that billing-related aspects only apply if you're on New Relic One pricing. Basic user. Details: These users are free and have access to a wide range of features, including setting up and configuring any New Relic data-reporting tool, running queries of your data, using our logs UI, making custom charts and dashboards, and setting up alerts. Unlike full users, they do not have access to our Full-Stack Observability features and some Applied Intelligence features (for a detailed comparison, see Capabilities). Basic users will see prompts to become a full user when they attempt to access unavailable features. For details, see Upgrade. Full user. Details: Full users have access to our Full-Stack Observability features, which include curated UI experiences like APM, infrastructure monitoring, browser monitoring, mobile monitoring, synthetic monitors, access to New Relic One apps, and more. For details, see Capabilities. Standard edition includes one free full user and up to five total full users. A full user can downgrade to a basic user twice in a 12-month period. To view and edit the user type of your users, use the User management UI. Learn more about basic user versus full user differences: Compare full vs basic capabilities Below is a table comparing what basic users and full users can do. In short: basic users have access to our Telemetry Data Platform and some Applied Intelligence features, while full users have theoretical access to everything (dependent on any group-related restrictions). Another way to think about this is that full users are users with access to Full Stack Observability, which gates our more curated UI features. Features Full user Basic user Full-Stack Observability (Curated UI experiences) Application performance monitoring (APM) UI Infrastructure monitoring UI Digital Experience Monitoring UI, which includes: Browser monitoring UI Mobile monitoring UI Synthetic monitoring UI Synthetics checks Serverless monitoring UI Logs in context Distributed tracing Infinite Tracing (Pro and Enterprise edition) Assorted UI experiences, including: Kubernetes cluster explorer UI Key transaction UI Workloads UI Manage other users Access to New Relic One apps Can build apps but can't access other apps Applied Intelligence Automatic anomaly detection Correlated alerts and events Anomaly/alert analysis Root cause details in issues Telemetry Data Platform Data ingest from any source (agents, integrations, APIs) Query your data Create custom charts and dashboards Alerts and notifications Our APIs, including NerdGraph (GraphQL) (with some restrictions) Query and chart log data Build New Relic One apps (but cannot access other apps) Encryption at rest Standard data retention Security and compliance Data management Note that the pricing edition (Standard, Pro, or Enterprise) will also affect what features you have access to. For organizations with New Relic One pricing, learn more about how full users impact billing. Tips on choosing user type A user's type (basic user vs full user) is meant to be a long-term assignment, based on the New Relic responsibilities that user is expected to perform. A full user can be downgraded to a basic user only twice in one year. Below are tips for why you'd choose full user versus basic user. Reasons to make someone a full user: They play a key role in the development, testing, deployment, and maintenance phases of the application development lifecycle. They break/fix code regularly; they are responsible for triaging workflows, troubleshooting, or managing users and roles for their team. They have DevOps practices (i.e. version control systems and implement CI/CD). They need to use New Relic's curated dashboards and experiences (not just the ability to create their own custom queries and charts); in other words, they need full access to our platform. They need to be able to manage users and/or billing. Reasons to make someone a basic user: They play a key role in the planning phase of the application development lifecycle. They use and configure New Relic agents, APIs, and integrations to send us data, and access, configure, and use alerts on such data (not necessarily responsible for triaging workflows, troubleshooting, or managing users and roles for their team). They want to see high-level analytics and business metrics for future planning (such as C-Suite executives). They do not need to use our curated experiences and dashboards, but would benefit from the ability to create their own custom queries and charts of data; in other words, they don't need full access to the platform. They don't manage users. For accounts on New Relic One pricing, learn more about user-related billing calculations. Understand user-related billing If you're on the New Relic One pricing plan, full users are billable, and there are restrictions around how often a full user can downgrade to a basic user. For details, see User count billing details. For how to query and alert on usage data, see Query usage data. Have questions about why you can't access something? See Factors affecting access. Default groups: Admin and User For users on our New Relic One user model, a \"group\" is what allows the grouping together and managing of multiple users at the same time. Your New Relic users are assigned to a group, and that group is granted access to specific roles on specific accounts. We have two default groups: User: This group allows a user to use and configure monitoring/analysis features but not perform account-related tasks like managing billing or users. It has access to the All product admin role, which gives access to our observability platform tools but not to the organization and user management capabilities governed by the Organization manager and Authentication manager roles. Admin: has full access and capabilities, including the organization-level admin abilities. This is the equivalent of having the All product admin, the Billing user, the Organization manager and the Authentication domain manager roles. These groups are added inside your default authentication domain, which includes the default settings of users a) being managed via New Relic and b) logging in via standard email and password. If you add other authentication domains (for SAML SSO and/or SCIM provisioning of users), you'd have new custom groups in those new domains to govern those users. Note that groups, whether default or custom, are not what limit a user's capabilities: it is the role that is assigned to that group (with any basic user restrictions on top of that). If your organization is Pro or Enterprise edition and you want to understand how users are granted access to specific roles and accounts, see Access grants. To change the group a user is in, use the User management UI. How do user type, roles, and groups relate to each other? For users on the New Relic One user model, here's a table explaining how user type (basic vs full user), roles, and groups relate to each other: Full user Basic user Group Full users can be assigned to default groups (User and Admin) or custom groups. When basic users are added to a group, that group's role-related restrictions apply. A basic user's capabilities can be restricted in that way, but a basic user can never be granted more capabilities than they start with. For Standard edition, basic users can't be assigned to groups. For Pro and Enterprise edition, they can. Role For an explanation of the roles our default groups have, see Default groups. Custom groups can have either our default standard roles, or custom roles. A basic user's abilities aren't directly defined by a specific role. A basic user can best be described as having the All product admin role but without access to Full Stack Observability features (learn more about user type). When basic users are added to a group, that group's role-related restrictions apply, but a basic user can never be granted more capabilities than they start with. Roles and capabilities For users on the New Relic One user model, a \"role\" can be defined as \"a set of capabilities.\" A capability is defined as the ability to do a specific New Relic task, like 'Delete alert conditions' (learn more about capabilities). Roles are assigned to user groups. Our default groups Admin and User already have our standard roles (defined below) assigned. Organizations on Pro or Enterprise edition can also create custom roles. Standard (default) roles Roles are sets of capabilities. We have several \"standard roles,\" which are roles that satisfy some commonly needed use cases. To view roles and their associated capabilities, use the Organization and access UI. Important Note that some of our standard roles have hidden, non-exposed capabilities that are not available for selection when creating a custom role. The only standard roles that can be replicated with a custom role are Standard user and Read only; all others have some hidden capabilities. Our standard roles include: Standard roles Scope Description All product admin Account Provides admin-level access to observability platform features but not organization-level and user management features. In other words, this role includes all New Relic capabilities with the exception of managing users (Authentication domain manager role), managing organization/account-structure settings (Organization manager role), and managing billing (Billing user role). Note: the Standard user role is essentially the All product admin role minus observability feature configuration capabilities. Standard user Account Provides access to observability platform features, but lacks permissions for configuring those features (for example, ability to configure synthetic monitor secure credentials) and lacks organization-level and user management permissions. Note: the Standard user role is essentially the All product admin role without that role's ability to configure platform features. Billing user Account Provides ability to manage subscriptions and billing setup, and read-only access to the rest of the platform. For organizations with multiple accounts, billing is aggregated in the primary (first-created) account, which is why assigning this role to that primary account grants billing permissions for the entire organization. Organization manager Organization Provides the ability to manage organization settings, including organization structure, name, and preferences. Due to our recent switch to the New Relic One user model, this role currently has few abilities but more will be added over time. For how to grant this role, see Add user management capability. Organization read only Organization Provides the ability to view organization-level settings. For how to grant this role, see Add user management capability. Authentication domain manager Organization Provides ability to add and manage users, and configure authentication domains for users on the New Relic One user model. For how to grant this role, see Add user management capability. Authentication domain read only Organization Provides the ability to view users in your organization and view the configuration of authentication domains. For how to grant this role, see Add user management capability. Read only Account Provides read-only access to the New Relic platform (except for synthetic monitor secure credentials). Manage v1 users Account For New Relic organizations that existed before July 30 2020 and have users on our original user model, this role lets you manage those \"v1\" users. For more about how you'd assign roles to groups and create custom roles, see the user management tutorial. Capabilities A role, whether one of our standard roles or a custom role, is defined as a set of capabilities. To view roles and their associated capabilities, use the Organization and access UI. Important Some of our standard roles have hidden capabilities that aren't available for selection when creating a custom role. For details, see Standard roles. A view of the capabilities associated with the All product admin role. When creating a custom role, you select a custom set of capabilities. Note that the capabilities we expose may change over time: this screenshot was taken in April of 2021. For how to set up roles with custom capabilities, see the user management tutorial. Manage users To learn how to add users, assign them to groups, and create custom groups and roles, see Manage users. 2020 user model changes If you'd like to understand how our user model changed in 2020 and what the impacts of that change were, see User model changes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.76669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " restrictions) Query and chart log data Build New Relic One apps (but cannot access other apps) Encryption at rest Standard data retention Security and compliance Data management Note that the pricing edition (Standard, <em>Pro</em>, or Enterprise) will also affect what <em>features</em> you have access"
      },
      "id": "603e88e328ccbcfcbaeba7a8"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/javascript-errors-page-detect-analyze-errors": [
    {
      "sections": [
        "Install the browser monitoring agent",
        "Enable browser monitoring",
        "Deployment options",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Use REST API",
        "Browser agent types: Lite, Pro, Pro+SPA"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-10-07T02:54:31Z",
      "updated_at": "2021-08-08T05:47:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet, also referred to as an \"agent,\" to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. If you don't have one already, create a New Relic account. It's free, forever. Enable browser monitoring Browser Pro+SPA is the default agent when you enable browser monitoring. This automatically gives you access to all of our browser monitoring features. For more information about the browser monitoring options, see Browser agent types in this document. To enable browser monitoring: Go to one.newrelic.com, select Browser, and then select Add more data. Follow the instructions in the UI to add browser monitoring to your app. Generate some traffic for your app, then wait a few minutes for data to appear in New Relic. Optional: After installation is complete and you are seeing data, go to the App settings page for additional agent configuration, or to change the browser agent type. It may take several minutes after enabling the browser monitoring agent before your webpage data appear in New Relic. If have problems, follow our troubleshooting tips. Deployment options No matter which option you use to deploy browser monitoring, the end result is the same: the browser monitoring JavaScript snippet (also referred to as the \"agent\") is inserted into your app pages. The method you select depends on your preferences and business needs. Enable an APM-monitored app When enabling browser monitoring, you can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that's already being monitored by APM. APM-monitored apps are listed on your APM Applications index. Enable with copy/paste When enabling browser monitoring, you can manually insert the JavaScript snippet into your app's webpages. The copy/paste option gives you control over the exact placement of our JavaScript snippet, which is required to monitor the webpage's performance. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Some tips for using the JavaScript snippet: Placement in your webpage: Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. License key and app ID: Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. Our APM agents can instrument webpages with the required JavaScript for page load timing. If you are using an APM agent's API to manually add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Use REST API This information applies to apps that are also monitored by APM. The REST API lets you manage deployment outside the browser monitoring UI. This is useful for large organizations deploying multiple apps. Browser agent types: Lite, Pro, Pro+SPA We have three types of browser agents: Lite, Pro, and Pro+SPA. The agent type has no impact on your billing. Browser agent type Comparison Pro+SPA This is the default installed agent when you enable browser monitoring. What it includes: Gives you access to all of the Browser Pro features and to Single Page App (SPA) monitoring. Provides detailed page timing data and the most up-to-date New Relic features, including distributed tracing, for all types of applications. Pro+SPA is not limited only to single page applications. After install, you can downgrade anytime to the less advanced agents if you don't want or need SPA monitoring. Pro What it includes: Gives you access to the Browser Pro features. What it doesn't include: Lacks the functionality designed for single page app monitoring. Lite What it includes: Gives you information about some basic page load timing and browser user information. What it doesn't include: Lacks the Browser Pro features and SPA features. Details about how agent types relate to pricing: New Relic One pricing: This pricing plan has data ingest as a billing factor. If you want to reduce data ingest, you may want to consider downgrading to lesser agent types after install. Original pricing: Your access to browser monitoring features is gated by your subscription plan, not by the agent type. This means there is no reason not to use the default Pro+SPA agent. After initial agent installation is finished, you can go to the App settings page to edit your configuration or to change your subscription.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.72563,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": ". It&#x27;s free, forever. Enable <em>browser</em> <em>monitoring</em> <em>Browser</em> <em>Pro</em>+SPA is the default agent when you enable <em>browser</em> <em>monitoring</em>. This automatically gives you access to all of our <em>browser</em> <em>monitoring</em> <em>features</em>. For more information about the <em>browser</em> <em>monitoring</em> options, see <em>Browser</em> agent types in this document"
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.54907,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Page load timing <em>process</em>",
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/upload-source-maps-api": [
    {
      "image": "https://docs.newrelic.com/static/e6ad2975a5ef8d6c5f5ff030e9aca62c/9bb7a/browser-source-map-ui-ss.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/upload-source-maps-un-minify-js-errors/",
      "sections": [
        "Upload source maps to un-minify JS errors",
        "Import source maps via the New Relic UI",
        "Tip",
        "Troubleshooting",
        "Stack traces are still minified",
        "Can't generate source maps",
        "Generate source maps with UglifyJS",
        "Generate source maps with webpack"
      ],
      "published_at": "2021-10-07T05:48:15Z",
      "title": "Upload source maps to un-minify JS errors",
      "updated_at": "2021-07-09T23:32:24Z",
      "type": "docs",
      "external_id": "965a3764d519b00e672d93f45a58ae1eec1e9585",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring supports the uploading of source maps. Source maps support is primarily useful for \"decoding\" minified JavaScript. Minified JavaScript results in mostly useless error stack traces on browser's JS errors page. Uploading source maps converts these errors to understandable stack traces, with useful references to code lines. This feature might also be useful for bundled or transpiled JavaScript code. Browser gives you two options for using source maps: Upload source maps via the browser UI Publish source maps to browser via the API This document will explain the first method: how to upload source maps via the UI, along with general troubleshooting help. For instructions on using the API method, see Push source maps via the API. Import source maps via the New Relic UI You can drag and drop, or upload, a source map file into the browser UI to associate it with a specific JavaScript file. New Relic will then convert minified stack traces into un-minified traces and source code visible on the JS errors page. To drag in or upload a source map to browser, the source map must be on your local machine. To associate a source map with an error stack trace on the JS errors page: Go to one.newrelic.com > Browser > (select an app) > JS Errors, then select a JS error group. (Don't select an Errors without a stack trace group.) From the selected JS error group, select the error instance details tab (next to the Summary tab). Error groupings will have one or more frames listed that reference JavaScript files. Select the + icon on the right side of a frame to expand it. Then drag the matching source map file into the frame. Alternative option: when the frame is expanded, select find file to upload the file manually. Tip An error frame with a gray strip on the left side indicate minified JS; a blue strip indicates it has had a source map applied. Other JS error frame features include: If you want to... Do this... See more of the surrounding code Select Show 10 more lines above/below to view the code before or after the code in the stack trace. See original, minified file information For individual frame info: Next to the frame's source line and column, mouse over the ellipsis. For raw data of the entire stack trace: At the top of the error tab, select < /> Raw. Remove a source map From an expanded stack trace frame, select Remove file. Troubleshooting Stack traces are still minified If you have uploaded source maps to New Relic and still see minified stack traces, there are a few things to check. Using the API is the best way to investigate potential issues, by listing or deleting published source maps. Typical problems Troubleshooting tips URL mismatch Each frame in the stack trace is associated with a specific JavaScript URL. That URL must match the JavaScript URL that was used when publishing the source map. Ensure that these URLs match exactly. Release name/ID mismatch If the JavaScript URL is not versioned when you deploy your front end assets, a release name and release ID must be specified using the newrelic.addRelease API method, and also when publishing your source maps. Ensure that these strings match exactly. 409 error: Combination of javascriptUrl, releaseName, and releaseId must be unique If a source map file for a particular JavaScript URL is uploaded without a release name or ID specified, New Relic treats the URL as a unique identifier. To resolve this, delete the source map that has NULL release name and ID values and re-upload all versions for that URL including those parameters. This will allow multiple versions of source maps for a particular JS URL. Missing SourcesContent component Your mapping file must contain the SourcesContent component for New Relic to un-minify your stack traces. If you have uploaded your map successfully and are still not seeing un-minified code, check the original source map for this component. If you can't find it, regenerate the source map so the component is included, and upload your map to New Relic. If the SourcesContent component is not added, an error similar to Whoops, that was the wrong file. Please try again. will appear. Can't generate source maps Having trouble even generating source maps? Every build system has its own instructions for generating source maps. For more specific details, please see the documentation for your particular tool. Below are source map generation instructions for two popular build systems: Generate source maps with UglifyJS Generate source maps using UglifyJS: When \"uglifying\" source files, specify a source map file name and include the original source content: Starting on version v3.12.5: uglifyjs [source files] \\ -o bundle.min.js \\ -c -m --source-map \"includeSources=true\" Copy For older versions: uglifyjs [source files] \\ -o bundle.min.js \\ --source-map bundle.min.js.map \\ --source-map-include-sources \\ -c -m Copy Generate source maps with webpack Generate source maps using Webpack: In your production webpack config, simply specify source-map for the config.devtool property. The sourceMapFilename property of config.output is optional and defaults to [name].js.map. devtool: 'source-map', output: { path: path.join(__dirname, 'dist'), filename: '[name].js', sourceMapFilename: '[name].js.map', }, Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 126.28691,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Upload</em> <em>source</em> <em>maps</em> to un-minify JS errors",
        "sections": "<em>Upload</em> <em>source</em> <em>maps</em> to un-minify JS errors",
        "body": ": how to <em>upload</em> <em>source</em> <em>maps</em> <em>via</em> the UI, along with general troubleshooting help. For instructions on using the <em>API</em> method, see Push <em>source</em> <em>maps</em> <em>via</em> the <em>API</em>. Import <em>source</em> <em>maps</em> <em>via</em> the New Relic UI You can drag and drop, or <em>upload</em>, a <em>source</em> <em>map</em> file into the browser UI to associate it with a specific"
      },
      "id": "604429a828ccbcfaad2c60be"
    },
    {
      "sections": [
        "Upload dSYM files",
        "Automatic script",
        "Identify missing dSYMs",
        "Upload dSYM files through the mobile monitoring UI",
        "Manually upload dSYM files",
        "Via Python script (agent versions 6.0.0 or higher)",
        "Via command line",
        "Troubleshooting",
        "Auto-upload failure",
        "Missing dSYMs"
      ],
      "title": "Upload dSYM files",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile iOS",
        "Configuration"
      ],
      "external_id": "3655f49cf0e1ae693de0f8ea45bf4e5e6437e399",
      "image": "https://docs.newrelic.com/static/5c859575f391fbb1eaa18243a8c97000/8c557/Screen-Shot-2014-09-23-at-11.30.35-AM_0.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-ios/configuration/upload-dsyms-bitcode-apps/",
      "published_at": "2021-10-07T20:29:08Z",
      "updated_at": "2021-09-27T15:06:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your app's dSYM files are stored in Xcode's dSYM archive path folder. This is the folder where the iOS agent gets the dSYM files that are used to symbolicate your crash reports. New Relic provides a post-build script as part of the iOS agent's install process and the tvOS agent's install process. This script automatically uploads your app's dSYM files. Automatic script The script automatically uploads dSYM files only for release builds. Non-release builds must upload their files either manually or through the mobile monitoring UI. Bitcode-enabled apps have their dSYM files generated by Apple. You must download the dSYM files for Bitcode-enabled apps from Apple and upload them to New Relic. If you see unreadable machine code in the Crashes page, your dSYM files may not be uploaded correctly. In some cases, you may need to manually upload dSYM files. The automatic script uses Python 2. As of October 2019 with macOS 10.15 (Catalina), Python won't be installed by default. If you're using the automatic script (recommended), you may need to manually install Python 2. If you're using Homebrew, see Python on Homebrew. Identify missing dSYMs When a Bitcode-enabled app is uploaded to Apple for App Store review or ad-hoc distribution, dSYMs need to be manually downloaded from Apple and uploaded to New Relic to allow the mobile crash reports to be properly symbolicated. These dSYMs can be downloaded through the archives organizer in Xcode within several minutes of uploading the app. In this situation follow the procedures to find the archive and download dSYMs. If an app is missing a dSYM file, you'll see three indicators in the mobile monitoring UI: Banner notification: A banner warning appears on the Crash report page. The warning reads: We were unable to locate your dsym. Copy Upload prompt: From the Crash type summary page you will be automatically prompted to upload a dSYM file if it is missing. Machine code: The crash stack trace on the Crash report page displays machine code and not a human-readable error message. Upload dSYM files through the mobile monitoring UI You can easily upload your dSYM files directly from the New Relic One UI. The maximum file size is 600 MB. To upload your dSYM files: Go to one.newrelic.com and click Mobile. Then select your app from the list. View Crash analysis. Select a specific crash from the Crash types list. Click Upload dSYM. You can either drag and drop your dSYMs directly, or select the file form your computer. Manually upload dSYM files In some circumstances, New Relic's automatic upload of dSYM files may fail. If a dSYM upload is attempted and fails, it creates a build error with a detailed message. For example, if there's a network failure and the dSYM upload isn't completed, Xcode will report an error. For additional information about how New Relic handles dSYM uploads, see New Relic's Online Technical Community. If the automatic upload fails, you can manually upload your dSYM file. If you have multiple dSYM files, they can be within a single zip with a maximum file size of 600 MB. The YOUR_NEW_RELIC_APPLICATION_TOKEN value in the commands below is the same key used for +[NewRelic startWithApplicationToken:] (in Objective-C) or NewRelic.start(withApplicationToken:) (in Swift). To manually upload your dSYM files: Via Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework/Resources/generateMap.py \"DSYM_ARCHIVE_PATH\" \"YOUR_NEW_RELIC_APPLICATION_TOKEN\" Copy Via command line To manually upload individual dSYM files from the command line: Zip up your dSYM file or files using the following command. Replace ~ /ZIPPED_DSYM_PATH with your new dSYM archive path and file name (for example, Users/my-name/desktop). Also replace ~ /dSYM_PATH with your existing dSYM file path. /usr/bin/zip --recurse-paths --quiet \"~/ZIPPED_DSYM_PATH\" \"~/dSYM_PATH\" Copy Upload the dSYM zip file using the following command: For US accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.newrelic.com/symbol Copy For EU accounts: curl -F dsym=@\"~/DSYM_ZIP_PATH\" -H \"X-APP-LICENSE-KEY: YOUR_NEW_RELIC_APPLICATION_TOKEN\" https://mobile-symbol-upload.eu01.nr-data.net/symbol Copy Troubleshooting Auto-upload failure If a dSYM auto-upload failed, the Report Navigator may have a fully formed cURL command. You can use this cURL command to reattempt an upload. Depending on the error, you may also need to follow some of the dSYM manual upload steps. Here is an example of a successful dSYM upload in the Report Navigator: Example: A successful dSYM upload in the Report Navigator. Missing dSYMs If dSYM files are missing, you may need to check Xcode build settings to ensure the file is being generated. Frameworks which are built locally have separate build settings and may need to be updated as well. Build settings: Debug Information Format : Dwarf with dSYM File Deployment Postprocessing: Yes Strip Linked Product: Yes Strip Debug Symbols During Copy : Yes Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.45349,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Upload</em> dSYM files",
        "sections": "<em>Upload</em> dSYM files",
        "body": " dSYM files: <em>Via</em> Python script (agent versions 6.0.0 or higher) In iOS agent versions 6.0.0 or higher, the agent includes a Python script that automatically processes and uploads symbols. You can call this script from the command line: NewRelicAgent.framework&#x2F;Resources&#x2F;generate<em>Map</em>.py &quot;DSYM_ARCHIVE_PATH"
      },
      "id": "60441960e7b9d24f705799ca"
    },
    {
      "sections": [
        "Android agent crash reporting",
        "Upload the ProGuard or DexGuard file",
        "Use mapping.txt file",
        "Exception",
        "Map Processing",
        "Important",
        "Maps are reported for select variant builds",
        "Variants are assigned unique build IDs",
        "Compress maps prior to upload",
        "Deferred crash reporting",
        "Disable crash reporting",
        "Debug the crash reporter",
        "Manually upload a ProGuard or DexGuard map file"
      ],
      "title": "Android agent crash reporting",
      "type": "docs",
      "tags": [
        "Mobile monitoring",
        "New Relic Mobile Android",
        "Install configure"
      ],
      "external_id": "f954a196ede1c24634e45c82e0f7cf9fce4dc1c9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/new-relic-mobile-android/install-configure/android-agent-crash-reporting/",
      "published_at": "2021-10-07T20:19:50Z",
      "updated_at": "2021-07-09T15:00:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "By default, mobile monitoring enables crash reporting for your mobile applications to help track and diagnose crashes. When an Android application crashes, the agent uploads a crash report to the New Relic collector. The crash details will then be processed and de-obfuscated automatically if you are using ProGuard or DexGuard. You can view detailed information about crashes in the Crash analysis UI, or receive crash notifications by email. You can also explore the crash data deeper with New Relic Insights, or integrate with ticketing systems for further investigation. Upload the ProGuard or DexGuard file The Android agent supports ProGuard and DexGuard. DexGuard is an extension to ProGuard, and it behaves the same as ProGuard when dealing with crash symbolication and obfuscated code maps. ProGuard obfuscates your code by renaming classes, fields, and methods with semantically obscure labels. DexGuard adds another additional layer of obfuscation and security, but otherwise behaves identically to ProGuard. If ProGuard or DexGuard is enabled, the stack trace produced by a crash consists only of these obfuscated labels, which are not human-readable. Follow the SDK installation or upgrade instructions to configure ProGuard or DexGuard and enable crash reporting. Be sure to create the newrelic.properties file containing your application token. Use mapping.txt file The agent uses the mapping.txt file produced during a ProGuard/DexGuard-enabled build. This file consists of the obfuscated label names, and provides reverse mapping between obfuscated and plain text labels. You must use the copy of mapping.txt generated during the build that produced your final application. The application's build ID changes each time an APK is generated, and the build ID in the mapping file must match the ID contained in each uploaded crash report. After you create a newrelic.properties file containing your New Relic app token in your project, the ProGuard or DexGuard mapping.txt file will be uploaded automatically after each build. Exception If either of the following situations occur, you must manually upload the mapping.txt replacement file: If the mapping.txt file is renamed using the DexGuard -printmapping option, the Android agent will be unable to locate or upload the stripped names. If you see obfuscated crash reports in the Crashes page, you may not have a mapping.txt file uploaded. Map Processing Important Agent version 5.27.0 introduces changes to the way the agent plugin process maps during builds. Maps are reported for select variant builds The agent will tag and report only those mapping.txt files generated by Release build-type variants. This behavior can be configured or disabled through the New Relic Gradle Plugin extension. Variants are assigned unique build IDs During an execution of a Gradle build, a single unique ID (build ID) was generated to represent all variants of the app built during that invocation. This often led to mismatched crash reports for customers using variants to customize a common app code base. Each variant is now identified by its own unique ID, which is used when reporting the variant's ProGuard map to New Relic. You can disable this behavior through the New Relic Gradle Plugin extension. Compress maps prior to upload As apps get larger, so do their associated maps, which then results in longer upload times when reporting the map. If map reporting time is unreasonably long, the agent can compress the map prior to transfer. To enable compressed map uploads, add the following to your app's newrelic.properties file: com.newrelic.compressed_uploads=true Copy Deferred crash reporting Important Agent version 6.0.0 introduces changes to the way the agent plugin processes crashes at runtime. In an attempt to address crash report duplication, deferred crash reporting is now the default crash reporting behavior. In this case, crash reports are recorded when they occur, but they're not uploaded until the next application launch. The previous crash reporting behavior is still available: uploading the crash as soon as it occurs before the application process terminates. You can use the NewRelic.withCrashReportingEnabled(boolean) API method. For example: NewRelic .withApplicationToken(\"<appToken>\") .withCrashReportingEnabled(true) .start(this.getApplication()); Copy Disable crash reporting If you want to use another crash reporting tool, you can disable crash reporting by calling NewRelic.disableFeature(FeatureFlag.CrashReporting) prior to agent initialization. For example: NewRelic.disableFeature(FeatureFlag.CrashReporting); NewRelic .withApplicationToken(\"<appToken>\") .start(this.getApplication()); Copy Debug the crash reporter Crash reporting for Android is designed to work with other crash reporting frameworks by chaining the uncaught exception handler if it is already registered. If no other framework has been found (or if New Relic is the first framework registered), the debug logs will include: Installing New Relic crash handler. Copy If another handler is already registered, debug logs will include: Installing New Relic crash handler and chaining previous exception handler. Copy Every time New Relic catches an exception, it is logged to DEBUG level. For example: A crash has been detected in <className>. Copy If New Relic catches an exception but crash reporting has been disabled for any reason, this message is logged: A crash has been detected but crash reporting is disabled. Copy If you don't see crash reports, check the debug logs for messages like this. Manually upload a ProGuard or DexGuard map file In some unusual circumstances, it may not be possible to automatically upload the ProGuard or DexGuard mapping file. This is often due to incorrectly creating a newrelic.properties file containing your application token. This will result in build errors or warnings with detailed log messages. To manually upload a ProGuard or DexGuard map file: Find the mapping.txt file(s) in the project's build directory For example, the file is located in the <PROJECT_ROOT>/app/build/outputs/mapping/<BUILD_VARIANT> directory for projects that use Android Studio. Generally, a release variant is used when building the final version of the application. The following command is useful for finding map files: find <project_root> -name mapping.txt Copy Using a command terminal, upload the ProGuard or DexGuard mapping file: For a US account: curl -v -F upload=@\"<mapping.txt>\" -H \"X-APP-LICENSE-KEY:<APPLICATION_TOKEN>\" https://mobile-symbol-upload.newrelic.com/symbol Copy For a EU account: curl -v -F upload=@\"<mapping.txt>\" -H \"X-APP-LICENSE-KEY:<APPLICATION_TOKEN>\" https://mobile-symbol-upload.eu.newrelic.com/symbol Copy Replace the following in your command: <mapping.txt> is the full path to the ProGuard or DexGuard mapping.txt file. <APPLICATION_TOKEN> is your mobile monitoring application token.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.35621,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Compress <em>maps</em> prior to <em>upload</em>",
        "body": " for customers using variants to customize a common app code base. Each variant is now identified by its own unique ID, which is used when reporting the variant&#x27;s ProGuard <em>map</em> to New Relic. You can disable this behavior through the New Relic Gradle Plugin extension. Compress <em>maps</em> prior to <em>upload</em> As apps"
      },
      "id": "603ed67564441ffa8f4e8883"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/browser-app-settings-page": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/filter-ajax-request-events/",
      "sections": [
        "Filter AjaxRequest events",
        "Using the deny list",
        "Access the deny list",
        "Validation"
      ],
      "published_at": "2021-10-09T01:07:13Z",
      "title": "Filter AjaxRequest events",
      "updated_at": "2021-10-09T01:07:12Z",
      "type": "docs",
      "external_id": "b98518c4c4625917bcf07e19a30afb79d183f69a",
      "document_type": "page",
      "popularity": 1,
      "body": "In agent version 1211 or higher, all network requests made by a page are recorded as AjaxRequest events. You can use the deny list configuration options in the Application settings page to filter which requests record events. Regardless of this filter, all network requests are captured as metrics and available in the AJAX page. Using the deny list Requests can be blocked in three ways: To block recording of all AjaxRequest events, add the wildcard. Example: `` To block recording of AjaxRequest events to a domain, enter just the domain name. Example: example.com To block recording of AjaxRequest events to a specific domain and path, enter the domain and path. Example: example.com/path The protocol, port, search and hash of a URL are ignored by the deny list. Access the deny list To update the deny list of URLs your application will filter from creating events, go to the app settings page: Go to one.newrelic.com, and click Browser. Select an app. On the left navigation, click App settings. Under Ajax Request Deny List, add the filters you would like to apply to your app. Select Save application settings to update the agent configuration. Redeploy the browser agent (either restarting the associated APM agent or updating the copy/paste browser installation). Validation To validate whether the filters you have added work as expected, run a NRQL query for AjaxRequest events matching your filter. FROM AjaxRequest SELECT * WHERE requestUrl LIKE `%example.com%` Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.16142,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Using <em>the</em> deny list",
        "body": ": Go to one.newrelic.com, and click <em>Browser</em>. Select an <em>app</em>. On the left navigation, click <em>App</em> <em>settings</em>. Under Ajax Request Deny List, add the filters you would like to apply to your <em>app</em>. Select Save application <em>settings</em> to update the <em>agent</em> configuration. Redeploy the <em>browser</em> <em>agent</em> (either restarting"
      },
      "id": "6160eb4128ccbc2be9f21447"
    },
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "account switcher",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation delay",
        "aggregation function",
        "aggregation method",
        "aggregation_timer",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "child account",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "Full-Stack Observability",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "parent account",
        "permalink",
        "pinger",
        "Plugins",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "Telemetry Data Platform",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/44172b3e07c1f24191825360676b9d99/c1b63/account-dropdown.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-10-07T05:14:06Z",
      "updated_at": "2021-10-07T05:14:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown In the upper right of the New Relic UI, the account dropdown gives you access to your account settings. If you're trying to switch between accounts, use the account switcher. account switcher If you have access to more than one account in a multi-account organization, you can use the account switcher to switch between accounts. This is located in the top right of most New Relic UI pages. For more on factors that affect access to accounts, see Factors affecting access. To find account settings, use the account dropdown. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation delay The length of time in seconds to wait for the aggregation window to fill with data. Required when using CADENCE or EVENT_FLOW aggreation_method types. aggregation function You can use NRQL query functions, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation method New Relic aggregates data into windows, and needs to determine when the current window ends and the next one begins. The aggregation_method is the logic that tells us when we have all the data for a given aggregation window. Once the window is closed, the data is aggregated into a single point and evaluated against the threshold. This field is optional. One of the following three values can be specified: *EVENT_FLOW: (Default) Each aggregation window will wait until it starts to see timestamps arrive that are past its own delay setting. Once this occurs, the data is published. Relies on the timestamps of arriving data, so wall-clock time is no longer relevant. Works best for sources that come in frequently and with low event spread (high througput metrics) *CADENCE: Classic New Relic logic where each evaluation window waits exactly as long as the aggregation_delay setting, using the wall-clock time as a timer. aggregation_delay is required when using this option. Data arriving too late will be dropped, which can cause false alerts. *EVENT_TIMER: Each aggregation window has a timer on it, set to the aggregation_timer setting. The Timer starts running as soon as the first data point appears for that aggregation window (based on the data point’s timestamp). The aggregation_timer is reset for each new data point that arrives for that window. Once the aggregation_timer reaches 0, the aggregation window is published. Ideal for sparse and batched data, such as cloud integrations and infrequent error logs. aggregation_timer The length of time in seconds to wait after each data point received, to ensure the entire batch is processed. Required when using EVENT_TIMER aggregation_method type. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. child account See parent account. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, the browser monitoring agent, the mobile monitoring agents, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure monitoring By connecting changes in host performance to changes in your configuration, infrastructure monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, as well as the ability to query and chart your New Relic data. These features are now a fundamental part of the New Relic One platform and are no longer governed by the Insights product or name. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some places. For example: Some APM agents still have Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For New Relic organizations on our original pricing plan, Insights Pro is still the product name governing custom event data ingest and retention. There is an API key called the Insights insert key. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our mobile monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. You can see much of the data included in an interaction in the BrowserInteraction event. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account See parent account. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, mobile monitoring, and browser monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile monitoring Mobile monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. parent account New Relic organizations can have a parent/child account structure. This structure was much more important for organizations on our original user model, but is still used for some features for organizations on the New Relic One user model. Learn more about account structure. Parent accounts were previously referred to as \"master accounts\", and child accounts were previously referred to as \"sub-accounts\". permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our Full Stack Observability pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.29819,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>data</em> <em>collector</em>",
        "body": " such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects <em>data</em> from New Relic agents running on an <em>app</em> server, mobile device, or end-user <em>browser</em>. While the <em>agent</em> is installed on a user&#x27;s <em>app</em> server, the collectors are centrally located in New Relic"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    },
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-07T11:16:32Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.64273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "IBM WebSphere <em>Application</em> Server",
        "sections": "IBM WebSphere <em>Application</em> Server",
        "tags": "<em>Agents</em>",
        "body": "This describes how to <em>configure</em> New Relic&#x27;s Java <em>agent</em> if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic&#x27;s procedures to install the Java <em>agent</em> on WebSphere. IBM WebSphere <em>App</em> Server Comments Compatible IBM JVM versions New Relic supports all versions"
      },
      "id": "6043b986e7b9d279085799eb"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/browser-settings-ui-options-apdex-geography": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.54886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32097,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Monitor or block specific domains and subdomains",
        "Tip",
        "Configure domain conditions",
        "Turn off domain conditions"
      ],
      "title": "Monitor or block specific domains and subdomains",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Configuration"
      ],
      "external_id": "bf81374c9ec84ce08154a76b10f526fb5ee7e7ec",
      "image": "https://docs.newrelic.com/static/1bf47635bd1556e86b9019a47176e3b9/c1b63/browser_domain_conditions.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/monitor-or-block-specific-domains-subdomains/",
      "published_at": "2021-10-07T16:59:34Z",
      "updated_at": "2021-07-10T02:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser lets you choose which domains or subdomains that a browser app monitors. This is useful for limiting monitoring only to the application activity you consider important. For example, if you use the copy/paste method to deploy your browser app, you can set domain conditions to protect the security of your browser monitoring license key and app ID. Tip Domain conditions only filter data based on the url of the page that is reported. Domain condition filters do not apply to AJAX data reported to New Relic. Configure domain conditions To view or edit your domain condition settings: Go to one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Edit conditions. Select the option to build a list of allowed domains or to build a list of blocked/denied domains. Select the domain conditions (maximum 10 conditions). Select the domain conditions with the Starts with condition, then enter the URL with the subdomain (maximum 10 conditions). one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions: Use this feature to limit monitoring only to your important app activity, or to enhance security for your browser license key and app ID. Review and confirm your domain condition settings. A preview text box displays in real time what domains match the conditions you set. You will also see an estimate of the impact the proposed settings will have on your data. Turn off domain conditions To disable domain conditions and return to monitoring all domains: Go to one.newrelic.com > Browser > (select an app) > Settings > Domain conditions. Set the Enable domain conditions option to Off.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.66204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> or block specific domains and subdomains",
        "sections": "<em>Monitor</em> or block specific domains and subdomains",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> lets you choose which domains or subdomains that a <em>browser</em> app monitors. This is useful for limiting <em>monitoring</em> only to the application activity you consider important. For example, if you use the copy&#x2F;paste method to deploy your <em>browser</em> app, you can set domain conditions to protect"
      },
      "id": "6043fd41e7b9d240ca5799bb"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/filter-ajax-request-events": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/new-relic-browser-release-notes/browser-agent-release-notes/browser-agent-v1211/",
      "sections": [
        "Browser agent v1211",
        "Improvements",
        "AjaxRequest events for all XHR/fetch requests",
        "Span events are for all XHR/fetch requests",
        "Update to Cumulative Layout Shift calculation",
        "Bug Fixes",
        "Prevent duplicate session trace nodes"
      ],
      "published_at": "2021-10-09T00:21:25Z",
      "title": "Browser agent v1211",
      "updated_at": "2021-10-09T00:21:25Z",
      "type": "docs",
      "external_id": "81b8698293a99d7ec2803cc9fe24709917247c2b",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "Improvements AjaxRequest events for all XHR/fetch requests Previously, XHR/fetch requests were captured as AjaxRequest events only when they were part of a route change. With this change, all requests will be captured as events. This feature can be further configured by specifying which requests should not be collected. Span events are for all XHR/fetch requests Previously, Span events were generated only for XHR/fetch requests that were part of a route change. With this change, all requests will be captured as Spans. Update to Cumulative Layout Shift calculation The CLS calculation has been updated to use session windows in order to align with Google Chrome tooling (Lighthouse, PageSpeed Insights, CrUX). For more information, see the official blog post on web.dev. Bug Fixes Prevent duplicate session trace nodes The agent no longer calls the clearResourceTimings API, which had the potential to affect other scripts from accessing all resources. Instead, it now uses the PerformanceObserver API to collect information about resources.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 352.75967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>AjaxRequest</em> <em>events</em> for all XHR&#x2F;fetch <em>requests</em>",
        "body": "Improvements <em>AjaxRequest</em> <em>events</em> for all XHR&#x2F;fetch requests Previously, XHR&#x2F;fetch requests were captured as <em>AjaxRequest</em> <em>events</em> only when they were part of a route change. With this change, all requests will be captured as <em>events</em>. This feature can be further configured by specifying which requests"
      },
      "id": "6160e085196a6761b6b70da7"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/attribute-dictionary/",
      "sections": [
        "New Relic data dictionary",
        "AjaxRequest",
        "AwsLambdaInvocation",
        "AwsLambdaInvocationError",
        "BrowserInteraction",
        "BrowserTiming",
        "ContainerSample",
        "DistributedTraceSummary",
        "InfrastructureEvent",
        "JavaScriptError",
        "Metric",
        "Mobile",
        "MobileCrash",
        "MobileHandledException",
        "MobileRequest",
        "MobileRequestError",
        "MobileSession",
        "NetworkSample",
        "NrAiIncident",
        "NrAuditEvent",
        "NrConsumption",
        "NrDailyUsage",
        "NrIntegrationError",
        "NrMTDConsumption",
        "NrUsage",
        "PageAction",
        "PageView",
        "PageViewTiming",
        "ProcessSample",
        "Span",
        "StorageSample",
        "SyntheticCheck",
        "SyntheticRequest",
        "SyntheticsPrivateLocationStatus",
        "SyntheticsPrivateMinion",
        "SystemSample",
        "Transaction",
        "TransactionError",
        "WorkloadStatus"
      ],
      "published_at": "2021-10-10T01:50:04Z",
      "title": "New Relic data dictionary",
      "updated_at": "2021-10-07T02:00:01Z",
      "type": "docs",
      "external_id": "cbca3a897621bcbb31159067d6d4ec27c5178fe4",
      "document_type": "views_page_content",
      "popularity": 1,
      "body": "AjaxRequest Data source : Browser agent An AjaxRequest event is created automatically when an Ajax request occurs during a BrowserInteraction event. The event attributes track geographic and browser info. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming groupedRequestUrl The grouped URL of the AJAX request. For example: myapp.com/acct/*/ajax. AjaxRequest Span hostname The fully qualified domain name (FQDN) of the request URL. AjaxRequest httpMethod enum The HTTP method of the AJAX request. Example: POST. AjaxRequest httpResponseCode enum The HTTP response code. Example: 200. AjaxRequest jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError port enum The request port. AjaxRequest Span priority Likelihood this event will be saved. AjaxRequest regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming requestBodySize bytes (B) The payload size of the request body, in bytes. AjaxRequest requestUrl The URL of the AJAX request. For example: myapp.com/acct/1/ajax. AjaxRequest responseBodySize bytes (B) The payload size of the response body, in bytes. AjaxRequest session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventStart seconds (s) The time, in seconds, from the start of the AJAX request to the start of its load event. This value represents the duration of the AJAX request with single page app (SPA) monitoring. For more information, see the Mozilla developer documentation about XMLHttpRequest load events. AjaxRequest timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming AwsLambdaInvocation Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. This event captures overall function timing and associated metadata. A single AwsLambdaInvocation event is generated for each invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.status bytes (B) The response code for an HTTP request AwsLambdaInvocation totalTime seconds (s) The sum of all async components' duration, in seconds. An async component is a method or function where there is no instrumented encapsulating method or function. AwsLambdaInvocation Transaction traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError AwsLambdaInvocationError Data source : AWS Lambda This event is reported by New Relic monitoring for AWS Lambda. It's generated when an error occurs during a Lambda function invocation. Attribute name Definition Data types aws.lambda.arn The Amazon Resource Name (ARN) of the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.coldStart A Boolean indicating if the AWS Lambda invocation is a cold start. AwsLambdaInvocation AwsLambdaInvocationError aws.lambda.eventSource.arn The Amazon Resource Name (ARN) of the entity that invoked the instrumented Lambda function. AwsLambdaInvocation AwsLambdaInvocationError aws.requestId ID AWS identifier of the invocation. AwsLambdaInvocation AwsLambdaInvocationError databaseCallCount count The number of database calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError databaseDuration seconds (s) The database response time in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError duration seconds (s) The total invocation time for the transaction, in seconds. (Data source: AWS Lambda) AwsLambdaInvocation AwsLambdaInvocationError error.class The class name or type for the error. This will be server and platform specific. AwsLambdaInvocationError TransactionError error.message The error message for the transaction. This will be server and platform specific. AwsLambdaInvocationError TransactionError externalCallCount count The number of external calls made by this transaction. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError externalDuration seconds (s) The total response time of all external (out-of-process) services, in seconds. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError newRelic.ingestPoint Where the data point entered the platform (such as browser.spans, or api.traces). AwsLambdaInvocation AwsLambdaInvocationError Span parent.account ID If a distributed tracing payload is received, this is the account identifier for the transaction's upstream caller. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.app ID If a distributed tracing payload is received, this is the application identifier. APM agents retrieve this value in the connect response under the key primary_application_id. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.transportType When a distributed tracing payload is received, the method of transport for the payload. Example values: Unknown, HTTP, HTTPS, Kafka, JMS, IronMQ, AMQP, Queue, or Other. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError parent.type If a distributed trace payload was received, the parent's data source type. Example values: App, Browser, Mobile. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.accept The types as read from the HTTP Accept request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentLength bytes (B) Incoming request size in bytes as read from the Content-Length HTTP request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.contentType Incoming request content-type as read from the HTTP request header Content-Type. Example value: application/octet-stream. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.host The name from the HTTP host request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.referer The incoming request referer as read from the Referer request header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.headers.userAgent The contents of the User-Agent HTTP header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError request.method The HTTP request method used. Example values: POST, GET. AwsLambdaInvocation AwsLambdaInvocationError Span Transaction TransactionError response.headers.contentLength bytes (B) The outgoing response size in bytes as read from the Content-Length response header. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError response.headers.contentType For an HTTP response, the data type of the returned response. Example values: text/html, application/json. AwsLambdaInvocation AwsLambdaInvocationError Transaction TransactionError stackTrace The error stack trace. The format will be different depending on the agent language. AwsLambdaInvocationError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span transactionName Name of the transaction in which the error occurred. Example value: Controller/customers/show. Value may be 'Unknown' if an error occurs outside of a transaction. AwsLambdaInvocationError TransactionError type The New Relic event type. Example values: Transaction, Span. AwsLambdaInvocation AwsLambdaInvocationError BrowserInteraction Data source : Browser agent A BrowserInteraction represents a unit of work in a browser session, triggered by a user interacting with the webpage. It captures information about the session, AJAX calls and custom JavaScript timing that occurred as a result of the interaction. Initial load and route changes are captured as special types of browser interactions, and are used for SPA monitoring. Attribute name Definition Data types actionText The text of the HTML element that was clicked when a browser interaction started. BrowserInteraction ajaxCount count A count of all XHRs included in the timing of a SPA interaction. BrowserInteraction appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming backendTransactionName The name of the backend transaction that served the initial page load. BrowserInteraction browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming category The type of interaction; either initial page load, route change, or custom. BrowserInteraction city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming duration seconds (s) The total time elapsed of the interaction event BrowserInteraction eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming firstContentfulPaint firstContentfulPaint is the point when the browser renders the first bit of content from the DOM, which may be text, an image, SVG, or a <canvas> element. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstContentfulPaint. See Compatibility and requirements for New Relic Browser for additional information about firstContentfulPaint browser compatibility. BrowserInteraction PageView firstPaint firstPaint marks the point when the browser renders anything that is visually different from what was on the screen prior to navigation. This includes non-default background paint and the enclosing box of an iframe. Google's User-centric Performance Metrics contains detailed information about its Paint Timing API and firstPaint. See Compatibility and requirements for New Relic Browser for additional information about firstPaint browser compatibility. BrowserInteraction PageView jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError previousGroupedUrl The grouped version of the URL in the browser at the start of the interaction. BrowserInteraction previousRouteName The route name of the page at the start of the interaction. This is the last value passed by setCurrentRouteName before the start of the interaction. BrowserInteraction previousURL The ungrouped URL in the browser at the start of the interaction. BrowserInteraction regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span targetGroupedUrl The grouped version of the URL in the browser at the end of the interaction. BrowserInteraction targetRouteName The route name for the page at the end of the interaction. The last value passed by setCurrentRouteName before the end of the interaction. BrowserInteraction targetUrl The ungrouped URL in the browser at the end of the interaction. BrowserInteraction timeToConnectEnd seconds (s) The time, in seconds, from the start of the interaction to the connectEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToConnectStart seconds (s) The time, in seconds, from the start of the interaction to the connectStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomComplete seconds (s) The time, in seconds, from the start of the interaction to the domComplete, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventEnd seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomContentLoadedEventStart seconds (s) The time, in seconds, from the start of the interaction to the domContentLoadedEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomInteractive seconds (s) The time, in seconds, from the start of the interaction to the domInteractive, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomLoading seconds (s) The time, in seconds, from the start of the interaction to the domLoading, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupEnd seconds (s) The time, in seconds, from the start of the interaction to the domainLookupEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToDomainLookupStart seconds (s) The time, in seconds, from the start of the interaction to the domainLookupStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToFetchStart seconds (s) The time, in seconds, from the start of the interaction to the fetchStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToLoadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the loadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToLoadEventStart seconds (s) The time, in seconds, from the start of the interaction to the loadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information, see our documentation about instrumentation for the Navigation Timing API. BrowserInteraction timeToRedirectEnd seconds (s) The time, in seconds, from the start of the interaction to the redirectEnd, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRedirectStart seconds (s) The time, in seconds, from the start of the interaction to the redirectStart, as defined by the Navigation Timing API. This attribute exists only for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToRequestStart seconds (s) The time, in seconds, from the start of the interaction to the requestStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseEnd seconds (s) The time, in seconds, from the start of the interaction to the responseEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToResponseStart seconds (s) The time, in seconds, from the start of the interaction to the responseStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToSecureConnectionStart seconds (s) The time, in seconds, from the start of the interaction to the secureConnectionStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventEnd seconds (s) The time, in seconds, from the start of the interaction to the unloadEventEnd, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timeToUnloadEventStart seconds (s) The time, in seconds, from the start of the interaction to the unloadEventStart, as defined by the Navigation Timing API. This attribute exists for initial page load events, not route changes. For more information about the Navigation Timing API, see Instrumentation for Browser monitoring. BrowserInteraction timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span trigger The cause of the route change or page load. The default values are click, submit, popstate, or initial page load. For a custom event created with the API, the default value for trigger will be api. This value can also be set via the API. BrowserInteraction userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming BrowserTiming Data source : Browser agent BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. Attribute name Definition Data types appId ID The ID of your application, as recorded by New Relic. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserInteractionName The name of the interaction. This is either the targetGroupedUrl or the custom name set via the API. AjaxRequest BrowserInteraction BrowserTiming browserTimingName The name of the event. This is taken from the name argument of createTracer. BrowserTiming city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView eventId ID A value that you can link to multiple BrowserInteraction events so you can view the interactions that occurred surrounding a specific event. For example, you can see the browser interactions that occurred prior to a JS error. AjaxRequest BrowserInteraction BrowserTiming groupedPageURL The grouped URL of the view that made the AJAX request. For example: myapp.com/acct/*/dash. AjaxRequest BrowserTiming jsDuration seconds (s) The total duration, in seconds, spent on JavaScript execution. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. This attribute doesn't exist for initial page load events. AjaxRequest BrowserInteraction BrowserTiming pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span timeSinceBrowserInteractionStart seconds (s) The time in seconds between the start of the BrowserInteraction and the start of the request. AjaxRequest BrowserTiming timeToLastCallbackEnd seconds (s) The duration, in seconds, from the start of the request (timestamp) to the end of the last callback. This is not just an additive function; the callback time can overlap with the wait time. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserInteraction BrowserTiming timeToSettle seconds (s) The time, in seconds, from the start of the request to when all resulting callbacks (including callbacks of subsequent AJAX requests) are complete. This attribute is only seen in AjaxRequest data that is tied to BrowserInteraction. AjaxRequest BrowserTiming timeToTracedCallbackStart seconds (s) The time in seconds from the start of the custom tracer until the start of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming timestamp The time (date, hour, minute, second) at which the interaction occurred. AjaxRequest BrowserInteraction BrowserTiming PageAction PageView PageViewTiming Span tracedCallbackDuration seconds (s) The duration in seconds of the traced callback. This attribute is unique to the BrowserTiming event. BrowserTiming userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming ContainerSample Data source : Infrastructure This event is reported by the New Relic Infrastructure agent. It collects data from all the Docker containers on the host (which may or may not be running). It includes the container's ID, name, image, image name, and metrics about CPU, memory and networking. We take a snapshot of this data every 15 seconds for each container and package it into this event, which is then sent to New Relic. This data appears on the Containers UI page. Attribute name Definition Data types StorageDataAvailableBytes bytes (B) Data space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataTotalBytes bytes (B) Total Data space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsagePercent percentage (%) Percent of Data space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageDataUsedBytes bytes (B) Data space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataAvailableBytes bytes (B) Metadata space available in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataTotalBytes bytes (B) Total Metadata space in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsagePercent percentage (%) Percent of Metadata space used in the Storage Driver. Only Device Mapper driver is supported. ContainerSample StorageMetadataUsedBytes bytes (B) Metadata space used by the Storage Driver. Only Device Mapper driver is supported. ContainerSample commandLine The command line used in the container. ContainerSample containerId ID The unique Docker container ID. ContainerSample cpuKernelPercent percentage (%) CPU time percentage used in kernel space. ContainerSample cpuLimitCores count Number of cores available for the container. ContainerSample cpuPercent percentage (%) CPU usage percentage used. ContainerSample cpuShares count Number of CPU shares assigned to the container. ContainerSample cpuThrottlePeriods count Total number of periods throttled. ContainerSample cpuThrottleTimeMs milliseconds (ms) Total throttling time in milliseconds. ContainerSample cpuUsedCores percentage (%) CPU usage per core. ContainerSample cpuUsedCoresPercent percentage (%) CPU usage percentage per core. ContainerSample cpuUserPercent percentage (%) CPU time percentage used in user space. ContainerSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample image ID The Docker image ID for the image the container is based on. ContainerSample imageName The Docker image name for the container. ContainerSample label_KEY Docker labels associated with this container (where KEY represents a custom label's key value). ContainerSample memoryCacheBytes count The amount of memory used by the container that can be associated precisely with a block on a block device. ContainerSample memoryKernelUsageBytes bytes (B) The amount of current kernel memory allocation. ContainerSample memoryResidentSizeBytes bytes (B) The amount of memory that doesn't correspond to anything on disk: stacks, heaps, and anonymous memory maps. ContainerSample memorySizeLimitBytes bytes (B) The total amount of memory the container is allowed to use. ContainerSample memorySoftLimitBytes bytes (B) The soft limit of memory usage equivalent to the memory reservation of the container. ContainerSample memorySwapLimitBytes bytes (B) The total amount of memory the container is using, including swap. ContainerSample memorySwapLimitUsagePercent percentage (%) This metric is calculated as the percentage of memorySwapUsageBytes over memorySwapLimitBytes, if the limit exists. ContainerSample memorySwapOnlyUsageBytes bytes (B) The amount of swap memory the container is using. This memory doesn't include non-swap memory. ContainerSample memorySwapUsageBytes bytes (B) The amount of memory swap the container is using, including swap. ContainerSample memoryUsageBytes bytes (B) This metric doesn't account for swap usage. ContainerSample memoryUsageLimitPercent percentage (%) This metric is calculated as the memoryUsageBytes percentage over memorySizeLimitBytes, if the limit exists. ContainerSample name The Docker container name. ContainerSample networkRxBytes bytes (B) Total number of received bytes. ContainerSample networkRxBytesPerSecond rate Number of received bytes per second. ContainerSample networkRxDropped count Total number of received packets dropped. ContainerSample networkRxDroppedPerSecond rate Number of received packets dropped per second. ContainerSample networkRxError count Total number of received packets with error. ContainerSample networkRxErrorsPerSecond rate Number of received packets with error per second. ContainerSample networkRxPackets count Total number of received packets. ContainerSample networkRxPacketsPerSecond rate Number of received packets with error per second. ContainerSample networkTxBytesPerSecond rate Number of transmitted bytes per second. ContainerSample networkTxDropped count Total number of transmitted packets dropped. ContainerSample networkTxDroppedPerSecond rate Number of transmitted packets dropped per second. ContainerSample networkTxErrors count Total number of transmitted packets with error. ContainerSample networkTxErrorsPerSecond rate Number of transmitted packets with error per second. ContainerSample networkTxPackets count Total number of transmitted packets. ContainerSample networkTxPacketsPerSecond rate Number of transmitted packets per second. ContainerSample networksTxBytes count Total number of bytes transmitted. ContainerSample restartCount count The number of times the container was restarted. ContainerSample state It can be: created, restarting, running, removing, paused, exited, or dead. ContainerSample status Holds the current container state. ContainerSample warningViolationCount count The number of times that alert conditions violated warning thresholds, causing warning violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample DistributedTraceSummary Data source : Distributed Tracing This event contains summary data about a distributed trace and provides an aggregated view of distributed tracing data. DistributedTraceSummary events are generated by New Relic and are triggered by distributed tracing data from agents or the Trace API. Attribute name Definition Data types accountIds A comma delimited list of newrelic accountIds that took part in this trace. DistributedTraceSummary backend.duration.ms milliseconds (ms) The total elapsed time in milliseconds of all backend services in this trace. DistributedTraceSummary backend.timestamp milliseconds (ms) The timestamp of the first span in this trace from a backend entity. In distributed tracing, any events that are not from client-side applications contributed to the backend duration. DistributedTraceSummary duration.ms The duration of the entire distributed trace, including both backend and client-side entities. the earliest span to the latest. DistributedTraceSummary entityCount count The number of unique entities that took part in this trace. DistributedTraceSummary entityGuids A comma delimited list of entity GUIDs for entities that participated in this trace. These GUIDs are assigned by New Relic for the New Relic-monitored entity (host, application, etc.). Each GUID is stored as a Base64 encoded value. DistributedTraceSummary errorCount count The number of events in this distributed trace that were identified as errors. DistributedTraceSummary newRelic.traceFilter.type The name of the trace filter used by the Infinite Tracing trace observer to select this trace. DistributedTraceSummary Span root.entity.accountId The New Relic account ID that the root entity of this trace reports data to. DistributedTraceSummary root.entity.guid The entity GUID associated with the root entity of this trace. DistributedTraceSummary root.entity.name The name of the root entity of this trace. DistributedTraceSummary root.span.duration.ms milliseconds (ms) The elapsed time in milliseconds of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary root.span.id The unique identifier of the root span of this trace. The root of a distributed trace is the first span, and it has a null value for parent.id. DistributedTraceSummary root.span.name The name of the root span of this trace. DistributedTraceSummary root.span.timestamp milliseconds (ms) The timestamp of the root span of this trace. The root of a distributed trace is the first span, and will have a null value for parent.id. DistributedTraceSummary spanCount count The number of events in this distributed trace. Events in a distributed trace can have several event types, including Span, Transaction, and TransactionError. DistributedTraceSummary timestamp milliseconds (ms) The timestamp of the root span in this distributed trace. DistributedTraceSummary trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError InfrastructureEvent Data sources : InfrastructureCloudTrail InfrastructureEvent describes changes (deltas) that occur in a system's live state. When an inventory or system state is added, removed, or changed, Infrastructure will produce an InfrastructureEvent that logs that activity. Attribute name Definition Data types category A New Relic category used to organize events in the UI. For example: automation, notification, and service. InfrastructureEvent changeType A simple classification of the type of change made to the entity: added, modified, or removed. InfrastructureEvent changedPath The fully specified name of the item that changed. This is constructed by taking the source and adding one or more additional path elements that uniquely identify the item that changed. InfrastructureEvent deltaId Delta refers to a recorded change in the system. The deltaId is a number used by New Relic to organize incoming inventory change data. InfrastructureEvent eventId The unique ID of the event, generated by New Relic. InfrastructureEvent format The type of infrastructure event. Each format type includes attributes that may be used to render the event in the UI. InfrastructureEvent newStatus The new agent status: disconnected or connected. InfrastructureEvent newValue If a change is made to the entity, this attribute contains the new value of the inventory that was changed. This will have no value if no change has been made. The value will display approximately 4K bytes of data. InfrastructureEvent oldValue If a change is made to the entity, this attribute contains the old value of the inventory that was changed. This will be blank if no change has been made. InfrastructureEvent provider For integrations that use generic event types (like the DatastoreSample event), the provider value specifies the source of the data (the service, or a sub-category of data from that service). Some Insights events are generic and are used by several integrations. For example, the DatastoreSample event is used by several integrations, including the AWS DynamoDB integration and the AWS RDS integration. In these cases, the provider attribute value represents the source of that attribute. This will usually be the service that data comes from or, for integrations that use several provider values, a certain sub-category of data from that service. When a provider value is present for a generic event, that event will have additional integration-specific attributes attached to it. Here’s an example of an Insights NRQL query that returns the attributes present for a DatastoreSample event reported by the AWS RDS integration: SELECT * from DatastoreSample where provider = 'RdsDbCluster' InfrastructureEvent source The fully specified origin of this inventory item. This is typically in the form category/plugin, where plugin is the generic word used for the tool that gathered this data. InfrastructureEvent summary A summary of the change that happened. Uses a human-friendly string, such as Agent disconnected. InfrastructureEvent violationUpdateType The type of change to the violation: For example: open or closed. InfrastructureEvent JavaScriptError Data source : Browser agent As JavaScript errors are triggered, we capture details as events. The JavaScriptError event contains information to help you segment errors to understand how they impact performance. Attribute name Definition Data types appId ID The identification number for the reporting browser agent. JavaScriptError appName The name of the application that handled the request as shown in New Relic Browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnLatitude The latitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's latitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnLongitude The longitude of the geographic center of the postal code where the Autonomous System Network is registered. This is not the end user's longitude. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming asnOrganization The organization that owns the Autonomous System Number. Often an ISP, sometimes a private company or institution. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming browserInteractionId ID A unique value generated for each browser interaction captured by the New Relic agent. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError browserStackHash ID An unique identifier generated for a stack trace. The browserStackHash for a stack trace is different across different browsers. An identical stack trace will generate the same identifier. JavaScriptError city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the browser initiated the page load. For a list of country codes, see ISO 3166-1 alpha-2. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming deviceType The type of device that loaded the page: mobile, tablet, or desktop. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageView domain The domain portion of the request URL. BrowserInteraction JavaScriptError PageView PageViewTiming entityGuid The unique identifier of the monitor referenced in New Relic One. JavaScriptError SyntheticCheck SyntheticRequest errorClass The error type of the JavaScript Error object. Examples: ReferenceError, SyntaxError, and UncaughtException. JavaScriptError errorMessage The error message that was delivered. JavaScriptError firstErrorInSession A value to indicate whether or not this was the first JS error in the session. Example: true. JavaScriptError monitorAccountId The Synthetics account from which you are running the monitor. BrowserInteraction JavaScriptError monitorId ID A unique number identifying a particular monitor. BrowserInteraction JavaScriptError SyntheticCheck monitorJobId ID The ID of a single Synthetics monitor run, which began at a specific time and originated from a specific location. BrowserInteraction JavaScriptError pageUrl The URL of the page that was loaded for the PageView. For example: http://www.newrelic.com. This URL does not include query parameters. AjaxRequest BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span parentEventId ID A unique value generated for each interaction with the page. You can use this value to group interactions together. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError regionCode The specific administrative division within a country where the PageView event occurred. In the United States, regions correspond to state codes, such as WA or NY. Outside the United States, a country's regions correspond to numerical codes. In the United States, regions correspond to state codes ; for example, WA or NY. Outside the United States, a country's regions correspond to numerical codes . AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming releaseIds ID The releases in which the app was updated. Example: {\\\"jQuery\\\":\\\"v3.1.1\\\",\\\"multiverse\\\":\\\"96e9ac7\\\"}. JavaScriptError requestUri The URI of the requested resource. JavaScriptError session A unique identifier for a single session. The session cookie expires when the user closes the browser (for example, they fully exit Chrome.) A new session identifier will be assigned when the user opens up a new instance of the browser. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Span stackHash ID A unique identifier generated by the Browser agent for a stack trace. The stackHash for a stack trace is the same across different browsers. An identical stack trace will generate the same identifier. JavaScriptError stackTrace A collection of the active stack frames when the error occurred. JavaScriptError stackTraceGzip A compressed version of the stackTrace attribute. JavaScriptError timestamp The time that the error occurred, in Unix time. JavaScriptError transactionName The full metric name of the transaction in which the error occurred, or Unknown if the error occurs outside of a transaction. JavaScriptError userAgentName The browser’s name, such as Chrome and Firefox, obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentOS The browser’s reported operating system, such as Windows or Linux, that it is running on. This is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming userAgentVersion The browser’s reported software version, which is obtained from the User-Agent header of an HTTP request. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError PageAction PageView PageViewTiming Metric Data source : Metrics Represents a metric data point (e.g., a measurement over a range of time, or a sample at a specific point in time) with multiple attributes attached, which allow for in-depth analysis and querying. This metric data comes from our Metric API, our Telemetry SDKs, and some of our open-source exporters/integrations. Attribute name Definition Data types endTimestamp milliseconds (ms) The end of the time range associated with the metric, in Unix time, in milliseconds. This is calculated by adding the metric interval to the timestamp of the metric (timestamp + interval.ms). Metric interval.ms milliseconds (ms) The length of the time window. Metric metricName Name of the metric. Metric newrelic.source The source of this data. For example: metricAPI. Metric timestamp milliseconds (ms) The start time for the metric, in Unix time. Metric Mobile Data source : Mobile A Mobile event is created when a crash occurs, when an interaction ends or has run for 1 second, or if a session completes after the app is closed, backgrounded, or has run for 10 minutes. Mobile events were once the only event type and were generated for every event, but now there are several specialized event types. Recommendation: Upgrade to the most recent mobile monitoring agent version to take full advantage of the new event types. Attribute name Definition Data types category The type of data, either session or interaction. Mobile MobileSession interactionDuration For interaction category events only. This is the total time for the interaction to render on the device. In addition to render time, this usually includes all external calls associated with the interaction. Currently, this attribute is measured in seconds for Android devices and in milliseconds for iOS devices. Mobile name For interaction category events only. This is the label of the interaction associated with the event. It is by default assigned by New Relic. For example: ApplicationsListFragment or Display iOS_Example.MasterViewController. Mobile reportedTimestampMs For interaction category events only. The UTC based timestamp for when the event was sent to New Relic. This is different from the attribute ‘timestamp’, which is when the event began. Mobile MobileCrash Data source : Mobile The MobileCrash event is created when an app crashes. MobileCrash includes attributes such as crash line number, class, and crash message. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appToken The mobile application license token. MobileCrash appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession architecture The processor architecture of the device. For example: armv7 or arm64. MobileCrash asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession crashException The exception associated with the crash, if one is present. For example: java.lang.NullPointerException. MobileCrash crashFingerprint ID The New Relic-generated fingerprint used to uniquely identify the crash and other crashes identical to this one. MobileCrash crashLocationFile The file in which the crash occurred. MobileCrash crashMessage The message associated with the crash, if one is present. MobileCrash deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceName The device's name. MobileCrash deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession diskAvailable bytes (B) Space available on the device, in bytes. MobileCrash interactionHistory The client interactions with the application that led to the crash. MobileCrash isFirstOccurrence A boolean value indicating whether or not this was the first occurrence of the crash. MobileCrash lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession modelNumber The model of the device. This is the same as the session-level deviceModel attribute. MobileCrash networkStatus The type of network that the device was on at the time of crash, such as wifi or LTE. MobileCrash newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceId ID The ID for this instance of the crash. MobileCrash orientation The orientation of the device, such as landscape or portrait. MobileCrash osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession parentProcess The parent process that launched the crashing process. MobileCrash parentProcessId ID The parent identification number (PID) of the parent process. MobileCrash platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession processId ID The PID of the previously running process on the device. MobileCrash processName The name of the previously running process. MobileCrash processPath The path to the binary. MobileCrash reportedTimestampMs The UTC timestamp for when the event was received by New Relic. (This is different from timestamp, which is when the MobileSession event began that crashed.) MobileCrash runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession symbolicated A boolean value indicating whether or not the crash was properly symbolicated. MobileCrash timeSinceLastInteraction milliseconds (ms) The time, in milliseconds, since the interaction before a crash event. MobileCrash userImageUuids ID The array of build UUIDs for applications and libraries. MobileCrash uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileHandledException Data source : Mobile MobileHandledException is sent when an exception is caught and is used for non-fatal exceptions reported to New Relic using the recordHandledException API for Android or iOS. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession exceptionAppBuildUuid ID The build uuid of the application binary in which the exception was caught. MobileHandledException exceptionCause The unsymbolicated, platform-specific cause of the exception. MobileHandledException exceptionLocation New Relic defined location of an exception. Contains a combination of exception file name, class, line number, and method. MobileHandledException exceptionLocationClass The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationFile The class that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLibraryOffset For XCFramework agent only. The library offset of the library that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionLocationLine Comes from the exception: The line number where the exception was generated. Only present if symbolication succeeded. MobileHandledException exceptionLocationMethod The method that generated the exception. Only present if symbolication succeeded. MobileHandledException exceptionMessage The unsymbolicated message from the exception. It can be user-generated or a generic system message. For Android, this is the Throwable message. MobileHandledException exceptionName The unsymbolicated exception type. MobileHandledException fingerprint ID The New Relic-generated identifier used to group like exceptions. MobileHandledException handledExceptionUuid ID The unique ID of the exception event. MobileHandledException lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession libraryName For XCFramework agent only. The library name where the exception was generated. MobileHandledException libraryStartAddr For XCFramework agent only. The library start address where the exception was generated. MobileHandledException memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession occurrenceTimestamp Agent-reported epoch timestamp of the handled exception. MobileHandledException osBuild For Android only. The specific build of the Android OS. MobileCrash MobileHandledException osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession runTime For Android only. The Android Runtime version where the exception/crash was generated. MobileCrash MobileHandledException sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timestamp Epoch timestamp of the handled exception. This exception timestamp represents the time New Relic created the event, if it's older than two days or some other unexpected time. MobileHandledException uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequest Data source : Mobile A MobileRequest event is created when an HTTP request successfully completes, resulting in a response code below 400. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestFingerprint ID The New Relic-generated identifier used to group like request events. MobileRequest requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileRequestError Data source : Mobile A MobileRequestError is used for HTTP errors or network failures. HTTP errors are HTTP requests that have a status code greater than 400. A network failure is a HTTP request that results in no response. The event is sent when the HTTP request completes. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bytesReceived bytes (B) Optional: If the application received a response from the requestUrl, the size of that response in bytes. MobileRequest MobileRequestError bytesSent bytes (B) Optional: If the application sent a request to the requestUrl, the size of that request in bytes. MobileRequest MobileRequestError carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession connectionType The type of connection which the device was using, such as 2G or 3G. MobileRequest MobileRequestError countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceSize The display size of the device: Small, normal, large, xlarge. MobileRequest MobileRequestError deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession duration seconds (s) Optional: The time to complete the request, measured in fractional seconds. MobileRequest MobileRequestError errorType Either HTTPError or NetworkFailure, depending on whether the error is a result of a failed request to a host or a failure on the cellular network. MobileRequestError guid ID The unique identifier for the segment. This is equivalent to spanID in OpenTracing semantics. MobileRequest MobileRequestError Span lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession networkError The error message associated with the iOS NSURL Error code. See networkErrorCode for more information. MobileRequestError networkErrorCode If the error is a network error, this is the iOS network error code. For Android applications, this is the mapped value. MobileRequestError newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession requestDomain The domain that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestErrorFingerprint ID The New Relic-generated identifier used to group like request error events. MobileRequestError requestMethod The REST method (GET, PUT, POST, etc.) that the application attempted when the event occurred. MobileRequest MobileRequestError requestPath The path that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUrl The URL that the application attempted to access when the event occurred. MobileRequest MobileRequestError requestUuid ID A unique identifer for the request event. MobileRequest MobileRequestError responseBody Optional: The response that is sent from the requestDomain for the HTTP error, up to 4096 bytes. MobileRequestError responseTime seconds (s) The time between the request and the response in fractional seconds. MobileRequest MobileRequestError sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession statusCode Optional: The HTTP status code for the HTTP event. MobileRequest MobileRequestError timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession trace.id ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. DistributedTraceSummary MobileRequest MobileRequestError Span Transaction TransactionError traceId ID The unique ID (a randomly generated string) used to identify a single request as it crosses inter- and intra- process boundaries. This ID allows the linking of spans in a distributed trace. Included when distributed tracing is enabled. AwsLambdaInvocation AwsLambdaInvocationError MobileRequest MobileRequestError Span uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession MobileSession Data source : Mobile A MobileSession event is sent when an app is closed, backgrounded, or when 10 minutes of active use has elapsed. This is the source of the general session data used by the other mobile monitoring events. MobileSession captures attributes such as device type, device OS, and geographical information. Attribute name Definition Data types appBuild Indicates the technical build number of the app binary. As a developer, you can use this attribute to identify specific builds of your app. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appId ID A unique identifier for a monitored app, based on the app token. For example: 35091. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appName The name of the monitored app. For example: My Mobile App - iOS. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersion The version number of the monitored app. For example: 2.2.9. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession appVersionId ID An identifier for the specific version of the app. For example: 1713477. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession asn Autonomous System Number: a unique number identifying a group of IP networks that serves the content to the end user. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileRequest MobileRequestError MobileSession PageAction PageView PageViewTiming Span asnOwner The telecom owner of the ASN. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession bundleId ID The unique string used to identify the application. MobileCrash MobileSession carrier The network over which the app transferred data, such as Wi-Fi, Verizon, or Sprint. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession category The type of data, either session or interaction. Mobile MobileSession city The city in which the event occurred, such as Portland or Seattle. AjaxRequest BrowserInteraction BrowserTiming JavaScriptError MobileHandledException MobileSession PageAction PageView PageViewTiming countryCode The country from which the device ran the application. For a list of country codes, see ISO 3166-1 alpha-2. MobileHandledException MobileRequest MobileRequestError MobileSession device The specific type of the device: iPhone 8, iPad Pro, etc. Duplicate of deviceType. MobileHandledException MobileRequest MobileRequestError MobileSession deviceGroup The category of the device, such as iPhone or Tablet. MobileRequest MobileRequestError MobileSession deviceManufacturer The manufacturer of the device, such as Motorola or HTC. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceModel The model number of the device, such as XT1039 or SM-G900F. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession deviceType The specific type of device: iPhone 8, iPad Pro, etc. Duplicate of device. MobileHandledException MobileRequest MobileRequestError MobileSession deviceUuid ID A unique identifier assigned at the time of app installation by New Relic. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of uuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession install Indicates true only if the current session is the first session after app install. MobileSession lastInteraction The last interaction before a crash or harvest event, if one is present. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession memUsageMb megabytes (MB) The total amount of memory, in MB, used by the application. Updated every 60 seconds. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession newRelicAgent The New Relic agent running on the application. For example: the iOSAgent or the androidAgent. MobileSession newRelicVersion The version number of the agent running on the application. For example: 4.232.0. Duplicate of newRelicAgentVersion. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osMajorVersion The simplified version number of the app's host operating system, such as iOS 11, as compared to iOS 11.0.4. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osName The name of the app's host operating system, for example, iOS or Android. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession osVersion The exact version number of the app's host operating system, such as iOS 11.0.4, as compared to iOS 11. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession platform The platform type of the mobile monitoring agent, such as native or Cordova. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession regionCode The specific region within a country where the monitored app is located. In the United States, regions are states. The regionCode is based on IP address and may not always match your region. MobileHandledException MobileRequest MobileRequestError MobileSession sessionCrashed A boolean value indicating whether or not that session crashed. MobileCrash MobileSession sessionDuration seconds (s) The length of time for which the user used the application in seconds. If the session crashes, sessionDuration is not captured (although other events and attributes are still recorded). For sessions longer than 10 minutes, events in the Interaction and Custom event categories are sent to Insights while the session is ongoing, and therefore do not have sessionDuration attributes. Events recorded near the end of the session will include the duration, as will the Session event category. MobileSession sessionId ID A unique identifier for a single user session. A new sessionId is created each time the app is brought into the foreground. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession timeSinceLoad seconds (s) The time, in seconds, from the beginning of the mobile session to the time the event occurred. MobileSession timestamp The UTC epoch time at which an event began. MobileRequest MobileRequestError MobileSession upgradeFrom Indictates previous version number only if this is the first launch after app upgrade. MobileSession uuid ID A unique identifier assigned by New Relic for a specific app on a particular device. It is only reset if a user deletes and then reinstalls the app. For example: B8B0BC30-0235-11E4-9191-0800200C9A66. Dupliate of deviceUuid. MobileCrash MobileHandledException MobileRequest MobileRequestError MobileSession NetworkSample Data source : Infrastructure NetworkSample event captures the descriptive and state information for each network device associated with a server. It includes the device's interface and address information, as well as current usage data. New Relic samples this data every 10 seconds for each attached network interface and packages it into a NetworkSample event, then sends the raw data to New Relic's collectors every 60 seconds. Attribute name Definition Data types agentName The name of the agent (Infrastructure). NetworkSample ProcessSample StorageSample SystemSample agentVersion The version of the New Relic Infrastructure agent. NetworkSample ProcessSample StorageSample SystemSample criticalViolationCount count The number of times that alert conditions violated critical thresholds, causing critical violations and opening incidents. If this attribute does not exist on the sample, it has zero violations. ContainerSample NetworkSample ProcessSample StorageSample SystemSample entityID ID New Relic's unique ID number for the entity that is reporting data. This is used by New Relic to distinguish between customers and their entities. NetworkSample ProcessSample StorageSample SystemSample fullHostname The fully qualified (DNS) hostname. NetworkSample ProcessSample StorageSample SystemSample hardwareAddress The unique hardware address of the interface. NetworkSample hostname The short version of the entity's name. NetworkSample ProcessSample StorageSample SystemSample interfaceName The interface name as reported by the operating system. NetworkSample ipV4Address The IP version 4 address. NetworkSample ipV6Address The IP version 6 address. NetworkSample kernelVersion The Linux kernel version, in string format. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample linuxDistribution The name of the Linux distribution the server is using. This attribute is available only for systems on a Linux platform. NetworkSample ProcessSample StorageSample SystemSample operatingSystem The operating system on which the agent is installed. NetworkSample ProcessSample StorageSample SystemSample receiveBytesPerSecond bytes (B) The number of bytes per second received during the sampling period. NetworkSample receiveDroppedPerSecond count The number of received packets per second dropped during the sampling period. NetworkSample receiveErrorsPerSecond count The number of receive errors per second on the interface during the sampling period. NetworkSample receivePacketsPerSecond count The number of packets per second (",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 331.1754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>AjaxRequest</em>",
        "body": " that loaded the page: mobile, tablet, or desktop. <em>AjaxRequest</em> BrowserInteraction BrowserTiming JavaScriptError PageView <em>event</em>Id ID A value that you can link to multiple BrowserInteraction <em>events</em> so you can view the interactions that occurred surrounding a specific <em>event</em>. For example, you can see"
      },
      "id": "603f53b164441f41894e8875"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/understand-data/event-data/events-reported-browser-monitoring/",
      "sections": [
        "Events reported by browser monitoring"
      ],
      "published_at": "2021-10-07T07:55:57Z",
      "title": "Events reported by browser monitoring",
      "updated_at": "2021-09-20T19:27:38Z",
      "type": "docs",
      "external_id": "d6f86607d41e6a9a053b9f8a4d0775c2fca6f4bc",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring in New Relic reports event data that is displayed in some UI displays and is also available for querying and charting. Select an event name in the following table to see its attributes. Event Description PageView PageView tracks geographic and timing data for each browser page load. PageViewTiming PageViewTiming sends each data point as a separate event as soon as it is available. This is useful for asynchronous, dynamic pages. To use this event, you must have browser agent version 1149 or higher. For more information, see the PageViewTiming query examples. PageAction PageAction event tracks data on each action performed on a page. Its attributes provide app and geographic data, as well as data about the user’s browser dimensions, session IDs, and referring and page URLs. BrowserInteraction (SPA) BrowserInteraction contains several PageView attributes as well as attributes that are specific to single-page apps (SPA) AjaxRequest An AjaxRequest event is created any time an Ajax call is made. When an Ajax call happens during a BrowserInteraction event, it is decorated with additional attributes related to the browser interaction. The event attributes track geographic and browser information. BrowserTiming (SPA) BrowserTiming is a custom event that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other events, especially AjaxRequest. JavaScriptError When a JavaScript error occurs, a JavaScriptError event is created. JavaScriptError captures JavaScript error data as well as browser interaction data. For more information, see the JS errors page in the browser UI and the example NRQL queries for browser and SPA events. Span When distributed tracing is enabled for browser monitoring, Span data is reported.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.1239,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Events</em> reported by browser monitoring",
        "sections": "<em>Events</em> reported by browser monitoring",
        "body": " geographic and browser information. BrowserTiming (SPA) BrowserTiming is a custom <em>event</em> that captures SPA timing data for browser interactions started using the custom createTracer SPA API method. BrowserTiming contains many of the same attributes used by other <em>events</em>, especially <em>AjaxRequest</em>"
      },
      "id": "609f8fe9196a677e8a22b1ab"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/group-browser-metrics-urls": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.5487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Monitor or block specific domains and subdomains",
        "Tip",
        "Configure domain conditions",
        "Turn off domain conditions"
      ],
      "title": "Monitor or block specific domains and subdomains",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Configuration"
      ],
      "external_id": "bf81374c9ec84ce08154a76b10f526fb5ee7e7ec",
      "image": "https://docs.newrelic.com/static/1bf47635bd1556e86b9019a47176e3b9/c1b63/browser_domain_conditions.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/monitor-or-block-specific-domains-subdomains/",
      "published_at": "2021-10-07T16:59:34Z",
      "updated_at": "2021-07-10T02:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser lets you choose which domains or subdomains that a browser app monitors. This is useful for limiting monitoring only to the application activity you consider important. For example, if you use the copy/paste method to deploy your browser app, you can set domain conditions to protect the security of your browser monitoring license key and app ID. Tip Domain conditions only filter data based on the url of the page that is reported. Domain condition filters do not apply to AJAX data reported to New Relic. Configure domain conditions To view or edit your domain condition settings: Go to one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Edit conditions. Select the option to build a list of allowed domains or to build a list of blocked/denied domains. Select the domain conditions (maximum 10 conditions). Select the domain conditions with the Starts with condition, then enter the URL with the subdomain (maximum 10 conditions). one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions: Use this feature to limit monitoring only to your important app activity, or to enhance security for your browser license key and app ID. Review and confirm your domain condition settings. A preview text box displays in real time what domains match the conditions you set. You will also see an estimate of the impact the proposed settings will have on your data. Turn off domain conditions To disable domain conditions and return to monitoring all domains: Go to one.newrelic.com > Browser > (select an app) > Settings > Domain conditions. Set the Enable domain conditions option to Off.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.66204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> or block specific domains and subdomains",
        "sections": "<em>Monitor</em> or block specific domains and subdomains",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> lets you choose which domains or subdomains that a <em>browser</em> app monitors. This is useful for limiting <em>monitoring</em> only to the application activity you consider important. For example, if you use the copy&#x2F;paste method to deploy your <em>browser</em> app, you can set domain conditions to protect"
      },
      "id": "6043fd41e7b9d240ca5799bb"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/monitor-or-block-specific-domains-subdomains": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.5487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Rename browser apps",
        "Rename app monitored by APM",
        "Caution",
        "Rename app via JavaScript snippet",
        "Rename app via New Relic REST API (v2)"
      ],
      "title": "Rename browser apps",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Configuration"
      ],
      "external_id": "6ba80996a8c58869876377c40ba67098f0870475",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/rename-browser-apps/",
      "published_at": "2021-10-07T17:10:24Z",
      "updated_at": "2021-07-10T02:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Follow the appropriate procedure to rename your browser app depending on the deployment option you used to add it to browser. Rename app monitored by APM If you added an app to browser already being monitored by APM, the app name that appears in browser is the same as the app name in the APM UI. To rename the app, use any of these options: Option Comments Rename and continue collecting data This option is useful when you simply want to give an app a different display name (alias). To change the alias that appears in the New Relic UI, use the app's Settings page: Go to one.newrelic.com > APM > (select an app) > Settings > Application. Stop reporting under the old name To stop reporting data under the old name and begin collecting data with a new name (app identifer), use the APM agent's configuration file. This changes the identifier that New Relic's data collector uses to distinguish one app from another. Based on the data retention schedule, New Relic will retain historical data collected under the old name, and will collect and aggregate data under the new name. If one or more apps share the same name, then their data will be aggregated in the UI. Caution If you change the app identifier, a new application will appear in our user interface with the new name, and data will stop reporting to the app(s) with the old name. Rename app via JavaScript snippet This information applies if you inserted the browser agent's JavaScript snippet into your: App monitored by APM that was deployed via the copy/paste method Single page app (SPA) Any standalone browser app that is not also monitored by APM You cannot directly edit the JavaScript snippet in the existing app. Instead, to use your app with a different name: Follow standard procedures to create a new app using the copy/paste method. Provide the new name, and generate the JavaScript snippet. Copy the new JavaScript snippet. In your webpage, replace the JavaScript from your original app with the JavaScript generated for the new app name. If your standalone app has multiple names, copy the custom app IDs in your configuration script to your new app. Based on the data retention schedule, New Relic will retain historical data collected under the old name, and will collect and aggregate data under the new name. Rename app via New Relic REST API (v2) This information applies only to browser apps that are also monitored by APM. You cannot change the app name via the REST API if you used the copy/paste method to insert browser's JavaScript snippet into your app. Follow standard procedures to change the APM app alias via REST API or API Explorer. New Relic automatically changes the display name for the app everywhere in the New Relic UI, including browser.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.66204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Rename <em>browser</em> apps",
        "sections": "Rename <em>browser</em> apps",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " <em>configuration</em> script to your new app. Based on the data retention schedule, New Relic will retain historical data collected under the old name, and will collect and aggregate data under the new name. Rename app via New Relic REST API (v2) This information applies only to <em>browser</em> apps that are also monitored"
      },
      "id": "603ea123e7b9d2943f2a07b3"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/rename-browser-apps": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.54865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Monitor or block specific domains and subdomains",
        "Tip",
        "Configure domain conditions",
        "Turn off domain conditions"
      ],
      "title": "Monitor or block specific domains and subdomains",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Configuration"
      ],
      "external_id": "bf81374c9ec84ce08154a76b10f526fb5ee7e7ec",
      "image": "https://docs.newrelic.com/static/1bf47635bd1556e86b9019a47176e3b9/c1b63/browser_domain_conditions.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/monitor-or-block-specific-domains-subdomains/",
      "published_at": "2021-10-07T16:59:34Z",
      "updated_at": "2021-07-10T02:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser lets you choose which domains or subdomains that a browser app monitors. This is useful for limiting monitoring only to the application activity you consider important. For example, if you use the copy/paste method to deploy your browser app, you can set domain conditions to protect the security of your browser monitoring license key and app ID. Tip Domain conditions only filter data based on the url of the page that is reported. Domain condition filters do not apply to AJAX data reported to New Relic. Configure domain conditions To view or edit your domain condition settings: Go to one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Edit conditions. Select the option to build a list of allowed domains or to build a list of blocked/denied domains. Select the domain conditions (maximum 10 conditions). Select the domain conditions with the Starts with condition, then enter the URL with the subdomain (maximum 10 conditions). one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions: Use this feature to limit monitoring only to your important app activity, or to enhance security for your browser license key and app ID. Review and confirm your domain condition settings. A preview text box displays in real time what domains match the conditions you set. You will also see an estimate of the impact the proposed settings will have on your data. Turn off domain conditions To disable domain conditions and return to monitoring all domains: Go to one.newrelic.com > Browser > (select an app) > Settings > Domain conditions. Set the Enable domain conditions option to Off.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.66203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> or block specific domains and subdomains",
        "sections": "<em>Monitor</em> or block specific domains and subdomains",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> lets you choose which domains or subdomains that a <em>browser</em> app monitors. This is useful for limiting <em>monitoring</em> only to the application activity you consider important. For example, if you use the copy&#x2F;paste method to deploy your <em>browser</em> app, you can set domain conditions to protect"
      },
      "id": "6043fd41e7b9d240ca5799bb"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/view-browser-apps-alert-information": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.54857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.3207,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Monitor or block specific domains and subdomains",
        "Tip",
        "Configure domain conditions",
        "Turn off domain conditions"
      ],
      "title": "Monitor or block specific domains and subdomains",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Configuration"
      ],
      "external_id": "bf81374c9ec84ce08154a76b10f526fb5ee7e7ec",
      "image": "https://docs.newrelic.com/static/1bf47635bd1556e86b9019a47176e3b9/c1b63/browser_domain_conditions.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/configuration/monitor-or-block-specific-domains-subdomains/",
      "published_at": "2021-10-07T16:59:34Z",
      "updated_at": "2021-07-10T02:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser lets you choose which domains or subdomains that a browser app monitors. This is useful for limiting monitoring only to the application activity you consider important. For example, if you use the copy/paste method to deploy your browser app, you can set domain conditions to protect the security of your browser monitoring license key and app ID. Tip Domain conditions only filter data based on the url of the page that is reported. Domain condition filters do not apply to AJAX data reported to New Relic. Configure domain conditions To view or edit your domain condition settings: Go to one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions. If there are no domain conditions in place, select Enable domain conditions. If conditions exist, select Edit conditions. Select the option to build a list of allowed domains or to build a list of blocked/denied domains. Select the domain conditions (maximum 10 conditions). Select the domain conditions with the Starts with condition, then enter the URL with the subdomain (maximum 10 conditions). one.newrelic.com > Browser > (select a browser app) > Settings > Domain conditions: Use this feature to limit monitoring only to your important app activity, or to enhance security for your browser license key and app ID. Review and confirm your domain condition settings. A preview text box displays in real time what domains match the conditions you set. You will also see an estimate of the impact the proposed settings will have on your data. Turn off domain conditions To disable domain conditions and return to monitoring all domains: Go to one.newrelic.com > Browser > (select an app) > Settings > Domain conditions. Set the Enable domain conditions option to Off.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.66203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Monitor</em> or block specific domains and subdomains",
        "sections": "<em>Monitor</em> or block specific domains and subdomains",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> lets you choose which domains or subdomains that a <em>browser</em> app monitors. This is useful for limiting <em>monitoring</em> only to the application activity you consider important. For example, if you use the copy&#x2F;paste method to deploy your <em>browser</em> app, you can set domain conditions to protect"
      },
      "id": "6043fd41e7b9d240ca5799bb"
    }
  ],
  "/docs/browser/new-relic-browser/getting-started/browser-apps-index": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Target framework version",
        "Important",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "ce9a62a0c6a2d98442118333f39152c38bf9fdda",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-10-07T08:42:12Z",
      "updated_at": "2021-10-07T08:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0. Table of minimum agent versions required per .NET Core version .NET Core Version Minimum Required .NET Agent Version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and NET 5.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5 runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as 64-bit (x64) on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, and 5.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.02353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to <em>get</em> this information) Automatic brower <em>monitoring</em> script injection (API or manual instrumentation"
      },
      "id": "603e8e7e196a675c41a83d9f"
    },
    {
      "sections": [
        "Compatibility and requirements for browser monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-10-07T17:11:30Z",
      "updated_at": "2021-09-02T06:45:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the browser agent, make sure your system meets these requirements. Want to try out our browser monitoring? Create a New Relic account for free! No credit card required. Basic requirements To report data to browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the browser agent for apps monitored by APM, or you can deploy the browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying browser for an app using APM, make sure your agent supports browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use our SPA monitoring features, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with browser. In all cases, the browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our Pro+SPA agent due to the way this library wraps promises. If you're using this library, we recommend selecting the Pro agent type. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organization’s standard procedures in order to install the browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.88531,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "sections": "Compatibility and requirements for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> includes strict security measures to provide a robust, standalone product with <em>browser</em> <em>monitoring</em> features. Before you install the <em>browser</em> agent, make sure your system meets these requirements. Want to try out our <em>browser</em> <em>monitoring</em>? Create a New Relic account for free! No credit"
      },
      "id": "603ed6b664441f4a784e883f"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-08-27T07:49:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Full-Stack Observability Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.55634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific <em>browser</em> type or platform, or whether the problem is more widespread. <em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em> Follow these basic steps, and you&#x27;ll quickly be up"
      },
      "id": "604429a9e7b9d2bde7579a04"
    }
  ],
  "/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring": [
    {
      "sections": [
        ".NET agent: compatibility and requirements for .NET Core",
        "Requirements",
        "Microsoft .NET Core version",
        "Target framework version",
        "Important",
        "App/web servers",
        "Operating system",
        "Microsoft Azure",
        "Processor architectures",
        "Permissions",
        "Security requirements",
        "Network requirements",
        "Automatic instrumentation",
        "App frameworks",
        "Datastores",
        "External call libraries",
        "Messaging",
        "Unavailable features",
        "Connect the agent to other New Relic products"
      ],
      "title": ".NET agent: compatibility and requirements for .NET Core",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Getting started"
      ],
      "external_id": "ce9a62a0c6a2d98442118333f39152c38bf9fdda",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core/",
      "published_at": "2021-10-07T08:42:12Z",
      "updated_at": "2021-10-07T08:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent supports both .NET Framework and .NET Core. This document describes compatibility and support for .NET Core applications. See Compatibility and requirements for .NET Framework for .NET Framework applications. New Relic's .NET agent includes built-in instrumentation for some of the most popular parts of the .NET Core ecosystem, including frameworks, databases, and message queuing systems. After installation, the agent runs within the monitored process; there is not a separate process or service created by the agent. For frameworks and libraries that are not automatically instrumented out of the box, you can extend the agent with .NET custom instrumentation. Want to try out our .NET agent? Create a New Relic account for free! No credit card required. Requirements Before you install the New Relic .NET agent on Windows or Linux, make sure your system meets these requirements: Microsoft .NET Core version The .NET agent supports .NET Core versions 2.0, 2.1, 2.2, 3.0, 3.1, and .NET 5.0. Table of minimum agent versions required per .NET Core version .NET Core Version Minimum Required .NET Agent Version .NET Core 2.0 > = 8.19.353.0 .NET Core 2.1 > = 8.19.353.0 .NET Core 2.2 > = 8.19.353.0 .NET Core 3.0 > = 8.21.34.0 .NET Core 3.1 > = 8.21.34.0 .NET 5.0 > = 8.35.0 The agent is not compatible with .NET Core versions 1.0 or 1.1. For .NET Core 2.1 or higher applications with tiered compilation enabled, the agent will disable tiered compilation. .NET Core 2.1 support requires .NET Core runtime 2.1.3 and .NET Core SDK 2.1.401 or higher due to a bug in the .NET Core profiling API. Target framework version The .NET agent only supports applications targeting .NET Core 2.0, 2.1, 2.2, 3.0, 3.1, and NET 5.0. You can find the target framework in your .csproj file: Supported: <TargetFramework>netcoreapp2.0</TargetFramework> Copy <TargetFramework>netcoreapp2.1</TargetFramework> Copy <TargetFramework>netcoreapp2.2</TargetFramework> Copy <TargetFramework>netcoreapp3.0</TargetFramework> Copy <TargetFramework>netcoreapp3.1</TargetFramework> Copy <TargetFramework>net5.0</TargetFramework> Copy Unsupported: <TargetFramework>net452</TargetFramework> Copy Important If you want to monitor an ASP.NET Core application targeting .NET Framework, ensure your install of the .NET agent has .NET Framework support enabled. App/web servers Ensure you use one of these app/web servers: Kestrel Kestrel with IIS reverse proxy via AspNetCoreModule Kestrel with IIS reverse proxy via AspNetCoreModuleV2 Kestrel with Nginx reverse proxy Kestrel with Apache reverse proxy Operating system The agent has been verified to work with the following operating systems: Operating system Supported versions Windows (32- and 64-bit Intel compatible architectures) Server 2008 R2 SP1 Server 2012 Server 2012 R2 Server 2016 Server 2019 Windows containers running on Server 2016 (NanoServer based images are not supported) Linux (64-bit Intel compatible only) All x64 Linux distributions supported by the .NET Core 2.0+/.NET 5 runtime are supported by the .NET agent. For a full list, refer to Microsoft's documentation for the version of the runtime you are using. Microsoft Azure For Azure-specific installation instructions, see: Install on Azure Cloud Services Install on Azure Service Fabric Install on Azure Web Apps Processor architectures The agent is available in both 32-bit (x86) and 64-bit (x64) versions on Windows as well as 64-bit (x64) on Linux. Permissions Installing and running the .NET agent requires these permissions: Component Necessary permissions Install the agent The process or user that installs the agent must have sufficient permissions to set environment variables and write access to the directory where the agent is installed. Run the agent The monitored process must have read/write access to the directory in which you installed the agent. The agent runs as a part of the monitored process and relies on those permissions to function. For applications using IIS via reverse proxy, the group IIS_IUSRS is often used. Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Network requirements The agent requires your firewall to allow outgoing connections to specific networks and ports. Automatic instrumentation If your application is hosted in ASP.NET Core, the agent automatically creates and instruments transactions. The .NET agent will automatically instrument your application after install. If your app is not automatically instrumented, or if you want to add instrumentation, use custom instrumentation. App frameworks The .NET agent automatically instruments these application frameworks: ASP.NET Core MVC 2.0, 2.1, 2.2, 3.0, 3.1, and 5.0 (includes Web API) Datastores The .NET agent automatically instruments the performance of .NET application calls to these datastores: Datastore Instance details Notes Microsoft SQL Server Use System.Data.SqlClient version 4.3.1 or Microsoft.Data.SqlClient. PostgresSQL Use Npgsql 4.0. Prior versions of Npgsql may also be instrumented, but duplicate and/or missing metrics are possible. MongoDB Driver version 2.3.x - 2.13.x: The .NET agent will support instrumenting pre-exising and new API methods in 2.6.x, but not new methods introduced in 2.7.x and higher. MySQL Use MySql.Data version 6.10.4 or later, or use the MySQL Connector StackExchange.Redis The .NET agent does not directly monitor datastore processes. Also, the .NET SQL parameter capture in a query trace does not list parameters for a parameterized query or a stored procedure. Collecting instance details for supported datastores is enabled by default. To request instance-level information from datastores not currently listed, get support at support.newrelic.com. External call libraries The .NET agent automatically instruments these external call libraries : Libraries Supported methods HttpClient The agent instruments these HttpClient methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync Messaging The agent automatically instruments these message systems: RabbitMQ 5.1.0 or higher: Puts and takes on messages and queue purge. When receiving messages using an IBasicConsumer, the EventingBasicConsumer is the only implementation that is instrumented by the .NET agent. BasicGet is instrumented, but the agent does not support distributed tracing for BasicGet. The following methods are instrumented: IModel.BasicGet IModel.BasicPublish IModel.BasicComsume IModel.QueuePurge EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to get this information) Automatic brower monitoring script injection (API or manual instrumentation is required) The .NET agent does not support trim self-contained deployments and executables, because the compiler can potentially trim assemblies that the agent depends on. Infinite Tracing is not supported on Alpine Linux due to a GRPC compatibility issue. See this agent issue for more information. Connect the agent to other New Relic products In addition to APM, the .NET agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The browser monitoring JavaScript agent will not be injected by the .NET agent for ASP.NET core applications. However, you can inject the browser agent by using the .NET agent API or the browser agent's copy/paste method. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see browser monitoring and the .NET agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. Dashboards The .NET agent sends default events and attributes for NRQL queries. You can also record custom events for advanced analysis.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.02353,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " EventingBasicConsumer.HandleBasicDeliver Unavailable features The following features are not available for the .NET agent: Memory usage on Linux due to an ongoing .NET Core issue (try using .NET performance metrics to <em>get</em> this information) Automatic brower <em>monitoring</em> script injection (API or manual instrumentation"
      },
      "id": "603e8e7e196a675c41a83d9f"
    },
    {
      "sections": [
        "Introduction to browser monitoring",
        "More than Real User Monitoring (RUM)",
        "Examine user perceptions",
        "Improve interactive app performance",
        "Correlate front-end and back-end problems",
        "Get started with browser monitoring"
      ],
      "title": "Introduction to browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "4928b2a5981bd2d6263f04b4b882d65adef22779",
      "image": "https://docs.newrelic.com/static/98ad878ffa7b586b779178656f19ec58/c1b63/browser_intro_0.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-08-27T07:49:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your end-user experience depends on your entire technology stack. You need to quickly understand what's causing a customer complaint or issue. Did the problem come from your infrastructure, your application, or the browsers that ultimately render it? Is it the result of a problematic internet provider, a problem in your own data center with failing CPU or memory, or something else? More than Real User Monitoring (RUM) Many websites contain dynamic content that is loaded after the initial page has finished loading, and complex JavaScript code increases the need for error reporting. Browser monitoring in New Relic One provides a Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. With browser monitoring in New Relic One, you see actionable data about your end users' experience with your app. But browser monitoring in New Relic goes far beyond the initial page load to measure full page life cycle data. For example, our browser UI shows you: Actual performance data, such as by page view popularity and user satisfaction (Apdex) scores Perceived performance data that measures how quickly your async or dynamic visuals and interactive page contents display JavaScript error analytics, stack traces, and line-of-code visibility, to show you the end-user steps leading up to an error itself Session performance with a detailed timeline and heat map of the load and interaction events during a webpage's full life cycle AJAX requests indicating problems with timing, end points, and specific locations in the webpage Hash-based route changes in apps with single-page application (SPA) architectures These tools (and more!) help your teams optimize your end users' page load experience, eliminate bugs, and troubleshoot faster across your full stack. Examine user perceptions Real user data gives insights into actual page performance, but you also need to look into your users' perception of your site's performance. Pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser monitoring agent. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. Additional metrics include: First paint, first contentful paint, and largest contentful paint First input delay First interaction This helps you understand how users experience your site, both from visual and responsiveness standpoints. Improve interactive app performance Our single-page app (SPA) monitoring automatically tracks route changes, initial page loads, and synchronous and asynchronous activity during browser interactions. You can also use our browser agent and SPA API to monitor virtually anything that executes inside the browser. If you are a developer, SPA monitoring can help you: Create faster, more responsive, highly interactive apps. Monitor the throughput and performance that real users are experiencing. Troubleshoot and resolve problems within the context of the page load. Query and visualize the data to assist with business decisions. Bring better apps to the marketplace more quickly. Correlate front-end and back-end problems With New Relic One, you can instrument any type of data you need, such as metrics, events, logs, and traces. This helps you find actionable data about your end users' experience across the stack. For example: Full-Stack Observability Comments Locations or domains Limit browser monitoring to focus on specific geographical locations or specific types of end-user activity. You can also monitor or block specific domains. Trends in interactions Use our comparative charting feature for a direct page load time comparison between real user (browser) interactions and trends appearing in Synthetic monitors. Distributed tracing Isolate latency from the web browser through back-end services with distributed tracing. The UI helps you see the connection across across a full transaction, from browser activity, to time spent in network, to back-end activity. Browser types Explore your end users' experience with your app segmented by any types of browsers they use, including: Top browsers by throughput Average page load time by platform type (mobile, desktop, and other) Selected browser type by version (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Get started with browser monitoring Follow these basic steps, and you'll quickly be up and running in New Relic with browser monitoring! Review the compatibility details and basic requirements for browser monitoring. Install the browser agent. Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. View summary data from your Browser summary page, then drill down into page load timing details and other UI data. Configure your alerts for key performance data, or use our Applied Intelligence solutions to reduce alert noise, correlate incidents, and automatically detect anomalies. Query and visualize your default data (or customize your own), then analyze what that data says about your business. Customize and share your own charts and dashboards.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.55634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>browser</em> <em>monitoring</em>",
        "sections": "<em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " (for example, Chrome 31, 32, 33, etc.) This helps you quickly determine whether problems with page load timing may be related to a specific <em>browser</em> type or platform, or whether the problem is more widespread. <em>Get</em> <em>started</em> with <em>browser</em> <em>monitoring</em> Follow these basic steps, and you&#x27;ll quickly be up"
      },
      "id": "604429a9e7b9d2bde7579a04"
    },
    {
      "sections": [
        "Browser Summary page",
        "View the Summary page",
        "Core Web Vitals widgets",
        "User time on the site",
        "Initial page load and route change chart",
        "User-centric page load times chart",
        "Throughput chart",
        "Tip",
        "Front end vs. back end chart",
        "First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL",
        "Related Entities widget",
        "View Synthetics monitors"
      ],
      "title": "Browser Summary page",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "a69bb31a3bff73ef8badce5ce435da62e9e7b644",
      "image": "https://docs.newrelic.com/static/d209fe2eab5c7d2da657e515ab49ae4a/c1b63/browser_summary_page.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/getting-started/browser-summary-page/",
      "published_at": "2021-10-07T17:58:05Z",
      "updated_at": "2021-08-27T06:56:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Summary page summarizes the real-user browser performance of your app. Use the Summary page to: View trends in an app's browser-side performance Quickly troubleshoot page load timing issues Navigate to other browser UI pages View the Summary page To view a summary of browser performance for an app: Go to [one.newrelic.com > Explorer > Browser applications. Use the Explorer to access all your entities, that is, anything we can identify that reports data, from applications and hosts to custom groupings of any elements. Alternatively, go to one.newrelic.com, click Browser, and select an app from the Browser index. From the app's Summary page, use standard New Relic page functions to drill down into detailed information. one.newrelic.com > Browser > (select an app) > Summary: After you select an application from the browser apps index, the Summary page shows a summary of browser performance for that app. The Summary page includes: Core Web Vitals widgets User time on the site Initial page load and route change chart User-centric page load times chart Throughput chart Front end vs. back end chart First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL Related Entities widget View Synthetics monitors Core Web Vitals widgets The Core Web Vitals widgets show how your browser performs according to Google's Core Web Vitals. The Core Web Vitals widgets include: LCP - Largest Contentful Paint FID - First Input Delay CLS - Cumulative Layout Shift User time on the site The User time on the site widget shows the time a user remains on the site. Initial page load and route change chart The Initial page load and route change chart shows the load time of a traditional URL change stemming from a load or reload of a URL. This chart appears with more detail about the page load timing process on the page load time page. User-centric page load times chart The User-centric page load times chart shows the load time of a page for a user. This chart appears with more detail about the page load timing process on the page load time page. Throughput chart The Throughput chart displays browser throughput as pages per minute (ppm). The value in the upper right of the chart is the average value for the selected time range. If you have enabled SPA monitoring enabled and the Summary page shows the SPA load time chart, the Throughput chart will also use SPA data. Tip App server requests per minute (rpm) may show a different measurement than the browser page load timing's pages per minute (ppm). Front end vs. back end chart The Front end vs. back end chart links to the connect APM service application. For details on APM and tracing, see Language agents and distributed tracing. First interaction by device type, First interaction by user agent, JavaScript errors, and Longest first input delay by URL You'll also see summary versions of these metrics from the page load time page and JavaScript errors page: First interaction by device type First interaction by user agent JavaScript errors Longest first input delay by URL Related Entities widget The Related Entities widget shows all the entities that are related to the browser. To understand more about connections between entities, read about Entity relationships. View Synthetics monitors The button directs you to the Synthetics page. To read more about Synthetics, see Synthetic monitoring.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.53828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> Summary page",
        "sections": "<em>Browser</em> Summary page",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s Summary page summarizes the real-user <em>browser</em> performance of your app. Use the Summary page to: View trends in an app&#x27;s <em>browser</em>-side performance Quickly troubleshoot page load timing issues Navigate to other <em>browser</em> UI pages View the Summary page To view a summary of <em>browser</em>"
      },
      "id": "60440d9c196a674ac8960f5b"
    }
  ],
  "/docs/browser/new-relic-browser/guides/guide-using-browser-spa-apis": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.9424,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.64288,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> agent API)",
        "sections": "addToTrace (<em>browser</em> agent API)",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    }
  ],
  "/docs/browser/new-relic-browser/installation/disable-browser-monitoring": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-07T11:16:32Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.22125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Additional <em>installation</em>",
        "body": " Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. <em>Browser</em> <em>monitoring</em> To use <em>browser</em> <em>monitoring</em> when running the Java agent on WebSphere, you must manually enable <em>browser</em> <em>monitoring</em>. WebSphere PMI metrics You can configure the Java agent"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.54836,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.3205,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    }
  ],
  "/docs/browser/new-relic-browser/installation/update-browser-agent": [
    {
      "sections": [
        "IBM WebSphere Application Server"
      ],
      "title": "IBM WebSphere Application Server",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "e3c2ba33d026b8912f7dd2c1d8dfc00d63f25b9c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/ibm-websphere-application-server/",
      "published_at": "2021-10-07T11:16:32Z",
      "updated_at": "2021-10-07T11:16:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This describes how to configure New Relic's Java agent if you are using IBM WebSphere Application Server. For compatible versions, follow New Relic's procedures to install the Java agent on WebSphere. IBM WebSphere App Server Comments Compatible IBM JVM versions New Relic supports all versions of WebSphere that are compatible with the Java agent. However, certain versions of the IBM JVM are incompatible with the Java agent due to known issues in the IBM JVM. New Relic's Java agent is compatible with these major versions of the IBM JVM: 8: All versions Java 2 Security If you are using Java 2 Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. Browser monitoring To use browser monitoring when running the Java agent on WebSphere, you must manually enable browser monitoring. WebSphere PMI metrics You can configure the Java agent to capture additional WebSphere PMI metrics. These metrics will appear on the New Relic JVM metrics page. Instance and display names You can configure the Java agent to change the default behavior of instance names or display names.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.22116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Additional <em>installation</em>",
        "body": " Security and WebSphere, you must grant the Java agent additional permissions before it can execute properly. <em>Browser</em> <em>monitoring</em> To use <em>browser</em> <em>monitoring</em> when running the Java agent on WebSphere, you must manually enable <em>browser</em> <em>monitoring</em>. WebSphere PMI metrics You can configure the Java agent"
      },
      "id": "6043b986e7b9d279085799eb"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.54828,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.32042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/cached-pages": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.7151,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.12143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-07T13:03:40Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.71487,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.12122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-07T13:03:40Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.71466,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.12103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Instrumentation for browser monitoring",
        "Instrumentation to collect browser data",
        "JavaScript placement requirements",
        "Data transmission",
        "Important"
      ],
      "title": "Instrumentation for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "a259fb8312470318f7907a17a9d228a3cf847a36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring/",
      "published_at": "2021-10-07T08:10:00Z",
      "updated_at": "2021-07-10T02:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For standard page load timing, sometimes referred to as real user monitoring (RUM), we measure the overall time to load the entire webpage. Additional monitoring after page load provides details on in-page AJAX calls, JavaScript errors, and other events and interactions. Browser monitoring can leverage the New Relic agent to dynamically inject JavaScript into pages as they are built, in order to collect more detailed back-end timing information. Browser can also monitor apps with single-page application (SPA) architectures. Instrumentation to collect browser data To collect data, browser monitoring uses JavaScript elements pasted or injected into your webpages, typically as part of the HEAD of the page, containing configuration details and essential browser environment instrumentation. Once the page finishes loading, an additional script is downloaded from a CDN server. This additional script processes the collected data and reports it back to New Relic via bam.nr-data.net so that you can see the data in your New Relic account. The script elements can be injected automatically or via the agent API by an APM agent installed in the back-end application, or they can be inserted manually via copy/paste. Both API calls and the copy/paste method allow you to control when and where the script elements are inserted. We use these methods to collect the page load timing information: Method Collecting page load timing information Browsers with Navigation Timing Specification API For browsers that implement the Navigation Timing Specification API, page load timing information is read from the browser and reported to New Relic by the browser agent. The appropriate values simply are read from the webpage's performance timing object to capture the timing information. Navigation start: navigationStart First byte: responseStart DOM ready: DOMContentLoadedEventEnd Page ready: loadEventEnd Browsers without Navigation Timing Specification API For browsers that do not implement the Navigation Timing Specification API, we rely on the NREUM cookie and the browser agent to collect timing information. Additional instrumentation Browser also uses: Instrumentation of the XMLHttpRequest object to collect AJAX timing data. Instrumentation of JavaScript functions to collect uncaught JavaScript errors. Resource Timing API For browsers that implement the Resource Timing API, the browser agent reads and reports session trace details. Single page app (SPA) monitoring For SPA monitoring, we require the Navigation Timing Specification API and the addEventListener API. JavaScript placement requirements Injecting the JavaScript inline in the HEAD is an unusual requirement for a JavaScript library, and different from how third-party scripts are typically included. We require this so that browser provides accurate information without impacting page load performance. The injected browser JavaScript elements wrap many of the browser's built in APIs to record information about JavaScript errors or callback timings. The unusual placement of the code element is necessary for the following reasons: The inline HEAD placement ensures the instrumentation code is loaded before all other scripts so that wrapping will occur when other libraries are registered. Inline code placement also eliminates the network round trips caused by externally referenced scripts. Data transmission For both https and http webpages, we transmit data via https. This summarizes when the data is transmitted to and from the webpage. Important New Relic requires support of the SHA256 hash function, which some older operating systems do not support. If an end user lacks SHA256, the browser agent will not connect to New Relic and data will not be sent. Data transmission Frequency Fetch the agent script Once following page load via https Send page load timing data Once following page load via https Send AJAX and JavaScript error data Once per minute when there is activity via https Send session trace data Every ten seconds when there is activity and a session trace is occurring via https Send SPA data At the end of an interaction via https",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "sections": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "For standard <em>page</em> <em>load</em> <em>timing</em>, sometimes referred to as real user <em>monitoring</em> (RUM), we measure the overall <em>time</em> to <em>load</em> the entire webpage. Additional <em>monitoring</em> after <em>page</em> <em>load</em> provides details on in-<em>page</em> AJAX calls, JavaScript errors, and other events and interactions. <em>Browser</em> <em>monitoring</em> can"
      },
      "id": "6043ef69e7b9d2d7055799f9"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 396.71448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-07T13:03:40Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    },
    {
      "sections": [
        "Instrumentation for browser monitoring",
        "Instrumentation to collect browser data",
        "JavaScript placement requirements",
        "Data transmission",
        "Important"
      ],
      "title": "Instrumentation for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "a259fb8312470318f7907a17a9d228a3cf847a36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring/",
      "published_at": "2021-10-07T08:10:00Z",
      "updated_at": "2021-07-10T02:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For standard page load timing, sometimes referred to as real user monitoring (RUM), we measure the overall time to load the entire webpage. Additional monitoring after page load provides details on in-page AJAX calls, JavaScript errors, and other events and interactions. Browser monitoring can leverage the New Relic agent to dynamically inject JavaScript into pages as they are built, in order to collect more detailed back-end timing information. Browser can also monitor apps with single-page application (SPA) architectures. Instrumentation to collect browser data To collect data, browser monitoring uses JavaScript elements pasted or injected into your webpages, typically as part of the HEAD of the page, containing configuration details and essential browser environment instrumentation. Once the page finishes loading, an additional script is downloaded from a CDN server. This additional script processes the collected data and reports it back to New Relic via bam.nr-data.net so that you can see the data in your New Relic account. The script elements can be injected automatically or via the agent API by an APM agent installed in the back-end application, or they can be inserted manually via copy/paste. Both API calls and the copy/paste method allow you to control when and where the script elements are inserted. We use these methods to collect the page load timing information: Method Collecting page load timing information Browsers with Navigation Timing Specification API For browsers that implement the Navigation Timing Specification API, page load timing information is read from the browser and reported to New Relic by the browser agent. The appropriate values simply are read from the webpage's performance timing object to capture the timing information. Navigation start: navigationStart First byte: responseStart DOM ready: DOMContentLoadedEventEnd Page ready: loadEventEnd Browsers without Navigation Timing Specification API For browsers that do not implement the Navigation Timing Specification API, we rely on the NREUM cookie and the browser agent to collect timing information. Additional instrumentation Browser also uses: Instrumentation of the XMLHttpRequest object to collect AJAX timing data. Instrumentation of JavaScript functions to collect uncaught JavaScript errors. Resource Timing API For browsers that implement the Resource Timing API, the browser agent reads and reports session trace details. Single page app (SPA) monitoring For SPA monitoring, we require the Navigation Timing Specification API and the addEventListener API. JavaScript placement requirements Injecting the JavaScript inline in the HEAD is an unusual requirement for a JavaScript library, and different from how third-party scripts are typically included. We require this so that browser provides accurate information without impacting page load performance. The injected browser JavaScript elements wrap many of the browser's built in APIs to record information about JavaScript errors or callback timings. The unusual placement of the code element is necessary for the following reasons: The inline HEAD placement ensures the instrumentation code is loaded before all other scripts so that wrapping will occur when other libraries are registered. Inline code placement also eliminates the network round trips caused by externally referenced scripts. Data transmission For both https and http webpages, we transmit data via https. This summarizes when the data is transmitted to and from the webpage. Important New Relic requires support of the SHA256 hash function, which some older operating systems do not support. If an end user lacks SHA256, the browser agent will not connect to New Relic and data will not be sent. Data transmission Frequency Fetch the agent script Once following page load via https Send page load timing data Once following page load via https Send AJAX and JavaScript error data Once per minute when there is activity via https Send session trace data Every ten seconds when there is activity and a session trace is occurring via https Send SPA data At the end of an interaction via https",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "sections": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "For standard <em>page</em> <em>load</em> <em>timing</em>, sometimes referred to as real user <em>monitoring</em> (RUM), we measure the overall <em>time</em> to <em>load</em> the entire webpage. Additional <em>monitoring</em> after <em>page</em> <em>load</em> provides details on in-<em>page</em> AJAX calls, JavaScript errors, and other events and interactions. <em>Browser</em> <em>monitoring</em> can"
      },
      "id": "6043ef69e7b9d2d7055799f9"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details": [
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 393.12082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Page</em> <em>load</em> <em>timing</em> process",
        "sections": "<em>Page</em> <em>load</em> <em>time</em> charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document explains: How a web <em>page</em> loads How <em>browser</em> <em>monitoring</em> measures <em>page</em> <em>load</em> <em>timing</em>, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Browser</em> can also <em>monitor</em> asynchronous <em>page</em> <em>load</em> <em>timing</em>. <em>Page</em> <em>load</em> process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-10-07T13:03:40Z",
      "updated_at": "2021-07-10T02:45:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing, the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case the browser agent has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em>, the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example, to the first <em>page</em> on your <em>page</em> <em>load</em> <em>timing</em>-enabled site"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    },
    {
      "sections": [
        "Instrumentation for browser monitoring",
        "Instrumentation to collect browser data",
        "JavaScript placement requirements",
        "Data transmission",
        "Important"
      ],
      "title": "Instrumentation for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "a259fb8312470318f7907a17a9d228a3cf847a36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring/",
      "published_at": "2021-10-07T08:10:00Z",
      "updated_at": "2021-07-10T02:44:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For standard page load timing, sometimes referred to as real user monitoring (RUM), we measure the overall time to load the entire webpage. Additional monitoring after page load provides details on in-page AJAX calls, JavaScript errors, and other events and interactions. Browser monitoring can leverage the New Relic agent to dynamically inject JavaScript into pages as they are built, in order to collect more detailed back-end timing information. Browser can also monitor apps with single-page application (SPA) architectures. Instrumentation to collect browser data To collect data, browser monitoring uses JavaScript elements pasted or injected into your webpages, typically as part of the HEAD of the page, containing configuration details and essential browser environment instrumentation. Once the page finishes loading, an additional script is downloaded from a CDN server. This additional script processes the collected data and reports it back to New Relic via bam.nr-data.net so that you can see the data in your New Relic account. The script elements can be injected automatically or via the agent API by an APM agent installed in the back-end application, or they can be inserted manually via copy/paste. Both API calls and the copy/paste method allow you to control when and where the script elements are inserted. We use these methods to collect the page load timing information: Method Collecting page load timing information Browsers with Navigation Timing Specification API For browsers that implement the Navigation Timing Specification API, page load timing information is read from the browser and reported to New Relic by the browser agent. The appropriate values simply are read from the webpage's performance timing object to capture the timing information. Navigation start: navigationStart First byte: responseStart DOM ready: DOMContentLoadedEventEnd Page ready: loadEventEnd Browsers without Navigation Timing Specification API For browsers that do not implement the Navigation Timing Specification API, we rely on the NREUM cookie and the browser agent to collect timing information. Additional instrumentation Browser also uses: Instrumentation of the XMLHttpRequest object to collect AJAX timing data. Instrumentation of JavaScript functions to collect uncaught JavaScript errors. Resource Timing API For browsers that implement the Resource Timing API, the browser agent reads and reports session trace details. Single page app (SPA) monitoring For SPA monitoring, we require the Navigation Timing Specification API and the addEventListener API. JavaScript placement requirements Injecting the JavaScript inline in the HEAD is an unusual requirement for a JavaScript library, and different from how third-party scripts are typically included. We require this so that browser provides accurate information without impacting page load performance. The injected browser JavaScript elements wrap many of the browser's built in APIs to record information about JavaScript errors or callback timings. The unusual placement of the code element is necessary for the following reasons: The inline HEAD placement ensures the instrumentation code is loaded before all other scripts so that wrapping will occur when other libraries are registered. Inline code placement also eliminates the network round trips caused by externally referenced scripts. Data transmission For both https and http webpages, we transmit data via https. This summarizes when the data is transmitted to and from the webpage. Important New Relic requires support of the SHA256 hash function, which some older operating systems do not support. If an end user lacks SHA256, the browser agent will not connect to New Relic and data will not be sent. Data transmission Frequency Fetch the agent script Once following page load via https Send page load timing data Once following page load via https Send AJAX and JavaScript error data Once per minute when there is activity via https Send session trace data Every ten seconds when there is activity and a session trace is occurring via https Send SPA data At the end of an interaction via https",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.23041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "sections": "Instrumentation for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "For standard <em>page</em> <em>load</em> <em>timing</em>, sometimes referred to as real user <em>monitoring</em> (RUM), we measure the overall <em>time</em> to <em>load</em> the entire webpage. Additional <em>monitoring</em> after <em>page</em> <em>load</em> provides details on in-<em>page</em> AJAX calls, JavaScript errors, and other events and interactions. <em>Browser</em> <em>monitoring</em> can"
      },
      "id": "6043ef69e7b9d2d7055799f9"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact": [
    {
      "sections": [
        "Security for browser monitoring",
        "Reported data",
        "Page view data",
        "AJAX timing data",
        "JavaScript error data",
        "Session trace data",
        "SPA data",
        "URL query strings",
        "Visitor's IP address",
        "Browser types",
        "CDN access",
        "Important",
        "Cookies",
        "JSONP requests"
      ],
      "title": "Security for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "99cd4023fc519082ebe94082e3a6affd1cc2344f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring/",
      "published_at": "2021-10-07T02:02:05Z",
      "updated_at": "2021-07-09T23:05:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring provides insights into how your application or site behaves when it is loaded in a web browser. Browser only records performance data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do so. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Reported data Browser reports many different types of data to help you analyze your website's performance. It only reports page view data, unless you have subscribed to Pro features. You can also enable functionality for AJAX requests, JavaScript errors, and session traces. For most data types, browser transmits the data securely using HTTPS encryption. The browser agent transmits data to New Relic's collectors by using either of the domains bam.nr-data.net or bam-cell.nr-data.net. Here is a summary of the types of data reported by browser monitoring. Page view data This data is reported once per page view and consists of: Page load timing data Name of the server-side app controller that served the page, if available (obfuscated in the page and during transmission) Additional custom parameters set by the server-side app controller, if available (obfuscated in the page and during transmission) Additional custom parameters set by the browser agent API, if set prior to page load This information appears on the Page views page. For data security reasons, browser does not record or collect URL query strings. Server-side data can only be collected when the host is also instrumented by New Relic and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. AJAX timing data When enabled, browser periodically reports AJAX timing data until the user navigates away from or closes the page. (New Relic automatically filters out all AJAX requests that take longer than two minutes.) Data includes: Hostnames, ports, and paths (but not search/query parameters) of AJAX request URLs HTTP status code of responses Byte size of request message bodies Name of the server-side app controller servicing the AJAX request and server-side timing data (obfuscated in the page and during transmission), when the browser instrumentation is injected by the New Relic agent Timing data for the AJAX transaction Timing data for the AJAX callbacks This information appears on the AJAX page. JavaScript error data When enabled, browser periodically reports data about every error that occurs on the page until the user navigates away from or closes the page. This information appears on the JavaScript errors page. For each error, the data includes: Exception class of the error Error message containing arbitrary text Stack trace of the error, which may contain function names and URLs of scripts causing the error Error messages typically do not contain any confidential or sensitive information. However, it is possible for messages to be purposefully constructed with sensitive information. Before enabling JavaScript error reporting, ensure that your website does not expose any sensitive information in error messages. Session trace data When enabled, browser periodically reports data on the details of the a single page's life cycle, including user interactions, AJAX loads, and JavaScript errors, until the user navigates away from or closes the page. New Relic automatically stops recording further data after ten minutes. Data includes: Asset load timing details User interactions such as scrolling, mousing, and clicking JavaScript error timing and other JavaScript error information Triggered Javascript events Session traces are captured randomly at a fixed rate from among the monitored page views. Session trace information appears on the Session traces page. SPA data If you use browser's single-page app (SPA) monitoring, New Relic reports the following data once per page load or route change. Browser data for page views, AJAX timing, JavaScript errors, and session traces Hash fragments associated with SPA route changes Additional custom parameters added from the SPA API When SPA monitoring has been enabled, this information appears on the Page views page. Server-side data can only be collected when the host is also instrumented by New Relic, and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. URL query strings The browser agent uses the HTTP referer attribute to track page URLs. URLs can sometimes contain potentially sensitive user-entered query data (for example, a user's name). For data security reasons, browser does not record or collect URL query strings. Visitor's IP address Browser uses the visitor's IP address to enrich data for additional visitor segmentation. Details such as the ASN and geoID are mapped to browser data from the IP address. For data security reasons, browser does not retain the visitor's IP address for reporting. The IP address is obtained in the HTTP header from the request to the New Relic collector. New Relic does not retain the visitor's IP address after the attributes have been mapped. The IP address value is overwritten within 24 hours of data being collected. Browser types Browser determines the browser type from the User-Agent header and the geographical location based on the browser's IP address. New Relic does not retain the IP address, only the country and region associated with the performance data. This information appears on the selected app's Geography page. Also, details about specific browser types appear on the selected app's Browsers page. CDN access Page load timing requires access to the content delivery network (CDN), where New Relic's utility JavaScript file (nr.js) is hosted. The domain name for the file (js-agent.newrelic.com) remains static, but the number in the path (version) may change periodically. A script tag is injected by the New Relic agent (or pasted into the webpage for standalone apps) that references the JavaScript on the CDN, which is then loaded by the browser. The loaded JavaScript collects and reports the metrics dynamically to either of the domains bam.nr-data.net or bam-cell.nr-data.net. Important If your end users are behind a firewall or proxy and do not have access to the CDN or to New Relic's networks (including bam.nr-data.net and bam-cell.nr-data.net), browser monitoring will not work. Cookies Browser monitoring creates cookies in the end user's browser. If the user has cookies disabled, page load timing (sometimes referred to as real user monitoring or RUM) will not be able to track sessions properly. Also, if the user has an older browser that does not support the Navigation Timing Specification API, page load timing will not be able to track response times as accurately. New Relic's cookies generated by browser agents older than version 995 may not contain the secure attribute. This is because page load timing data transmission in versions before version 995 use HTTP when the page is HTTP, but use HTTPS when the page is HTTPS. All browser agent versions above version 995 will always use the secure flag for cookies and transmit over HTTPS. JavaScript and AJAX data may contain more sensitive information, so they are always transmitted over HTTPS. Transmission of these cookies using HTTP or access to them from JavaScript is not a significant security risk, because the cookies are not used to make security decisions or allow access to an account. They are used only to collect performance data, with any identifiable data obfuscated. For customers subject to special guidelines for cookie collection, such as those under the EU GDPR/PECR ICO Guidelines, we now provide the option to disable cookie collection for your application. Please see our browser agent v1169 release notes for more information. Important If your site uses P3P, it must be configured to allow these cookies. JSONP requests Page load timing metrics are reported to New Relic using a Script GET, also known as a JSONP request. The Script GET returns a value that is subsequently stored in a cookie and used to trigger trace capturing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.87999,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>browser</em> <em>monitoring</em>",
        "sections": "Security for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> provides insights into how your application or site behaves when it is loaded in a web <em>browser</em>. <em>Browser</em> only records <em>performance</em> data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do"
      },
      "id": "6043efdf64441f772e378f12"
    },
    {
      "sections": [
        "Browser monitoring and search engine optimization",
        "Contents",
        "Efficiency of inline JavaScript",
        "Impact on SEO"
      ],
      "title": "Browser monitoring and search engine optimization",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "1f3f91b4e13af6b49f484d7ba08f338e7f4344f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization/",
      "published_at": "2021-10-07T18:01:46Z",
      "updated_at": "2021-07-09T23:05:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring places a small \"loader\" script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end performance, accurately time how long it takes for pages to load in all browsers, and to report details for JavaScript errors and AJAX calls. Have minimal impact on overall page load time and search engine optimization (SEO), including search engine ranking, indexing, crawl efficiency, or other SEO-related concerns. Contents Efficiency of inline JavaScript The most effective method for browser monitoring is to include a minimal amount of JavaScript instrumentation code inline in the head of the monitored page. This code then retrieves the remainder of the necessary code after the page finishes loading. Other browser monitoring methods include JavaScript code at the end of the page body or exclusively using an external script. However, these methods can limit visibility into the end users' experience. Impact on SEO Performance testing results indicate that using browser monitoring's JavaScript has a negligible effect on page load time. In addition, it has no negative impact on how users or search engines interact with your site. Google's consistent recommendation to website owners is to build a site that is valuable to users and accessible to search engine crawlers. Google rankings favor sites that provide the most relevant information and the best user experience. Browser monitoring can help you improve user experience by identifying performance bottlenecks, including: Slow page loads Problematic JavaScript errors Long AJAX calls Identifying Javascript errors is especially helpful because Google's bots are increasingly running the JavaScript code on websites they crawl in order to access content provided by AJAX-heavy web applications. A JavaScript error that previously was only visible to human users (for example, a broken button) could affect whether the Google bots can successfully interact with your site. We understand that SEO and traffic referred by search engines are critically important to many businesses. When used effectively, browser monitoring can even increase a site's ranking in Google and other search engines by improving performance and user experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.87999,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "sections": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> places a small &quot;loader&quot; script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end <em>performance</em>, accurately time how long it takes for pages to load in all browsers, and to report"
      },
      "id": "6043fa33196a675d7b960f85"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.2669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization": [
    {
      "sections": [
        "Browser monitoring and performance impact",
        "Contents",
        "Overall impact",
        "Network impact",
        "For more help"
      ],
      "title": "Browser monitoring and performance impact",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "5504ef3846f4bcdae0ff4f58e8c745079d9a5cb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact/",
      "published_at": "2021-10-07T18:00:54Z",
      "updated_at": "2021-07-09T23:38:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JavaScript snippet introduces a nearly invisible impact on website performance and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins monitoring for errors and events as the rest of the webpage executes. The negligible amount of overhead required to load the JavaScript results in a significant return of actionable data. Contents Overall impact The JavaScript's overhead takes into consideration both the impact on the user and the impact on your systems' performance: User perception: Typically users cannot detect performance degradations on a website of less than 200ms. Browser's JavaScript adds less than 15ms in aggregated time per page load. This is split up over time, so at no point would a user be able to perceive any performance impact due to the JavaScript. Webserver and systems: Browser app monitoring occurs on the user's browser, not on the server. Processing time does not have an impact on your CPU consumption. In addition, we take additional steps to minimize any potential impact on the apps and webpages being monitored. For example, the \"loader\" script is loaded synchronously in the <HEAD> in order to ensure monitoring is enabled for the entire life cycle of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The \"loader\" comes with the initial page load. Later in the life cycle of the page, New Relic loads an additional monitoring script asynchronously. This script should not have any perceivable effect to the user and is included in the overall overhead of less than 15ms per page. Network impact Browser monitoring also minimizes network traffic for the end user by aggregating data locally (in the client) and sending it back to New Relic on load, at periodic intervals, on unload, or when data has been collected. (During the browser session's idle periods, transmissions may not be required.) For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Browser monitoring and search engine optimization (how browser ensures that the JavaScript has a negligible impact on SEO)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.88412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "sections": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s JavaScript snippet introduces a nearly invisible impact on website <em>performance</em> and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins <em>monitoring</em> for errors"
      },
      "id": "603ec318196a67a757a83dd1"
    },
    {
      "sections": [
        "Security for browser monitoring",
        "Reported data",
        "Page view data",
        "AJAX timing data",
        "JavaScript error data",
        "Session trace data",
        "SPA data",
        "URL query strings",
        "Visitor's IP address",
        "Browser types",
        "CDN access",
        "Important",
        "Cookies",
        "JSONP requests"
      ],
      "title": "Security for browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "99cd4023fc519082ebe94082e3a6affd1cc2344f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring/",
      "published_at": "2021-10-07T02:02:05Z",
      "updated_at": "2021-07-09T23:05:15Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring provides insights into how your application or site behaves when it is loaded in a web browser. Browser only records performance data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do so. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Reported data Browser reports many different types of data to help you analyze your website's performance. It only reports page view data, unless you have subscribed to Pro features. You can also enable functionality for AJAX requests, JavaScript errors, and session traces. For most data types, browser transmits the data securely using HTTPS encryption. The browser agent transmits data to New Relic's collectors by using either of the domains bam.nr-data.net or bam-cell.nr-data.net. Here is a summary of the types of data reported by browser monitoring. Page view data This data is reported once per page view and consists of: Page load timing data Name of the server-side app controller that served the page, if available (obfuscated in the page and during transmission) Additional custom parameters set by the server-side app controller, if available (obfuscated in the page and during transmission) Additional custom parameters set by the browser agent API, if set prior to page load This information appears on the Page views page. For data security reasons, browser does not record or collect URL query strings. Server-side data can only be collected when the host is also instrumented by New Relic and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. AJAX timing data When enabled, browser periodically reports AJAX timing data until the user navigates away from or closes the page. (New Relic automatically filters out all AJAX requests that take longer than two minutes.) Data includes: Hostnames, ports, and paths (but not search/query parameters) of AJAX request URLs HTTP status code of responses Byte size of request message bodies Name of the server-side app controller servicing the AJAX request and server-side timing data (obfuscated in the page and during transmission), when the browser instrumentation is injected by the New Relic agent Timing data for the AJAX transaction Timing data for the AJAX callbacks This information appears on the AJAX page. JavaScript error data When enabled, browser periodically reports data about every error that occurs on the page until the user navigates away from or closes the page. This information appears on the JavaScript errors page. For each error, the data includes: Exception class of the error Error message containing arbitrary text Stack trace of the error, which may contain function names and URLs of scripts causing the error Error messages typically do not contain any confidential or sensitive information. However, it is possible for messages to be purposefully constructed with sensitive information. Before enabling JavaScript error reporting, ensure that your website does not expose any sensitive information in error messages. Session trace data When enabled, browser periodically reports data on the details of the a single page's life cycle, including user interactions, AJAX loads, and JavaScript errors, until the user navigates away from or closes the page. New Relic automatically stops recording further data after ten minutes. Data includes: Asset load timing details User interactions such as scrolling, mousing, and clicking JavaScript error timing and other JavaScript error information Triggered Javascript events Session traces are captured randomly at a fixed rate from among the monitored page views. Session trace information appears on the Session traces page. SPA data If you use browser's single-page app (SPA) monitoring, New Relic reports the following data once per page load or route change. Browser data for page views, AJAX timing, JavaScript errors, and session traces Hash fragments associated with SPA route changes Additional custom parameters added from the SPA API When SPA monitoring has been enabled, this information appears on the Page views page. Server-side data can only be collected when the host is also instrumented by New Relic, and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. URL query strings The browser agent uses the HTTP referer attribute to track page URLs. URLs can sometimes contain potentially sensitive user-entered query data (for example, a user's name). For data security reasons, browser does not record or collect URL query strings. Visitor's IP address Browser uses the visitor's IP address to enrich data for additional visitor segmentation. Details such as the ASN and geoID are mapped to browser data from the IP address. For data security reasons, browser does not retain the visitor's IP address for reporting. The IP address is obtained in the HTTP header from the request to the New Relic collector. New Relic does not retain the visitor's IP address after the attributes have been mapped. The IP address value is overwritten within 24 hours of data being collected. Browser types Browser determines the browser type from the User-Agent header and the geographical location based on the browser's IP address. New Relic does not retain the IP address, only the country and region associated with the performance data. This information appears on the selected app's Geography page. Also, details about specific browser types appear on the selected app's Browsers page. CDN access Page load timing requires access to the content delivery network (CDN), where New Relic's utility JavaScript file (nr.js) is hosted. The domain name for the file (js-agent.newrelic.com) remains static, but the number in the path (version) may change periodically. A script tag is injected by the New Relic agent (or pasted into the webpage for standalone apps) that references the JavaScript on the CDN, which is then loaded by the browser. The loaded JavaScript collects and reports the metrics dynamically to either of the domains bam.nr-data.net or bam-cell.nr-data.net. Important If your end users are behind a firewall or proxy and do not have access to the CDN or to New Relic's networks (including bam.nr-data.net and bam-cell.nr-data.net), browser monitoring will not work. Cookies Browser monitoring creates cookies in the end user's browser. If the user has cookies disabled, page load timing (sometimes referred to as real user monitoring or RUM) will not be able to track sessions properly. Also, if the user has an older browser that does not support the Navigation Timing Specification API, page load timing will not be able to track response times as accurately. New Relic's cookies generated by browser agents older than version 995 may not contain the secure attribute. This is because page load timing data transmission in versions before version 995 use HTTP when the page is HTTP, but use HTTPS when the page is HTTPS. All browser agent versions above version 995 will always use the secure flag for cookies and transmit over HTTPS. JavaScript and AJAX data may contain more sensitive information, so they are always transmitted over HTTPS. Transmission of these cookies using HTTP or access to them from JavaScript is not a significant security risk, because the cookies are not used to make security decisions or allow access to an account. They are used only to collect performance data, with any identifiable data obfuscated. For customers subject to special guidelines for cookie collection, such as those under the EU GDPR/PECR ICO Guidelines, we now provide the option to disable cookie collection for your application. Please see our browser agent v1169 release notes for more information. Important If your site uses P3P, it must be configured to allow these cookies. JSONP requests Page load timing metrics are reported to New Relic using a Script GET, also known as a JSONP request. The Script GET returns a value that is subsequently stored in a cookie and used to trigger trace capturing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.87999,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>browser</em> <em>monitoring</em>",
        "sections": "Security for <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> provides insights into how your application or site behaves when it is loaded in a web <em>browser</em>. <em>Browser</em> only records <em>performance</em> data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do"
      },
      "id": "6043efdf64441f772e378f12"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring": [
    {
      "sections": [
        "Browser monitoring and performance impact",
        "Contents",
        "Overall impact",
        "Network impact",
        "For more help"
      ],
      "title": "Browser monitoring and performance impact",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "5504ef3846f4bcdae0ff4f58e8c745079d9a5cb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact/",
      "published_at": "2021-10-07T18:00:54Z",
      "updated_at": "2021-07-09T23:38:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JavaScript snippet introduces a nearly invisible impact on website performance and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins monitoring for errors and events as the rest of the webpage executes. The negligible amount of overhead required to load the JavaScript results in a significant return of actionable data. Contents Overall impact The JavaScript's overhead takes into consideration both the impact on the user and the impact on your systems' performance: User perception: Typically users cannot detect performance degradations on a website of less than 200ms. Browser's JavaScript adds less than 15ms in aggregated time per page load. This is split up over time, so at no point would a user be able to perceive any performance impact due to the JavaScript. Webserver and systems: Browser app monitoring occurs on the user's browser, not on the server. Processing time does not have an impact on your CPU consumption. In addition, we take additional steps to minimize any potential impact on the apps and webpages being monitored. For example, the \"loader\" script is loaded synchronously in the <HEAD> in order to ensure monitoring is enabled for the entire life cycle of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The \"loader\" comes with the initial page load. Later in the life cycle of the page, New Relic loads an additional monitoring script asynchronously. This script should not have any perceivable effect to the user and is included in the overall overhead of less than 15ms per page. Network impact Browser monitoring also minimizes network traffic for the end user by aggregating data locally (in the client) and sending it back to New Relic on load, at periodic intervals, on unload, or when data has been collected. (During the browser session's idle periods, transmissions may not be required.) For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Browser monitoring and search engine optimization (how browser ensures that the JavaScript has a negligible impact on SEO)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.88412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "sections": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s JavaScript snippet introduces a nearly invisible impact on website <em>performance</em> and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins <em>monitoring</em> for errors"
      },
      "id": "603ec318196a67a757a83dd1"
    },
    {
      "sections": [
        "Browser monitoring and search engine optimization",
        "Contents",
        "Efficiency of inline JavaScript",
        "Impact on SEO"
      ],
      "title": "Browser monitoring and search engine optimization",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "1f3f91b4e13af6b49f484d7ba08f338e7f4344f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization/",
      "published_at": "2021-10-07T18:01:46Z",
      "updated_at": "2021-07-09T23:05:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring places a small \"loader\" script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end performance, accurately time how long it takes for pages to load in all browsers, and to report details for JavaScript errors and AJAX calls. Have minimal impact on overall page load time and search engine optimization (SEO), including search engine ranking, indexing, crawl efficiency, or other SEO-related concerns. Contents Efficiency of inline JavaScript The most effective method for browser monitoring is to include a minimal amount of JavaScript instrumentation code inline in the head of the monitored page. This code then retrieves the remainder of the necessary code after the page finishes loading. Other browser monitoring methods include JavaScript code at the end of the page body or exclusively using an external script. However, these methods can limit visibility into the end users' experience. Impact on SEO Performance testing results indicate that using browser monitoring's JavaScript has a negligible effect on page load time. In addition, it has no negative impact on how users or search engines interact with your site. Google's consistent recommendation to website owners is to build a site that is valuable to users and accessible to search engine crawlers. Google rankings favor sites that provide the most relevant information and the best user experience. Browser monitoring can help you improve user experience by identifying performance bottlenecks, including: Slow page loads Problematic JavaScript errors Long AJAX calls Identifying Javascript errors is especially helpful because Google's bots are increasingly running the JavaScript code on websites they crawl in order to access content provided by AJAX-heavy web applications. A JavaScript error that previously was only visible to human users (for example, a broken button) could affect whether the Google bots can successfully interact with your site. We understand that SEO and traffic referred by search engines are critically important to many businesses. When used effectively, browser monitoring can even increase a site's ranking in Google and other search engines by improving performance and user experience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.87997,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "sections": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> places a small &quot;loader&quot; script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end <em>performance</em>, accurately time how long it takes for pages to load in all browsers, and to report"
      },
      "id": "6043fa33196a675d7b960f85"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26675,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/ajax-call-fails-cors-redirect-error-message": [
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.84366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.64255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> agent API)",
        "sections": "addToTrace (<em>browser</em> agent API)",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/angularjs-errors-do-not-appear": [
    {
      "sections": [
        "Page load timing process",
        "Tip",
        "Page load process",
        "Page load time charts in browser monitoring",
        "Web application",
        "Network",
        "Important",
        "DOM processing",
        "Page rendering",
        "Request queuing",
        "App server requests vs. browser transactions",
        "Outliers"
      ],
      "title": "Page load timing process",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "3c1b807e4433968a69a461a95e612812ff0ff8e9",
      "image": "https://docs.newrelic.com/static/ade867510b645a97e56c905e4cf019f9/8c557/browser-page-load-timeline.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process/",
      "published_at": "2021-10-07T03:03:32Z",
      "updated_at": "2021-10-07T03:03:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains: How a web page loads How browser monitoring measures page load timing, also known as real user monitoring (RUM) Tip This is a description of traditional, synchronous page load timing. Browser can also monitor asynchronous page load timing. Page load process Here are the major steps in the loading of most web pages. The numbers 1-6 in the diagram correspond to the numbered steps below. Page load timeline: The steps involved in a web page load. Browser monitoring charts display the following segments of that process: Network, Web application, DOM processing, and Page rendering. A page load begins when a user selects a hyperlink, submits a form, or types a URL in a browser. This is also referred to as the initial request or the navigation start. The user's action sends a request across the network to the web application server. The request reaches the application for processing. (The request may take some time to start being processed. This could be the result of request queuing or it could be other factors.) The app finishes processing and sends an HTML response back across the network to the user's browser. This is sometimes referred to as response start or first byte. (Time To First Byte) The user's browser begins receiving the HTML response, and starts to process the Document Object Model, or DOM. The DOM finishes loading; this point is known as DOM ready. Using the DOM, the user's browser starts to render the page. The page finishes rendering in the user's browser and the window load event fires. (For pages that use asynchronous loading, some elements may continue to load after the window load event occurs.) Page load time charts in browser monitoring Browser monitoring captures the major page load timing segments in the browser Summary page and the Page views page. If you have SPA monitoring enabled, you will have access to both this chart and SPA-specific charts. The charts show: Network Web application time DOM processing Page rendering Other segments as applicable, such as request queuing The chart colors match the colors in the page load timing diagram. one.newrelic.com > Browser > (select an app) > Summary: The load time chart appears on the Summary and Page views page. The way browser collects these times depends on the browser's capability to use the Navigation Timing Specification API. You can add custom page load timing events with the browser agent API. Here are descriptions of the activity included in the browser load time chart segments: Web application The web application time includes the time spent on the application server. This can only be determined if the browser instrumentation for page load timing was provided by an APM agent. Network The Network layer includes time spent in redirects as well as in requesting and receiving HTML. It does not include time on the server or for static assets. Network time measurement starts from the initial click on a link. Network time includes DNS and may include more than one lookup if you have redirects on your site, TCP (including the firewall, unless you have configured request queue time monitoring), and SSL connect time. If you have configured request queue time monitoring, then the network time does not include any of the request queue time that occurs after the X-Request header. If you have not configured request queue time monitoring, then the network time does include all of the request queue time. The Navigation Timing Specification API provides a detailed breakdown of network time. (For old browsers, the timer starts on the \"before unload event.\") For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. This is because browser relies on the server-side agent to pass the application values to the browser agent through auto-injection. For more information about how this back-end time breaks down from the browser's point of view, use the Session traces page. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser is spending time on DNS lookups and other network events. Important Even with request queuing configured, the front-end server's setup can still affect network time. This is because the front-end server does not add the queueing time header until after it actually accepts and processes the request. If the front-end server is configured in some way that causes requests to start backlogging and to queue up in the listener socket that the front-end server uses to accept connections, then you will see network time increase for browser monitoring. The queueing time headers can never account for backlog in this listener socket. DOM processing DOM processing is the time it takes to parse the HTML into a DOM and retrieve or execute synchronous scripts. If the browser starts to download images in this phase, page load timing will capture the image load time. The DOM processing and page rendering layers include network time for static assets (assets that are not explicitly retrieved after page load). However, if a script on the page dynamically inserts image tags and loads images after the server or content delivery system (CDN) finishes, page load timing cannot capture the image load time. Page rendering The Page rendering phase is the time between the DOM being complete and the window load event. This phase measures browser-side processing of the page content, and often includes time for scripts and static assets to load. Request queuing Request queuing will be displayed in the load time chart if your account has both browser and APM linked. In New Relic, request queuing refers to the time between a request entering your production systems and it reaching your application. Depending on the specifics of your production infrastructure, this time may include an actual queue that requests enter, or it may represent other functions that take time (such as load balancing or internal network latency). App server requests vs. browser transactions Often the number of app server transactions (requests per minute or rpm) is larger than the number of browser transactions (pages per minute or ppm) for the same application. For more information, see the troubleshooting procedures. Outliers No matter how well your application performs, there will be some slow browsers, platforms, and networks that make your overall aggregate response times appear slower. To minimize the skew caused by outliers, page load timing clamps and scales the end user response times that are greater than 4.5 times your application's browser Apdex T setting to 4.5 times the Apdex T, or to 13.5 seconds, whichever is greater. (Histogram outliers are cut off at 95%.) For example, if your application's end user Apdex T threshold is 8 seconds, those response times will be clamped at 36 seconds. This minimizes the impact of these response times on your overall application but still provides accounting for \"frustrated\" Apdex scores. For SPA monitoring, outliers are handled differently. When the duration of an initial page load or route change reaches 30 minutes, that event is treated as invalid data and is discarded.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.84366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page load time charts in <em>browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "This document explains: How a web page loads How <em>browser</em> <em>monitoring</em> measures page load timing, also known as real user <em>monitoring</em> (RUM) Tip This is a description of traditional, synchronous page load timing. <em>Browser</em> can also <em>monitor</em> asynchronous page load timing. Page load process Here"
      },
      "id": "6043efdf28ccbc21ff2c60a2"
    },
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "CumulativeLayoutShift",
        "How is CLS captured in New Relic",
        "Approximating other CLS sources",
        "How CLS is aggregated",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-10-07T07:56:00Z",
      "updated_at": "2021-10-07T07:55:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals As of agent version 1177 for browser monitoring, we have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experience: loading, interactivity, and visual stability. This includes the following metrics and their respective thresholds: Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of these metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint The largestContentfulPaint,metric is available with agent version 1163 or higher. It reports the render time of the largest content element visible in the viewport. Google's research found that looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. For more information about this metric, including limitations and considerations, see the w3c draft. We also report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good,\" between 2.5-4.0 secs are considered \"Needs Improvement,\" and above 4.0 secs are considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics. It measures the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. We also report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good,\" between 100-300 ms are considered \"Needs Improvement,\" and above 300 ms are considered \"Poor.\" For a more detailed explanation, see our browser monitoring release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS) is available with agent v1177 or higher. CLS is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shifts. A low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good,\" between 0.1-0.25 are considered \"Needs Improvement,\" and above 0.25 are considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177 or higher, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. For supporting documentation and browser compatibility for the pageHide event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event is available with agent v1177 or higher. This is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. For supporting documentation and browser compatibility for the windowLoad event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event is available with agent v1163 or higher. This is fired when a document or child resource is being unloaded. For supporting documentation and browser compatibility for the windowUnload event, see the MDN Web Docs site. We also report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements Requirements: Meets install requirements. Reporting of this event requires browser agent version 1153 or higher and a Pro or Pro+SPA agent. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. CumulativeLayoutShift Cumulative Layout Shift (CLS) is a metric measuring the stability of the content on a webpage. For a complete description, see web.dev/cls. How is CLS captured in New Relic Shifts in page layout as reported by the Layout Instability API are aggregated throughout the life of the page and reported as an attribute on all PageViewTiming events, representing the CLS value when that event occurred. Using this model, users can look at their CLS value at different points in the page's life; for example, CLS values up until the first-time users interact with the page or hide the page. Approximating other CLS sources Lighthouse captures CLS value only up to the time when a page is loaded, which is useful in a development or lab environment. You can approximate Lighthouse values by looking at the windowLoad PageViewTiming event. CrUX report uses values captured over the lifespan of the page, which is useful to analyze worst-case shifts in a RUM environment. You can approximate CrUX values by looking at the CLS attribute on the windowUnload PageViewTiming event. These values will not be exactly the same because of different sample sets and a difference in how values from long-lived web pages are included. The New Relic browser monitoring agent captures CLS when the page unloads, while CrUX collects and updates the metric throughout the lifespan of the page. How CLS is aggregated As of July 2021, Google has updated the way CLS values are aggregated. Browser monitoring agent versions v12xx use the method described in Evolving the CLS metric. Browser monitoring agent v12xx or higher: Layout shift values are captured in windows. Layout shifts that occurred within 1 second of each other, but no more than 5 seconds between the first and last shift, are part of the same window. A CLS score represents the sum of layout shift values from the window with the highest sum of layout shift values. Prior to Browser agent v12xx: A CLS score represents the sum of all layout shifts that occurred up until that point in the page's life. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.26668,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "addToTrace (browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples"
      ],
      "title": "addToTrace (browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "cfc07079342fec5115dbc68cff1d4a40a66f9836",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api/",
      "published_at": "2021-10-07T13:21:20Z",
      "updated_at": "2021-10-01T23:08:02Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within browser session traces can provide context for other user actions, errors, and default events within the trace. This event will appear in the browser session trace details. If a session trace currently is in progress, this adds an object with a user-defined name, start time, and other optional fields. If you make this call and a session trace is not already in progress, this will not cause browser to capture a trace. Note that the number of events shared this way is limited by the Browser agent harvest cycle. Here is the last update on that limit. Parameters Parameter Description $custom_object JavaScript object Required. Supply a JavaScript object with these required and optional name/value pairs: Required name/value pairs: NAME, START Optional name/value pairs: END, ORIGIN, TYPE If you are sending the same event object to New Relic One as a PageAction, omit the TYPE attribute. (TYPE is a string to describe what type of event you are marking inside of a session trace.) If included, it will override the event type and cause the PageAction event to be sent incorrectly. Instead, use the NAME attribute for event information. Examples var obj = { // REQUIRED name: 'Event Name', start: 1417044274239, // Time in ms since epoch // OPTIONAL end: 1417044274252, // Time in ms since epoch. Defaults to same as start resulting in trace object with a duration of zero. origin: 'Origin of event', // Defaults to empty string type: 'What type of event was this' // Defaults to empty string } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.64255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addToTrace (<em>browser</em> agent API)",
        "sections": "addToTrace (<em>browser</em> agent API)",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Syntax newrelic.addToTrace(JavaScript object $custom_object) Copy Adds a JavaScript object with a custom name, start time, etc. to an in-progress session trace. Requirements Agent version nr-593 or higher. Description Custom events within <em>browser</em> session traces can provide context for other user"
      },
      "id": "6043faae196a6774ac960f30"
    }
  ]
}