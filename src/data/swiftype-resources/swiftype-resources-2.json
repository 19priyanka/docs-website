{
  "/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/troubleshooting/missing-alert-notifications": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.1839,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.47717,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.14328,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/troubleshooting/tag-information-not-showing-entity-infra-alert-condition": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18369,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.47699,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.14319,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/provide-runbook-instructions-alert-activity": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.8125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.79272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure <em>conditions</em> only. You can find available entity-related tags by going to the <em>New</em> <em>Relic</em> Explorer and looking under a service&#x27;s Metadata and tags, or by viewing violation details. Here&#x27;s an example of using tags"
      },
      "id": "6130be2e28ccbc115f56a814"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18369,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " are <em>applied</em> at the end of the default <em>alert</em> lifecycle in order to suppress, or mute, notifications. They don&#x27;t disable existing policies or <em>conditions</em>. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations"
      },
      "id": "60440c4728ccbc9c612c60c7"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/streaming-alerts-key-terms-concepts": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.46378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/view-entity-health-status-find-entities-without-alert-conditions": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.8122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.7926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure <em>conditions</em> only. You can find available entity-related tags by going to the <em>New</em> <em>Relic</em> Explorer and looking under a service&#x27;s Metadata and tags, or by viewing violation details. Here&#x27;s an example of using tags"
      },
      "id": "6130be2e28ccbc115f56a814"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.1835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " are <em>applied</em> at the end of the default <em>alert</em> lifecycle in order to suppress, or mute, notifications. They don&#x27;t disable existing policies or <em>conditions</em>. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations"
      },
      "id": "60440c4728ccbc9c612c60c7"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/understand-technical-concepts/violation-event-attributes": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View muted <em>violations</em> <em>and</em> incidents",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those <em>violations</em>. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.47662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.26483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom <em>violation</em> descriptions",
        "sections": "<em>Alert</em> custom <em>violation</em> descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-alert-conditions": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.81195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.79248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure <em>conditions</em> only. You can find available entity-related tags by going to the <em>New</em> <em>Relic</em> Explorer and looking under a service&#x27;s Metadata and tags, or by viewing violation details. Here&#x27;s an example of using tags"
      },
      "id": "6130be2e28ccbc115f56a814"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18332,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " are <em>applied</em> at the end of the default <em>alert</em> lifecycle in order to suppress, or mute, notifications. They don&#x27;t disable existing policies or <em>conditions</em>. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations"
      },
      "id": "60440c4728ccbc9c612c60c7"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.81165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.79236,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure <em>conditions</em> only. You can find available entity-related tags by going to the <em>New</em> <em>Relic</em> Explorer and looking under a service&#x27;s Metadata and tags, or by viewing violation details. Here&#x27;s an example of using tags"
      },
      "id": "6130be2e28ccbc115f56a814"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " are <em>applied</em> at the end of the default <em>alert</em> lifecycle in order to suppress, or mute, notifications. They don&#x27;t disable existing policies or <em>conditions</em>. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations"
      },
      "id": "60440c4728ccbc9c612c60c7"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/acknowledge-alert-incidents": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View muted violations <em>and</em> <em>incidents</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.47641,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.14291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/view-violation-event-details-incidents": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View muted violations <em>and</em> <em>incidents</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.47641,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.14291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/delete-alert-notification-channels": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.96423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.1918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.1918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, browser, mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Multi-location conditions for synthetic monitoring",
        "Multi-location synthetics: Create conditions for policies",
        "Multi-location synthetics: Update conditions for policies",
        "Multi-location synthetics: Delete conditions for policies",
        "Multi-location synthetics: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "af566e5c2f0a695c1146b5531849bb49248ea0ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2022-01-12T11:33:08Z",
      "updated_at": "2022-01-08T06:48:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, browser, and mobile (Some limitations apply.) Conditions for external services Conditions for synthetic monitoring Conditions for Multi-location synthetic monitoring Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://example.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, browser, mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and mobile), and synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is streamed, set the aggregation_method to EVENT_FLOW and use the default settings of 60 for aggregation_window and 120 for aggregation_delay. EVENT_FLOW works in most use-cases, but for a discussion on which use cases work better with EVENT_TIMER, see Which aggregation method to use?. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"aggregation_method\": \"string\", \"aggregation_delay\": integer, \"aggregation_timer\": integer, \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and mobile monitoring apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or mobile monitoring apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or mobile monitoring), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Multi-location conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used for multi-location conditions with synthetic monitoring. Before creating or updating a condition, read the rules for multi-location alert conditions. Multi-location synthetics: Create conditions for policies To add conditions to policies for multi-location synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_location_failure_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Location Failure Conditions > GET > List. Multi-location synthetics: Update conditions for policies To update policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Location Failure Conditions > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy Multi-location synthetics: Delete conditions for policies To delete policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Location Failure Conditions > GET > List) API Explorer: Alerts Location Failure Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Multi-location synthetics: List existing conditions for policies To view a list of existing policy conditions for multi-location synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Location Failure Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_location_failure_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, browser, mobile, synthetic monitoring, and alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity that apply to an entity in APM, browser, mobile, or key transactions, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 183.95238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "REST API calls for <em>alerts</em>",
        "sections": "Create <em>new</em> <em>notification</em> channels",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Our REST API (v2) allows you to configure settings for <em>alerts</em>. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create <em>alert</em> conditions in the UI. Important"
      },
      "id": "6130c144e7b9d2d160b6f25d"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.96393,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.7467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.96393,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.7467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19171,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.96368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19162,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/create-edit-or-find-alert-policy": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.55371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, browser, mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Multi-location conditions for synthetic monitoring",
        "Multi-location synthetics: Create conditions for policies",
        "Multi-location synthetics: Update conditions for policies",
        "Multi-location synthetics: Delete conditions for policies",
        "Multi-location synthetics: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "af566e5c2f0a695c1146b5531849bb49248ea0ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2022-01-12T11:33:08Z",
      "updated_at": "2022-01-08T06:48:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, browser, and mobile (Some limitations apply.) Conditions for external services Conditions for synthetic monitoring Conditions for Multi-location synthetic monitoring Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://example.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, browser, mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and mobile), and synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is streamed, set the aggregation_method to EVENT_FLOW and use the default settings of 60 for aggregation_window and 120 for aggregation_delay. EVENT_FLOW works in most use-cases, but for a discussion on which use cases work better with EVENT_TIMER, see Which aggregation method to use?. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"aggregation_method\": \"string\", \"aggregation_delay\": integer, \"aggregation_timer\": integer, \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and mobile monitoring apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or mobile monitoring apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or mobile monitoring), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Multi-location conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used for multi-location conditions with synthetic monitoring. Before creating or updating a condition, read the rules for multi-location alert conditions. Multi-location synthetics: Create conditions for policies To add conditions to policies for multi-location synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_location_failure_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Location Failure Conditions > GET > List. Multi-location synthetics: Update conditions for policies To update policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Location Failure Conditions > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy Multi-location synthetics: Delete conditions for policies To delete policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Location Failure Conditions > GET > List) API Explorer: Alerts Location Failure Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Multi-location synthetics: List existing conditions for policies To view a list of existing policy conditions for multi-location synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Location Failure Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_location_failure_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, browser, mobile, synthetic monitoring, and alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity that apply to an entity in APM, browser, mobile, or key transactions, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23108,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "REST API calls for <em>alerts</em>",
        "sections": "<em>Alert</em> <em>policies</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "&#x2F;<em>alerts</em>_nrql_conditions&#x2F;$CONDITION_ID.json&#x27; \\ -H &#x27;Api-Key:$API_KEY&#x27; -i Copy List existing NRQL conditions for <em>policies</em> To view a list of existing conditions for your <em>alert</em> policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: <em>Alerts</em> Nrql Conditions &gt; GET"
      },
      "id": "6130c144e7b9d2d160b6f25d"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.88701,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> <em>policies</em>, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.5535,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, browser, mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Multi-location conditions for synthetic monitoring",
        "Multi-location synthetics: Create conditions for policies",
        "Multi-location synthetics: Update conditions for policies",
        "Multi-location synthetics: Delete conditions for policies",
        "Multi-location synthetics: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "af566e5c2f0a695c1146b5531849bb49248ea0ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2022-01-12T11:33:08Z",
      "updated_at": "2022-01-08T06:48:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, browser, and mobile (Some limitations apply.) Conditions for external services Conditions for synthetic monitoring Conditions for Multi-location synthetic monitoring Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://example.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, browser, mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and mobile), and synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is streamed, set the aggregation_method to EVENT_FLOW and use the default settings of 60 for aggregation_window and 120 for aggregation_delay. EVENT_FLOW works in most use-cases, but for a discussion on which use cases work better with EVENT_TIMER, see Which aggregation method to use?. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"aggregation_method\": \"string\", \"aggregation_delay\": integer, \"aggregation_timer\": integer, \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and mobile monitoring apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or mobile monitoring apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or mobile monitoring), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Multi-location conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used for multi-location conditions with synthetic monitoring. Before creating or updating a condition, read the rules for multi-location alert conditions. Multi-location synthetics: Create conditions for policies To add conditions to policies for multi-location synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_location_failure_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Location Failure Conditions > GET > List. Multi-location synthetics: Update conditions for policies To update policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Location Failure Conditions > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy Multi-location synthetics: Delete conditions for policies To delete policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Location Failure Conditions > GET > List) API Explorer: Alerts Location Failure Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Multi-location synthetics: List existing conditions for policies To view a list of existing policy conditions for multi-location synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Location Failure Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_location_failure_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, browser, mobile, synthetic monitoring, and alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity that apply to an entity in APM, browser, mobile, or key transactions, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "REST API calls for <em>alerts</em>",
        "sections": "<em>Alert</em> <em>policies</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "&#x2F;<em>alerts</em>_nrql_conditions&#x2F;$CONDITION_ID.json&#x27; \\ -H &#x27;Api-Key:$API_KEY&#x27; -i Copy List existing NRQL conditions for <em>policies</em> To view a list of existing conditions for your <em>alert</em> policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: <em>Alerts</em> Nrql Conditions &gt; GET"
      },
      "id": "6130c144e7b9d2d160b6f25d"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.8869,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> <em>policies</em>, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.5535,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, browser, mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Multi-location conditions for synthetic monitoring",
        "Multi-location synthetics: Create conditions for policies",
        "Multi-location synthetics: Update conditions for policies",
        "Multi-location synthetics: Delete conditions for policies",
        "Multi-location synthetics: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "af566e5c2f0a695c1146b5531849bb49248ea0ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2022-01-12T11:33:08Z",
      "updated_at": "2022-01-08T06:48:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, browser, and mobile (Some limitations apply.) Conditions for external services Conditions for synthetic monitoring Conditions for Multi-location synthetic monitoring Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://example.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, browser, mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and mobile), and synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is streamed, set the aggregation_method to EVENT_FLOW and use the default settings of 60 for aggregation_window and 120 for aggregation_delay. EVENT_FLOW works in most use-cases, but for a discussion on which use cases work better with EVENT_TIMER, see Which aggregation method to use?. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"aggregation_method\": \"string\", \"aggregation_delay\": integer, \"aggregation_timer\": integer, \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and mobile monitoring apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or mobile monitoring apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or mobile monitoring), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Multi-location conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used for multi-location conditions with synthetic monitoring. Before creating or updating a condition, read the rules for multi-location alert conditions. Multi-location synthetics: Create conditions for policies To add conditions to policies for multi-location synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_location_failure_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Location Failure Conditions > GET > List. Multi-location synthetics: Update conditions for policies To update policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Location Failure Conditions > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy Multi-location synthetics: Delete conditions for policies To delete policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Location Failure Conditions > GET > List) API Explorer: Alerts Location Failure Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Multi-location synthetics: List existing conditions for policies To view a list of existing policy conditions for multi-location synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Location Failure Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_location_failure_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, browser, mobile, synthetic monitoring, and alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity that apply to an entity in APM, browser, mobile, or key transactions, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "REST API calls for <em>alerts</em>",
        "sections": "<em>Alert</em> <em>policies</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "&#x2F;<em>alerts</em>_nrql_conditions&#x2F;$CONDITION_ID.json&#x27; \\ -H &#x27;Api-Key:$API_KEY&#x27; -i Copy List existing NRQL conditions for <em>policies</em> To view a list of existing conditions for your <em>alert</em> policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: <em>Alerts</em> Nrql Conditions &gt; GET"
      },
      "id": "6130c144e7b9d2d160b6f25d"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.8869,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> <em>policies</em>, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/view-policies-conditions-our-products": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 255.55411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, browser, mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Multi-location conditions for synthetic monitoring",
        "Multi-location synthetics: Create conditions for policies",
        "Multi-location synthetics: Update conditions for policies",
        "Multi-location synthetics: Delete conditions for policies",
        "Multi-location synthetics: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "af566e5c2f0a695c1146b5531849bb49248ea0ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2022-01-12T11:33:08Z",
      "updated_at": "2022-01-08T06:48:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, browser, and mobile (Some limitations apply.) Conditions for external services Conditions for synthetic monitoring Conditions for Multi-location synthetic monitoring Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://example.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, browser, mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and mobile), and synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is streamed, set the aggregation_method to EVENT_FLOW and use the default settings of 60 for aggregation_window and 120 for aggregation_delay. EVENT_FLOW works in most use-cases, but for a discussion on which use cases work better with EVENT_TIMER, see Which aggregation method to use?. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"aggregation_method\": \"string\", \"aggregation_delay\": integer, \"aggregation_timer\": integer, \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and mobile monitoring apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or mobile monitoring apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or mobile monitoring), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Multi-location conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used for multi-location conditions with synthetic monitoring. Before creating or updating a condition, read the rules for multi-location alert conditions. Multi-location synthetics: Create conditions for policies To add conditions to policies for multi-location synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_location_failure_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Location Failure Conditions > GET > List. Multi-location synthetics: Update conditions for policies To update policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Location Failure Conditions > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy Multi-location synthetics: Delete conditions for policies To delete policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Location Failure Conditions > GET > List) API Explorer: Alerts Location Failure Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Multi-location synthetics: List existing conditions for policies To view a list of existing policy conditions for multi-location synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Location Failure Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_location_failure_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, browser, mobile, synthetic monitoring, and alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity that apply to an entity in APM, browser, mobile, or key transactions, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 236.23221,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "REST API calls for <em>alerts</em>",
        "sections": "<em>Alert</em> <em>policies</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "&#x2F;<em>alerts</em>_nrql_conditions&#x2F;$CONDITION_ID.json&#x27; \\ -H &#x27;Api-Key:$API_KEY&#x27; -i Copy List existing NRQL conditions for <em>policies</em> To view a list of existing conditions for your <em>alert</em> policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: <em>Alerts</em> Nrql Conditions &gt; GET"
      },
      "id": "6130c144e7b9d2d160b6f25d"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.88785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> <em>policies</em>, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/how-alert-condition-violations-are-closed": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18216,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View muted <em>violations</em> <em>and</em> incidents",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those <em>violations</em>. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.4755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.26456,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom <em>violation</em> descriptions",
        "sections": "<em>Alert</em> custom <em>violation</em> descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/view-alert-violations-our-products": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18198,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View muted <em>violations</em> <em>and</em> incidents",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those <em>violations</em>. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 225.47531,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 204.26447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom <em>violation</em> descriptions",
        "sections": "<em>Alert</em> custom <em>violation</em> descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.46222,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74594,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/choose-your-aggregation-method": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.46204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/condition-recommendations": [
    {
      "sections": [
        "Understand and use data from infrastructure integrations",
        "Explore your infrastructure integration's data",
        "Create alert conditions"
      ],
      "title": "Understand and use data from infrastructure integrations",
      "type": "docs",
      "tags": [
        "Integrations",
        "Infrastructure integrations",
        "Get started"
      ],
      "external_id": "74fbfa8de2ee02bdf8dd4aad22fab7f654e96904",
      "image": "",
      "url": "https://docs.newrelic.com/docs/infrastructure/infrastructure-integrations/get-started/understand-use-data-infrastructure-integrations/",
      "published_at": "2022-01-12T04:31:28Z",
      "updated_at": "2022-01-12T04:31:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With our infrastructure integrations, you can monitor the performance of many popular services. Our infrastructure integrations are separated into two main categories: Cloud integrations: Integrations for cloud platform services, including AWS, Azure, and GCP. On-host integrations: \"On-host\" refers to core services integrations that you can install directly on a host. Examples: MySQL, NGINX, Kubernetes, Redis. Here are some tips on how to find, understand, and use data reported from infrastructure integrations. Explore your infrastructure integration's data The best way to understand infrastructure integrations's data and see what you can do with it is to enable an integration and explore the data in the New Relic UI. Some recommendations for exploring: View dashboards: You can find your dashboards in New Relic One. For details, see Integration dashboards. Query data: You can run custom queries and charts of your integration data. For more information, see Query New Relic data. Create alert conditions: See Alert conditions. Learn more about what metrics and inventory data an integration reports: See an integration's documentation: cloud integrations and on-host integrations. Create alert conditions To create an alert condition for integration data in infrastructure, Go to one.newrelic.com > Infrastructure, choose an integration, and then select an available alert option. For more information, see Infrastructure and alerts. You can also create alert conditions using NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.79273,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create alert <em>conditions</em>",
        "tags": "<em>Get</em> started",
        "body": " infrastructure integrations&#x27;s data and see what you can do with it is to enable an integration and explore the data in the New Relic UI. Some <em>recommendations</em> for exploring: View dashboards: You can find your dashboards in New Relic One. For details, see Integration dashboards. Query data: You can run custom"
      },
      "id": "617dc61d28ccbcceb080096e"
    },
    {
      "image": "https://docs.newrelic.com/static/2ddf926e6e8fbdbcd9ee04a60e75c38b/ae694/add-alert.png",
      "url": "https://docs.newrelic.com/whats-new/2021/07/alert-conditions/",
      "sections": [
        "Recommended alert conditions",
        "Using recommended conditions"
      ],
      "published_at": "2022-01-12T11:16:58Z",
      "title": "Recommended alert conditions",
      "updated_at": "2021-10-30T17:13:56Z",
      "type": "docs",
      "external_id": "3a955d434afd832f8115e0274596f78045c9e6ea",
      "document_type": "nr1_announcement",
      "popularity": 1,
      "body": "Configuring incident detection consistently across your entire estate helps you track the overall health of your systems, avoid blindspots, and reduce the time it takes to identify and resolve issues. We know that creating accurate alert conditions is anything but simple. Knowing which metrics to monitor, and setting the thresholds accordingly, is a task that few have the necessary knowledge of both their systems and of New Relic to feel confident executing. This results in teams only applying incident detection practices to a subset of critical services. Good news: New Relic One now has an alert condition recommendation service that uses AI and machine learning (ML) to recommend specific metrics and signals to monitor for your specific entities. You can use the provided recommendations or modify them to fit your specific needs. Here’s how you can add recommended alerts to APM entities that do not currently have alert coverage. Using recommended conditions Go to Services - APM in New Relic Navigator and you’ll see a high-density view of the health of your system. With the traffic-light visual, it’s easy to view which entities are healthy, which entities have violations, and which entities do not have any alerts coverage. If an entity does not have alert coverage, its hexagon will be gray. Recommended conditions helps you automatically add alerts to entities that do not have alerts coverage, those gray hexagons. Select an entity: Click an uncovered entity (gray hexagon). A new option will appear on the right-hand side of the screen. Click Create alert condition as shown in the image below. Choose a number of recommended conditions. The recommendations will depend on the quality of the tags associated with an entity. The more accurate and informative the tags are, the more precise the recommendations will be. The image below shows a few possible recommendations based on error percentage, Apdex, and response time. Learn more about recent innovations in alerting with our PM Brian Goleno here!.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 86.67857,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Recommended</em> alert <em>conditions</em>",
        "sections": "<em>Recommended</em> alert <em>conditions</em>",
        "body": " an alert <em>condition</em> recommendation service that uses AI and machine learning (ML) to <em>recommend</em> specific metrics and signals to monitor for your specific entities. You can use the provided <em>recommendations</em> or modify them to fit your specific needs. Here’s how you can add recommended alerts to APM entities"
      },
      "id": "60febacb64441f990447ac4f"
    },
    {
      "sections": [
        "Get started with New Relic observability",
        "Get your data into New Relic with our quickstarts",
        "Some technical detail",
        "Guided install for New Relic",
        "All the answers in one place"
      ],
      "title": "Get started with New Relic observability",
      "type": "docs",
      "tags": [
        "Observe everything",
        "Get started"
      ],
      "external_id": "30f87d5f702f926efec49b59591679fa93627ad5",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability-2.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/get-started-full-stack-observability/",
      "published_at": "2022-01-12T18:26:43Z",
      "updated_at": "2022-01-12T18:26:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "True observability is the power of knowing what's happening across your digital system and why it's happening—at any time, whatever solution you’re using. It’s getting the whole picture of everything that enables your applications and devices to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Our platform goes beyond simple monitoring by offering you observability: data insights to help you make proactive and predictive improvements to your environment. A comparison between simple monitoring and observability. Get your data into New Relic with our quickstarts New Relic I/O is a rich catalog of open-source quickstarts that automatically include integrations, dashboards, and alerts for you to use immediately. Popular technologies such as Node.js, Python, and Ruby have full-featured quickstarts, while others contain a mixture of tools. Each quickstart is created by observability experts around the world, vetted by New Relic, and ready for you to install with one click. Leverage community expertise and get more value out of your telemetry data with New Relic I/O, your hub for instant observability. Ready to get started? Find your quickstart in New Relic I/O: New Relic I/O New Relic I/O is open source, which means that you can modify and improve existing quickstarts, or build new ones, to suit your needs. We thoroughly review external edits to our quickstarts for value and quality. Interested in contributing to the community? Check out our contributor guide in GitHub. Some technical detail New Relic quickstarts use open source installation recipes to instrument integrations using our guided install process. Guided install for New Relic Alternatively, if you're comfortable with the command line, our guided install discovers the applications, infrastructure, and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. If your account reports data through our EU data center, click EU Guided install. Guided install EU Guided install All the answers in one place Once your data is in New Relic, we give you a UI with tools to cut through the layers of complexity surrounding your systems. This is all in one platform so you don't need to switch between diagnostic applications. You can interrogate your data for patterns, discover them using our data platform, or get proactive results from our machine learning tools. All our observability tools are interconnected and accessible in New Relic One. Data reported to New Relic can be categorized as metrics, events, logs, and traces. This data feeds our platform's analytics and monitoring capabilities. New Relic links your data in a meaningful way so that you can explore it, build dashboards, and set up alerts. Our out-of-the-box observability UI experiences allow to visualize, analyze, and troubleshoot your entire software stack in one unified platform. The New Relic Explorer consolidates all the entities in your system, and how they're connected, in a single place, so you can easily detect performance trends and issues. By automatically connecting infrastructure health with application performance and end-user behavior, you can cut through the noise to find useful signals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.824326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> started with New Relic observability",
        "sections": "<em>Get</em> started with New Relic observability",
        "tags": "<em>Get</em> started",
        "body": ". <em>Get</em> your data into New Relic with our quickstarts New Relic I&#x2F;O is a rich catalog of open-source quickstarts that automatically include integrations, dashboards, and alerts for you to use immediately. Popular technologies such as Node.js, Python, and Ruby have full-featured quickstarts, while"
      },
      "id": "61743c6764441f60375fd317"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/introduction-applied-intelligence": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.46204,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/your-first-nrql-condition": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 385.00726,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. February 2022: <em>NRQL</em> baselines to replace outlier <em>NRQL</em> <em>alert</em> condition types. Reason for EOL: Outlier <em>conditions</em> don&#x27;t provide efficient cluster"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 310.92676,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feature is available for: <em>NRQL</em> <em>alert</em> <em>conditions</em> Infrastructure monitoring <em>alert</em> <em>conditions</em> The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of <em>conditions</em>, you can create a custom violation description that passes"
      },
      "id": "6130be2e28ccbc115f56a814"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 264.41058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " are <em>applied</em> at the end of the default <em>alert</em> lifecycle in order to suppress, or mute, notifications. They don&#x27;t disable existing policies or <em>conditions</em>. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations"
      },
      "id": "60440c4728ccbc9c612c60c7"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/learn-alerts/alerts-concepts-workflow": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.46185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74557,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/learn-alerts/introduction-alerts": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.46167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19107,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/learn-alerts/rules-limits-alerts": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 228.46167,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting <em>rules</em>: Suppress notifications",
        "sections": "Muting <em>rules</em>: Suppress notifications",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting <em>rules</em> that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting <em>rules</em> don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 226.74539,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " in this EOL transition guide, don&#x27;t hesitate to: Reach out to your <em>New</em> <em>Relic</em> account representative. Use the reply thread in our Explorers Hub post. What&#x27;s changed Starting in late 2021, we&#x27;ve reorganized the navigation UI for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. Although the <em>alerts</em> and <em>applied</em> <em>intelligence</em>"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.19107,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/notifications/destinations": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 353.90842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the muting rules page to temporarily stop your <em>alerts</em> violation notifications. Use workflows to add more data to your <em>alerts</em> notifications. Use <em>destinations</em> to configure where your <em>applied</em> <em>intelligence</em> notifications get sent. Use pathways to configure where your correlated issues get sent. Use"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Get started with Incident Intelligence",
        "Requirements",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "Tip",
        "2. Configure sources",
        "Alerts",
        "Datarobot (formerly Algorithmia)",
        "Aporia (MLOps)",
        "Superwise (MLOps)",
        "Anomalies",
        "AWS",
        "Grafana",
        "PagerDuty",
        "EOL NOTICE",
        "Prometheus Alertmanager",
        "REST API",
        "Splunk",
        "Important",
        "Splunk metadata",
        "3. Configure destinations (ServiceNow and others)",
        "Configure ServiceNow (example)",
        "Send data to ServiceNow",
        "Custom notification message",
        "Other destinations",
        "Send data to PagerDuty",
        "Send data via webhook",
        "4. Configure pathways",
        "What's next?"
      ],
      "title": "Get started with Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "8c4a5a914ca01cb42250908d2fb1a12ccc697e25",
      "image": "https://docs.newrelic.com/static/5cb28999dc618c6a5a2b8be1fa72e660/b97f6/image-%25281%2529_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence/",
      "published_at": "2022-01-12T08:56:30Z",
      "updated_at": "2021-12-09T22:19:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. Requirements If you haven't already, sign up for a New Relic account to get started. To use most Applied Intelligence features, you must be a full platform user. For more information, see user type capabilities. Set up Incident Intelligence To enable Incident Intelligence, follow these steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges. Can administrators set more than one environment? They can set one environment per parent account and its child accounts. More than one can be set if an administrator has privileges for more than one parent account. Tip Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts. On the left under Incident Intelligence, click Sources and then click Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Tip Adding alerts as a source will not affect your current configuration or notifications. Datarobot (formerly Algorithmia) By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. To configure Datarobot for Incident Intelligence, see our integration docs. Aporia (MLOps) By integrating Incident Intelligence with your Aporia machine-learning models, you can monitor your machine learning model performance. To configure our Aporia integration, see our docs. Superwise (MLOps) By integrating Incident Intelligence with your Superwise machine-learning models, you can monitor your machine learning model performance. To configure our Superwise integration, see our docs. Anomalies By integrating Incident Intelligence with your New Relic Proactive Detection anomalies, you can get context and correlations from what you're monitoring. To get data from New Relic Proactive Detection anomalies: From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Anomalies. Select the configurations you want to connect to Applied Intelligence by toggling to on (green). To add or remove alert policies, from Alerts & AI, click Sources, then Alerts. Tip Adding anomalies as a source won't affect your current Proactive Detection configurations or notifications. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Amazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources, and then click Grafana. Copy the URL, and paste it into your new Grafana webhook. PagerDuty EOL NOTICE As of October 2021, we've discontinued support for several capabilities with PagerDuty, including suggested responders, golden signals, and component enrichment. For more details, including how you can easily make this transition, see our Explorers Hub post. You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Copy Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Important Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME 3. Configure destinations (ServiceNow and others) Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. Configure ServiceNow (example) Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. Send data to ServiceNow To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. When you want to skip a selected field in an issue update, add the | skip_on_update string at the end of the value you've selected. Tip By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column name value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. Other destinations You can set other destinations: Send data to PagerDuty EOL NOTICE As of October 2021, we've discontinued support for several capabilities with PagerDuty, including suggested responders, golden signals, and component enrichment. For more details, including how you can easily make this transition, see our Explorers Hub post. Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Tip There’s a retry mechanism that is triggered a few times with exponential backoff for a couple of minutes once an error occurs. If we reach the retry limit, the Webhook will get auto-disabled. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. What's next? Now that you've set up some sources and destinations for your incidents, read about how to use Incident Intelligence.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.2922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "sections": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " one.newrelic.com, click <em>Alerts</em> &amp; AI. On the left under <em>Incident</em> <em>Intelligence</em>, click Sources and then click Anomalies. Select the configurations you want to connect to <em>Applied</em> <em>Intelligence</em> by toggling to on (green). To add or remove <em>alert</em> policies, from <em>Alerts</em> &amp; AI, click Sources, then <em>Alerts</em>. Tip Adding anomalies"
      },
      "id": "603ea62e64441f119f4e883f"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "EOL NOTICE",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook Names and Descriptions",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2022-01-12T08:57:10Z",
      "updated_at": "2021-11-06T20:07:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON formats. EOL NOTICE As of October 2021, we've discontinued support for several capabilities with PagerDuty, including suggested responders, golden signals, and component enrichment. For more details, including how you can easily make this transition, see our Explorers Hub post. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body and JSON format. Webhook Names and Descriptions Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.84958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> <em>destination</em> examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> <em>destination</em> examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "<em>Destinations</em> are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure <em>Incident</em> <em>Intelligence</em> <em>destinations</em> to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON formats"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/notifications/intro-notifications": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 383.65814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the muting rules page to temporarily stop your <em>alerts</em> violation <em>notifications</em>. Use <em>workflows</em> to add more data to your <em>alerts</em> <em>notifications</em>. Use destinations to configure where your <em>applied</em> <em>intelligence</em> <em>notifications</em> get sent. Use pathways to configure where your correlated issues get sent. Use"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 285.28815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Workflows",
        "What is an issue",
        "Add a Workflow",
        "Tip",
        "Enrichments",
        "Important",
        "Notifier"
      ],
      "title": "Workflows",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Workflows",
        "Notifications"
      ],
      "external_id": "0993c323f76467d22136cac6982ccd48e859f722",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/incident-workflows/",
      "published_at": "2022-01-12T06:25:28Z",
      "updated_at": "2021-12-17T01:48:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With workflows you control when and where you want to receive notifications about issues, tunnel the right information to the relevant person or team, and enrich your issue's notifications with additional New Relic data. What is an issue Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. For more information see Use Incident Inteligence. Add a Workflow Tip The maximum number of workflows you can add is 100 per environment and 50 per account. The workflows feature is located under the Alerts & AI menu. Go to one.newrelic.com, click Alerts & AI, in the left navigation under Enrich and Notify click Workflow, then click Add a workflow. Name your workflow. This field is mandatory and needs to be unique. Workflows filters the issues you want to send to the relevant destination. You can send all issues by selecting Send all issues or you can build a query to filter the right issues. Build a query by selecting an attribute, operator and value/s to narrow down the right issues you want to be passed on. Optional: Enriched Data, available to full platform users. Enrichments Enrichments can give additional context on alert notifications by adding NRQL query results to them The workflows enrich tool is similar to the query builder. The NRQL query's results are included in the notification message. If you create queries for your workflows, they run in real time and the query results are the value of the enricher. You can save any valid query into your workflow, even if they return an empty result, but you must run the query before saving the enrichment. You can also query with issue-specific variables; for example {{entitiesData.ids}} For enrichment examples, see Workflow data enrichment examples. Note: The query name needs to be unique because you'll use the name to decide how to include the result in the payload of the notification that will be sent by the workflow. Important At this stage, visual representation of enrichments are sent to Slack and email. For Servicenow and JIRA destinations, we recommend to limit to NRDB queries with single value results. For example: count, min, or max. The maximum number of enrichments per workflow is 5. The maximum number of variables an enrichment can contain is 1. Notify: Choose one or more destinations and add an optional message. Notifier To save and activate a Workflow, you need to include a notifier. Setting up a notifier requires having a notification destination configured. You can either set it up through the Destination menu item, or through the Create new destination item in the destination selection drop down in each destination channel screen. A notification destination includes the credentials required to send a notification to a third party platform and an option to customize the message sent by mapping fields from our issues to fields in the destination platform. To learn how to set up destinations and configure message templates, check the documentation on notifications. Click update message once completing the notifier requirements Optionally, test your workflow. We'll use existing data from your account to test what you've configured and send a sample notification Click activate to complete the workflow. Tip In any destination channel, start typing and a variable menu will open up. You'll see the names of the variables, which will be replaced with the variable's values at runtime. To use the enrichers' results, use their name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 278.13486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Workflows</em>",
        "sections": "<em>Workflows</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " problem of your symptoms. When a new incident is created, Incident <em>Intelligence</em> opens an issue and evaluates other open issues for correlations. For more information see Use Incident Inteligence. Add a <em>Workflow</em> Tip The maximum number of <em>workflows</em> you can add is 100 per environment and 50 per account"
      },
      "id": "603e967664441f7e6f4e889b"
    }
  ],
  "/docs/alerts-applied-intelligence/notifications/message-templates": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 248.9448,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. February 2022: NRQL baselines to replace outlier NRQL <em>alert</em> condition types. Reason for EOL: Outlier conditions don&#x27;t provide efficient cluster"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Proactive Detection with Applied Intelligence",
        "Requirements",
        "Why it matters",
        "How it works",
        "Set up notifications for Proactive Detection",
        "Set up for Slack",
        "Tip",
        "Set up for webhooks",
        "Set up without notifications",
        "Mute notifications (Slack only)",
        "Use Proactive Detection Slack messages",
        "View overview of anomalies",
        "Anomaly visibility settings",
        "Query anomaly data",
        "Important",
        "Add anomalies as source in Incident Intelligence",
        "Webhook payload and examples",
        "JSON schema example",
        "Data limits"
      ],
      "title": "Proactive Detection with Applied Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "53e01b53fc341ef1e89b96e7927b16de03e72358",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/proactive-detection-applied-intelligence/",
      "published_at": "2022-01-12T07:29:24Z",
      "updated_at": "2021-12-30T06:27:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With Applied Intelligence's Proactive Detection, anomalies from your APM-monitored applications are automatically surfaced in our activity streams and anomalies feed. You can click each anomaly to bring up an automatic analysis. Notifications for anomalies can be delivered in Slack, or you can set up a webhook to deliver messages when you need them. These events are available for querying, creating custom dashboards, and alerting. After you set up a Proactive Detection configuration (a group of apps you're interested in), you can add this configuration as a source. Then the anomalies will be automatically correlated with other data sources via Incident Intelligence. To learn where anomalies appear, how you can use them to understand potential issues before they become incidents, and create alerts from them, watch this short video (approx. 4:15 minutes). Requirements To use Proactive Detection, ensure you have: Full platform user access. If you haven't already, sign up for a New Relic account to get started. An APM agent installed for at least one applications. To receive notifications in Slack, you'll need to ask your IT administrator to install the New Relic application in your Slack workspace. For more on data limits, see Data limits. Why it matters With Proactive Detection, Applied Intelligence delivers insights about anomalies in your production system, along with an automatic analysis of the anomaly. It’s enabled automatically, at no additional cost. When an anomaly is detected, you can view it in the Applied Intelligence anomalies feed, or we'll send notifications directly to your Slack channel or a webhook. How it works Proactive Detection uses the following methods to detect anomalies in your app data: Proactive Detection monitors metric data reported by an APM agent, building a model of your typical application dynamics, and focuses on key golden signals: throughput, response time, and errors. If one of these golden signals shows anomalous behavior, the system flags it and tracks recovery to normal behavior. The system adapts to changes in your data, and continuously updates models based on new data. Automatically on: By default, Proactive Detection monitors all your APM applications, with no action required by you. When an anomaly is detected, it's automatically surfaced in various activity streams, the Applied Intelligence anomalies feed and is available for querying via NRQL. Receiving notifications: We send notifications when we detect anomalous changes in throughput, error rate, or response time. The notifications are sent to selected Slack channels, or sent via webhook. When the anomaly goes back to normal, a recovery message is sent. If you don't want to receive notifications, you still have access to the data via NRQL query. Anomaly analysis: For each anomaly, we provide a link in Slack to an analyze anomaly page. This page generates automatic insights into the anomaly. The page is also available from the anomalies tab, which lists recent anomalies. This page uses your existing APM and Proactive Detection data to provide explanations as to the cause of the anomaly. Activity stream: Inside various activity streams such as the New Relic One homepage, APM Summary page, Lookout and Explorer, you'll see relevant anomalies from your APM-monitored applications. Clicking on any of the anomaly events in the activity stream brings up the analysis page for that anomaly. Applications will not always generate anomalies, so it can be normal to not receive any detections. Set up notifications for Proactive Detection Proactive Detection is enabled automatically, at no additional cost. To receive notifications or to have a configuration (group of apps) that you can add as a source for Incident Intelligence, you will need to create a Proactive Detection configuration. You can create a configuration in the Proactive Detection UI: From one.newrelic.com, click Alerts & AI. Under Proactive Detection, click Settings. Click Add a configuration. Input the following information into the form: Choose a name for your configuration that helps you easily identify it from others in your account. Select an account. Select up to 1,000 applications. Note that certain applications with low throughput might not be good candidates for Proactive Detection, as they can be more sensitive to smaller amounts of data fluctuation. Optional: select the golden signals you'd like to monitor for anomalies. Optional: connect to Incident Intelligence. Set up for Slack To use Proactive Detection with Slack: Select Slack. Choose which Slack channel receives notifications. You can select any existing public or private channel. This prompts the workflow to add the Applied Intelligence Slack application to your selected channel. To create a new channel, do that directly in Slack first. Tip If you experience an error when assigning Slack channels, make sure that the New Relic AI Slack application has been added to your Slack workspace. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up for webhooks To use Proactive Detection with webhooks: Select Webhook. Input the following information into the form: Provide the webhook URL. Provide optional custom headers. Choose to edit the custom payload, or enable using the default payload. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up without notifications To use Proactive Detection when you don't need to receive notifications: Select No notifications. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Mute notifications (Slack only) In Slack, detections coming from specific applications can be muted temporarily or permanently. The entire channel can also be muted temporarily. This is useful in the case of an incident or when the channel should otherwise not be interrupted. To mute in Slack, select Mute this app’s warnings or Mute all warnings, then select the duration. We will resume sending notifications for any detections once the muting duration has completed. Muting an application permanently removes it from the configuration. To add it back in, go to one.newrelic.com, in the top nav click Alerts & AI, then click Proactive Detection, and select the configuration to edit. Muting Proactive Detection notifications does not affect alerts. Use Proactive Detection Slack messages Each anomaly message has several key pieces of information you can use to learn more about and start troubleshooting the potential issue: The application name and a link to more information about it in New Relic One. The metric experiencing an anomaly and a link to its details in New Relic One. A graph of the metric over time to provide a visual understanding of the anomaly’s behavior and degree. An Analyze button that navigates to an analysis page in Applied Intelligence that identifies key attributes that are unique to the anomaly, anomalies found upstream or downstream, and any other relevant signals. Once an anomaly has returned to normal, we send a recovery notification with the option to provide feedback. Your feedback provides our development team with input to help us improve detection quality. In the case of feedback provided on throughput anomalies, an evaluation is run each hour based on feedback to fit a more suitable model. If we helped you, you can select Yes or No. View overview of anomalies In addition to notifications for anomalies that give you information via Slack or webhook, you can view more information about the anomalies in your environment via the Anomalies tab on the Alerts & AI Overview page. That tab provides a list of all the recent anomalies from every configuration in the selected account, and you can select an anomaly for a detailed analysis. Anomaly visibility settings Anomalies are displayed in various New Relic activity streams and in the Applied Intelligence anomalies feed. You can customize what is displayed using the anomaly visibility settings (for example, hiding throughput anomalies on an activity stream but keeping them in the anomalies feed). To find these settings: from Alerts & AI, under Proactive Detection, click Settings. Notes on using these settings: These settings are applied at the user level. Changes you make won’t affect others users in your organization. Regardless of these settings, the anomalies are still reported and available for NRQL querying. Details on these UI sections: AI overview and anomalies tab: Use the AI overview and anomalies tab setting to hide anomalies from the AI overview and anomalies tab setting. Please note you also can use filters specific to these views as well. Global activity stream: Use the global activity stream section to customize what anomalies are shown in the various New Relic activity streams, including the New Relic One homepage, APM Summary, and Lookout. Anomaly types: Use the check boxes here to hide specific types of anomalies. For example, uncheck Web throughput and Non-web throughput anomalies to hide these types of anomalies from both the activity streams and the AI overview and anomalies tab. (Note they are still reported and available for querying.) Query anomaly data You can use NRQL to query and chart your Proactive Detection data using the NrAiAnomaly event. For example: FROM NrAiAnomaly SELECT * Important This data has previously been attached to the ProactiveDetection event. That event will be deprecated on April 7, 2021. If you use ProactiveDetection in your custom charts, you should convert those queries to using NrAiAnomaly. Here are important attributes attached to this event: Attribute Description closeTime timestamp The time when the anomaly ended. Example: 1615304100000. configurationType string The type of configuration monitoring the event. If at least one configuration is monitoring the entity, this is set to configuration. Otherwise, it's set to automatic. entity.accountId number The New Relic account ID to which the entity belongs. entity.domain number The domain of the entity (currently only APM but will change with future functionality). entity.guid string The GUID of the entity. This is used to identify and retrieve data about the entity via NerdGraph. Identical to entityGuid. entityGuid string The GUID of the entity. This is used to identify and retrieve data about the entity via NerdGraph. Identical to entity.guid. entity.name string The name of the entity whose data was determined to be anomalous. Identical to entityName. Example: Laura's coffee service. entityName string The name of the entity whose data was determined to be anomalous. Identical to entity.name. entity.type string The type of entity (currently only APPLICATION but will change with future functionality). evaluationType string This is always anomaly. event string Indicates whether it's the beginning (open) or end (close) of the anomalous data. openTime timestamp The time when the anomaly opened. Example: 1615303740000. signalType string The type of data that was analyzed. For example, error_rate or response_time.non_web. timestamp timestamp The time at which the event was written. title string Description of the anomaly. Example: Error rate was much higher than normal. Add anomalies as source in Incident Intelligence By integrating Incident Intelligence with your Proactive Detection anomalies, you can get context and correlations. To learn about doing this in Incident Intelligence, see Configure sources. You can also select Connect to Incident Intelligence from inside of a configuration. Webhook payload and examples Proactive Detection sends the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Proactive Detection, use these examples of the webhook body format and JSON schema. Attribute Description category enum The category of data that was analyzed. Categories include web throughput, non-web throughput, web transactions, non-web transactions, and error class. data list The time series data leading up to the detection. data[].timestamp number The timestamp of the data point in milliseconds since the Unix epoch. Example: 1584366819000 data[].unit string The unit describing the value of the data point. Data units include count, milliseconds, and error_rate. data[].value number The value of the data point. Example: 1.52 detectionType enum The type of data that was analyzed. Types include latency, throughput, and error_rate. entity object The entity that reported the unusual data. entity.accountId number The ID for the entity's account. entity.domain enum The domain for the entity. Example: APM. entity.domainId string The id used to uniquely identify the entity within the domain. entity.guid string The guid used to uniquely identify the entity across all products. entity.name string The name of the entity. Example: Laura’s coffee service entity.link string A link to view the entity. Example: https://rpm.newrelic.com/accounts/YOUR_ACCOUNT_ID/applications/987654321” Copy severity enum A description of how unusual of a change occurred, including NORMAL, WARNING, or CRITICAL. version string Version used to describe the data being provided. Example: v1 viewChartImageUrl string Image showing a chart of the anomalous data. anomalyzerUrl string URL that can be opened to analyze the anomaly in New Relic One. JSON schema example Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). Template: { \"version\": \"{{version}}\", \"entity\": { \"type\": \"{{entity.type}}\", \"name\": \"{{entity.name}}\", \"link\": \"{{entity.link}}\", \"entityGuid\": \"{{entity.entityGuid}}\", \"domainId\": \"{{entity.domainId}}\", \"domain\": \"{{entity.domain}}\", \"accountId\": {{entity.accountId}} }, \"detectionType\": \"{{detectionType}}\", \"category\": \"{{category}}\", \"data\": [{{#each data}} { \"value\": {{value}}, \"unit\": \"{{unit}}\", \"timestamp\": {{timestamp}} } {{#unless @last}},{{/unless}} {{/each}}], \"viewChartImageUrl\": \"{{viewChartImageUrl}}\", \"anomalyzerUrl\": \"{{anomalyzerUrl}}\" } Copy Sample payload: { \"version\": \"v1\", \"entity\": { \"type\": \"APPLICATION\", \"name\": \"My Application\", \"link\": \"https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/123\", \"entityGuid\": \"foo\", \"domainId\": \"123\", \"domain\": \"APM\", \"accountId\": YOUR_ACCOUNT_ID }, \"detectionType\": \"metric\", \"category\": \"web throughput\", \"data\": [ { \"value\": \"100\", \"unit\": \"count\", \"timestamp\": 1637260259819 }, { \"value\": \"99\", \"unit\": \"count\", \"timestamp\": 1637260319819 }, { \"value\": \"0\", \"unit\": \"count\", \"timestamp\": 1637260379819 } ], \"viewChartImageUrl\": \"https://www.example.com/image/8353cf2c-945c-48e8-99de-e903f033a881?height=200&width=400&show_timezone=true\", \"anomalyzerUrl\": \"https://www.example.com/anomalyzerUrlExample\" } Copy Data limits In addition to requirements, data limits include: Monitored APM applications: limited to 1,000 per configuration Slack configurations: limited to 200 per account Webhook configurations: limited to 200 per account Configurations without notifications: limited to 200 per account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.9745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Proactive Detection with <em>Applied</em> <em>Intelligence</em>",
        "sections": "Proactive Detection with <em>Applied</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " will be automatically correlated with other data sources via <em>Incident</em> <em>Intelligence</em>. To learn where anomalies appear, how you can use them to understand potential issues before they become incidents, and create <em>alerts</em> from them, watch this short video (approx. 4:15 minutes). Requirements To use Proactive"
      },
      "id": "603e9d68196a67dc21a83dd2"
    },
    {
      "sections": [
        "Get started with Incident Intelligence",
        "Requirements",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "Tip",
        "2. Configure sources",
        "Alerts",
        "Datarobot (formerly Algorithmia)",
        "Aporia (MLOps)",
        "Superwise (MLOps)",
        "Anomalies",
        "AWS",
        "Grafana",
        "PagerDuty",
        "EOL NOTICE",
        "Prometheus Alertmanager",
        "REST API",
        "Splunk",
        "Important",
        "Splunk metadata",
        "3. Configure destinations (ServiceNow and others)",
        "Configure ServiceNow (example)",
        "Send data to ServiceNow",
        "Custom notification message",
        "Other destinations",
        "Send data to PagerDuty",
        "Send data via webhook",
        "4. Configure pathways",
        "What's next?"
      ],
      "title": "Get started with Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "8c4a5a914ca01cb42250908d2fb1a12ccc697e25",
      "image": "https://docs.newrelic.com/static/5cb28999dc618c6a5a2b8be1fa72e660/b97f6/image-%25281%2529_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence/",
      "published_at": "2022-01-12T08:56:30Z",
      "updated_at": "2021-12-09T22:19:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. Requirements If you haven't already, sign up for a New Relic account to get started. To use most Applied Intelligence features, you must be a full platform user. For more information, see user type capabilities. Set up Incident Intelligence To enable Incident Intelligence, follow these steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges. Can administrators set more than one environment? They can set one environment per parent account and its child accounts. More than one can be set if an administrator has privileges for more than one parent account. Tip Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts. On the left under Incident Intelligence, click Sources and then click Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Tip Adding alerts as a source will not affect your current configuration or notifications. Datarobot (formerly Algorithmia) By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. To configure Datarobot for Incident Intelligence, see our integration docs. Aporia (MLOps) By integrating Incident Intelligence with your Aporia machine-learning models, you can monitor your machine learning model performance. To configure our Aporia integration, see our docs. Superwise (MLOps) By integrating Incident Intelligence with your Superwise machine-learning models, you can monitor your machine learning model performance. To configure our Superwise integration, see our docs. Anomalies By integrating Incident Intelligence with your New Relic Proactive Detection anomalies, you can get context and correlations from what you're monitoring. To get data from New Relic Proactive Detection anomalies: From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Anomalies. Select the configurations you want to connect to Applied Intelligence by toggling to on (green). To add or remove alert policies, from Alerts & AI, click Sources, then Alerts. Tip Adding anomalies as a source won't affect your current Proactive Detection configurations or notifications. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Amazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources, and then click Grafana. Copy the URL, and paste it into your new Grafana webhook. PagerDuty EOL NOTICE As of October 2021, we've discontinued support for several capabilities with PagerDuty, including suggested responders, golden signals, and component enrichment. For more details, including how you can easily make this transition, see our Explorers Hub post. You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Copy Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Important Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME 3. Configure destinations (ServiceNow and others) Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. Configure ServiceNow (example) Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. Send data to ServiceNow To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. When you want to skip a selected field in an issue update, add the | skip_on_update string at the end of the value you've selected. Tip By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column name value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. Other destinations You can set other destinations: Send data to PagerDuty EOL NOTICE As of October 2021, we've discontinued support for several capabilities with PagerDuty, including suggested responders, golden signals, and component enrichment. For more details, including how you can easily make this transition, see our Explorers Hub post. Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Tip There’s a retry mechanism that is triggered a few times with exponential backoff for a couple of minutes once an error occurs. If we reach the retry limit, the Webhook will get auto-disabled. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. What's next? Now that you've set up some sources and destinations for your incidents, read about how to use Incident Intelligence.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 232.61058,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "sections": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " one.newrelic.com, click <em>Alerts</em> &amp; AI. On the left under <em>Incident</em> <em>Intelligence</em>, click Sources and then click Anomalies. Select the configurations you want to connect to <em>Applied</em> <em>Intelligence</em> by toggling to on (green). To add or remove <em>alert</em> policies, from <em>Alerts</em> &amp; AI, click Sources, then <em>Alerts</em>. Tip Adding anomalies"
      },
      "id": "603ea62e64441f119f4e883f"
    }
  ],
  "/docs/alerts-applied-intelligence/notifications/notification-integrations": [
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 353.90814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the muting rules page to temporarily stop your <em>alerts</em> violation notifications. Use workflows to add more data to your <em>alerts</em> notifications. Use <em>destinations</em> to configure where your <em>applied</em> <em>intelligence</em> notifications get sent. Use pathways to configure where your correlated issues get sent. Use"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Get started with Incident Intelligence",
        "Requirements",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "Tip",
        "2. Configure sources",
        "Alerts",
        "Datarobot (formerly Algorithmia)",
        "Aporia (MLOps)",
        "Superwise (MLOps)",
        "Anomalies",
        "AWS",
        "Grafana",
        "PagerDuty",
        "EOL NOTICE",
        "Prometheus Alertmanager",
        "REST API",
        "Splunk",
        "Important",
        "Splunk metadata",
        "3. Configure destinations (ServiceNow and others)",
        "Configure ServiceNow (example)",
        "Send data to ServiceNow",
        "Custom notification message",
        "Other destinations",
        "Send data to PagerDuty",
        "Send data via webhook",
        "4. Configure pathways",
        "What's next?"
      ],
      "title": "Get started with Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "8c4a5a914ca01cb42250908d2fb1a12ccc697e25",
      "image": "https://docs.newrelic.com/static/5cb28999dc618c6a5a2b8be1fa72e660/b97f6/image-%25281%2529_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence/",
      "published_at": "2022-01-12T08:56:30Z",
      "updated_at": "2021-12-09T22:19:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. Requirements If you haven't already, sign up for a New Relic account to get started. To use most Applied Intelligence features, you must be a full platform user. For more information, see user type capabilities. Set up Incident Intelligence To enable Incident Intelligence, follow these steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges. Can administrators set more than one environment? They can set one environment per parent account and its child accounts. More than one can be set if an administrator has privileges for more than one parent account. Tip Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts. On the left under Incident Intelligence, click Sources and then click Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Tip Adding alerts as a source will not affect your current configuration or notifications. Datarobot (formerly Algorithmia) By integrating Incident Intelligence with your Datarobot machine-learning models, you can monitor your machine learning model performance. To configure Datarobot for Incident Intelligence, see our integration docs. Aporia (MLOps) By integrating Incident Intelligence with your Aporia machine-learning models, you can monitor your machine learning model performance. To configure our Aporia integration, see our docs. Superwise (MLOps) By integrating Incident Intelligence with your Superwise machine-learning models, you can monitor your machine learning model performance. To configure our Superwise integration, see our docs. Anomalies By integrating Incident Intelligence with your New Relic Proactive Detection anomalies, you can get context and correlations from what you're monitoring. To get data from New Relic Proactive Detection anomalies: From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Anomalies. Select the configurations you want to connect to Applied Intelligence by toggling to on (green). To add or remove alert policies, from Alerts & AI, click Sources, then Alerts. Tip Adding anomalies as a source won't affect your current Proactive Detection configurations or notifications. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Amazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources, and then click Grafana. Copy the URL, and paste it into your new Grafana webhook. PagerDuty EOL NOTICE As of October 2021, we've discontinued support for several capabilities with PagerDuty, including suggested responders, golden signals, and component enrichment. For more details, including how you can easily make this transition, see our Explorers Hub post. You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Copy Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Important Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME 3. Configure destinations (ServiceNow and others) Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. Configure ServiceNow (example) Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. Send data to ServiceNow To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. When you want to skip a selected field in an issue update, add the | skip_on_update string at the end of the value you've selected. Tip By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column name value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. Other destinations You can set other destinations: Send data to PagerDuty EOL NOTICE As of October 2021, we've discontinued support for several capabilities with PagerDuty, including suggested responders, golden signals, and component enrichment. For more details, including how you can easily make this transition, see our Explorers Hub post. Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Tip There’s a retry mechanism that is triggered a few times with exponential backoff for a couple of minutes once an error occurs. If we reach the retry limit, the Webhook will get auto-disabled. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. What's next? Now that you've set up some sources and destinations for your incidents, read about how to use Incident Intelligence.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 296.29218,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "sections": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " one.newrelic.com, click <em>Alerts</em> &amp; AI. On the left under <em>Incident</em> <em>Intelligence</em>, click Sources and then click Anomalies. Select the configurations you want to connect to <em>Applied</em> <em>Intelligence</em> by toggling to on (green). To add or remove <em>alert</em> policies, from <em>Alerts</em> &amp; AI, click Sources, then <em>Alerts</em>. Tip Adding anomalies"
      },
      "id": "603ea62e64441f119f4e883f"
    },
    {
      "sections": [
        "Destinations",
        "Early access",
        "Tip",
        "Required capabilities",
        "Manage destinations",
        "Destination status",
        "Notifications log"
      ],
      "title": "Destinations",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident Intelligence",
        "Destinations"
      ],
      "external_id": "6a4550f053d167b43178996347fc6a51d2953e59",
      "image": "https://docs.newrelic.com/static/a4a0201ffecf01f56e314de250eeee71/c1b63/destinations-overview.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/notifications/destinations/",
      "published_at": "2022-01-12T07:44:41Z",
      "updated_at": "2021-12-10T06:26:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Early access The features described here are early access. You won't be able to use these features if you're not part of the early access program. For more information on related features, see our docs on Alerts notification channels, Incident Intelligence destinations, and Proactive Detection notifications. Destinations are where we send notifications about your New Relic One data. A destination is a unique identifier for a third-party system that you use. Destination settings contain the connection details to integrate with third-party systems and can be used across a variety of tools in New Relic One. The supported destination platforms include: Atlassian Jira ServiceNow Slack Webhook Email For more on these and other destinations, see notification integrations. Tip It's also possible to configure destinations using the aiNotifications NerdGraph API. Required capabilities Destination settings require specific capabilities: To access your settings: you need View capabilities for Applied Intelligence:Destinations or Alerts. To modify or delete your settings: you need Modify capabilities for Applied Intelligence:Destinations or Alerts. Manage destinations Go to one.newrelic.com, click Alerts & AI, and in the left nav under Enrich and Respond, click Destinations. The destinations table shows information about the existing destinations and allows users to enable, disable, and modify. To add a destination, click the appropriate platform tile. To modify destination settings, click the destination row in the destinations table. one.newrelic.com > Alerts & AI > Destinations. Destination status Destinations have a 'status' value that indicates if we encountered issues while processing and sending events to them (see the destinations table in the above image). Some errors, like Authentication or Authorization issues, require an update to the destination's connection details. After the update, the destination status value will be changed to \"Default\". Notifications log To view past notification events details, go to the Destination menu, and click the Notifications log tab. Notifications log enable you to view the history and status of all your past notifications. Here you can view the status of any notification along with related error details and destination ticket numbers. Filter your destination logs by destination type, sent by, and status.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.86398,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Destinations</em>",
        "sections": "<em>Destinations</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Early access The features described here are early access. You won&#x27;t be able to use these features if you&#x27;re not part of the early access program. For more information on related features, see our docs on <em>Alerts</em> notification channels, <em>Incident</em> <em>Intelligence</em> <em>destinations</em>, and Proactive Detection"
      },
      "id": "618f3a3ee7b9d2bd07388279"
    }
  ],
  "/docs/alerts-applied-intelligence/overview": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1740.9182,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alerts and applied intelligence transition guide",
        "What's changed",
        "An overview of alerts and applied intelligence navigation changes",
        "Analyze",
        "Detect",
        "Correlate",
        "Enrich & notify",
        "Settings",
        "Alerts (classic)",
        "What's changing",
        "February 2022: NRQL baselines to replace outlier NRQL alert condition types.",
        "May 2022: Sliding window aggregations to replace sum of query results thresholds.",
        "2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow.",
        "2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies.",
        "2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types."
      ],
      "title": "Alerts and applied intelligence transition guide",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "EOL",
        "Transition guide"
      ],
      "external_id": "d4f955daf5b142de47ef06ae57e0d0392d2aee5a",
      "image": "https://docs.newrelic.com/static/ff6c0db8c1999f23a21c4b4f11d8afa3/c1b63/alerts-ai-categories.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/transition-guide/",
      "published_at": "2022-01-12T05:33:08Z",
      "updated_at": "2022-01-12T05:33:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Over the course of several months during 2022, new functionalities in New Relic One will replace alerting functionalities reaching end of life (EOL). We are providing these early notices so you can plan accordingly and make a smooth transition. If you have questions or comments about anything in this EOL transition guide, don't hesitate to: Reach out to your New Relic account representative. Use the reply thread in our Explorers Hub post. What's changed Starting in late 2021, we've reorganized the navigation UI for alerts and applied intelligence. Although the alerts and applied intelligence navigation has changed pretty dramatically, all the features you use are still there. Instead of grouping things by features, we've reorganized the navigation into categories that clarify your alerts and applied intelligence workflow. For example, the Analyze category is the place where you can go to see all the recent activity for violations, issues, incidents, and anomalies. We're slowly rolling out this update to all of our users over the next months. An overview of alerts and applied intelligence navigation changes The new UI includes these new categories. Analyze Use the analyze features to scan for critical problems affecting your systems, via alerts violations, issues, incidents, and anomalies. The overview page shows your most recent open, closed, and muted violations. The Issues & activity page shows your most recent issues, incidents, and anomalies. Detect Use the detect features to define the conditions in your system you want to be notified about, as well as configuring how anomalies are detected. The alert conditions (policies) page lists the policies where your conditions are created and organized. Create new policies here. The anomaly detection page lists your expanded anomaly detection configurations. An anomaly is a behavioral trend that doesn't match the historical data for your system. You can add or edit the configurations here. Correlate Use the correlate features to define your data sources and review and configure the logic grouping your incidents together. The sources page shows the data input sources you've chosen to analyze and be notified about. You can add new sources or configure existing ones. Sources include New Relic sources, such as alerts conditions and detected anomalies, as well as third-party sources like AWS Cloudwatch Alarms and PagerDuty. The decisions page shows your correlated incidents. You can review, edit, and add decisions. Enrich & notify Use the enrich and notify features to add additional metadata to your notifications, schedule when you don't want to be notified, and configure where your notifications get sent. Use the muting rules page to temporarily stop your alerts violation notifications. Use workflows to add more data to your alerts notifications. Use destinations to configure where your applied intelligence notifications get sent. Use pathways to configure where your correlated issues get sent. Use incident workflows to automate common problems and actions related to your alerts policies. Use incident destinations to add and configure third-party services for your incidents. Settings Use the settings page to review and manage your current incident intelligence usage. Alerts (classic) Alerts (classic) lets you manage events, incidents, and notification channels with the UI you're used to using. Use the events and incidents pages to review alerts violations and other events. Use the channels page for a list of your alerts notification channels and to create new channels. What's changing Here is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for alerts and applied intelligence. February 2022: NRQL baselines to replace outlier NRQL alert condition types. Reason for EOL: Outlier conditions don't provide efficient cluster identification and analysis capabilities. Replacement: Use NRQL baselines to watch for anomalies in your cluster or to group similar signals. This method is an improvement over outlier conditions, since it will alert you to exactly which member of the group is misbehaving. You may be able to meet the same need as your old outlier conditions by using a faceted baseline condition. Learn more: Faceted baseline conditions documentation Explorers Hub May 2022: Sliding window aggregations to replace sum of query results thresholds. Reason for EOL: The NRQL sum of query results option has not been an ideal way to address issues caused by sporadic signals. It lacks the ability to smooth out volatile signals or efficiently deal with gaps in signal. Replacement: Development for full support for sliding window aggregation in NRQL conditions is underway. You can start using our current sliding windows functionality now. Learn more: Sliding window aggregation documentation Explorers Hub 2nd half of 2022: Native experience in New Relic One to replace classic incident response workflow. Reason for EOL: The classic incident response workflow involves the Incident and Violation details pages in the UI. It also uses APIs for incidents and violations. Replacement: We will replace the current experience by rolling out improved incident response experiences with a new, native UI experience in New Relic One. Learn more: Additional documentation will be provided. Explorers Hub 2nd half of 2022: Workflows and destinations to replace notification channels and relationship to policies. Reason for EOL: The current alerting setup process is rigid and cannot be customized. It also requires restrictive policy-based alert conditions that focus on incident creation. Replacement: Workflows and destinations, a new way to manage issue-driven notifications, will replace current notification channel options. This solution is more flexible, and it enables notifications for all severity levels. Learn more: Additional documentation will be provided for the new workflow. Explorers Hub 2nd half of 2022: NRQL conditions to replace all non-NRQL alert condition types. Reason for EOL: Currently NRQL alert conditions are one type of alert condition we offer. But our many types of alert conditions have resulted in a complex user experience, and the lack of alignment has prevented advances in detection capabilities. Replacement: This is being replaced by NRQL alert conditions with increased functionality. You can start preparing for this transition now by using NRQL alert conditions instead of other types. Learn more: Additional documentation will be provided. Explorers Hub",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1727.8401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "sections": "<em>Alerts</em> <em>and</em> <em>applied</em> <em>intelligence</em> transition guide",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " is a summary of what we plan to EOL in 2022, why this is happening, and what will replace the current experience for <em>alerts</em> and <em>applied</em> <em>intelligence</em>. February 2022: NRQL baselines to replace outlier NRQL <em>alert</em> condition types. Reason for EOL: Outlier conditions don&#x27;t provide efficient cluster"
      },
      "id": "61dda55228ccbcf5cebc4c21"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1426.4307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    }
  ],
  "/docs/alerts-applied-intelligence/transition-guide": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 227.18085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "A list of <em>alert</em> events, some of which are muted",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Alert custom violation descriptions",
        "Requirements",
        "What is a custom violation description?",
        "Create a custom violation description",
        "Custom violation description template example",
        "How to use attributes",
        "Create a custom violation description with NRQL",
        "Mentioning users or notifying channel in Slack",
        "Important"
      ],
      "title": "Alert custom violation descriptions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "080c6ffb472c4587de0f56d58c4ddeb1e85c4e7c",
      "image": "https://docs.newrelic.com/static/49d472a0d630303eef92c1731a943654/31198/new-relic-alert-violation-description-screenshot.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/advanced-techniques/alert-custom-violation-descriptions/",
      "published_at": "2022-01-12T18:40:16Z",
      "updated_at": "2022-01-08T17:05:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some types of conditions, you can define a custom violation description that passes useful information downstream for better violation responses or for use by other systems. You can create a custom violation description in the UI or with NRQL. Requirements The custom violation description feature is available for: NRQL alert conditions Infrastructure monitoring alert conditions The custom violation description field has a maximum character size of 4000. What is a custom violation description? For some types of conditions, you can create a custom violation description that passes information about a condition and its violations downstream. Using a description, you can: Capture the reason for the condition Define the signal being monitored Define next steps Add metadata to downstream systems The Custom violation description field allows you to use a general template structure that, when a violation is generated, substitutes the generic sections with specific values. For example, let's say you used this in a description: This is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Copy A violation resulting from this condition would fill in the details and you'd receive a notification like this: This is my condition name : My Great Alert Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): Click + Add custom violation description to open the field. You can create a custom violation description using the dedicated field for NRQL alerts, or the Describe this condition section for infrastructure alerts. Custom violation description template example Here's a custom violation description template example: this is my condition name : {{conditionName}} The hostname is : {{tags.fullHostname}} Owning Team: {{tags.label.owning_team}} Product: {{tags.label.product}} ec2VpcId: {{tags.aws.ec2VpcId}} Service name : {{tags.label.Name}} AWS Region : {{tags.aws.awsRegion}} AWS Availability Zone: {{tags.aws.awsAvailabilityZone}} Department : {{tags.label.department}} Environment: {{tags.label.environment}} Cluster: {{tags.clusterName}} Cluster Role: {{tags.clusterRole}} EC2 Instance Type: {{tags.instanceType}} EC2 InstanceID: {{tags.aws.ec2InstanceId}} EC2 AmiId: {{tags.aws.ec2AmiId}} EC2 Root Device Type: {{tags.aws.ec2RootDeviceType}} Copy Here's how that data might appear in a notification: How to use attributes The attributes you can use in a custom violation description are a subset of attributes attached to the violation event. Here are some details about the available attributes and how to use them: Violation event attributes: For any of the standard attributes available for use in a custom violation description, use the format {{AN_ATTRIBUTE}}. For example: The target name is : {{targetName}} Copy Tag attributes: For tags, you would use the format {{tags.TAG_NAME}}. There are two types of tags: Entity-related tags: For Infrastructure conditions only. You can find available entity-related tags by going to the New Relic Explorer and looking under a service's Metadata and tags, or by viewing violation details. Here's an example of using tags in a custom violation description: The AWS region is : {{tags.aws.awsRegion}} Responsible team : {{tags.label.owning_team}} Copy Facet clause tags: For NRQL conditions only. If a NRQL condition uses a FACET clause, you can use tags formatting to use those values in your custom violation description. For example, if the NRQL query included FACET hostName, cluster, you could then use this: The host is : {{tags.hostName}} The cluster is : {{tags.cluster}} Copy Please note that tag names cannot include whitespace. The expanded values can include whitespace, but not the names of the tags themselves. Create a custom violation description with NRQL You can create a custom violation description using a NRQL alert condition by creating a mutation with a description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { YOUR_CUSTOM_VIOLATION_DESCRIPTION } } Copy Here's an example mutation with a custom violation description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tags.commandLine}} \\n entityGuid : {{tags.entityGuid}} \\n entityName : {{tags.entityName}} \\n fullHostname : {{tags.fullHostname}} \\n instanceType : {{tags.instanceType}} \\n processDisplayName : {{tags.processDisplayName}}\"}) { description } } Copy For more information on NRQL conditions and using the NerdGraph API, go to NerdGraph API: NRQL condition alerts. For Infrastructure monitoring conditions, you can create the custom violation description when creating an Infrastructure monitoring alert condition. To learn about how to structure a custom violation description, see the example template and the attribute/tag instructions. Mentioning users or notifying channel in Slack When creating a description that you know will be sent to Slack, you may wish to @mention a user or generate a channel-wide notification (for example, @here or @channel). To achieve this, simply include the User ID or a channel-wide notification in the description surrounded by < and > characters. Here's an example for mentioning a user: Attention <@LewCirne> Copy Here's an example for generating a channel-wide notification: Attention <!channel> Copy Important Note that the Slack convention for channel-wide notifications in Incoming Webhooks is to use a ! prefix instead of @. For example, !here or !channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.14183,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alert</em> custom violation descriptions",
        "sections": "<em>Alert</em> custom violation descriptions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and you&#x27;d receive a notification like this: This is my condition name : My Great <em>Alert</em> Condition The hostname is : ip-123-45-67-89.us-west-1.compute.internal Copy Create a custom violation description In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em> policies, (select a policy"
      },
      "id": "6130be2e28ccbc115f56a814"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, browser, mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Multi-location conditions for synthetic monitoring",
        "Multi-location synthetics: Create conditions for policies",
        "Multi-location synthetics: Update conditions for policies",
        "Multi-location synthetics: Delete conditions for policies",
        "Multi-location synthetics: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "af566e5c2f0a695c1146b5531849bb49248ea0ec",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2022-01-12T11:33:08Z",
      "updated_at": "2022-01-08T06:48:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, browser, and mobile (Some limitations apply.) Conditions for external services Conditions for synthetic monitoring Conditions for Multi-location synthetic monitoring Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://example.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://example.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, browser, mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and mobile), and synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is streamed, set the aggregation_method to EVENT_FLOW and use the default settings of 60 for aggregation_window and 120 for aggregation_delay. EVENT_FLOW works in most use-cases, but for a discussion on which use cases work better with EVENT_TIMER, see Which aggregation method to use?. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"aggregation_method\": \"string\", \"aggregation_delay\": integer, \"aggregation_timer\": integer, \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and mobile monitoring apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or mobile monitoring apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or mobile monitoring apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or mobile monitoring), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Multi-location conditions for synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used for multi-location conditions with synthetic monitoring. Before creating or updating a condition, read the rules for multi-location alert conditions. Multi-location synthetics: Create conditions for policies To add conditions to policies for multi-location synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_location_failure_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Location Failure Conditions > GET > List. Multi-location synthetics: Update conditions for policies To update policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Location Failure Conditions > GET > List) The required location_failure_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Location Failure Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"location_failure_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"entities\": [ \"string\" ], \"terms\": [ { \"priority\": \"string\", \"threshold\": integer, } ], \"violation_time_limit_seconds\": integer } }' Copy Multi-location synthetics: Delete conditions for policies To delete policy conditions for multi-location synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Location Failure Conditions > GET > List) API Explorer: Alerts Location Failure Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_location_failure_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Multi-location synthetics: List existing conditions for policies To view a list of existing policy conditions for multi-location synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Location Failure Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_location_failure_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, browser, mobile, synthetic monitoring, and alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity that apply to an entity in APM, browser, mobile, or key transactions, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 182.92062,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "REST API calls for <em>alerts</em>",
        "sections": "REST API calls for <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Our REST API (v2) allows you to configure settings for <em>alerts</em>. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create <em>alert</em> conditions in the UI. Important"
      },
      "id": "6130c144e7b9d2d160b6f25d"
    }
  ],
  "/docs/apis/insights-apis/insights-dashboard-api": [
    {
      "sections": [
        "Insights query API",
        "Tip",
        "Requirements and recommendations",
        "1. Register an API key",
        "2. Create the API query request",
        "Linux",
        "Microsoft Windows",
        "3. Process the returned JSON",
        "Example",
        "Query, query API request, returned data",
        "Rate limiting guidelines"
      ],
      "title": "Insights query API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "fa0e72f1345a7adde2418c08dc8950c970140a74",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/query-insights-event-data-api/",
      "published_at": "2022-01-12T05:38:28Z",
      "updated_at": "2021-07-08T23:30:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Insights query API is a REST API for making NRQL queries. Tip This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. Requirements and recommendations This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. Use of this API may be restricted by role-related user permissions. To add custom data to New Relic, you'd use our data ingest APIs. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. 1. Register an API key To use the Insights query API, you need a query key. You can have multiple query keys, and any query key can be used to initiate any Insights API query. If you have multiple systems querying Insights or different data destinations, New Relic recommends you use multiple query keys to enhance data security. For security reasons, query keys cannot be altered or read using the API. To change or read a query key, use the New Relic UI. Tip This API is no longer the preferred way to query New Relic data. Please use NerdGraph to do that. To create a new query key: Go to insights.newrelic.com > Manage data > API keys. Select the plus icon next to the Query keys heading. Enter a short description of the key. Select Save your notes. 2. Create the API query request When you create or edit a query key, you will see an example curl query that you can use as a template. The example query won't work unless you follow these query rules: The NRQL query string must be URL-encoded. The query string must be less than 4000 bytes. The URL must contain a valid account ID. The X-Query-Key must contain a valid query key. The Content-Type must be application/json. Linux Here is a curl example: curl -H \"Accept: application/json\" -H \"X-Query-Key: YOUR_QUERY_KEY\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=YOUR_URL_ENCODED_QUERY\" Copy Microsoft Windows You can use Powershell to query events via API: Invoke-WebRequest -Uri https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=YOUR_URL_ENCODED_QUERY -Headers @{\"X-Query-Key\"=\"YOUR_QUERY_KEY\"} -ContentType \"application/json\" -Method GET Copy 3. Process the returned JSON The query API returns results in JSON format. There is a limit of 2,000 results per request. The structure of the JSON data depends on the NRQL that you used in the request: Different combinations of SELECT statements, clauses, and functions each return an appropriate response. When writing your code to process the JSON, you should do a test run of your query and examine the resulting JSON. Example The Insights query API returns JSON data. Here's an example of a query, its query request format, and its returned data: Query, query API request, returned data Original NRQL query: SELECT count(appName) FROM PageView SINCE '2014-08-04 00:00:00+0500' Copy Query cURL request (with URL-encoded NRQL query): curl -H \"Accept: application/json\" -H \"X-Query-Key: YOUR_QUERY_KEY\" \"https://insights-api.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/query?nrql=SELECT+count%28appName%29+FROM+PageView+SINCE+%272014-08-04+00%3A00%3A00%2B0500%27\" Copy Returned JSON data: { \"results\": [ { \"count\": 80275388 } ], \"metadata\": { \"eventTypes\": [ \"PageView\" ], \"eventType\": \"PageView\", \"openEnded\": true, \"beginTime\": \"2014-08-03T19:00:00Z\", \"endTime\": \"2017-01-18T23:18:41Z\", \"beginTimeMillis=\": 1407092400000, \"endTimeMillis\": 1484781521198, \"rawSince\": \"'2014-08-04 00:00:00+0500'\", \"rawUntil\": \"`now`\", \"rawCompareWith\": \"\", \"clippedTimeWindows\": { \"Browser\": { \"beginTimeMillis\": 1483571921198, \"endTimeMillis\": 1484781521198, \"retentionMillis\": 1209600000 } }, \"messages\": [], \"contents\": [ { \"function\": \"count\", \"attribute\": \"appName\", \"simple\": true } ] } } Copy Rate limiting guidelines We have query rate limits. You likely won't encounter these limits, especially if you follow these general guidelines: Limit the amount of requests with complex queries (for example, queries with FACET or TIMESERIES clauses, or queries of over a million events) run at the same time. Limit the amount of requests run concurrently over extended periods of time to a maximum of 5, especially if they include complex queries. If New Relic applies rate limits on your account for the number of queries per minute, the query API returns a 429 error. If New Relic applies rate limits on your account for records inspected, the query API returns a 503 error and your charts may display timeout error messages.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.09145,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Insights</em> query <em>API</em>",
        "sections": "<em>Insights</em> query <em>API</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": "-Key: YOUR_QUERY_KEY&quot; &quot;https:&#x2F;&#x2F;<em>insights</em>-<em>api</em>.newrelic.com&#x2F;v1&#x2F;accounts&#x2F;YOUR_ACCOUNT_ID&#x2F;query?nrql=SELECT+count%28appName%29+FROM+PageView+SINCE+%272014-08-04+00%3A00%3A00%2B0500%27&quot; Copy Returned JSON <em>data</em>: { &quot;results&quot;: [ { &quot;count&quot;: 80275388 } ], &quot;metadata&quot;: { &quot;<em>event</em>Types&quot;: [ &quot;PageView&quot; ], &quot;<em>event</em>"
      },
      "id": "609f9c86196a67e93722b170"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2022-01-12T02:25:05Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.46564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring custom <em>events</em> and attributes",
        "sections": "Report mobile monitoring custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " gathers the attributes and events for that session and sends them to <em>Insights</em>. (On iOS, this happens the next time the app is launched). You can then use <em>Insights</em> to query and analyze the <em>event</em> and attribute <em>data</em>. To set the maximum time (in seconds) that the agent will store events in memory, use"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2022-01-12T02:21:28Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.46564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring custom <em>events</em> and attributes",
        "sections": "Report browser monitoring custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " attribute to the PageView <em>event</em> via the browser agent, use the setCustomAttribute browser <em>API</em> call. This allows you to capture an attribute to be annotated on any PageAction <em>event</em>. Forward custom attributes from APM <em>data</em> If you added custom attributes to the APM Transaction <em>event</em> via an APM agent, you"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/apis/insights-apis/query-insights-event-data-api": [
    {
      "sections": [
        "Insights Dashboard API",
        "End of life notice",
        "Requirements",
        "Overview",
        "Example use cases",
        "Account and data security",
        "Use the API Explorer",
        "View Dashboard API video",
        "Use API endpoints",
        "Dashboard API schema",
        "Important",
        "Caution",
        "Example dashboard schema",
        "Dashboard data definitions",
        "Widget data definitions",
        "Supported visualizations"
      ],
      "title": "Insights Dashboard API",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Insights API"
      ],
      "external_id": "71a0104d88a3a8859513802e853850d8b0456606",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/insights-apis/insights-dashboard-api/",
      "published_at": "2022-01-12T05:38:28Z",
      "updated_at": "2021-08-02T03:52:39Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Do not use the Insights Dashboards API. Instead, use the New Relic One Dashboards API with NerdGraph, our GraphQL API. End of life notice The Insights Dashboard API reaches end of life in 2021. As of July 28, 2021, the CREATE and UPDATE endpoints are not available. As of August 30, 2021, the GET and DELETE endpoints are not available. To make the transition from the Insights Dashboard API to the New Relic One Dashboards API, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Overview The Insights Dashboard API allows you to list, create, read, update, and delete new or existing dashboards. New Relic's API Explorer includes the cURL request format, available parameters, response status codes, and JSON response structure for available API calls. Example use cases The Insights Dashboard API is a flexible solution for many different use cases. Here are a few examples of how you can leverage the Dashboard API to solve problems: Automatically create dashboards for new teams or services pre-populated with standard organization metrics and charts. Use the API to view dashboard schemas, and save them in a central repository for source control and backups. Create widget and dashboard templates to allow teams to self-service. Account and data security The Dashboard API includes safeguards to help ensure account and data security. Requirements Comments User key and permissions Required: This API requires a user key. You cannot use your account-level REST API key to manage dashboards. Cross-account widgets You can view cross-account widgets on a dashboard by using the Insights or New Relic One dashboards UI. However, the ability to view cross-account widgets when using the Dashboard API has these restrictions: To view the list of widgets on a specific dashboard with the Dashboard API, you must use the SHOW endpoint. To view a widget in the API payload, the widget's account ID must be the same as the account ID for the payload. If the account ID is not the same, the widget's details will not be listed. Instead, the widget's payload will show: \"visualization\": \"inaccessible\" Copy Use the API Explorer To view the Dashboard API options in the API Explorer: Log in to your New Relic account. Go to rpm.newrelic.com/api/explore. From the API Explorer's Select an account and key dropdown, select a user key. Select Dashboards, then select the API function. To use API functions with existing dashboards, include the dashboard id. To find the dashboard id, select the LIST endpoint, and apply filtering options. View Dashboard API video Follow along with this step-by-step tutorial to learn how to find your API keys, create new dashboards, view and update existing dashboards via the REST API. For a step-by-step guide to using the New Relic API Explorer to manage Insights dashboards, watch this video (approximately 6 minutes). Or, go directly to the full online course about New Relic APIs. Use API endpoints The API supports the following functions for Insights dashboards only. The API does not support these functions for data apps (collections of linked dashboards). API endpoints Comments CREATE POST /v2/dashboards Create a new dashboard. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to POST more than 300 widgets will produce an error. To add more widgets to the dashboard, use the Insights UI. UPDATE PUT /v2/dashboards/:id: Update an existing dashboard for the dashboard id. The API permits a maximum of 300 widgets when creating or updating a dashboard. Attempting to PUT more than 300 widgets will produce an error. To add more or edit existing widgets on the dashboard, use the Insights UI. SHOW GET /v2/dashboards/:id: View an existing dashboard and all accessible widgets for the dashboard id. To help ensure data security, the SHOW function returns only the dashboard widgets that the user has permission to view. If a dashboard includes widgets that the user is not authorized to view, the API will provide a placeholder with the visualization field set to inaccessible. LIST GET /v2/dashboards?page=:page:&per_page=:count: View a paginated list of dashboards. The list shows filterable dashboard metadata only; no widgets will appear in the list. Search options include: filter[title] as substring search filter[category] (all / favorites / mine} filter[created_after] as ISO date filter[created_before] as ISO date filter[updated_after] as ISO date filter[updated_before] as ISO date Sort options include: name recently_viewed last_edited If no sort option is provided, results will be ordered by id. Pagination options include the page and per_page fields. The per_page field controls the number of results per page with a default and maximum of 100 results. The response will include a pagination Link header, which provides next page and last page links. DELETE DELETE /v2/dashboards/:id: Delete an existing dashboard indicated by the dashboard id. Dashboard API schema JSON is the only supported format. When using API functions, be sure to add .json to the end of the request URL, as shown in the API Explorer. Important Widgets have a size limit of 3x3 (height and width may not exceed 3). Caution The Dashboard API 3-column restriction also applies to the dashboards you upload to New Relic One dashboards. If you update a dashboard with a different layout using the API, the uploaded dashboard will revert to the 3-column configuration. Example dashboard schema { \"dashboard\": { \"metadata\": { \"version\": 1 }, \"title\": \"API Widget Sample\", \"icon\":\"none|archive|bar-chart|line-chart|bullseye|user|usd|money|thumbs-up|thumbs-down|cloud|bell|bullhorn|comments-o|envelope|globe|shopping-cart|sitemap|clock-o|crosshairs|rocket|users|mobile|tablet|adjust|dashboard|flag|flask|road|bolt|cog|leaf|magic|puzzle-piece|bug|fire|legal|trophy|pie-chart|sliders|paper-plane|life-ring|heart\", \"grid_column_count\": 3|12, \"visibility\": \"owner|all\", \"editable\": \"read_only|editable_by_owner|editable_by_all\", \"filter\": { \"event_types\": [ \"Transaction\" ], \"attributes\": [ \"appName\" ] }, \"widgets\": [ { \"visualization\": \"billboard|gauge|billboard_comparison\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Threshold Event Chart\", \"notes\": null, \"threshold\": { \"red\": 18000000, \"yellow\": 8000000 } }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 1 } }, { \"visualization\": \"facet_bar_chart|faceted_line_chart|facet_pie_chart|facet_table|faceted_area_chart|heatmap\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT count(*) from Transaction since 5 minutes ago facet appName\" } ], \"presentation\": { \"title\": \"Facet Chart\", \"notes\": null, \"drilldown_dashboard_id\": 64 }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 2 } }, { \"visualization\": \"attribute_sheet|single_event|histogram|funnel|raw_json|event_feed|event_table|uniques_list|line_chart|comparison_line_chart\", \"account_id\": 12345, \"data\": [ { \"nrql\": \"SELECT latest(appName), latest(duration) from Transaction since 5 minutes ago\" } ], \"presentation\": { \"title\": \"Simple Event Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 1, \"column\": 3 } }, { \"visualization\": \"markdown\", \"account_id\": 12345, \"data\": [ { \"source\": \"# Dashboard Note\\n\\n[link goes here](https://www.newrelic.com)\" } ], \"presentation\": { \"title\": \"\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 1 } }, { \"visualization\": \"metric_line_chart\", \"account_id\": 12345, \"data\": [ { \"duration\": 1800000, \"end_time\": null, \"entity_ids\": [ 238575 ], \"metrics\": [ { \"name\": \"Apdex\", \"units\": null, \"scope\": \"\", \"values\": [ \"score\" ] } ], \"order_by\": \"score\", \"limit\": 10 } ], \"presentation\": { \"title\": \"Metric Line Chart\", \"notes\": null }, \"layout\": { \"width\": 1, \"height\": 1, \"row\": 2, \"column\": 2 } }, ] } } Copy Dashboard data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Dashboard data element Description metadata Object Specifies the version of the dashboard schema. The version must be 1. icon String Name of an icon from the Insights icon library. grid_column_count Integer Specifies the number of columns in the grid layout. title String User-supplied title of the dashboard. filter Object Specifies configuration of the smart filter on the dashboard. visibility String Specifies who can view the dashboard in the Insights UI and the API. editable String Specifies who can edit the dashboard in the Insights UI and the API. widgets Array Array of widget data element objects. Widget data definitions For examples of these data elements being used in a JSON call, see the Dashboard API schema. Widget data element Description visualization String What sort of visualization to place in the widget; for example, billboard, line_chart, area chart, etc. data Array Array of objects with chart-specific information needed to query necessary data. Currently only one data object is supported. account_id Long Source account to fetch data from, if not the current account. presentation Object Object with chart title and notes, plus chart-specific customization. layout Object Object with column, row, width, and height to determine chart layout in the dashboard. Supported visualizations The Dashboard API supports: event_table line_chart facet_table facet_bar_chart facet_pie_chart billboard faceted_area_chart faceted_line_chart event_table comparison_line_chart heatmap histogram billboard_comparison attribute_sheet funnel gauge json list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.53667,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Insights</em> Dashboard <em>API</em>",
        "sections": "<em>Insights</em> Dashboard <em>API</em>",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " and DELETE endpoints are not available. To make the transition from the <em>Insights</em> Dashboard <em>API</em> to the New Relic One Dashboards <em>API</em>, see our migration guide. For more information, see the NerdGraph dashboards tutorial and Explorers Hub post. Requirements If your account hosts <em>data</em> in the EU <em>data</em> center"
      },
      "id": "609f9c8664441fc63fd2a1f9"
    },
    {
      "sections": [
        "Report mobile monitoring custom events and attributes",
        "Create custom attributes and events",
        "Mobile event and attribute query examples",
        "Custom event example: Track purchases",
        "Tip",
        "Attribute example: Track a specific user",
        "Attribute example: Track a specific store id",
        "Custom attribute example: Track a specific action",
        "Important",
        "Size limits and restricted characters",
        "Set the time to send data",
        "Privacy considerations"
      ],
      "title": "Report mobile monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "65970eacbedb3360fd1c7394affc8cbc42f2ab0c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-mobile-monitoring-custom-events-attributes/",
      "published_at": "2022-01-12T02:25:05Z",
      "updated_at": "2021-10-23T21:59:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Mobile monitoring in New Relic sends some default event data from your mobile app to New Relic, such as data about interactions, sessions, crashes, and request errors. You can also create your own custom attributes and events for more detailed querying and analysis. Create custom attributes and events You can create custom session-level attributes for default mobile monitoring events using the mobile agent SDKs. For example, to record a username attribute for some part of your iOS or Android app, you would use the setAttribute API (Android | iOS). These attributes are session-related information and are shared by multiple mobile event types. You can also create entirely new custom event types and assign them their own custom attributes, using the recordCustomEvent API (Android | iOS). To help with crash analysis, you can use the SDK to create MobileBreadcrumb and MobileHandledException events. These events are available for querying and also displayed in the crash event trail UI. For more on creating custom attributes and custom events, see: Android SDK API guide iOS SDK API guide NRQL query examples MobileRequestError examples MobileRequest examples Limits and restricted characters Mobile event and attribute query examples Here are some examples of using NRQL to query your mobile app events and attributes: Custom event example: Track purchases To track purchases in your app, use recordCustomEvent to create an event type (such as \"UserAction\") and associate attributes such as \"name\" (with value \"Purchase\"), price, quantity, and SKU. Tip For performance reasons, you should limit the total number of event types to maybe one or two. The recordCustomEvent parameter eventType is meant to be used for high-level categories. For example, you might create an event typeGestures, and then create many different custom event names under the Gesture event type. Create an event on iOS: BOOL purchaseRecorded = [NewRelic recordCustomEvent:@\"UserAction\" attributes:@{@\"name\": @\"Purchase\", @\"sku\": @\"12345LPD\", @\"quantity\": @1, @\"unitPrice\": @99.99, @\"total\": @99.99}]; Copy Create an event on Android: Map<String, Object> userActionAttributes = new HashMap<String, Object>(); userActionAttributes.put(\"name\", \"Purchase\"); userActionAttributes.put(\"sku\", \"12345LPD\"); userActionAttributes.put(\"quantity\", 1); userActionAttributes.put(\"unitPrice\", 99.99); userActionAttributes.put(\"total\", 99.99); boolean userActionRecorded = NewRelic.recordCustomEvent(\"UserAction\", userActionAttributes); Copy New Relic reports a custom event of type UserAction and name Purchase, which allows you to query all purchases made in your app in the last day: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Replace deprecated recordEvent method: As of Android agent version 5.12.0 and iOS agent version 5.12.0, use the recordCustomEvent method to create these custom events. If you have replaced the deprecated recordEvent method for your custom events, be sure to also replace its corresponding NRQL query with the new format. Look for queries used with recordEvent method, such as this: SELECT * from Mobile where category = 'Custom' and name = 'Purchase' since 1 day ago Copy Replace them with the query format used with recordCustomEvent: SELECT * from UserAction where name = 'Purchase' since 1 day ago Copy Attribute example: Track a specific user You can create a custom attribute to track a custom user identifier across the session, and then query for all that user's interactions. To add an attribute for the userId, call the setUserId method: Set the userId on iOS: BOOL userIdWasSet = [NewRelic setUserId:@\"jsmith\"]; Copy Set the userId on Android: boolean userIdWasSet = NewRelic.setUserId(\"jsmith\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that username in the last day: SELECT * from Mobile WHERE userId = 'jsmith' since 1 day ago Copy Attribute example: Track a specific store id You can create a custom attribute to track a store id across the session, and then query for all that store's interactions. To add an attribute for the storeId, call the setAttribute method: Set the storeId on iOS: BOOL attributeSet = [NewRelic setAttribute:@\"storeId\" value:@\"NY0531\"]; Copy Set the storeId on Android: boolean attributeSet = NewRelic.setAttribute(\"storeId\", \"NY0531\"); Copy With this attribute, you can use a WHERE clause to see all actions performed by that storeId in the last day: SELECT * from Mobile WHERE storeId = 'NY0531' since 1 day ago Copy Custom attribute example: Track a specific action You can use custom attributes to track the number of times that a specific action occurs in your application. For example, you can track the number of times a button was clicked or the number of times a level was completed in a game. To track completing a game level, call incrementAttribute with no value specified. This creates an attribute with a default value of 1: Create a counter on iOS: BOOL levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Create a counter on Android: boolean levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Each subsequent call to incrementAttribute adds 1 to the attribute level: Increment a counter on iOS: levelIncremented = [NewRelic incrementAttribute@\"level\"]; Copy Increment a counter on Android: levelIncremented = NewRelic.incrementAttribute(\"level\"); Copy Important Be sure to reset the value to 0 when starting over. To reset the level back to 1 or 0, call setAttribute: Reset a counter on iOS: levelReset = [NewRelic setAttribute:@\"level\" value:@1]; Copy Reset a counter on Android: levelReset = NewRelic.setAttribute(\"level\", 1); Copy When querying, use this level attribute to filter your data. For example, if you have a username and level attribute, use the max() function to find the highest level the user had reached: SELECT max(level) from Mobile where username = 'jsmith' Copy Size limits and restricted characters Limits for custom attributes added to default mobile events: Attributes: 128 maximum String attributes: 4 KB maximum length (empty string values are not accepted) Limits for custom events: Attributes: 254 maximum per event (number includes default session attributes) String attributes: 4 KB maximum length (empty string values are not accepted) Naming syntax and rules: See Rules for custom data. Set the time to send data By default, New Relic transmits event data in any of these situations: A session has been ongoing for 600 seconds. The app session ends by backgrounding. The app crashes. If the app crashes, New Relic gathers the attributes and events for that session and sends them to Insights. (On iOS, this happens the next time the app is launched). You can then use Insights to query and analyze the event and attribute data. To set the maximum time (in seconds) that the agent will store events in memory, use the following SDK calls: iOS method: + (void) setMaxEventBufferTime:(unsigned int)seconds; Copy Android method: public static void setMaxEventBufferTime(int maxBufferTimeInSec); Copy Privacy considerations If you want to collect personal data via custom attributes, please consult with your privacy or legal teams. Be sure to follow your organization's obligations for notices and consent regulations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.46564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report mobile monitoring custom <em>events</em> and attributes",
        "sections": "Report mobile monitoring custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " gathers the attributes and events for that session and sends them to <em>Insights</em>. (On iOS, this happens the next time the app is launched). You can then use <em>Insights</em> to query and analyze the <em>event</em> and attribute <em>data</em>. To set the maximum time (in seconds) that the agent will store events in memory, use"
      },
      "id": "609fa5cf28ccbc508d9832d3"
    },
    {
      "sections": [
        "Report browser monitoring custom events and attributes",
        "Page actions and views",
        "Prerequisites",
        "Create PageAction events",
        "Add custom attributes to PageView event",
        "Use setCustomAttribute browser API call",
        "Forward custom attributes from APM data",
        "PageAction and PageView attributes",
        "Troubleshooting"
      ],
      "title": "Report browser monitoring custom events and attributes",
      "type": "docs",
      "tags": [
        "Insights",
        "Event data sources",
        "Custom events"
      ],
      "external_id": "17c97a462616f2b23ead796b62780a1ffeb3dfac",
      "image": "",
      "url": "https://docs.newrelic.com/docs/data-apis/custom-data/custom-events/report-browser-monitoring-custom-events-attributes/",
      "published_at": "2022-01-12T02:21:28Z",
      "updated_at": "2021-10-23T21:59:19Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use browser monitoring in New Relic to add custom events and attributes. Page actions and views Use the browser API's addPageAction call to capture events, actions, route changes, or any end-user interactions with your application. The addPageAction call adds an event named PageAction that contains the action name and any custom attribute names and values you capture along with it. The PageAction event also contains any custom attributes you added to the PageView event. Add custom attributes to the PageView event so you can query or filter your data to answer more questions about your application. Prerequisites In order to report PageAction events, verify these prerequisites: Requirement Comments Agent version Your browser monitoring agent version must be 593 or higher. Client browser version To record PageAction events, the browser must support cross-domain XHRs. Max events per cycle PageAction events are reported every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that cycle. Event/attribute naming, data type, size Ensure you follow general requirements around event/attribute naming syntax, data types, and size. Create PageAction events To create a PageAction event: Ensure the browser agent is installed for your app. Call the newrelic.addPageAction function in the relevant part of your application's JavaScript. Wait a couple minutes for the application to run and report relevant PageAction events. Run a NRQL query of the PageAction event that includes the actionName attribute you used to capture the event (and any associated attributes you sent along with the action). Add custom attributes to PageView event The PageView event is a default browser-reported event. You can add custom attributes to the PageView event. Any custom attributes you add to the PageView event are also automatically added to the PageAction event. There are two ways to add custom attributes to the PageView event: Use setCustomAttribute browser API call To add a custom attribute to the PageView event via the browser agent, use the setCustomAttribute browser API call. This allows you to capture an attribute to be annotated on any PageAction event. Forward custom attributes from APM data If you added custom attributes to the APM Transaction event via an APM agent, you can forward those custom attributes to the PageView event automatically: Insert custom attributes by following the agent-specific instructions. Enable attribute forwarding in your agent configuration file: Agent Enable attribute forwarding C SDK Not supported. Go To enable attributes, add this to your config (disabled by default): cfg.BrowserMonitoring.Attributes.Enabled = true Copy Then add the attributes you want to include: cfg.BrowserMonitoring.Attributes.Include = []string{\"request.*\"} Copy Java Add the attributes.enabled option in the browser_monitoring stanza and set it to true. .NET Add the <attributes enabled=\"true\"> element as a child of the browserMonitoring element: <configuration xmlns=\"urn:newrelic-config\"> ... <browserMonitoring autoInstrument=\"true\"> ... <attributes enabled=\"true\"> ... </attributes> </browserMonitoring> ... </configuration> Copy If you are using manual browser instrumentation the attribute needs to be created before the GetBrowserTimingHeader() call. Node.js Add attributes: {enabled: true} to the browser_monitoring: { section of your app's newrelicjs configuration file. PHP Add the newrelic.browser_monitoring.attributes.enabled option and set it to true. Python Add the browser_monitoring.attributes.enabled option and set it to true. Ruby Add the browser_monitoring.attributes.enabled option and set it to true. PageAction and PageView attributes To see the default attributes of PageAction and PageView, see Browser events. Troubleshooting Here are some troubleshooting tips: Problem Comments Custom attributes missing If your custom attributes do not appear on PageView events, verify you are calling setCustomAttribute before the Load event on your page. If the custom attribute is called after the page load occurs, it will not be visible on PageView. PageAction events If your PageAction events do not appear when you query, check that your account is compatible. If your account is compatible, check that you are not using reserved attribute names or invalid values.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.46564,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report browser monitoring custom <em>events</em> and attributes",
        "sections": "Report browser monitoring custom <em>events</em> and attributes",
        "tags": "<em>Event</em> <em>data</em> <em>sources</em>",
        "body": " attribute to the PageView <em>event</em> via the browser agent, use the setCustomAttribute browser <em>API</em> call. This allows you to capture an attribute to be annotated on any PageAction <em>event</em>. Forward custom attributes from APM <em>data</em> If you added custom attributes to the APM Transaction <em>event</em> via an APM agent, you"
      },
      "id": "609fa5cfe7b9d2c93dc3eb26"
    }
  ],
  "/docs/apis/intro-apis/introduction-new-relic-apis": [
    {
      "sections": [
        "New Relic API keys",
        "API key UI",
        "Overview of keys",
        "Keys for data ingest",
        "Recommendations for managing ingest keys",
        "Keys for querying and configuration",
        "License key",
        "Create and manage license keys",
        "User key",
        "Browser key",
        "Insights insert key",
        "Important",
        "REST API key",
        "Insights query key",
        "Admin key",
        "Account ID"
      ],
      "title": "New Relic API keys",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "b373cd68cf21daeb5d912ffb4b1ae3f14f500fcc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/",
      "published_at": "2022-01-12T07:47:49Z",
      "updated_at": "2022-01-08T03:11:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has several different APIs that use different API keys. This resource explains our keys, what they're used for, and how to access them. Ready to get started? Make sure you have a New Relic account. It's free, forever! API key UI Most of the keys can be viewed and managed via the API keys UI page: From the account dropdown, click API keys (get a direct link to the API keys page). If you're using NerdGraph, you can manage license keys and user keys from our GraphiQL explorer. Overview of keys If you're using a specific API, see the docs for that API to understand which keys are required and recommended. To learn about our APIs, see Introduction to APIs. Our keys can be broken down into two categories: Keys used for data ingest Keys used for querying and configuration Keys for data ingest There are many ways to get data into New Relic. Here are the API keys used for data ingest: License key: our primary ingest key, used for APM ingest, infrastructure monitoring ingest, and our ingest APIs and the integrations that use them. Browser key: used for browser monitoring ingest. Mobile app token: used for mobile monitoring ingest. Insights insert key: an older key that has been mostly deprecated, it has the same functionality as the license key. We recommend using the license key instead. Recommendations for managing ingest keys Some recommendations for managing data ingest keys: Keep them safe. Because these keys are used for data ingest, we recommend you treat ingest keys securely, like you would a password. This ensures no unwanted data is sent to your New Relic account. If a data ingest key falls into the wrong hands, it would allow someone to send data to your account, which could trigger false alerts and contaminate your data so that detecting actual issues is more difficult. If you believe a data ingest key has been exposed and has generated unwanted data, work with our Support team. Make additional keys. When setting up monitoring solutions that require a data ingest key, we recommend creating a new key, if possible. The original data ingest key for an account or app cannot be deleted or edited, so in order to give you greater management control (for example, deleting a key if exposed), we recommend creating new ones and using those. Keys for querying and configuration Here are keys used for querying New Relic data or configuration of features: User key, also known as a \"personal API key\": used for NerdGraph (our GraphQL API) and for accessing REST API endpoints. REST API key: used for the REST API but we instead recommend using the user key because it has fewer restrictions. Insights query key: used with the Insights query API for querying New Relic data. We recommend using NerdGraph instead of this API. License key Our primary key used for data ingest is called the license key, also referenced in the UI and NerdGraph API as ingest - license. The license key is a 40-character hexadecimal string associated with a New Relic account. Each account in a New Relic organization has at least one license key. When you first sign up for New Relic, that creates an organization with a single account, and that account has its own license key. If more accounts are added, each account will have its own license key. An account's original license key cannot be deleted but you can create additional license keys that can be managed and deleted. The types of data ingest the license key is used for include: APM agent data. Infrastructure agent data. Data sent via our core data ingest APIs (Metric API, Trace API, Event API, Log API), and the SDKs and integrations that use those APIs. The license key is used for almost all New Relic data ingest. The main exceptions are browser monitoring data (which uses a browser key) and mobile monitoring data (which uses a mobile app token). Create and manage license keys For tips on best practices for key management, see Ingest key recommendations. To add, delete, and manage license keys: From the account dropdown, click API keys (get a direct link to the API keys page). You can also create and manage keys with our NerdGraph API. Note that you can't delete or change an account's original license key (the one generated upon account creation). For that, contact New Relic support. User key New Relic user keys, sometimes referred to as \"personal API keys\", are required for using NerdGraph and for the REST API. A user key is tied to both a specific New Relic user and a specific account, and they cannot be transferred. Our APIs that use this key let a user make queries for any accounts that user has been granted access to, not just the specific account the key was created under. If the key's user is deleted, all their user keys will be deactivated and will no longer be valid in API requests. To view and manage the user key and other API keys in the UI: From the account dropdown, click API keys (here's a direct link to the API keys page). To manage this key via API, see Manage keys with NerdGraph. You can also get or generate a user key from the NerdGraph GraphiQL explorer. Browser key One of the New Relic API keys that are used for data ingest is the browser key. The browser key allows the ingestion of data from New Relic browser monitoring. For tips on best practices for key management, see Ingest key recommendations. To view and manage this key: From the account dropdown, click API keys (here's a direct link to the API keys page). You can't manage or delete an original browser key that was created when your account was created. For that, contact New Relic support. Insights insert key Important This key is still in use but we highly recommend using the license key, which can be used for the same things and more. One of the New Relic API keys used for data ingest is the Insights insert key, also known as an \"insert key\"). Note that the license key is used for the same functionality and more, which is why we recommend the license key over this key. This key is used for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. To find and manage Insights insert keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click Insights insert keys. REST API key Important We highly recommend using a user key instead, because that key has fewer restrictions. The REST API key is for using our REST APIs for Alerts, APM, browser, infrastructure alerts, as well as mobile monitoring REST APIs and the API Explorer. Things to consider: We recommend using our newer NerdGraph API over the REST API, if possible. Requires admin-level user permissions. If you don't have access to the REST API key or the REST API explorer, it might be due to lack of permissions. Talk to your New Relic account manager, or use a user key instead. Each New Relic account can have only one REST API key. To find and manage REST API keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click REST API key. Before you configure or delete an API key, ensure you are doing so for the correct account. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. To find and manage Insights query keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click Insights query keys. Admin key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don’t need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says “Migrated from an admin user key” in the key table, so you’ll be able to find them easily. Account ID Looking for the account ID? See Account ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.6706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>API</em> keys",
        "sections": "New Relic <em>API</em> keys",
        "tags": "<em>Intro</em> <em>to</em> <em>APIs</em>",
        "body": "New Relic has several different <em>APIs</em> that use different <em>API</em> keys. This resource explains our keys, what they&#x27;re used for, and how to access them. Ready to <em>get</em> <em>started</em>? Make sure you have a New Relic account. It&#x27;s free, forever! <em>API</em> key UI Most of the keys can be viewed and managed via the <em>API</em> keys"
      },
      "id": "6043fa3464441f1358378f3b"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2022-01-12T08:59:39Z",
      "updated_at": "2022-01-08T03:28:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags APM agents APM agent configuration Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Service levels Configure and manage service levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing model) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.68463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "sections": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "NerdGraph is our GraphQL-format <em>API</em> that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can <em>get</em> <em>started</em> with NerdGraph. What is NerdGraph? New Relic has several <em>APIs</em>. NerdGraph"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster",
        "Troubleshoot from anywhere in your stack"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "f47a40a9afd699e69c351f5e87f64ed5dadd7e43",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/intro-new-relic/",
      "published_at": "2022-01-12T18:27:10Z",
      "updated_at": "2022-01-12T18:27:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. This short video shows twenty of the most common ways to get your data into New Relic (approx. 5:22 minutes): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will set up many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for full stack observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and use distributed tracing to find relevant logs: Bring all your data together Capture, organize, and make sense of your data in New Relic One, no matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data that’s more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic Instant Observability. There you will find integrations bundled into quickstarts, providing you instant access to pre-built dashboards and alerts specific to your technology. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure you’re meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. New Relic One gives you access to a wide range of observability tools, including: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. True observability across your entire stack means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified. Troubleshoot from anywhere in your stack Being fully connected, the New Relic UI allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but they can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.87366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic",
        "sections": "<em>Get</em> <em>started</em> with New Relic",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and <em>APIs</em>, and access it from a single UI. Analyze your data: <em>Get</em> all your data at your fingertips to find the root causes of problems"
      },
      "id": "619d5b3e196a6705bda0837d"
    }
  ],
  "/docs/apis/intro-apis/new-relic-api-keys": [
    {
      "sections": [
        "Introduction to New Relic APIs",
        "APIs for data ingest",
        "NerdGraph (GraphQL)",
        "REST API",
        "APIs by feature",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2022-01-12T05:39:15Z",
      "updated_at": "2021-12-19T15:29:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Send data to New Relic. Retrieve data from New Relic. View and configure settings. This document provides examples and reference information for our APIs. APIs for data ingest Our four primary data ingest APIs are some of the many solutions for reporting data to New Relic. These APIs can be used directly, but they're also the underlying ingest route for any of our tools that use those APIs (for example, our OpenTelemetry integration, or our Telemetry SDKs). API type Description Metric API Send dimensional metrics to New Relic from any source (including other telemetry monitoring services). Event API Send custom event data to New Relic without the use of an agent or integration. Log API Send log data to New Relic. Trace API Send distributed tracing data (also referred to as \"spans\") to New Relic without the use of an agent or integration. NerdGraph (GraphQL) NerdGraph is the API we recommend for querying New Relic data, querying account information, and making a range of feature configurations. To learn what you can do, check out the NerdGraph tutorials. NerdGraph is our newest API and is our attempt to bring together in one place some of our older APIs, like our REST API. Note that there is still some functionality you can do with REST APIs that can't yet be done with NerdGraph, and this is why some New Relic organizations still use the REST API. REST API Our REST API is our older API for querying and configuration, which NerdGraph is in the process of replacing. The REST API has some configuration abilities that NerdGraph doesn't yet have, but when possible you should use NerdGraph. The REST API can be used for a wide range of features: for detail, see APIs by feature. APIs by feature New Relic tools and features, like APM, infrastructure monitoring, browser monitoring, and alerts, are often used together, and sometimes can overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The browser API resources include: Resource Details Browser agent API Use the browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To query New Relic data, use NerdGraph. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To query New Relic data, use NerdGraph. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To query New Relic data, use NerdGraph. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To query New Relic data, use NerdGraph. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage (original pricing model) For organizations on our original pricing model, you can use NerdGraph to query subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API If you're a New Relic partnership organization, you can use the Partner API to retrieve data and make configurations. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing models that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API Our Insights Query API is mostly deprecated. Instead, use NerdGraph for querying your New Relic data. Dashboard API Use the Dashboards API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 231.98653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic <em>APIs</em>",
        "sections": "<em>Introduction</em> <em>to</em> New Relic <em>APIs</em>",
        "tags": "<em>Intro</em> <em>to</em> <em>APIs</em>",
        "body": " <em>APIs</em> Mobile <em>APIs</em> let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android REST <em>API</em> Use the REST <em>API</em> for such tasks as: Retrieve a list of monitored apps. <em>Get</em> subscription usage data. <em>Get</em> metric names and data. <em>Get</em> crash count and crash"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2022-01-12T08:59:39Z",
      "updated_at": "2022-01-08T03:28:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags APM agents APM agent configuration Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Service levels Configure and manage service levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing model) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.68463,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "sections": "<em>Introduction</em> <em>to</em> New Relic NerdGraph, our GraphQL <em>API</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "NerdGraph is our GraphQL-format <em>API</em> that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can <em>get</em> <em>started</em> with NerdGraph. What is NerdGraph? New Relic has several <em>APIs</em>. NerdGraph"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster",
        "Troubleshoot from anywhere in your stack"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "f47a40a9afd699e69c351f5e87f64ed5dadd7e43",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/intro-new-relic/",
      "published_at": "2022-01-12T18:27:10Z",
      "updated_at": "2022-01-12T18:27:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. This short video shows twenty of the most common ways to get your data into New Relic (approx. 5:22 minutes): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will set up many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for full stack observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and use distributed tracing to find relevant logs: Bring all your data together Capture, organize, and make sense of your data in New Relic One, no matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data that’s more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic Instant Observability. There you will find integrations bundled into quickstarts, providing you instant access to pre-built dashboards and alerts specific to your technology. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure you’re meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. New Relic One gives you access to a wide range of observability tools, including: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. True observability across your entire stack means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified. Troubleshoot from anywhere in your stack Being fully connected, the New Relic UI allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but they can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.87366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> New Relic",
        "sections": "<em>Get</em> <em>started</em> with New Relic",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and <em>APIs</em>, and access it from a single UI. Analyze your data: <em>Get</em> all your data at your fingertips to find the root causes of problems"
      },
      "id": "619d5b3e196a6705bda0837d"
    }
  ],
  "/docs/apis/nerdgraph/examples/apm-config-nerdgraph": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29395,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9085,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/configure-infinite-tracing-graphql": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29358,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/create-widgets-dashboards-api": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29358,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9084,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/export-dashboards-pdfpng-using-api": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.2932,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.0073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/export-import-dashboards-using-api": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.2932,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.0073,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/golden-metrics-entities-nerdgraph-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00702,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/manage-live-chart-urls-via-api": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00702,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90808,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90796,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-data-partition-rules-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00674,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster",
        "Troubleshoot from anywhere in your stack"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "f47a40a9afd699e69c351f5e87f64ed5dadd7e43",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/intro-new-relic/",
      "published_at": "2022-01-12T18:27:10Z",
      "updated_at": "2022-01-12T18:27:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. This short video shows twenty of the most common ways to get your data into New Relic (approx. 5:22 minutes): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will set up many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for full stack observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and use distributed tracing to find relevant logs: Bring all your data together Capture, organize, and make sense of your data in New Relic One, no matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data that’s more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic Instant Observability. There you will find integrations bundled into quickstarts, providing you instant access to pre-built dashboards and alerts specific to your technology. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure you’re meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. New Relic One gives you access to a wide range of observability tools, including: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. True observability across your entire stack means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified. Troubleshoot from anywhere in your stack Being fully connected, the New Relic UI allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but they can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.52682,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our <em>NerdGraph</em> <em>Graph</em>QL <em>API</em>. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable"
      },
      "id": "619d5b3e196a6705bda0837d"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-distributed-trace-data-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.2921,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00647,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00647,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2022-01-12T08:59:39Z",
      "updated_at": "2022-01-08T03:28:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags APM agents APM agent configuration Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Service levels Configure and manage service levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing model) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.5,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "sections": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> <em>API</em>",
        "tags": "<em>APIs</em>",
        "body": "<em>NerdGraph</em> is our <em>Graph</em>QL-format <em>API</em> that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with <em>NerdGraph</em>. What is <em>NerdGraph</em>? New Relic has several <em>APIs</em>. <em>NerdGraph</em>"
      },
      "id": "6043ff97196a67d0a0960f55"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-log-parsing-rules-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29172,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster",
        "Troubleshoot from anywhere in your stack"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "f47a40a9afd699e69c351f5e87f64ed5dadd7e43",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/intro-new-relic/",
      "published_at": "2022-01-12T18:27:10Z",
      "updated_at": "2022-01-12T18:27:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. This short video shows twenty of the most common ways to get your data into New Relic (approx. 5:22 minutes): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will set up many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for full stack observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and use distributed tracing to find relevant logs: Bring all your data together Capture, organize, and make sense of your data in New Relic One, no matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data that’s more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic Instant Observability. There you will find integrations bundled into quickstarts, providing you instant access to pre-built dashboards and alerts specific to your technology. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure you’re meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. New Relic One gives you access to a wide range of observability tools, including: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. True observability across your entire stack means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified. Troubleshoot from anywhere in your stack Being fully connected, the New Relic UI allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but they can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 316.52625,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our <em>NerdGraph</em> <em>Graph</em>QL <em>API</em>. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable"
      },
      "id": "619d5b3e196a6705bda0837d"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-nrql-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29172,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-relationships-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29172,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-slm": [
    {
      "sections": [
        "Service level management: Questions and next steps",
        "BETA FEATURE",
        "What permissions do I need to use New Relic's service levels?",
        "How do I get support from New Relic during the public beta?",
        "Why don’t I see any data right after I create an SLI?",
        "Can I configure an SLI on any entity type?",
        "Can I get alerts on SLI data?",
        "How does New Relic calculate the remaining error budget?",
        "How can I view the queries that define an SLI from the UI?",
        "How can I view the queries that define an SLI through the API?",
        "Can I chart the SLI attainment on a dashboard?"
      ],
      "title": "Service level management: Questions and next steps",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service level management"
      ],
      "external_id": "262058f4dc430fbaee0382261f79de147e348f53",
      "image": "https://docs.newrelic.com/static/763695119ceaa7668fdb3fb858c83c75/c1b63/slm_edit_menu_2.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/faqs-slm/",
      "published_at": "2022-01-12T07:58:23Z",
      "updated_at": "2022-01-08T02:39:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic's service levels? To use New Relic's service levels and see SLO results, you need a full platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify events to metric rules. If you get the following errors, check your user permissions: The UI has disabled the option to save an SLI/SLO. The API returns the error message “Cannot query field \\\"eventExportRegisterRule\\\" on type \\\"RootMutationType\\\".”. How do I get support from New Relic during the public beta? Service level management is in public beta, and no official support is offered yet through the Support portal. If you have general questions and feedback, please post them on the Explorers Hub. New Relic’s community and the product team will be glad to help you there. If you have suggestions about documentation, please suggest an improvement or send your contribution using the Create issue or Edit page buttons on the top right corner in the docs UI. Why don’t I see any data right after I create an SLI? New Relic starts generating new SLI metrics from the moment that you create an SLI. This is why we need a few minutes before we can start showing the first meaningful SLI attainment results. The benefit of the new data is that it has 13 month retention by default, and it’s more efficient to query for long periods of time. Can I configure an SLI on any entity type? Yes, you can configure an SLI on any entity type, such as an APM service, a browser application, or a Lambda function. SLI queries support NRDB events. Support for dimensional metrics on SLI queries is on our roadmap. Can I get alerts on SLI data? Alerts on New Relic's service levels are on our roadmap. How does New Relic calculate the remaining error budget? The remaining error budget indicates what percentage of requests could still have a bad response over the SLO period without compromising the objective. Therefore, the total amount of tolerated bad responses will vary with the throughput of requests. Time-based error budgets are on our roadmap. How can I view the queries that define an SLI from the UI? To view the queries that define an SLI, you can click on the ... menu on the SLI summary card, then select the Edit option. The queries will show at the top-right corner. How can I view the queries that define an SLI through the API? To view the queries that define an SLI through the API, use Nerdgraph. In order to view the SLI configuration, you'll need to know the GUID of the entity the SLI is attached to, and replace it in the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { events { badEvents { where from } goodEvents { from where } validEvents { from where } } name } } } } } Copy As a response you are going to receive all the SLIs attached to the entity, the SLI name, and the queries. Keep in mind that either goodEvents or badEvents is going to have content, depending on the configuration of the SLI. Can I chart the SLI attainment on a dashboard? You can chart SLI attainment time series on your custom dashboards using the following query: FROM Metric SELECT clamp_max((count(newrelic.sli.valid) - count(newrelic.sli.bad)) / count(newrelic.sli.valid) * 100, 100) as 'SLI attainment' WHERE sli.id = '<sli.id>' UNTIL 2 MINUTES AGO TIMESERIES AUTO Copy Where sli.id is the SLI identifier. The easiest way to add a chart like this to your dashboard is by using the Add to dashboard option, available on the Details view. Alternatively, you can find the SLI id and SLI attainment query through the Nerdgraph API with the following query: { actor { entity(guid: \"{entityGuid}\") { serviceLevel { indicators { name id resultQueries { indicator { nrql } } } } } } } Copy Use the entityGuid of the entity that's associated with the SLI. On the query results, you’ll get the SLI id in the serviceLevel.indicators.id field.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 717.5551,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Service</em> <em>level</em> <em>management</em>: Questions and <em>next</em> steps",
        "sections": "<em>Service</em> <em>level</em> <em>management</em>: Questions and <em>next</em> steps",
        "tags": "<em>Service</em> <em>level</em> <em>management</em>",
        "body": "BETA FEATURE This feature is currently in beta. What permissions do I need to use New Relic&#x27;s <em>service</em> levels? To use New Relic&#x27;s <em>service</em> levels and see <em>SLO</em> results, you need a <em>full</em> platform user. However, in order to create new SLIs and SLOs, you need the specific capability in your role to modify"
      },
      "id": "61ab3a9d28ccbc492ac23ee2"
    },
    {
      "sections": [
        "Get started with New Relic's service level management",
        "BETA FEATURE",
        "What are SLIs and SLOs?",
        "Service levels and APM SLA reports",
        "What's next?"
      ],
      "title": "Get started with New Relic's service level management",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started",
        "Service levels management"
      ],
      "external_id": "c3da65667ad9557562bd537c738309d80d3f31ee",
      "image": "https://docs.newrelic.com/static/a0a3554edde9777dc70c4ee8281fddd6/01e7c/slm1_1.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/intro-slm/",
      "published_at": "2022-01-12T07:44:40Z",
      "updated_at": "2022-01-08T01:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. With New Relic you can define and consume service level indicators and service level objectives for your applications. What are SLIs and SLOs? Service levels are used to measure the performance of a service from the end user (or client application) point of view. For instance, a Service Level can represent whether a video loaded quickly enough, or whether a directions service returned at least one possible route between two points. Service level indicators (SLIs) are accurate quantitative measures of the user experience as described by a service level. They represent a proportion of successful outputs, and therefore they’re expressed as a percentage (%). For example, an SLI can measure the proportion of requests that were faster than some threshold, or the proportion of records coming into a pipeline that resulted in the correct value coming out. And while users understand that a video might take a few additional seconds to load, or that an application might return an error from time to time, this shouldn’t happen often if you don’t want to lose their trust. Therefore, once you’ve defined SLIs for the performance aspects that are most relevant for the end users of your services, you need to set SLOs to track that the service is meeting their expectations. Service level objectives (SLOs) are defined as a target value that an SLI must meet over a period of time. For example, videos must start playing in less than 2 seconds 99% of the time over a week period. Please refer to the Service level management use case implementation guide to learn more about identifying service boundaries and deploying the instrumentation that your service levels will be based on. Service levels and APM SLA reports New Relic has provided automatic SLA Reports for APM Services for a long time. The Apdex-based reports, which you can get on your email inbox on Mondays, are automatically generated for services that produce web transactions, and are useful to see trends over time. On top of the SLAs, our new SLM level capability is better aligned with modern service level best practices, such as those promoted by the Google SRE Handbook, and provides new, improved functionality: SLIs can be defined on any NRDB event that is reported to New Relic, not just APM transactions. Therefore you can also base SLIs on your own custom events. You can decide which service boundaries and which metrics are relevant for your service levels, and you can set your own objectives. You can view SLO results across your accounts, and within your workloads. What's next? Ready to get started? If you don't already have one, sign up for a free New Relic account. You can find service levels in several places in New Relic One: At the top nav bar, under the More menu (which you can customize). At the previews of those entities that have an SLI defined. In APM services, at the reports section. Within a workload, at the service levels tab. Carry on and read our docs on how to create and consume SLIs and SLOs. You can also check out how to manage SLMs with our API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 695.7576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>New</em> Relic&#x27;s <em>service</em> <em>level</em> <em>management</em>",
        "sections": "Get started with <em>New</em> Relic&#x27;s <em>service</em> <em>level</em> <em>management</em>",
        "tags": "<em>Service</em> <em>levels</em> <em>management</em>",
        "body": "BETA FEATURE This feature is currently in beta. With New Relic you can define and <em>consume</em> <em>service</em> <em>level</em> indicators and <em>service</em> <em>level</em> objectives for your applications. What are SLIs and SLOs? <em>Service</em> levels are used to measure the performance of a <em>service</em> from the end user (or client application"
      },
      "id": "61a824fe28ccbcc5e3c22dc5"
    },
    {
      "sections": [
        "Consume service levels",
        "BETA FEATURE",
        "Check your SLOs state",
        "Understand service levels details",
        "Good and bad responses",
        "SLI attainment over time (%)",
        "Compliance over the period",
        "Remaining error budget (Requests)",
        "SLI attainment over time and SLO target (%)",
        "Analyze bad responses"
      ],
      "title": "Consume service levels",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Service levels management",
        "SLI/SLO",
        "Consume"
      ],
      "external_id": "2b1e77937fb81e4b43d6f81d660e53f1cbbb5f80",
      "image": "https://docs.newrelic.com/static/5ecaa57f52ed11c79de67ea6200443c8/c1b63/sli_card.png",
      "url": "https://docs.newrelic.com/docs/service-level-management/consume-slm/",
      "published_at": "2022-01-12T05:34:50Z",
      "updated_at": "2022-01-08T02:38:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "BETA FEATURE This feature is currently in beta. After you create your set of SLIs and SLOs, New Relic will start generating SLI data. The first results will take a few minutes to appear in the New Relic One UI. Find service levels: At the top nav bar, under Service Levels in the More menu (which you can customize). Here you can filter the SLIs by entity tags. At the previews of those entities that have an SLI defined. You can find them all around the UI. For instance, click on an entity from the Explorer's Navigator view. In APM services, at the reports section. In any workload that contains the SLI entity, such as an APM service or browser application. If you want to group SLIs under a certain workload, make sure to add the APM service or browser app to an existing workload, or create a new one. Click on any SLI to open the SLI card, which contains: The entity the SLI refers to, and the SLI name. Each row represents an SLO with: Target and time window. Compliance in the SLO period. Remaining requests error budget. Check your SLOs state Request-based SLOs are determined from SLIs defined as the ratio of the number of good responses to the total number of requests. This means a request-based SLO is met when that ratio meets or exceeds the goal for the SLO compliance period. If the SLO row has a green background, you’re doing good for the period. You may have not served successfully 100% of the requests, but you still have some remaining error budget to consume. If the SLO row has a yellow background, your error budget is closer to being totally consumed, and you should be more cautious for the rest of the period. If the SLO row has a red background, you’ve not reached the target SLO in this period, and you’ve consumed all of your error budget. Be careful if you need to deploy, and plan some work to improve your SLIs. You can click on the SLO to see more data about the entity, such as the golden metrics, the latest deployments, anomalies, and ongoing issues. This data can help you understand when and why you missed the SLO targets. You can define more than one SLO for the same SLI to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to consume most of it in a single day, or the SLO will be at risk for the rest of the week. Understand service levels details We provide SLI details for two main purposes: For SLO analysis: See in which time ranges the SLO targets were missed. For SLI/SLO configuration and fine tuning: Learn how New Relic calculated SLO values. The SLI card contains the following charts: Good and bad responses These are the key concepts to analyze service levels: A valid request is any request that you want to count as meaningful for your SLIs. A good response is any response that you consider to provide a good experience (for example, the service responded in less than 2 seconds, providing a good navigation experience for the end user). A bad response is any response that you consider to provide a bad experience (like the service responded with a server error, interrupting the user's flow). This chart shows the total number of valid requests that your service received, broken down by good or bad. This chart shows the actual throughput of your service, which you can use to see if there’s any correlation between the increase of throughput and bad responses. SLI attainment over time (%) It's the proportion of what you consider good responses over time. The line should stay close to 100%, meaning that most requests were served successfully. Compliance over the period It's the ratio of good events (responses) to total events (requests), measured over the SLO compliance period. The closer to 100%, the closer your service is to meet the SLO target over the period. When this percentage goes below the SLO target, the chart will turn red: You need to put more effort in reliability. Remaining error budget (Requests) The error budget is an alternative way to read the SLO. It indicates what percentage of requests could still have a bad response over the SLO period, without compromising the objective. As the total amount of tolerated bad responses will vary with the request throughput, New Relic shows the percentage of remaining error budget: As long as the remaining error budget is above 25%, you'll see green, and your SLO is good. When the error budget goes below 25%, it will turn yellow. This means you’re close to burning the whole budget for the period. You may want to be more careful with new deployments and changes, and plan for some reliability work. Once the error budget is completely spent, it will show in red. SLI attainment over time and SLO target (%) The last chart shows two time series: the (SLI attainment over time) [#sli-over-time] , and the SLO target. When the SLI value is below the SLO target,your service is missing the SLO. Use this chart to learn in which time ranges your service missed the SLO target. Analyze bad responses When an SLO is not compliant, you need to analyze the original data to better understand what the impact is for your customer, with a special focus on what went wrong. At the Service Levels page, click the ... menu in any SLI and select Analyze. You'll access the query that represents the original NRDB events used to determine the bad responses which calculate the SLI attainment. You can then use the query builder to facet and filter down the unsuccessful responses by user account, client id, requesting source, etc. to better understand the cause and impact of missing your SLIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 678.86,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Consume</em> <em>service</em> <em>levels</em>",
        "sections": "<em>Consume</em> <em>service</em> <em>levels</em>",
        "tags": "<em>Service</em> <em>levels</em> <em>management</em>",
        "body": " for the same <em>SLI</em> to check how fast you’re consuming the error budget. For instance, if you have an error budget of 0,1% requests for a whole week, you may not want to <em>consume</em> most of it in a single day, or the <em>SLO</em> will be at risk for the rest of the week. Understand <em>service</em> levels details We provide"
      },
      "id": "61ab3a9d28ccbc4b5fc23f44"
    }
  ],
  "/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00592,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.90753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/examples/topology-nerdgraph-tutorial": [
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2022-01-12T08:59:39Z",
      "updated_at": "2022-01-08T03:28:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags APM agents APM agent configuration Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Service levels Configure and manage service levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing model) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 502.76447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "sections": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "tags": "<em>NerdGraph</em>",
        "body": " Dashboard API to <em>NerdGraph</em> Alerts See all alert-related tutorials <em>Applied</em> <em>Intelligence</em> View and configure <em>topology</em> Workloads View and configure workloads Service levels Configure and manage service levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Important",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2022-01-12T08:04:24Z",
      "updated_at": "2022-01-12T08:04:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use a subset of violation event attributes (specifically accountId, conditionId, conditionName, entity.guid, nrqlEventType, nrqlQuery, policyId, policyName, runbookUrl (as conditionRunbookUrl), tags.<NAME>, and targetName) and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. Important The Repeat day of the week checkboxes override the Starts and Ends date fields. If you set a start date and also choose a day of the week, your muting rules will be applied on the first of those days after your start date You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from infrastructure conditions where the target host is host-1 or the violation was from synthetic or mobile monitoring: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and synthetics/mobile mute rule\", description: \"Mute host-1 and synthetics/mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 402.51587,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Manage muting rules with <em>NerdGraph</em>",
        "tags": "Alerts and <em>Applied</em> <em>Intelligence</em>",
        "body": " of occurrences. Manage muting rules with <em>NerdGraph</em> In <em>NerdGraph</em>, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "NerdGraph tutorial: Notification channels",
        "Tip",
        "Get notification channels",
        "List all notification channels for an account",
        "Paginate through notification channels with cursor pagination",
        "Find a specific notification channel by id",
        "List notification channels with their associated policies",
        "Create a notification channel",
        "Caution",
        "Create an email notification channel",
        "Create an OpsGenie notification channel",
        "Create a PagerDuty notification channel",
        "Create a Slack notification channel",
        "Create a VictorOps notification channel",
        "Create a Webhook notification channel",
        "Create an xMatters notification channel",
        "Update a notification channel",
        "Update an email notification channel",
        "Update an OpsGenie notification channel",
        "Update a PagerDuty notification channel",
        "Update a Slack notification channel",
        "Update a VictorOps notification channel",
        "Update a Webhook notification channel",
        "Update an xMatters notification channel",
        "Delete a notification channel",
        "Associate channels to a policy",
        "Dissociate a channel from a policy"
      ],
      "title": "NerdGraph tutorial: Notification channels",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and NerdGraph"
      ],
      "external_id": "d62b37e04d0601fec177951123d72e13f57458a0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/advanced-alerts/alerts-nerdgraph/nerdgraph-api-notification-channels/",
      "published_at": "2022-01-12T18:43:45Z",
      "updated_at": "2021-11-15T05:31:06Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alert notification channels using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. Get notification channels The notificationChannels query allows you to paginate through all of your notification channels per account. You can also use the notificationChannel query to get a specific notification channel by its ID. Tip Note that certain secret fields (for example, passwords or API keys) are obfuscated in the returned fields. List all notification channels for an account This example returns every field for every notification channel on the supplied account ID, up to the page limit of 200. Note how we use inline fragments to refer to the specific fields on the concrete types implementing the AlertsNotificationChannel interface. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type ... on AlertsXMattersNotificationChannel { config { integrationUrl } } ... on AlertsWebhookNotificationChannel { config { baseUrl basicAuth { password username } customHttpHeaders { name value } customPayloadBody customPayloadType } } ... on AlertsVictorOpsNotificationChannel { config { key routeKey } } ... on AlertsUserNotificationChannel { config { userId } } ... on AlertsSlackNotificationChannel { config { teamChannel url } } ... on AlertsPagerDutyNotificationChannel { config { apiKey } } ... on AlertsOpsGenieNotificationChannel { config { apiKey dataCenterRegion recipients tags teams } } ... on AlertsHipChatNotificationChannel { config { authToken baseUrl roomId } } ... on AlertsEmailNotificationChannel { config { emails includeJson } } ... on AlertsCampfireNotificationChannel { config { room subdomain token } } } totalCount nextCursor } } } } } Copy Paginate through notification channels with cursor pagination If a given account's list of notification channels exceeds the 200 channel page limit, you can use the pagination cursor to retrieve additional pages. With cursor pagination, you continue to request additional pages using the nextCursor until that field returns empty in the response. An empty nextCursor signals that you have reached the end of the result set. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type } totalCount nextCursor } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"notificationChannels\": { \"channels\": [ { \"id\": \"250\", \"name\": \"Channel 1\", \"type\": \"SLACK\" }, { \"id\": \"713\", \"name\": \"Channel 2\", \"type\": \"WEBHOOK\" }, // ... +198 more notification channels in reality ], \"nextCursor\": \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\", \"totalCount\": 268 } } } } } } Copy In your next request, provide the cursor like so, updating each subsequent request to return the updated cursor, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels(cursor: \"Wh4LK9JYzfACVlNkyvf7Rg==:I5VbSEpgx3UWNA5AOVsUPv4=\") { channels { id name type } totalCount nextCursor } } } } } Copy Find a specific notification channel by id If you have a specific notification channel's ID, the API allows you to look it up directly. Note that because the specific channel is a concrete type implementing the AlertsNotificationChannel interface, you may need to specify certain fields using the ... on syntax for inline fragments. In this example, we are retrieving a Slack channel: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannel(id: YOUR_CHANNEL_ID) { id name type ... on AlertsSlackNotificationChannel { config { teamChannel url } } } } } } } Copy List notification channels with their associated policies This example returns the ID, name, and type for every notification channel on the supplied account ID, as well as a list of every policy that is associated with that channel. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { notificationChannels { channels { id name type associatedPolicies { policies { id name } totalCount } } nextCursor totalCount } } } } } Copy Create a notification channel In order to create an alert notification channel, you need to know the specific type of notification channel you want to create (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Once a notification channel has been created, it can be associated with one or more alert policies. Once associated, those channels will receive notifications from those policies when conditions are violated. Caution While you can query for any existing notification channel type, you can only create a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Create an email notification channel An example create mutation for an email notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { email: { emails: [\"email@example.com\"], includeJson: true, name: \"Some Name <email@example.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type config { emails includeJson } } } error { description errorType } } } Copy Create an OpsGenie notification channel An example create mutation for an OpsGenie notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { opsGenie: { apiKey: \"api-key-from-opsgenie\", dataCenterRegion: US, name: \"OpsGenie notification channel name\", recipients: [\"user@example.com\"], tags: [\"tag1\", \"tag2\"], teams: [\"team1\", \"team2\"] } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type config { apiKey teams tags recipients dataCenterRegion } } } error { description errorType } } } Copy Create a PagerDuty notification channel An example create mutation for a PagerDuty notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty notification channel name\", apiKey: \"api-key-from-pagerduty\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type config { apiKey } } } error { description errorType } } } Copy Create a Slack notification channel An example create mutation for a Slack notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { slack: { name: \"Slack notification channel name\", teamChannel: \"#team-channel\", url: \"https://hooks.slack.com/services/FAKE/MOREFAKE/IMAGINARYEXAMPLEURLCHUNK\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type config { teamChannel url } } } error { description errorType } } } Copy Create a VictorOps notification channel An example create mutation for a VictorOps notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { victorOps: { key: \"example-api-key-from-victorops\", name: \"VictorOps notification channel name\", routeKey: \"example-route-key\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type config { key routeKey } } } error { description errorType } } } Copy Create a Webhook notification channel An example create mutation for a Webhook notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { webhook: { baseUrl: \"https://example.com/webhook\", basicAuth: { password: \"t0t4lly-s3cr3t-p455w0rd\", username: \"webhook-user\" }, customHttpHeaders: [ {name: \"X-Api-Key\", value: \"100%-real-api-key\"}, {name: \"X-Calling-Service\", value: \"New Relic Alerts\"} ], customPayloadBody: \"{ \\\"account_id\\\": \\\"$ACCOUNT_ID\\\", \\\"account_name\\\": \\\"$ACCOUNT_NAME\\\", \\\"closed_violations_count_critical\\\": \\\"$CLOSED_VIOLATIONS_COUNT_CRITICAL\\\", \\\"closed_violations_count_warning\\\": \\\"$CLOSED_VIOLATIONS_COUNT_WARNING\\\", \\\"condition_description\\\": \\\"$DESCRIPTION\\\", \\\"condition_family_id\\\": \\\"$CONDITION_FAMILY_ID\\\", \\\"condition_name\\\": \\\"$CONDITION_NAME\\\", \\\"current_state\\\": \\\"$EVENT_STATE\\\", \\\"details\\\": \\\"$EVENT_DETAILS\\\", \\\"duration\\\": \\\"$DURATION\\\", \\\"event_type\\\": \\\"$EVENT_TYPE\\\", \\\"incident_acknowledge_url\\\": \\\"$INCIDENT_ACKNOWLEDGE_URL\\\", \\\"incident_id\\\": \\\"$INCIDENT_ID\\\", \\\"incident_url\\\": \\\"$INCIDENT_URL\\\", \\\"metadata\\\": \\\"$METADATA\\\", \\\"open_violations_count_critical\\\": \\\"$OPEN_VIOLATIONS_COUNT_CRITICAL\\\", \\\"open_violations_count_warning\\\": \\\"$OPEN_VIOLATIONS_COUNT_WARNING\\\", \\\"owner\\\": \\\"$EVENT_OWNER\\\", \\\"policy_name\\\": \\\"$POLICY_NAME\\\", \\\"policy_url\\\": \\\"$POLICY_URL\\\", \\\"runbook_url\\\": \\\"$RUNBOOK_URL\\\", \\\"severity\\\": \\\"$SEVERITY\\\", \\\"targets\\\": \\\"$TARGETS\\\", \\\"timestamp\\\": \\\"$TIMESTAMP\\\", \\\"timestamp_utc_string\\\": \\\"$TIMESTAMP_UTC_STRING\\\", \\\"violation_callback_url\\\": \\\"$VIOLATION_CALLBACK_URL\\\", \\\"violation_chart_url\\\": \\\"$VIOLATION_CHART_URL\\\" }\", customPayloadType: JSON, name: \"Webhook notification channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type config { customPayloadType customPayloadBody customHttpHeaders { value name } basicAuth { password username } baseUrl } } } error { description errorType } } } Copy Create an xMatters notification channel An example create mutation for an xMatters notification channel: mutation { alertsNotificationChannelCreate(accountId: YOUR_ACCOUNT_ID, notificationChannel: { xMatters: { integrationUrl: \"https://company.instance.xmatters.com/api/xm/v<version>/...\", name: \"xMatters notification channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type config { integrationUrl } } } error { description errorType } } } Copy Update a notification channel In order to update an alert notification channel, you need to know the specific type of notification channel you want to change (for example email, Slack, etc.), as well as the details necessary to configure it (which will depend on the channel type). Consistent with other GraphQL APIs, you can update a single field on the channel without knowing anything other than the channel's ID. Caution While you can query for any existing notification channel type, you can only update a subset of them. Specifically, the user channel type has no editable fields, and the Campfire and HipChat channel types are both deprecated. Update an email notification channel An example update mutation for an email notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { email: { name: \"Updated Name <email@example.com>\" } }) { notificationChannel { ... on AlertsEmailNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an OpsGenie notification channel An example update mutation for an OpsGenie notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { opsGenie: { name: \"OpsGenie updated channel name\" } }) { notificationChannel { ... on AlertsOpsGenieNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a PagerDuty notification channel An example update mutation for a PagerDuty notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { pagerDuty: { name: \"PagerDuty updated channel name\" } }) { notificationChannel { ... on AlertsPagerDutyNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Slack notification channel An example update mutation for a Slack notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { slack: { name: \"Slack updated channel name\" } }) { notificationChannel { ... on AlertsSlackNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a VictorOps notification channel An example update mutation for a VictorOps notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, id: YOUR_CHANNEL_ID, notificationChannel: { victorOps: { name: \"VictorOps updated channel name\" } }) { notificationChannel { ... on AlertsVictorOpsNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update a Webhook notification channel An example update mutation for a Webhook notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { webhook: { name: \"Webhook updated channel name\" } }) { notificationChannel { ... on AlertsWebhookNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Update an xMatters notification channel An example update mutation for an xMatters notification channel where we're updating only the name: mutation { alertsNotificationChannelUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID, notificationChannel: { xMatters: { name: \"xMatters updated channel name\" } }) { notificationChannel { ... on AlertsXMattersNotificationChannel { id name type } } error { description errorType notificationChannelId } } } Copy Delete a notification channel You can delete a notification channel with only the account ID and the channel ID. Note that deleting a channel dissociates it from all policies, meaning that no further notifications will be sent to that channel. mutation { alertsNotificationChannelDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CHANNEL_ID) { id error { description errorType notificationChannelId } } } Copy Associate channels to a policy Creating an alert notification channel is not enough: Once the channel has been created, it needs to be associated to one or more policies. Once associated to a policy, the channel can recieve alert notifications when conditions on that policy go into violation. In this example, we associate two channels with a policy: mutation { alertsNotificationChannelsAddToPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Dissociate a channel from a policy In those instances where a notification channel has outlived its usefulness (for example, an email list that has been retired), the time has come to dissociate that channel from the policy (or policies) that are sending alert notifications to it. This API call leaves the channel itself intact, but removes it from the specified policy. In this example, we are removing two channels from a policy (leaving any others in place), and getting back confirmation that those two channel IDs have been removed: mutation { alertsNotificationChannelsRemoveFromPolicy(accountId: YOUR_ACCOUNT_ID, notificationChannelIds: [FIRST_CHANNEL_ID, SECOND_CHANNEL_ID], policyId: YOUR_POLICY_ID ) { notificationChannels { id } policyId errors { description errorType notificationChannelId } } } Copy Tip Removing an alert notification channel from a policy does not delete the channel because it might be used by other policies. On the other hand, deleting a channel will cause all associated policies to stop sending alert notifications to that channel.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.1541,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> <em>tutorial</em>: Notification channels",
        "sections": "<em>NerdGraph</em> <em>tutorial</em>: Notification channels",
        "tags": "Alerts and <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your alert notification channels using our <em>Graph</em>QL <em>NerdGraph</em> API. Here are some queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. Get notification channels"
      },
      "id": "6130bf9c28ccbc027d56a863"
    }
  ],
  "/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-user-keys": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.291,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.0056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9074,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph": [
    {
      "sections": [
        "New Relic API keys",
        "API key UI",
        "Overview of keys",
        "Keys for data ingest",
        "Recommendations for managing ingest keys",
        "Keys for querying and configuration",
        "License key",
        "Create and manage license keys",
        "User key",
        "Browser key",
        "Insights insert key",
        "Important",
        "REST API key",
        "Insights query key",
        "Admin key",
        "Account ID"
      ],
      "title": "New Relic API keys",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "b373cd68cf21daeb5d912ffb4b1ae3f14f500fcc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/",
      "published_at": "2022-01-12T07:47:49Z",
      "updated_at": "2022-01-08T03:11:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic has several different APIs that use different API keys. This resource explains our keys, what they're used for, and how to access them. Ready to get started? Make sure you have a New Relic account. It's free, forever! API key UI Most of the keys can be viewed and managed via the API keys UI page: From the account dropdown, click API keys (get a direct link to the API keys page). If you're using NerdGraph, you can manage license keys and user keys from our GraphiQL explorer. Overview of keys If you're using a specific API, see the docs for that API to understand which keys are required and recommended. To learn about our APIs, see Introduction to APIs. Our keys can be broken down into two categories: Keys used for data ingest Keys used for querying and configuration Keys for data ingest There are many ways to get data into New Relic. Here are the API keys used for data ingest: License key: our primary ingest key, used for APM ingest, infrastructure monitoring ingest, and our ingest APIs and the integrations that use them. Browser key: used for browser monitoring ingest. Mobile app token: used for mobile monitoring ingest. Insights insert key: an older key that has been mostly deprecated, it has the same functionality as the license key. We recommend using the license key instead. Recommendations for managing ingest keys Some recommendations for managing data ingest keys: Keep them safe. Because these keys are used for data ingest, we recommend you treat ingest keys securely, like you would a password. This ensures no unwanted data is sent to your New Relic account. If a data ingest key falls into the wrong hands, it would allow someone to send data to your account, which could trigger false alerts and contaminate your data so that detecting actual issues is more difficult. If you believe a data ingest key has been exposed and has generated unwanted data, work with our Support team. Make additional keys. When setting up monitoring solutions that require a data ingest key, we recommend creating a new key, if possible. The original data ingest key for an account or app cannot be deleted or edited, so in order to give you greater management control (for example, deleting a key if exposed), we recommend creating new ones and using those. Keys for querying and configuration Here are keys used for querying New Relic data or configuration of features: User key, also known as a \"personal API key\": used for NerdGraph (our GraphQL API) and for accessing REST API endpoints. REST API key: used for the REST API but we instead recommend using the user key because it has fewer restrictions. Insights query key: used with the Insights query API for querying New Relic data. We recommend using NerdGraph instead of this API. License key Our primary key used for data ingest is called the license key, also referenced in the UI and NerdGraph API as ingest - license. The license key is a 40-character hexadecimal string associated with a New Relic account. Each account in a New Relic organization has at least one license key. When you first sign up for New Relic, that creates an organization with a single account, and that account has its own license key. If more accounts are added, each account will have its own license key. An account's original license key cannot be deleted but you can create additional license keys that can be managed and deleted. The types of data ingest the license key is used for include: APM agent data. Infrastructure agent data. Data sent via our core data ingest APIs (Metric API, Trace API, Event API, Log API), and the SDKs and integrations that use those APIs. The license key is used for almost all New Relic data ingest. The main exceptions are browser monitoring data (which uses a browser key) and mobile monitoring data (which uses a mobile app token). Create and manage license keys For tips on best practices for key management, see Ingest key recommendations. To add, delete, and manage license keys: From the account dropdown, click API keys (get a direct link to the API keys page). You can also create and manage keys with our NerdGraph API. Note that you can't delete or change an account's original license key (the one generated upon account creation). For that, contact New Relic support. User key New Relic user keys, sometimes referred to as \"personal API keys\", are required for using NerdGraph and for the REST API. A user key is tied to both a specific New Relic user and a specific account, and they cannot be transferred. Our APIs that use this key let a user make queries for any accounts that user has been granted access to, not just the specific account the key was created under. If the key's user is deleted, all their user keys will be deactivated and will no longer be valid in API requests. To view and manage the user key and other API keys in the UI: From the account dropdown, click API keys (here's a direct link to the API keys page). To manage this key via API, see Manage keys with NerdGraph. You can also get or generate a user key from the NerdGraph GraphiQL explorer. Browser key One of the New Relic API keys that are used for data ingest is the browser key. The browser key allows the ingestion of data from New Relic browser monitoring. For tips on best practices for key management, see Ingest key recommendations. To view and manage this key: From the account dropdown, click API keys (here's a direct link to the API keys page). You can't manage or delete an original browser key that was created when your account was created. For that, contact New Relic support. Insights insert key Important This key is still in use but we highly recommend using the license key, which can be used for the same things and more. One of the New Relic API keys used for data ingest is the Insights insert key, also known as an \"insert key\"). Note that the license key is used for the same functionality and more, which is why we recommend the license key over this key. This key is used for the ingestion of data via our Event API, Log API, Metric API, and Trace API, or via tools that use those APIs. Tips on availability and access: Because these keys are associated with an account and not a specific user, anyone in the account with access to a key can use it. As a best practice for security purposes, we recommend you use different Insights insert keys for different applications or different data sources. To find and manage Insights insert keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click Insights insert keys. REST API key Important We highly recommend using a user key instead, because that key has fewer restrictions. The REST API key is for using our REST APIs for Alerts, APM, browser, infrastructure alerts, as well as mobile monitoring REST APIs and the API Explorer. Things to consider: We recommend using our newer NerdGraph API over the REST API, if possible. Requires admin-level user permissions. If you don't have access to the REST API key or the REST API explorer, it might be due to lack of permissions. Talk to your New Relic account manager, or use a user key instead. Each New Relic account can have only one REST API key. To find and manage REST API keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click REST API key. Before you configure or delete an API key, ensure you are doing so for the correct account. Insights query key The Insights query key is used for our Insights query API: we now recommend using NerdGraph for querying New Relic data. To find and manage Insights query keys: From the account dropdown, click API keys (get a direct link to the API keys page). Then click Insights query keys. Admin key Important As of December 4, 2020, all existing admin keys have been migrated to be user keys. You don’t need to do anything for existing admin keys to remain active. They will be automatically accessible via the API keys UI, labeled as user keys, and granted identical permissions. You can manage them as you would any user key via the same workflow. All migrated admin keys will have a note that says “Migrated from an admin user key” in the key table, so you’ll be able to find them easily. Account ID Looking for the account ID? See Account ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 356.03403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>API</em> keys",
        "sections": "New Relic <em>API</em> keys",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " UI page: From the account dropdown, click <em>API</em> keys (<em>get</em> a direct link to the <em>API</em> keys page). If you&#x27;re using <em>NerdGraph</em>, you can manage license keys and user keys from our GraphiQL explorer. Overview of keys If you&#x27;re using a specific <em>API</em>, see the docs for that <em>API</em> to understand which keys"
      },
      "id": "6043fa3464441f1358378f3b"
    },
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 352.32208,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": " are used to provide data for specific entity types, as you will see in many of these <em>NerdGraph</em> query examples. <em>Get</em> entity data using queryBuilder If you aren&#x27;t sure how to <em>start</em> crafting an entity search query, use <em>NerdGraph</em> to help you build one. Next, retrieve entity data and the query string"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00537,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - <em>get</em> any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and <em>get</em> alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    }
  ],
  "/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 443.29272,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: View entity data",
        "sections": "<em>NerdGraph</em> tutorial: View entity data",
        "tags": "<em>APIs</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 347.00793,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build queries with <em>NerdGraph</em>",
        "body": " data - any source <em>APIs</em>, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.9093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic REST <em>API</em> (v2)",
        "sections": "<em>Examples</em>",
        "tags": "<em>APIs</em>",
        "body": " with .xml. <em>API</em> key $<em>API</em>_KEY New Relic <em>API</em> calls require an <em>API</em> key. This may be one of several <em>API</em> keys: A user key: This is recommended. It&#x27;s our latest key implementation and has fewer limitations than a REST <em>API</em> key. The user key is also used for our <em>NerdGraph</em> <em>API</em>. A REST <em>API</em> key: This is our older"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/nerdgraph/tutorials/provisions-your-subscriptions-nerdgraph": [
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 581.0772,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> <em>tutorial</em>: View entity data",
        "sections": "<em>NerdGraph</em> <em>tutorial</em>: View entity data",
        "tags": "<em>NerdGraph</em>",
        "body": "With <em>NerdGraph</em>, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics API <em>tutorial</em>. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "sections": [
        "Introduction to New Relic NerdGraph, our GraphQL API",
        "What is NerdGraph?",
        "Important",
        "Use the GraphiQL explorer",
        "Requirements and endpoints",
        "What can you do with NerdGraph?",
        "NerdGraph terminology",
        "Tips on using the GraphiQL explorer",
        "Query accounts a New Relic user can access",
        "Query user, account, and NRQL in one request"
      ],
      "title": "Introduction to New Relic NerdGraph, our GraphQL API",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Get started"
      ],
      "external_id": "e8e96c16cd75f494ebfacb3bc53b4ee9ccf1c727",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph/",
      "published_at": "2022-01-12T08:59:39Z",
      "updated_at": "2022-01-08T03:28:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "NerdGraph is our GraphQL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with NerdGraph. What is NerdGraph? New Relic has several APIs. NerdGraph is the API we recommend for querying New Relic data and for performing some specific configurations (learn more about features). NerdGraph provides a single API interface for returning data from New Relic’s various APIs and microservices. Over time, other configuration capabilities will be added to NerdGraph. Important NerdGraph isn’t used for data ingest. For that, you'd use our data ingest APIs. NerdGraph is built using GraphQL, which is an open source API format that allows you to request exactly the data needed, with no over-fetching or under-fetching. For a lesson in how to use NerdGraph, watch this 7-minute video: Want to watch more video tutorials? Go to the New Relic University’s Intro to NerdGraph. Or see the online course on New Relic APIs. Use the GraphiQL explorer To get started using GraphQL, we recommend playing around with our GraphiQL explorer (GraphiQL is an open source graphical interface for using GraphQL). You can use it to explore our data schema, to read built-in object definitions, and to build and execute queries. To use GraphQL, you’ll need a user-specific New Relic API key called a user key. You can generate one or find an existing one from the GraphiQL explorer’s API key dropdown. To find the GraphiQL explorer: If your New Relic account uses an EU data center, go to api.eu.newrelic.com/graphiql. Otherwise use api.newrelic.com/graphiql. For tips on how to build queries, see Build queries. Requirements and endpoints To use NerdGraph, you need a New Relic user key, which can be generated and accessed from the GraphiQL explorer. The endpoints are: Main endpoint: https://api.newrelic.com/graphql Endpoint for accounts using EU data center: https://api.eu.newrelic.com/graphql To access the endpoint, use the following cURL command: curl -X POST https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: YOUR_NEW_RELIC_USER_KEY' \\ -d '{ \"query\": \"{ requestContext { userId apiKey } }\" } ' Copy What can you do with NerdGraph? NerdGraph functionality can be broken down into two main categories: Querying New Relic data. You can fetch data for a variety of purposes, including using it in a programmatic workflow, or building a New Relic One app for custom data visualizations. Configuring New Relic features. There are a variety of configurations available and more will be added over time. You can do things like add tags, configure workloads, or customize \"golden metrics.\" You can use NerdGraph to return a wide range of New Relic data but we’ve created some tutorials for common use cases: Topic Tutorials Your monitored entities Get data about entities Understand entity relationships and dependencies (used to build service maps) Query and configure \"golden metrics\" (important entity metrics) Querying data Query using NRQL (our query language) Tags Add and manage tags APM agents APM agent configuration Dashboards Create dashboards Export dashboards to other accounts Export dashboards as files Migrate from Insights Dashboard API to NerdGraph Alerts See all alert-related tutorials Applied Intelligence View and configure topology Workloads View and configure workloads Service levels Configure and manage service levels Manage keys Create and manage keys (license keys used for data ingest, and user keys) Manage data Convert event data to metric data Drop data Distributed tracing Query distributed tracing data Configure Infinite Tracing New Relic One apps Build a New Relic One app Cloud integrations (AWS, Azure, GCP) Configure cloud integrations Partners and resellers Manage subscriptions (only for partners using original pricing model) Data partitions Manage data partitions Date retention Manage data retention NerdGraph terminology The following are terms that originate with GraphQL (the API format NerdGraph uses). Term Definition Queries and mutations There are two classes of GraphQL operations: Queries are basic requests used only to fetch data. These queries are not static, meaning that you can ask for more data or less data, depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Mutations are requests that perform an action, such as creating a resource or changing configuration. Mutations require the keyword mutation, as well as the name of the mutation. Type Data in GraphQL is organized into types. Types can be scalars (like strings, numbers, or booleans) or object types. An object type is a custom type made up of a collection of fields. For example, an object type called User may represent a user in a system. Field A field represents a piece of information on an object type that can be queried. Fields can be scalars, lists, or objects. For example, a User object type could have a string field called name. Interface An interface is an abstract type that represents a collection of common fields that other object types can implement. Tips on using the GraphiQL explorer You can make queries with the NerdGraph GraphiQL explorer. The explorer provides built-in schema definitions and features, including auto-complete and query validation. Query accounts a New Relic user can access You can query for the name of an account that an actor (a New Relic authorized user) has access to: query { actor { account(id: YOUR_ACCOUNT_ID) { name } } } Copy The response will mirror the query structure you defined in the request, making it easy to ask for the specific data that you want. { \"data\": { \"actor\": { \"account\": { \"name\": \"Data Nerd\" } } } } Copy Query user, account, and NRQL in one request The graph structure shows its capabilities when queries become more complex. For example, you can query for user information, account information, and make a NRQL query with one request. With REST API, this would take three different requests to three different endpoints. query { actor { account(id: YOUR_ACCOUNT_ID) { name nrql(query: \"SELECT * FROM Transaction\") { results } } user { name id } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 487.1006,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "sections": "Introduction to New Relic <em>NerdGraph</em>, our <em>GraphQL</em> API",
        "tags": "<em>NerdGraph</em>",
        "body": "<em>NerdGraph</em> is our <em>Graph</em>QL-format API that lets you query New Relic data and configure some New Relic features. After you sign up for a free New Relic account and install any of our monitoring services, you can get started with <em>NerdGraph</em>. What is <em>NerdGraph</em>? New Relic has several APIs. <em>NerdGraph</em>"
      },
      "id": "6043ff97196a67d0a0960f55"
    },
    {
      "sections": [
        "Forward your logs to New Relic",
        "How it works",
        "Get started with log forwarders",
        "Log forwarding options",
        "TCP endpoint",
        "Log API",
        "What's next?"
      ],
      "title": "Forward your logs to New Relic",
      "type": "docs",
      "tags": [
        "Logs",
        "Enable log management in New Relic",
        "Enable log monitoring in New Relic"
      ],
      "external_id": "b6e203ddc367d5a2b5e002916e49d34f4ba17a87",
      "image": "https://docs.newrelic.com/static/c3d5443b84a1e2b26a4767ce35fa58f3/e5166/new-relic-logs-in-context-diagram.jpg",
      "url": "https://docs.newrelic.com/docs/logs/forward-logs/enable-log-management-new-relic/",
      "published_at": "2022-01-12T06:23:33Z",
      "updated_at": "2022-01-12T06:23:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our log management capabilities help you to collect, process, explore, query, and alert on your log data. To get your logs into New Relic, you can: Use your existing log forwarding solution to collect your logs and extend the metadata that is forwarded to New Relic. Use our infrastructure agent as a lightweight data collector, without having to use additional software. Use our Log API to forward your logs via HTTP. Use syslog protocols to forward your logs via a TCP endpoint. How it works The following diagram shows the lifecycle of a log message for an app, from enrichment with APM agent metadata (contextual logging), to formatting and forwarding the log data to New Relic. This diagram illustrates the flow of log messages through New Relic. Standard log formatters transform log events into meaningful output (such as text files) that can be used by downstream people and processes. The NewRelicFormatter transforms log events into the JSON format expected by New Relic. These files contain log information and extended metadata. When you configure your log forwarder (our infrastructure monitoring agent, Fluentd, Logstash, etc.), you can also extend and enrich your log data. By configuring logs in context, the log enricher links the formatted log data with additional transaction information from your application or host. Now your log files are enriched with enhanced metadata and contextual logging data. Your log forwarder sends the files to our logging endpoint for processing. From there you can use our log management capabilities to view, query, set up alerts, and more in New Relic. Here is an example of logs for your host's UI. You can see logs in context of events for the selected time period, and drill down into detailed data for any of the highlighted attributes. To take advantage of even more capabilities, click Query logs from here to go directly to the Logs UI. Here is an example of a host's logs in context related to an event. Get started with log forwarders To forward your logs to New Relic with enriched metadata: If you don't have one already, create a New Relic account. It's free, forever. Have your New Relic account's license key. Install a compatible log forwarder. Ensure that outbound connectivity on TCP port 443 is allowed to the CIDR range that matches your region. Use the DNS name log-api.newrelic.com or log-api.eu.newrelic.com for configuration. For apps monitored by a New Relic APM agent, configure logs in context. Log forwarding options Use any of these solutions to forward your logs to New Relic. Recommended: Infrastructure monitoring agent You can use our guided install process to quickly and easily install log management and infrastructure monitoring together! To get learn how the guided install process works and how to use the logging data you see in New Relic One, watch this Nerdlog video on YouTube (14:46 minutes): Amazon: AWS CloudWatch plugin AWS FireLens plugin AWS Kinesis Firehose AWS Lambda for sending logs from S3 Microsoft: Azure ARM template Other log forwarding plugins: Fluent Bit plugin Fluentd plugin Google Cloud Platform Pub/Sub Heroku log streaming Kubernetes plugin Logstash plugin Vector plugin TCP endpoint In some situations you may not have log forwarders; for example, with CDNs, hardware devices, or managed services. You can use syslog protocols such as rsyslog and syslog-ng, and forward your logs to New Relic via a TCP endpoint. Log API If you prefer to connect to New Relic without installing a plugin, we offer an HTTP input integration. This option sends your monitored log data directly to New Relic via the Log API. What's next? After you enable your log forwarder, make the most of your data in New Relic with our log management capabilities: Explore the logging data across your platform with our Logs UI. See your logs in context of your app's performance in the APM UI. Troubleshoot errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data if you are forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards. For example, to query and manage your data partition rules, see our NerdGraph tutorial.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 320.9284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " errors with distributed tracing, stack traces, application logs, and more. Get deeper visibility into both your application and your platform performance data if you are forwarding your logs with our infrastructure monitoring agent. Review your infrastructure logs in the UI. Set up alerts. Query your data and create dashboards. For example, to query and manage your data partition rules, see our <em>NerdGraph</em> <em>tutorial</em>."
      },
      "id": "61571e0e28ccbcbc52f21431"
    }
  ],
  "/docs/apis/rest-api-v1-deprecated/new-relic-rest-api-v1/working-new-relic-rest-api-v1-deprecated": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Collect data - any source",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Monitor your network devices with New Relic",
        "Query data with NRQL"
      ],
      "published_at": "2022-01-12T01:46:49Z",
      "title": "Collect data",
      "updated_at": "2022-01-12T01:37:33Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect data - any source APIs, agents, OS emitters - get any data 15 min Add custom attributes Use custom attributes for deeper analysis Create custom events Define, visualize, and get alerts on the data you want using custom events 5 min Build queries with NerdGraph Try NerdGraph and build the queries you need 25 min Monitor your network devices with New Relic Monitor your network devices with New Relic 45 min Query data with NRQL Query default data, custom events, and attributes 10 min",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.52989,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Monitor your network devices with <em>New</em> <em>Relic</em>",
        "body": "Through our opensource agents or <em>APIs</em>, <em>New</em> <em>Relic</em> makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data Collect"
      },
      "id": "6091fa38196a67a932d52a29"
    },
    {
      "sections": [
        "NerdGraph tutorial: View entity data",
        "Important",
        "Entity definition",
        "Requirements",
        "Search for entities",
        "Caution",
        "Tip",
        "Search with queryBuilder",
        "Search with freeform query",
        "Fetch entities by GUID",
        "Example queries",
        "Get entity data using queryBuilder",
        "Get data for infrastructure integration entities in search results",
        "Get alert information on alertable entities in search results",
        "Get summary data on APM entities in search results",
        "Get data specific to each entity type in search results",
        "Get all tags for each entity in search results",
        "Use tags to filter entity results",
        "Aggregate results by an attribute or a tag",
        "Get the nextCursor for paginated search results",
        "Delete entities"
      ],
      "title": "NerdGraph tutorial: View entity data",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "82cba56e3512473f842550da49290068828ede3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-entities-api-tutorial/",
      "published_at": "2022-01-12T07:57:42Z",
      "updated_at": "2022-01-12T07:57:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity's golden metrics and tags, see the golden metrics API tutorial. Entity definition Entities are an important New Relic concept: we define an entity as anything we monitor. This includes (but is not limited to): Applications monitored by APM. Cloud integrations, services, and hosts monitored by our infrastructure monitoring. To view entity details in the UI, you can use the Explorer. When working with entities in NerdGraph, it's important to keep in mind that: A unique entity GUID identifies an entity. An entity exists over a span of time, even if it's a short period. An entity provides a useful entry point for exploring data about specific metrics and events, or for contextualizing data related to other entities. Requirements To use entities, you need a user key. Search for entities New Relic searches for entities by their attributes, primarily their name, but also by type of entity and other values. The search returns basic data about entities matching the search criteria. Then, from the basic query results, you can query a specific entity by its GUID. Besides domainType, other common entity attributes are: id accountId name domainId alertSeverity reporting You can filter by any of the above attributes. Additionally, you can use tags for filtering too. Caution You cannot filter by custom, root-level entity properties. Custom properties are only retrieved as part of the entity's metadata in the actual search response. To filter by a custom field, transform it into an entity tag. You can craft a query in one of two ways: Use the queryBuilder argument to help you craft a query. Use the freeform query argument to build your own search. To use NerdGraph to query one or more entities, you can search by attribute or GUID. Tip NerdGraph sets the total number of entities that can be returned in one query to 200. If you need to retrieve all entities for a query, use cursor pagination as explained in the examples. In addition to the examples below, we highly recommend exploring the API using the NerdGraph GraphiQL explorer, and benefiting from its inline documentation. Search with queryBuilder The queryBuilder argument is useful to construct simple queries. It allows you to add filters to your query from a predefined list of attributes, and their typical values. For more advanced queries, use the query argument instead. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { name entityType guid } } } } } Copy Search with freeform query This is useful to craft more complex queries. Go to the NerdGraph GraphiQL explorer. Run a basic query to find entities that match your search criteria. For example: query($query: String! ) { actor { entitySearch(query: $query) { count results { entities { name entityType guid } } } } } Copy Add the following variables to the Query variables section in NerdGraph: {\"query\": \"name LIKE 'nerd-graph' AND domainType IN ('APM-APPLICATION')\"} Copy Fetch entities by GUID When you know the GUID of the entity you want to fetch, you can just use the entity attribute: { actor { entity(guid: \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\") { name entityType } } } Copy This can also be written as a search query: { actor { entitySearch(query: \"id = 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3'\") { query results { entities { name entityType } } } } } Copy Or, to fetch multiple entities at the same time, you can use the entities attribute: { actor { entities(guids: [\"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3\", \"MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3\"]) { name entityType } } } Copy Otherwise, use a search query: { actor { entitySearch(query: \"id in ('MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0Mjk3', 'MTAwNDc5MzZ8QVBNfEFQUExJQ0FUSU9OfDExNzA0MTM3')\") { query results { entities { name entityType } } } } } Copy Example queries Queries are requests that are intended to only fetch data (and don't have any other effect). NerdGraph queries are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it's supported by the schema. Entities in NerdGraph rely on GraphQL interfaces, a concept that allows objects to share common fields. Interfaces are used to provide data for specific entity types, as you will see in many of these NerdGraph query examples. Get entity data using queryBuilder If you aren't sure how to start crafting an entity search query, use NerdGraph to help you build one. Next, retrieve entity data and the query string that was built. Request the query field in your results to see the query string built by the queryBuilder argument. You cannot use the query and queryBuilder arguments at the same time. We highly recommend exploring the API using the NerdGraph GraphiQL explorer, and using its inline documentation to see the query options available to you. { actor { entitySearch( queryBuilder : {domain: APM, type: APPLICATION}) { query results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get data for infrastructure integration entities in search results There are many different types of Infrastructure integration entities and they are listed separately from other entity types. Use the infrastructureIntegrationType input argument to explore them. You cannot use the query and queryBuilder arguments at the same time. Use infrastructureIntegrationType in place of the type input argument. We highly recommend exploring the API using the NerdGraph GraphiQL explorer and using its inline documentation to see the query options available to you. { actor { entitySearch(queryBuilder: { infrastructureIntegrationType : F5_NODE}) { query results { entities { entityType domain } } } } } Copy Get alert information on alertable entities in search results Fetch the alert severity of any entity that can be monitored by New Relic's alerts. This NerdGraph query will tell you if we are currently receiving data from your application (using the reporting field). If the entity is an alertable type, results will include the alert severity of the entity. If the results include entities that are not alertable, they will not include the AlertableEntityOutline fields. { actor { entitySearch(query: \"name like 'nerdgraph' and alertSeverity is not null\") { results { entities { reporting ... on AlertableEntityOutline { alertSeverity } } } } } } Copy Get summary data on APM entities in search results Different entity types have specific data associated with them. The following NerdGraph query example shows a selection of fields available for APM application entities: More summary data can be requested in your query. If entities of other types are returned in your search results, they will not include these fields. { actor { entitySearch(query: \"name like 'nerdgraph' and domainType = 'APM-APPLICATION'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate apdexScore webResponseTimeAverage responseTimeAverage } } } } } } } Copy Get data specific to each entity type in search results Different entity types have specific data associated with them. This NerdGraph query example requests the name for all entities regardless of which entity type they are, as well as the error rate for APM, browser monitoring, and mobile entities. If entities of other types are returned in your search results, they will not include an error rate field. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name ... on ApmApplicationEntityOutline { apmSummary { errorRate } } ... on BrowserApplicationEntityOutline { browserSummary { jsErrorRate } } ... on MobileApplicationEntityOutline { mobileSummary { httpErrorRate } } } } } } } Copy Get all tags for each entity in search results This NerdGraph query example fetches tags for every entity returned in the search results. For more information, see the NerdGraph GraphiQL tagging tutorial. { actor { entitySearch(query: \"name like 'nerdgraph'\") { results { entities { name tags { key values } } } } } } Copy Use tags to filter entity results This NerdGraph query example filters entities that belong to the INFRA domain and belong to awsRegion us-east-1, and returns their name in the search results. { actor { entitySearch(query: \"domain = 'INFRA' and tags.aws.awsRegion = 'us-east-1'\") { results { entities { name } } } } } Copy Additionally, filtering can be done by whether a given tag is present. The following query filters entities of the domainType BROWSER-APPLICATION and have the tag clusterAgentId defined. { actor { entitySearch(query: \"domainType = 'BROWSER-APPLICATION' and tags.clusterAgentId is not null\") { results { entities { name } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Aggregate results by an attribute or a tag This NerdGraph query example filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, and returns their name in the search results. Then aggregates results to get the total number of entities grouped by New Relic account id. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION'\") { facetedCounts(facets: {facetCriterion: {facet: ACCOUNT_ID}}) { counts { count facet } } } } } Copy Additionally, aggregation can be done by tags too; the following query filters entities of domainType APM-APPLICATION domain that belong to awsRegion us-east-1, then aggregates results to get the total number of entities grouped by Agent language. { actor { entitySearch(query: \"domainType = 'APM-APPLICATION' and tags.aws.awsRegion = 'us-east-1'\") { facetedCounts(facets: {facetCriterion: {tag: \"language\"}}) { counts { count facet } } } } } Copy For more information, see the NerdGraph GraphiQL tagging tutorial. Get the nextCursor for paginated search results The NerdGraph GraphiQL explorer paginates results from an entity search. If your search criteria yields more than the API limit of 200 entities in a single response, and you want to view the rest of the results, you can request nextCursor in your initial request, and use its value in another query to retrieve the following \"page\" of results. If there are no more results, nextCursor will be null. { actor { entitySearch(query: \"name like 'nerd-graph'\") { results { nextCursor entities { name } } } } } Copy Use the value of nextCursor in your next search: { actor { entitySearch(query: \"name like 'nerd-graph'\") { results(cursor: \"next_cursor_value\") { nextCursor entities { name } } } } } Copy Delete entities You can manually delete any entity in your account by using the NerdGraph API. To do so, run this query with the entity's GUID in the NerdGraph GraphiQL explorer: mutation { entityDelete(guids: [\"EntityGuid\"]) { deletedEntities failures } } Copy Important Currently, you can only remove the following entity types using the Nerdgraph API: APM-APPLICATION, EXT-SERVICE, and REF-REPOSITORY. You may see a deleted entity in your UI if a New Relic agent reindexes it again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 66.77379,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph tutorial: <em>View</em> entity data",
        "sections": "NerdGraph tutorial: <em>View</em> entity data",
        "tags": "<em>APIs</em>",
        "body": "With NerdGraph, you can query details about your monitored entities. Important To work with an entity&#x27;s golden metrics and tags, see the golden metrics <em>API</em> tutorial. Entity definition Entities are an important <em>New</em> <em>Relic</em> concept: we define an entity as anything we monitor. This includes"
      },
      "id": "6044058c64441f2d4f378ed9"
    },
    {
      "sections": [
        "Introduction to New Relic",
        "Get started with New Relic",
        "All the answers in one place",
        "Bring all your data together",
        "Analyze your data",
        "Respond to incidents faster",
        "Troubleshoot from anywhere in your stack"
      ],
      "title": "Introduction to New Relic",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "f47a40a9afd699e69c351f5e87f64ed5dadd7e43",
      "image": "https://docs.newrelic.com/static/44970161aec793f3141cfcdc0fc96a57/c1b63/observability.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/intro-new-relic/",
      "published_at": "2022-01-12T18:27:10Z",
      "updated_at": "2022-01-12T18:27:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic is an observability platform that helps you build better software. You can bring in data from any digital source so that you can fully understand your system and how to improve it. This short video shows twenty of the most common ways to get your data into New Relic (approx. 5:22 minutes): With New Relic, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and APIs, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems and optimize your systems. Build dashboards and charts or use our powerful query language. Respond to incidents quickly: Our machine learning solution proactively detects and explains anomalies and warns you before they become problems. Get started with New Relic Here's how you can quickly get started capturing and analyzing your data: If you don't have a New Relic account, sign up at newrelic.com/signup. It's free, forever! Follow the steps in our Add your data UI page to get data flowing in. For your first install, we recommend the Guided install option, which will set up many integrations with a single command. Once you have data coming into New Relic, learn more about the New Relic UI or set up Alerts. All the answers in one place New Relic is built for full stack observability. It links all relevant data so that you get the whole picture of everything that enables your systems to deliver value to your customers, from the container running a microservice in the cloud to a mobile website's shopping cart button. Monitoring vs. observability: New Relic provides answers to essential questions in one place. As just one example of what you can do with New Relic, imagine you are a Kubernetes administrator overseeing many clusters and pods of software containers. Where do you start troubleshooting? This short video shows how you can locate a problem cluster and use distributed tracing to find relevant logs: Bring all your data together Capture, organize, and make sense of your data in New Relic One, no matter where it comes from. Use our agents and integrations to automatically collect data from common frameworks and tools, or use our APIs for data that’s more specific to your business or technology. If you don't see your technologies or tasks listed here, see a larger list at New Relic Instant Observability. There you will find integrations bundled into quickstarts, providing you instant access to pre-built dashboards and alerts specific to your technology. If you want to... New Relic can help you... Instrument your application Instrument your code: Use our APM agents to automatically instrument your applications in C, Go, Java, .NET, Node.js, PHP, Python, and Ruby. Track transactions: Gather distributed tracing details as your transactions cross boundaries between apps and services. Instrument your environment Instrument your infrastructure: Observe your entire environment (including Linux, Windows, AWS, Azure, Google Cloud Platform, Kubernetes, Docker, and more). Collect and centralize logs: See your log data in context with your other application and infrastructure data. Save time switching between tools and reach solutions more quickly. Instrument your digital experiences Enhance browser performance: Decrease page load times, as well as triage and eliminate errors. Monitor mobile apps: Troubleshoot crashes and check the health of your Android and iOS apps with our mobile agents. Simulate user activity: Ensure you’re meeting customer expectations by running automated checks to monitor key user flows and experiences. Send data via APIs or build your own solution Collect data without an agent: Call our APIs directly if you prefer to use OpenTelemetry or other agents. Build your own integration: You can use our Flex tool, or one of language-specific SDKs for creating your own exporters to send data to New Relic. New Relic One gives you access to a wide range of observability tools, including: Application monitoring Browser monitoring Mobile monitoring Synthetic monitoring Serverless monitoring Infrastructure monitoring Log management You can start anywhere, but you'll never get lost. True observability across your entire stack means that you're in control. Analyze your data With your data secure at New Relic, our platform can alert you to problems and help you organize, process, and understand your data, whether it's metrics, events, logs, or traces: Explore your data visually: Jump into our data explorer to navigate all your data and make connections between your entities without any knowledge of query languages. Query and visualize your data: Use our curated dashboard visualizations or create your own. Use NRQL (New Relic Query Language) to slice and dice your data and dig deeper into questions. Query your data programmatically: Access your data through our NerdGraph GraphQL API. Easily prototype queries in our GraphiQL editor. Respond to incidents faster DevOps, site-reliability, and network operation teams need reliable, real-time alerts and anomaly detection to ensure their systems are always up and running efficiently. Let Applied Intelligence, our hybrid machine learning engine, automatically detect anomalies, reduce alert noise, and enrich incidents with context so that you can respond faster to incidents. Proactive detection: Be notified of unusual app behavior and get an analysis of this unusual behavior sent to Slack. Not using Slack? Set up a webhook to deliver messages when you need them. Get notifications: Set up alerts across your data sources and get notified when systems need your attention. Preserve your attention and control how many threshold violations should fire before you're notified. Troubleshoot from anywhere in your stack Being fully connected, the New Relic UI allows you to start your observability journey from any element of your stack. For example, you can get to crucial infrastructure logs from traces of an application running on a problematic Kubernetes pod. Use the Explorer in New Relic One to access and observe the full stack of your software, see performance data and alerting status at a glance, and check relationships. We provide you with a simple yet powerful visual tool to monitor all your entities, that is, anything we can identify that reports data. In the New Relic ecosystem, entities include basic components like applications, hosts, containers, or database services, but they can also refer to custom groupings of such elements. You can also create your own entities. The more entities you instrument, the more data you'll bring in. The more data you've brought to New Relic, the more you'll understand your metrics, events, logs, and traces.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.223114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>New</em> <em>Relic</em>",
        "sections": "Introduction to <em>New</em> <em>Relic</em>",
        "tags": "Using <em>New</em> <em>Relic</em>",
        "body": "): With <em>New</em> <em>Relic</em>, you can: Bring all your data together: Instrument everything and import data from across your technology stack using our agents, integrations, and <em>APIs</em>, and access it from a single UI. Analyze your data: Get all your data at your fingertips to find the root causes of problems"
      },
      "id": "619d5b3e196a6705bda0837d"
    }
  ],
  "/docs/apis/rest-api-v2/account-examples-v2/listing-users-your-account": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.0052,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region <em>account</em>, the URL is: <em>api</em>. eu .newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.72055,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Accounts</em> <em>and</em> billing",
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.24733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic partnership <em>account</em> authentication",
        "sections": "New Relic partnership <em>account</em> authentication",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " <em>API</em> key, partner ID, and your <em>account</em> ID: X-<em>Api</em>-Key:YOUR_PARTNER_<em>ACCOUNT_API</em>_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-<em>Account</em>-Id:YOUR_CUSTOMERS_<em>ACCOUNT</em>_ID Providing authentication to the <em>REST</em> <em>API</em> (<em>v2</em>) in this form allows you to complete any <em>API</em> operation on your customer’s accounts"
      },
      "id": "60440747e7b9d2a1465799f2"
    }
  ],
  "/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer": [
    {
      "sections": [
        "Retrieve metric timeslice data for your app (Explorer)",
        "View your app's ID",
        "View metric names for your app",
        "Get metric timeslice data for your app",
        "View other REST API data"
      ],
      "title": "Retrieve metric timeslice data for your app (Explorer)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "3553a434fa75f931ca76da34d5696329801070d9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/retrieve-metric-timeslice-data-your-app-explorer/",
      "published_at": "2022-01-12T09:02:23Z",
      "updated_at": "2021-10-31T03:54:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using New Relic's REST API Explorer (v2) to get metric timeslice data for your application, you need: An API key The app's ID The type of metric timeslice data available for your app, including the metric names and values View your app's ID To view your app's ID: From the New Relic REST API Explorer, select Applications > GET List. If you are not signed in to New Relic, provide an API key for your app. Optional: From Applications > List, fill in values for the name, ids, or language filters. Select Send Request. From the Response section, copy the app's id. Continue with the procedure to view metric names. View metric names for your app To view the metric timeslice data available for your app: From the New Relic REST API Explorer, select Applications > GET Metric Names. From Applications > Metric Names, type or paste your application ID. Fill in a specific or partial metric name, or leave blank to view the list of available metric names and values. Select Send Request. From the Response section, review the app's available metrics. Continue with the procedure to get metric timeslice data. Get metric timeslice data for your app To get the metric values for your app, copy the values from the Metric Names results, and paste them in the Metric Timeslice Data fields: From the New Relic REST API Explorer, select Applications > GET Metric Data. From Applications > Metric Data, type or paste your application ID. Type or paste one or more names (from GET Metric Names) for your app. Start each name on a new line. Select Send Request. From the Response section, review the app's available metric_data. After reviewing the Response section, you can continue making adjustments, and select Send Request again. For example: To specify a time range for the metric timeslice data, fill the from and to values, or use the diamond . To create an average of the data over the time range, set summarize to true. Or, to keep the data for each time period for the range you have specified, leave summarize blank. View other REST API data To use the API Explorer with other New Relic capabilities, select the corresponding API key. This may include: Synthetic monitoring Partners",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.0473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Retrieve metric timeslice data for your app (<em>Explorer</em>)",
        "sections": "<em>View</em> other <em>REST</em> <em>API</em> data",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": "When using New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em> (<em>v2</em>) to get metric timeslice data for your application, you need: An <em>API</em> key The app&#x27;s ID The type of metric timeslice data available for your app, including the metric names and values View your app&#x27;s ID To view your app&#x27;s ID: From the New Relic <em>REST</em> <em>API</em>"
      },
      "id": "6043ffe628ccbcbb0b2c60a9"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2022-01-12T09:04:10Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.65143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    },
    {
      "sections": [
        "Get average CPU usage per host for an app",
        "Get CPU usage for a host",
        "Tip",
        "Get CPU usage for the entire app"
      ],
      "title": "Get average CPU usage per host for an app",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "d8301a66a2273586c11af5705b5201f0cf73d242",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-cpu-usage-host-app/",
      "published_at": "2022-01-12T09:03:35Z",
      "updated_at": "2021-03-13T02:39:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app's hosts, use a single command to obtain the metric names[]=CPU/User+Time with values[]=percent. This example shows the time range for the default time period (last 30 minutes): curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace the $HOST_ID with the host id of your target host. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields. Get CPU usage for the entire app To get the average CPU usage for your application, use a command similar to the one in the previous example but without the reference to the host_id: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Applications > GET Metric Data, and include your API key. Add your application ID, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.65024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app&#x27;s hosts, use a single"
      },
      "id": "604405bc196a6747d2960f3f"
    }
  ],
  "/docs/apis/rest-api-v2/api-explorer-v2/retrieve-metric-timeslice-data-your-app-explorer": [
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2022-01-12T09:01:37Z",
      "updated_at": "2021-10-31T03:53:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.39964,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> <em>Explorer</em>."
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2022-01-12T09:04:10Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.65143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    },
    {
      "sections": [
        "Get average CPU usage per host for an app",
        "Get CPU usage for a host",
        "Tip",
        "Get CPU usage for the entire app"
      ],
      "title": "Get average CPU usage per host for an app",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "d8301a66a2273586c11af5705b5201f0cf73d242",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-cpu-usage-host-app/",
      "published_at": "2022-01-12T09:03:35Z",
      "updated_at": "2021-03-13T02:39:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app's hosts, use a single command to obtain the metric names[]=CPU/User+Time with values[]=percent. This example shows the time range for the default time period (last 30 minutes): curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace the $HOST_ID with the host id of your target host. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields. Get CPU usage for the entire app To get the average CPU usage for your application, use a command similar to the one in the previous example but without the reference to the host_id: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=CPU/User+Time&values[]=percent&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. For additional detail: Remove summarize=true to obtain detailed time series data. Specify a different time range. Tip To get the same information from the New Relic API Explorer (v2), select Applications > GET Metric Data, and include your API key. Add your application ID, and the names[]=CPU/User Time and values[]=percent metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.65024,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get the average CPU usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled CPU usage. Get CPU usage for a host To get the average CPU usage for one of your app&#x27;s hosts, use a single"
      },
      "id": "604405bc196a6747d2960f3f"
    }
  ],
  "/docs/apis/rest-api-v2/api-explorer-v2/use-api-explorer": [
    {
      "sections": [
        "Introduction to New Relic's REST API Explorer",
        "Features",
        "Differences from API version 1",
        "Tip"
      ],
      "title": "Introduction to New Relic's REST API Explorer",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "457d31007ab690d5e6f3679e150814c280b49441",
      "image": "https://docs.newrelic.com/static/c506cb08149178347d12b6cbb236c855/23592/API_explorer_main_page.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/introduction-new-relics-rest-api-explorer/",
      "published_at": "2022-01-12T09:01:37Z",
      "updated_at": "2021-10-31T03:53:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several APIs, including the New Relic REST API. This document introduces you to the REST API Explorer, which allows admin users and those with the API Key to: Browse the available REST API endpoints. Interact with the REST API within a user interface (the API Explorer). View a live source of documentation. Obtain curl commands for API actions. Share configured API calls with colleagues by copy and pasting API Explorer's URLs. This helps you to quickly search for solutions and test your API calls before adding them to your own software components. Features New Relic's API Explorer includes an interactive user interface for your selected account. The API Explorer UI lists the types of API calls (Applications, Users, etc.) and their available functions, such as GET metric data, PUT (update) applications, DELETE applications, etc. As you type values for Parameters, they automatically appear in the Request so that you can test and verify your syntax before sending the request. The UI indicates required fields, field descriptions, their type (integer, float, Boolean, etc.), and their location (path, query, etc.). For information on API key requirements, see REST API keys. rpm.newrelic.com/api/explore: The New Relic API Explorer makes it easy to test and send requests for any API endpoint. After you select your account and your choice of functions for the type of API call (applications, browsers, users, etc.), the UI provides an interactive form to view requirements and test your parameter values. Differences from API version 1 This API Explorer applies only to the New Relic REST API version 2, which focuses on data in and data out of New Relic. Version 2 replaces New Relic's deprecated REST API version 1. Be aware there are some differences between version 2 and 1: Names for data may be different. Some cURL commands for v2 are different than v1. Tip The New Relic agents use different APIs and are not accessible via the API Explorer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.39964,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "sections": "Introduction to New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em>",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": " and 1: Names for data may be different. Some cURL commands for <em>v2</em> are different than <em>v</em>1. Tip The New Relic agents use different <em>APIs</em> and are not accessible via the <em>API</em> <em>Explorer</em>."
      },
      "id": "6043ff97196a67c2f2960f65"
    },
    {
      "sections": [
        "Retrieve metric timeslice data for your app (Explorer)",
        "View your app's ID",
        "View metric names for your app",
        "Get metric timeslice data for your app",
        "View other REST API data"
      ],
      "title": "Retrieve metric timeslice data for your app (Explorer)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "API Explorer v2"
      ],
      "external_id": "3553a434fa75f931ca76da34d5696329801070d9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/api-explorer-v2/retrieve-metric-timeslice-data-your-app-explorer/",
      "published_at": "2022-01-12T09:02:23Z",
      "updated_at": "2021-10-31T03:54:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using New Relic's REST API Explorer (v2) to get metric timeslice data for your application, you need: An API key The app's ID The type of metric timeslice data available for your app, including the metric names and values View your app's ID To view your app's ID: From the New Relic REST API Explorer, select Applications > GET List. If you are not signed in to New Relic, provide an API key for your app. Optional: From Applications > List, fill in values for the name, ids, or language filters. Select Send Request. From the Response section, copy the app's id. Continue with the procedure to view metric names. View metric names for your app To view the metric timeslice data available for your app: From the New Relic REST API Explorer, select Applications > GET Metric Names. From Applications > Metric Names, type or paste your application ID. Fill in a specific or partial metric name, or leave blank to view the list of available metric names and values. Select Send Request. From the Response section, review the app's available metrics. Continue with the procedure to get metric timeslice data. Get metric timeslice data for your app To get the metric values for your app, copy the values from the Metric Names results, and paste them in the Metric Timeslice Data fields: From the New Relic REST API Explorer, select Applications > GET Metric Data. From Applications > Metric Data, type or paste your application ID. Type or paste one or more names (from GET Metric Names) for your app. Start each name on a new line. Select Send Request. From the Response section, review the app's available metric_data. After reviewing the Response section, you can continue making adjustments, and select Send Request again. For example: To specify a time range for the metric timeslice data, fill the from and to values, or use the diamond . To create an average of the data over the time range, set summarize to true. Or, to keep the data for each time period for the range you have specified, leave summarize blank. View other REST API data To use the API Explorer with other New Relic capabilities, select the corresponding API key. This may include: Synthetic monitoring Partners",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.0473,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Retrieve metric timeslice data for your app (<em>Explorer</em>)",
        "sections": "<em>View</em> other <em>REST</em> <em>API</em> data",
        "tags": "<em>API</em> <em>Explorer</em> <em>v2</em>",
        "body": "When using New Relic&#x27;s <em>REST</em> <em>API</em> <em>Explorer</em> (<em>v2</em>) to get metric timeslice data for your application, you need: An <em>API</em> key The app&#x27;s ID The type of metric timeslice data available for your app, including the metric names and values View your app&#x27;s ID To view your app&#x27;s ID: From the New Relic <em>REST</em> <em>API</em>"
      },
      "id": "6043ffe628ccbcbb0b2c60a9"
    },
    {
      "sections": [
        "Get host memory used for an application",
        "Get memory usage for a host",
        "Get memory usage for the entire app"
      ],
      "title": "Get host memory used for an application",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "cbc8fbdc5012ba202ff02eea52a6b62e91f30596",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application/",
      "published_at": "2022-01-12T09:04:10Z",
      "updated_at": "2021-03-13T04:02:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory usage for one of your app's hosts, use the following command to obtain the metric names[]=Memory/Physical with values[]=percent. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/hosts/$HOST_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=used_mb_by_host&summarize=true' Copy Replace $APP_ID and $API_KEY with your app ID and your API key. Replace $HOST_ID with the host id of your target host. This example shows the time range for the default time period (last 30 minutes). For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Application Hosts > GET Metric Data, and include your API key. Add your application ID, host id, and the names[]=Memory/Physical and values[]=used_mb_by_host metrics in the appropriate fields. Get memory usage for the entire app To obtain the average Memory usage for your application, use a command similar to the one in the previous example, but remove the reference to hosts and $HOST_ID. Replace $APP_ID and $API_KEY with your app ID and your API key. curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Memory/Physical&values[]=total_used_mb&summarize=true' Copy For additional detail: Remove the summarize=true to obtain detailed time series data. Specify a different time range. To obtain the same information from the New Relic API Explorer (v2): Select Applications > GET Metric Data, and include your API key. Add your application ID and the names[]=Memory/Physical and values[]=total_used_mb metrics in the appropriate fields.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 192.65143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average memory usage for your application on a single host. This value appears on the APM Summary page in the Hosts table, in the column labeled Memory, or in the corresponding chart. Get memory usage for a host To obtain the average Memory"
      },
      "id": "604405fe28ccbc10d72c60bc"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/application-error-rate-example-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.68661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.9102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/application-reporting-health-status-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.6866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.9102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/average-response-time-examples-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.6866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.9102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.6866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    },
    {
      "sections": [
        "Average response time examples (v2)",
        "Contents",
        "Average response time",
        "Tip",
        "Response time"
      ],
      "title": "Average response time examples (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "8adf5a9e8fbbf50b8eca64eb2471eb9a06a3cda5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/average-response-time-examples-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is an example of how to use the New Relic API Explorer (v2) to get your application's average response time over a specified time period. Contents Average response time The average response time (milliseconds) is the value that appears on the main chart for your app on the APM Summary page. New Relic uses this formula to calculate response time: Response time = HttpDispatcher:average_call_time + ((WebFrontend/Queue:call_count * WebFrontend/Queue:average_response_time)/ HttpDispatcher:call_count) Copy To obtain the metric values, use the following two commands. In these examples, the same time period has been used for each, and they are both summarized (averaged). curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_call_time&values[]=call_count&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=WebFrontend/QueueTime&values[]=call_count&values[]=average_response_time&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy Your application may have zero queuing time for the time period in question. In that case, the WebFrontend/QueueTime metric will have a zero value. Tip If your app has never reported a queuing time, the metric WebFrontend/QueueTime will not exist. Response time On the APM Summary page, Response time is the overlaid line within the main chart for your app. To obtain the metric values shown by this line, use the same formula and two commands described above, but remove summarize=true from the commands.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average response time <em>examples</em> (<em>v2</em>)",
        "sections": "Average response time <em>examples</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here is an example of how to use the New Relic <em>API</em> Explorer (<em>v2</em>) to get your <em>application</em>&#x27;s average response time over a specified time period. Contents Average response time The average response time (milliseconds) is the value that appears on the main chart for your app on the APM Summary page"
      },
      "id": "604405bc196a673e3d960f46"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-average-cpu-usage-host-app": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.6866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.9102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2": [
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.9102,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    },
    {
      "sections": [
        "Average response time examples (v2)",
        "Contents",
        "Average response time",
        "Tip",
        "Response time"
      ],
      "title": "Average response time examples (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "8adf5a9e8fbbf50b8eca64eb2471eb9a06a3cda5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/average-response-time-examples-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is an example of how to use the New Relic API Explorer (v2) to get your application's average response time over a specified time period. Contents Average response time The average response time (milliseconds) is the value that appears on the main chart for your app on the APM Summary page. New Relic uses this formula to calculate response time: Response time = HttpDispatcher:average_call_time + ((WebFrontend/Queue:call_count * WebFrontend/Queue:average_response_time)/ HttpDispatcher:call_count) Copy To obtain the metric values, use the following two commands. In these examples, the same time period has been used for each, and they are both summarized (averaged). curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_call_time&values[]=call_count&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=WebFrontend/QueueTime&values[]=call_count&values[]=average_response_time&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy Your application may have zero queuing time for the time period in question. In that case, the WebFrontend/QueueTime metric will have a zero value. Tip If your app has never reported a queuing time, the metric WebFrontend/QueueTime will not exist. Response time On the APM Summary page, Response time is the overlaid line within the main chart for your app. To obtain the metric values shown by this line, use the same formula and two commands described above, but remove summarize=true from the commands.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average response time <em>examples</em> (<em>v2</em>)",
        "sections": "Average response time <em>examples</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here is an example of how to use the New Relic <em>API</em> Explorer (<em>v2</em>) to get your <em>application</em>&#x27;s average response time over a specified time period. Contents Average response time The average response time (milliseconds) is the value that appears on the main chart for your app on the APM Summary page"
      },
      "id": "604405bc196a673e3d960f46"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-host-memory-used-application": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.6866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.91019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/get-web-transaction-time-data-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.6866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.91019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.68658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.91019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Average response time examples (v2)",
        "Contents",
        "Average response time",
        "Tip",
        "Response time"
      ],
      "title": "Average response time examples (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "8adf5a9e8fbbf50b8eca64eb2471eb9a06a3cda5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/average-response-time-examples-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here is an example of how to use the New Relic API Explorer (v2) to get your application's average response time over a specified time period. Contents Average response time The average response time (milliseconds) is the value that appears on the main chart for your app on the APM Summary page. New Relic uses this formula to calculate response time: Response time = HttpDispatcher:average_call_time + ((WebFrontend/Queue:call_count * WebFrontend/Queue:average_response_time)/ HttpDispatcher:call_count) Copy To obtain the metric values, use the following two commands. In these examples, the same time period has been used for each, and they are both summarized (averaged). curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_call_time&values[]=call_count&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=WebFrontend/QueueTime&values[]=call_count&values[]=average_response_time&from=2014-03-01T20:59:00+00:00&to=2014-03-01T21:59:00+00:00&summarize=true' Copy Your application may have zero queuing time for the time period in question. In that case, the WebFrontend/QueueTime metric will have a zero value. Tip If your app has never reported a queuing time, the metric WebFrontend/QueueTime will not exist. Response time On the APM Summary page, Response time is the overlaid line within the main chart for your app. To obtain the metric values shown by this line, use the same formula and two commands described above, but remove summarize=true from the commands.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average response time <em>examples</em> (<em>v2</em>)",
        "sections": "Average response time <em>examples</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here is an example of how to use the New Relic <em>API</em> Explorer (<em>v2</em>) to get your <em>application</em>&#x27;s average response time over a specified time period. Contents Average response time The average response time (milliseconds) is the value that appears on the main chart for your app on the APM Summary page"
      },
      "id": "604405bc196a673e3d960f46"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/list-apps-host-ids-instance-ids": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.68658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.91019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/list-your-app-id-metric-timeslice-data-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.68658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.91019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/application-examples-v2/summary-data-examples-v2": [
    {
      "sections": [
        "Get average throughput for an app (v2)",
        "Web app throughput",
        "Web app throughput (single host)",
        "Non-web app throughput",
        "Non-web app throughput (single host)"
      ],
      "title": "Get average throughput for an app (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "69213d0faede1c54abe3ab51a41b506fd27427bc",
      "image": "https://docs.newrelic.com/static/8f3717e1b97fa8027a5db9ecca408b7f/6c1e7/Web_app_throughput.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/get-average-throughput-app-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use the New Relic REST API (v2) to obtain the average throughput for your app, including web application and non-web application throughput. These values appear in the Throughput chart on your app's APM Summary page: Go to one.newrelic.com > APM > (select an app). Click the app's Transaction time chart title, then select your choice. Web app throughput To find the average web application throughput value for a time period, use a single command to get the metric HttpDispatcher:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=HttpDispatcher&values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range, include from and to values. To keep the default time period of the last 30 minutes, omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Web app throughput (single host) To find the average throughput from a single host, for a given time period, use a single command to get the metric HttpDispatcher:requests_per_minute, and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=HttpDispatcher&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy Non-web app throughput To find the average non-web application throughput value for a given time period, use a single command to get the metric OtherTransaction/all:requests_per_minute. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=OtherTransaction/all&values[]=requests_per_minute&;from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&summarize=true' Copy Be sure to replace $ { APPID} and $ { APIKEY} with your application ID and API key for the account. To change the time range (as shown in this example), include from and to values. To keep the default time period (last 30 minutes), omit the from and to values. To return a series of throughput values instead of an average, omit summarize. Here is an example of the Throughput chart for a non-web app on the APM Summary page. You can use the New Relic REST API (v2) to return the average Throughput value that appears here. Non-web app throughput (single host) To obtain the average throughput for a non-web app from a single host, for a given time period, use a single command to obtain the metric OtherTransaction:requests_per_minute and specify the numeric $ { HOST}. To identify the host, use the UI or the REST API. This example shows the time range for a specific 24 hour period. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/hosts/${HOST}/metrics/data.json\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\     -d 'names[]=OtherTransaction/all&:values[]=requests_per_minute&from=2014-02-21T23:59:00+00:00&to=2014-02-22T23:59:00+00:00&:summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 234.68658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get average throughput for an app (<em>v2</em>)",
        "sections": "Get average throughput for an app (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "You can use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the average throughput for your app, including web <em>application</em> and non-web <em>application</em> throughput. These values appear in the Throughput chart on your app&#x27;s APM Summary page: Go to one.newrelic.com &gt; APM &gt; (select an app). Click the app"
      },
      "id": "603ec9ba28ccbccf81eba797"
    },
    {
      "sections": [
        "Change the alias for your application (v2)",
        "Set application alias and modify Apdex thresholds"
      ],
      "title": "Change the alias for your application (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "e5f896b364a0e6a0f4809fafafa877ac2dc61c7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/change-alias-your-application-v2/",
      "published_at": "2022-01-12T09:02:56Z",
      "updated_at": "2021-10-31T03:56:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The application name you see in the New Relic's user interface is a human-readable alias for the primary name assigned in your configuration settings. If you change it, the name of your app is updated everywhere in New Relic One, including APM, browser monitoring, etc. By default, the alias is the same as the name used in the agent configuration file. Changing the alias does not affect the agent's configured name, and data still reports using that name. Set application alias and modify Apdex thresholds To change the alias for the app name from the New Relic REST API (v2), use this command. You can also change the app alias from New Relic's API Explorer by selecting Applications > Update. You will need to supply the ${APPID}, ${API_KEY}, and the alias name you want the application to be displayed as in the New Relic UI. You must also provide APP_APDEX_THRESHOLD, BROWSER_APDEX_THRESHOLD, and the monitoring enabled BOOLEAN (true or false) even if they are not being modified. curl -X PUT \"https://api.newrelic.com/v2/applications/${APPID}.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"application\": { \"name\": \"name\", \"settings\": { \"app_apdex_threshold\": APP_APDEX_THRESHOLD, \"end_user_apdex_threshold\": BROWSER_APDEX_THRESHOLD, \"enable_real_user_monitoring\": BOOLEAN } } }' Copy This is the equivalent of using the APM UI to change the displayed app name. This will not change the app identifier name under which your data will be collected. It will only change the app name that appears in the New Relic user interface.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.91019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "sections": "Change the alias for your <em>application</em> (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": " is the same as the name used in the agent configuration file. Changing the alias does not affect the agent&#x27;s configured name, and data still reports using that name. Set <em>application</em> alias and modify Apdex thresholds To change the alias for the app name from the New Relic <em>REST</em> <em>API</em> (<em>v2</em>), use this command"
      },
      "id": "603ed66c28ccbc230feba7a9"
    },
    {
      "sections": [
        "Getting Apdex data for apps or browsers (v2)",
        "Metric names and values for Apdex",
        "Average Apdex score",
        "Average Apdex metric values",
        "All average Apdex values",
        "Tip"
      ],
      "title": "Getting Apdex data for apps or browsers (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Application examples (v2)"
      ],
      "external_id": "02654775837fc3b3dc3c062720c3d4b05fbe32d2",
      "image": "https://docs.newrelic.com/static/5dd43a481520de96231ec55ce1c0676c/8c557/Apdex_average.png",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/application-examples-v2/getting-apdex-data-apps-or-browsers-v2/",
      "published_at": "2022-01-12T09:04:09Z",
      "updated_at": "2021-10-31T03:58:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are some examples of how to use the New Relic REST API (v2) to get Apdex data for your application and browser, for a specific application ID and API key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values returned may be affected by the time period you specify and the way the data is stored. For more information, see Extracting metric data. Metric names and values for Apdex To specify Apdex metric names and values with REST API calls, use these codes as needed. Metric name Metric value Apdex score: Application's Apdex score s: Application's satisfied count t: Application's tolerating count f: Application's frustrated count count: Application's request count EndUserApdex score: Browser's Apdex score s: Browser's satisfied count t: Browser's tolerating count f: Browser's frustrated count count: Browser's request count The calculation used to determine the score is explained in Apdex: Measuring user satisfaction. The following sections describe how to obtain the score and the s, t, and f values used to arrive at it. Average Apdex score To obtain the average Apdex score (both app and browser) for a specific time period, use this command. This example shows 24 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-01-01T00:00:00+00:00&to=2014-01-02T00:00:00+00:00&summarize=true' Copy This will return the same Apdex scores shown in your APM Overview page. APM > (selected app) > Monitoring > Overview: You can use API v2 to return the same Apdex scores shown in the APM Overview page. Average Apdex metric values To obtain the average Apdex metric values for a specific time range, use this command. This example shows 12 hours in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&values[]=score&from=2014-06-09T00:00:00+00:00&to=2014-06-09T12:00:00+00:00&summarize=true' Copy Tip: To return a series of Apdex scores instead of an average, omit &summarize=true. All average Apdex values To obtain the complete set of average scores, s, t, f, count, and threshold values for a specific time range, use this command. This example shows 24 hours (adjusted to the time zone 6 hours west of UTC by using %2B06:00) in XML format for your application ID and its corresponding API key. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.xml\" \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00%2B06:00&to=2014-06-10T00:00:00%2B06:00&summarize=true' Copy Tip Even though this example adjusts the time zone, the output still returns as UTC time.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.67735,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "sections": "Getting Apdex data for apps or browsers (<em>v2</em>)",
        "tags": "<em>Application</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are some <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to get Apdex data for your <em>application</em> and browser, for a specific <em>application</em> ID and <em>API</em> key. By default, this will provide a list of values every minute for the last 30 minutes in JSON format. When acquiring data, the values"
      },
      "id": "604405fe196a674cd9960f1f"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/api-overload-protection-handling-429-errors": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.72,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2022-01-12T08:37:37Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.15874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/calculate-average-metric-values-summarize": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00455,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2022-01-12T08:37:37Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.15874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/extract-metric-timeslice-data": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00455,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2022-01-12T08:37:37Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.15874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/pagination-api-output": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2022-01-12T08:37:37Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.15874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Pagination for API output",
        "Requirements and limitations",
        "Important",
        "Request a specific page",
        "Link header examples showing page count",
        "Tip",
        "Example: Return 3 pages"
      ],
      "title": "Pagination for API output",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "e53248f738396172abad2740144738488b9f1c1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/pagination-api-output/",
      "published_at": "2022-01-12T09:05:22Z",
      "updated_at": "2021-03-13T05:36:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic REST API (v2) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination is no longer available for metrics output for some customers (deprecation beginning December 2020). Returns up to 3000 results per cell. For large outputs, we recommend narrowing the query using application ID or another attribute. The sort order for returned data is indeterminate. Do not assume or rely on a particular order. The data returned per page depends on what data is requested. The number of pages depends on the number of JSON objects necessary to complete the list. Important Before listing metric names, see Metric name listing guidelines. Request a specific page To specify a page, add the page= parameter to the query. Here's an example: curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json?page=3' \\ -H 'Api-Key:$API_KEY' -i Copy In the REST API Explorer, you can quickly change the page being viewed. Link header examples showing page count The API call returns the Link header if the data is paginated. This indicates the number of pages and the page being viewed. This line also appears at the top of the Response in the REST API Explorer. Important The Link header will only appear if the output data is paginated. Tip The rel=\"last\" reference will not be shown when making calls to the Violations endpoint (https://api.newrelic.com/v2/alerts_violations.json). To determine the final page when making calls to this endpoint, look for the absence of a rel=\"next\" reference. To obtain this line using some implementations of curl, you may need to include the -v option. curl -v -X GET 'https://api.newrelic.com/v2/applications/$APP_ID/...' Copy New Relic uses the RFC 5988 standard format for links. Example: Return 3 pages The API output will contain a Link line similar to this. Lines are wrapped to improve readability. Link: <https://api.newrelic.com/v2/alert_policies.xml?page=2>;rel=\"next\", <https://api.newrelic.com/v2/alert_policies.xml?page=3>;rel=\"last\" Copy This indicates there are three pages and you are viewing the first one. Parameter Description ...page=2>;rel=\"next\" Page 2 is the next page ...page=3>;rel=\"last\" Page 3 is the last page",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.06244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Pagination for <em>API</em> output",
        "sections": "Pagination for <em>API</em> output",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "The New Relic <em>REST</em> <em>API</em> (<em>v2</em>) paginates some responses, for performance reasons. This is because returning the entire data set might be feasible for some queries but prohibitive for others that return a very large amount of data. Requirements and limitations Metric data return: Pagination"
      },
      "id": "604406cf28ccbce7b02c60ab"
    }
  ],
  "/docs/apis/rest-api-v2/basic-functions/specify-time-range-v2": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00446,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Set a custom user agent",
        "Prerequisites",
        "User agents",
        "Set a user agent",
        "Tip",
        "Set custom user-agent for your integration",
        "User agent strings and New Relic"
      ],
      "title": "Set a custom user agent",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Basic functions"
      ],
      "external_id": "9135fbe2a8dc7c5b4ccbfb20c28af858ef81cdf8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/basic-functions/set-custom-user-agent/",
      "published_at": "2022-01-12T08:37:37Z",
      "updated_at": "2021-03-13T05:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To ensure that New Relic correctly identifies API integration publishers, each integration needs a unique custom user agent string. If you are only using your integration internally, and don't plan on sharing it with anyone outside your organization, you don't need to set a unique custom agent string. Prerequisites This document assumes you plan to publicly distribute an integration that makes use of any of New Relic's public RESTful APIs. Examples of public distribution include: Publicizing your integration code on Github. Packaging your integration into a plugin, extension, or other package, and distributing it via a directory like WordPress Plugins. Offering an \"as a service\" integration between your product and New Relic, without actually distributing your integration code, like Runscope's integration. User agents When writing applications to work with New Relic's RESTful APIs (referred to as an integration in this document), you are creating an HTTP agent to manage information exchange between your application and New Relic. An integration identifies itself by submitting a standard identification string. In HTTP this string is included in the header field User-Agent. When using New Relic's RESTful APIs, set a User-Agent header that identifies your integration in API calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic's APIs. By setting a custom user agent, New Relic can track: Usage statistics for your integration. Potentially buggy or abusive API usage. Set a user agent To set a custom user agent, include an agent string in the HTTP header User-Agent. Examples: Language Example cURL curl -H 'User-Agent: my-integration/1.2.3' Copy Java (using GET) get.setHeader(\"User-Agent\", \"my-integration/1.2.3\"); Copy PHP header('User-Agent: my-integration/1.2.3'); Copy The minimum user agent string is the integration name and version: name/version. You can string together multiple values in a space-separated list. The full syntax is: name/version [(comments)] [name/version [(comments)]] [...]​ Copy For the integration name, use a string that clearly and meaningfully identifies your integration. Ambiguous name: New Relic Integration Clear and meaningful name: SaaS XYZTools Integration with New Relic For the integration version, use a build ID, commit hash, or other identifier that is updated when you release new integration versions. Wrap comments in parentheses () as a semi-colon separated list; Helpful comments to include: The publicly-accessible URL of your integration. For instance, a Github URL, or a page in your docs site that describes the integration. Contact information so that New Relic can easily reach the integration publisher. Tip Information from the user agent string will never be shared, nor used by New Relic for any purpose other than discussing the integration with its publisher. Set custom user-agent for your integration You have an integration with the following identifying information: Name: MetricMeter Version: 3.2 URL: meter.me/info Contact: help@meter.me The custom user agent string would be: MetricMeter for New Relic/3.2 (meter.me/info; help​@​meter.me) Copy User agent strings and New Relic New Relic captures user agent strings from API calls to identify their source. Using custom user agent strings for publicly-available integration is a recommended best practice. Depending on your business relationship with New Relic, it may be required. Labeling your integration with a custom user agent string does not affect its interaction with New Relic's APIs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.15874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": " using New Relic&#x27;s RESTful <em>APIs</em>, set a User-Agent header that identifies your integration in <em>API</em> calls. This custom User-Agent string allows New Relic to identify the integration that is making requests to New Relic&#x27;s <em>APIs</em>. By setting a custom user agent, New Relic can track: Usage statistics for your"
      },
      "id": "6044070d196a67ce36960f5c"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2": [
    {
      "sections": [
        "Average browser (end user) page throughput example (v2)",
        "Average page throughput"
      ],
      "title": "Average browser (end user) page throughput example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "713534d353c7a66e7c02ec00f7d5340dab172740",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2/",
      "published_at": "2022-01-12T08:40:57Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser throughput appears at the top right of the Throughput by browser chart on your Summary page. This is the average pages per minute (PPM) by browser type in the time range shown on the chart. Average page throughput To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET 'https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json' \\ -H 'X-Api-Key:${API_KEY}' -i \\ -d 'names[]=EndUser&values[]=requests_per_minute&summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.75502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " minutes), use the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&#x27; \\ -H &#x27;X-<em>Api</em>-Key:${<em>API</em>_KEY}&#x27; -i \\ -d &#x27;names[]=EndUser&amp;values[]=requests_per_minute&amp;summarize=true&#x27; Copy"
      },
      "id": "604406cf28ccbc10652c6091"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.96834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Obtaining browser (end user) page load time data (v2)",
        "General API values",
        "Network time",
        "Page rendering time",
        "DOM processing time",
        "Web application time",
        "Request queuing time"
      ],
      "title": "Obtaining browser (end user) page load time data (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "c0c497cf900d84a9e57a07aba5062003e86506a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/obtaining-browser-end-user-page-load-time-data-v2/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-07-09T14:40:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The metric timeslice data presented on the Browser page load time chart on your application's Summary page will depend on your web app's configuration. Possible components may include: Network time Page rendering time DOM processing time Web application time Request queuing time This describes how to use the New Relic REST API (v2) to obtain the data shown on the Browser page load time chart. General API values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these examples. For calculated values, the time range you specify must be consistent in all of the queries; otherwise the final calculations will be incorrect. You must replace the ${APPID} and ${API_KEY} variables in these examples with your specific application ID and corresponding REST API key. Ensure you adjust the time units returned by the API requests as needed. Network time The EndUser:average_network_time is the network latency, or time it takes for a request to make a round trip over the Internet. Use the following command to obtain this. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_network_time' Copy This time is returned in milliseconds. Page rendering time Page rendering time is a derived value. To calculate it, use this equation: \"Page rendering\" time = EndUser:average_fe_response_time - EndUser/RB:average_dom_content_load_time Copy To obtain the data for this calculation, use the following commands. EndUser:average_fe_response_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_fe_response_time' Copy This time is returned in milliseconds. EndUser/RB:average_dom_content_load_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. DOM processing time The EndUser/RB:average_dom_content_load_time is the time spent in the browser to parse and interpret the HTML. This is measured by the browser's DOM Content event. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. Web application time The Web application time is the time spent in the application code. To calculate this value, use this equation: Web application = EndUser:total_app_time / EndUser:call_count Copy To obtain the data for this calculation, use the following commands. EndUser:total_app_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=total_app_time' Copy This time is returned in seconds. EndUser:call_count curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=call_count' Copy Request queuing time The EndUser/RB:average_queue_time is the wait time between the web server and the application code. Large numbers indicate a busy application server. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_queue_time' Copy This time is returned in milliseconds. The request queuing time is not included in the calculation of averages. New Relic includes it in this chart as a convenience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.93283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Obtaining <em>browser</em> (end user) page load time data (<em>v2</em>)",
        "sections": "Obtaining <em>browser</em> (end user) page load time data (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the data shown on the <em>Browser</em> page load time chart. General <em>API</em> values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these <em>examples</em>. For calculated values, the time range you"
      },
      "id": "6044070de7b9d2b9f7579a16"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2": [
    {
      "sections": [
        "Add or list browser apps via API (v2)",
        "Important",
        "Add browser apps",
        "List all browser apps",
        "View specific browser apps"
      ],
      "title": "Add or list browser apps via API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "53568984e3b360bac9255a33adad7e6b43fadf5d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2/",
      "published_at": "2022-01-12T08:40:18Z",
      "updated_at": "2021-11-13T06:57:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to add apps to browser monitoring or to get a list of your browser apps for a specific API key. This helps you manage deployment outside of New Relic One. These API calls are useful, for example, with larger organizations deploying multiple apps, or for integration partners who facilitate New Relic account creation and browser monitoring deployments. Important When you add a browser app via API (v2), you can only instrument basic page load timing. To use instrumentation supporting all SPA features, set up single page app monitoring via another method. Add browser apps To add an app to New Relic One, replace ${APIKEY} with your New Relic API key, and replace ${STRING} with the app's name in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser applications > POST create. Use the following command: curl -X POST 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"browser_application\": { \"name\": ${STRING} } }' Copy The API returns an array of data where the element is a browser application and the data associated with it: { \"browser_application\": { \"id\": \"integer\", \"name\": \"string\", \"browser_monitoring_key\": \"string\", \"loader_script\": \"string\" } Copy API (v2) output Description Browser app id (integer) This is the unique identification code for each app in New Relic One. App name (string) This is the app's name as it appears in the New Relic One. The browser_monitoring_key (string) This a unique key that is linked to (but is not the same as) the account license key. It is used to indicate the account in New Relic One where data will be reported. It cannot be used to determine your New Relic account's license key. Browser monitoring loader_script (string) The returned loader script is a JSON-encoded JavaScript snippet that is configured with the New Relic license key and application ID. The rest of the script is static and is approximately 10k in size. The loader script must be inserted into the user’s HTML pages correctly: It must appear in the page's <head> tag before the first script tag. If there are no script tags, put the JavaScript immediately before the </head> (end of head) tag. The entire loader script must be inserted in-line, not as a link to the .js file. List all browser apps To view a list of your browser-monitored apps, replace ${APIKEY} with your New Relic API key in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > GET List. Use the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can use the results to verify the account or name, and to get a copy of the loader script for the app, if needed. View specific browser apps View by name: To view a specific browser app if you know its name, replace ${APIKEY} with your New Relic API key, and replace ${NAME} with your app's name in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${NAME}\" Copy View by browser application ID: To view a specific browser app if you know its ID, replace ${APIKEY} with your New Relic API key, and replace ${ID} with your browser application ID in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[ids]=${ID}' Copy View multiple browser apps: To get information for multiple apps, separate the name or ID values with a comma in these commands; for example: -d 'filter[ids]=12345,23456' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.32542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add or list <em>browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "sections": "Add or list <em>browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to add apps to <em>browser</em> monitoring or to get a list of your <em>browser</em> apps for a specific <em>API</em> key. This helps you manage deployment outside of New Relic One. These <em>API</em> calls are useful, for example, with larger organizations deploying"
      },
      "id": "603ed6a928ccbc422beba77b"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.96834,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Obtaining browser (end user) page load time data (v2)",
        "General API values",
        "Network time",
        "Page rendering time",
        "DOM processing time",
        "Web application time",
        "Request queuing time"
      ],
      "title": "Obtaining browser (end user) page load time data (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "c0c497cf900d84a9e57a07aba5062003e86506a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/obtaining-browser-end-user-page-load-time-data-v2/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-07-09T14:40:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The metric timeslice data presented on the Browser page load time chart on your application's Summary page will depend on your web app's configuration. Possible components may include: Network time Page rendering time DOM processing time Web application time Request queuing time This describes how to use the New Relic REST API (v2) to obtain the data shown on the Browser page load time chart. General API values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these examples. For calculated values, the time range you specify must be consistent in all of the queries; otherwise the final calculations will be incorrect. You must replace the ${APPID} and ${API_KEY} variables in these examples with your specific application ID and corresponding REST API key. Ensure you adjust the time units returned by the API requests as needed. Network time The EndUser:average_network_time is the network latency, or time it takes for a request to make a round trip over the Internet. Use the following command to obtain this. curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_network_time' Copy This time is returned in milliseconds. Page rendering time Page rendering time is a derived value. To calculate it, use this equation: \"Page rendering\" time = EndUser:average_fe_response_time - EndUser/RB:average_dom_content_load_time Copy To obtain the data for this calculation, use the following commands. EndUser:average_fe_response_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=average_fe_response_time' Copy This time is returned in milliseconds. EndUser/RB:average_dom_content_load_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. DOM processing time The EndUser/RB:average_dom_content_load_time is the time spent in the browser to parse and interpret the HTML. This is measured by the browser's DOM Content event. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_dom_content_load_time' Copy This time is returned in milliseconds. Web application time The Web application time is the time spent in the application code. To calculate this value, use this equation: Web application = EndUser:total_app_time / EndUser:call_count Copy To obtain the data for this calculation, use the following commands. EndUser:total_app_time curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=total_app_time' Copy This time is returned in seconds. EndUser:call_count curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser&values[]=call_count' Copy Request queuing time The EndUser/RB:average_queue_time is the wait time between the web server and the application code. Large numbers indicate a busy application server. To obtain this data, use the following command: curl -X GET \"https://api.newrelic.com/v2/applications/${APPID}/metrics/data.json\" \\ -H \"X-Api-Key:${API_KEY}\" -i \\ -d 'names[]=EndUser/RB&values[]=average_queue_time' Copy This time is returned in milliseconds. The request queuing time is not included in the calculation of averages. New Relic includes it in this chart as a convenience.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.93283,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Obtaining <em>browser</em> (end user) page load time data (<em>v2</em>)",
        "sections": "Obtaining <em>browser</em> (end user) page load time data (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to obtain the data shown on the <em>Browser</em> page load time chart. General <em>API</em> values When making your own calculations, be aware of the following: You can change the default time range (30 minutes) used in these <em>examples</em>. For calculated values, the time range you"
      },
      "id": "6044070de7b9d2b9f7579a16"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/average-browser-page-load-time-example-v2": [
    {
      "sections": [
        "Add or list browser apps via API (v2)",
        "Important",
        "Add browser apps",
        "List all browser apps",
        "View specific browser apps"
      ],
      "title": "Add or list browser apps via API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "53568984e3b360bac9255a33adad7e6b43fadf5d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2/",
      "published_at": "2022-01-12T08:40:18Z",
      "updated_at": "2021-11-13T06:57:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to add apps to browser monitoring or to get a list of your browser apps for a specific API key. This helps you manage deployment outside of New Relic One. These API calls are useful, for example, with larger organizations deploying multiple apps, or for integration partners who facilitate New Relic account creation and browser monitoring deployments. Important When you add a browser app via API (v2), you can only instrument basic page load timing. To use instrumentation supporting all SPA features, set up single page app monitoring via another method. Add browser apps To add an app to New Relic One, replace ${APIKEY} with your New Relic API key, and replace ${STRING} with the app's name in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser applications > POST create. Use the following command: curl -X POST 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"browser_application\": { \"name\": ${STRING} } }' Copy The API returns an array of data where the element is a browser application and the data associated with it: { \"browser_application\": { \"id\": \"integer\", \"name\": \"string\", \"browser_monitoring_key\": \"string\", \"loader_script\": \"string\" } Copy API (v2) output Description Browser app id (integer) This is the unique identification code for each app in New Relic One. App name (string) This is the app's name as it appears in the New Relic One. The browser_monitoring_key (string) This a unique key that is linked to (but is not the same as) the account license key. It is used to indicate the account in New Relic One where data will be reported. It cannot be used to determine your New Relic account's license key. Browser monitoring loader_script (string) The returned loader script is a JSON-encoded JavaScript snippet that is configured with the New Relic license key and application ID. The rest of the script is static and is approximately 10k in size. The loader script must be inserted into the user’s HTML pages correctly: It must appear in the page's <head> tag before the first script tag. If there are no script tags, put the JavaScript immediately before the </head> (end of head) tag. The entire loader script must be inserted in-line, not as a link to the .js file. List all browser apps To view a list of your browser-monitored apps, replace ${APIKEY} with your New Relic API key in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > GET List. Use the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can use the results to verify the account or name, and to get a copy of the loader script for the app, if needed. View specific browser apps View by name: To view a specific browser app if you know its name, replace ${APIKEY} with your New Relic API key, and replace ${NAME} with your app's name in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${NAME}\" Copy View by browser application ID: To view a specific browser app if you know its ID, replace ${APIKEY} with your New Relic API key, and replace ${ID} with your browser application ID in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[ids]=${ID}' Copy View multiple browser apps: To get information for multiple apps, separate the name or ID values with a comma in these commands; for example: -d 'filter[ids]=12345,23456' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.32542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add or list <em>browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "sections": "Add or list <em>browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to add apps to <em>browser</em> monitoring or to get a list of your <em>browser</em> apps for a specific <em>API</em> key. This helps you manage deployment outside of New Relic One. These <em>API</em> calls are useful, for example, with larger organizations deploying"
      },
      "id": "603ed6a928ccbc422beba77b"
    },
    {
      "sections": [
        "Average browser (end user) page throughput example (v2)",
        "Average page throughput"
      ],
      "title": "Average browser (end user) page throughput example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "713534d353c7a66e7c02ec00f7d5340dab172740",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2/",
      "published_at": "2022-01-12T08:40:57Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser throughput appears at the top right of the Throughput by browser chart on your Summary page. This is the average pages per minute (PPM) by browser type in the time range shown on the chart. Average page throughput To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET 'https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json' \\ -H 'X-Api-Key:${API_KEY}' -i \\ -d 'names[]=EndUser&values[]=requests_per_minute&summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.75502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " minutes), use the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&#x27; \\ -H &#x27;X-<em>Api</em>-Key:${<em>API</em>_KEY}&#x27; -i \\ -d &#x27;names[]=EndUser&amp;values[]=requests_per_minute&amp;summarize=true&#x27; Copy"
      },
      "id": "604406cf28ccbc10652c6091"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.96826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/rest-api-v2/browser-examples-v2/obtaining-browser-end-user-page-load-time-data-v2": [
    {
      "sections": [
        "Add or list browser apps via API (v2)",
        "Important",
        "Add browser apps",
        "List all browser apps",
        "View specific browser apps"
      ],
      "title": "Add or list browser apps via API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "53568984e3b360bac9255a33adad7e6b43fadf5d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/add-or-list-browser-apps-api-v2/",
      "published_at": "2022-01-12T08:40:18Z",
      "updated_at": "2021-11-13T06:57:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are examples of how to use the New Relic REST API (v2) to add apps to browser monitoring or to get a list of your browser apps for a specific API key. This helps you manage deployment outside of New Relic One. These API calls are useful, for example, with larger organizations deploying multiple apps, or for integration partners who facilitate New Relic account creation and browser monitoring deployments. Important When you add a browser app via API (v2), you can only instrument basic page load timing. To use instrumentation supporting all SPA features, set up single page app monitoring via another method. Add browser apps To add an app to New Relic One, replace ${APIKEY} with your New Relic API key, and replace ${STRING} with the app's name in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser applications > POST create. Use the following command: curl -X POST 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"browser_application\": { \"name\": ${STRING} } }' Copy The API returns an array of data where the element is a browser application and the data associated with it: { \"browser_application\": { \"id\": \"integer\", \"name\": \"string\", \"browser_monitoring_key\": \"string\", \"loader_script\": \"string\" } Copy API (v2) output Description Browser app id (integer) This is the unique identification code for each app in New Relic One. App name (string) This is the app's name as it appears in the New Relic One. The browser_monitoring_key (string) This a unique key that is linked to (but is not the same as) the account license key. It is used to indicate the account in New Relic One where data will be reported. It cannot be used to determine your New Relic account's license key. Browser monitoring loader_script (string) The returned loader script is a JSON-encoded JavaScript snippet that is configured with the New Relic license key and application ID. The rest of the script is static and is approximately 10k in size. The loader script must be inserted into the user’s HTML pages correctly: It must appear in the page's <head> tag before the first script tag. If there are no script tags, put the JavaScript immediately before the </head> (end of head) tag. The entire loader script must be inserted in-line, not as a link to the .js file. List all browser apps To view a list of your browser-monitored apps, replace ${APIKEY} with your New Relic API key in the following command. To accomplish the same task from the API Explorer, use your API key and go to rpm.newrelic.com/api/explore > Browser Applications > GET List. Use the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i Copy You can use the results to verify the account or name, and to get a copy of the loader script for the app, if needed. View specific browser apps View by name: To view a specific browser app if you know its name, replace ${APIKEY} with your New Relic API key, and replace ${NAME} with your app's name in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d \"filter[name]=${NAME}\" Copy View by browser application ID: To view a specific browser app if you know its ID, replace ${APIKEY} with your New Relic API key, and replace ${ID} with your browser application ID in the following command: curl -X GET 'https://api.newrelic.com/v2/browser_applications.json' \\ -H \"X-Api-Key:${APIKEY}\" -i \\ -d 'filter[ids]=${ID}' Copy View multiple browser apps: To get information for multiple apps, separate the name or ID values with a comma in these commands; for example: -d 'filter[ids]=12345,23456' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.32542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add or list <em>browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "sections": "Add or list <em>browser</em> apps <em>via</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": "Here are <em>examples</em> of how to use the New Relic <em>REST</em> <em>API</em> (<em>v2</em>) to add apps to <em>browser</em> monitoring or to get a list of your <em>browser</em> apps for a specific <em>API</em> key. This helps you manage deployment outside of New Relic One. These <em>API</em> calls are useful, for example, with larger organizations deploying"
      },
      "id": "603ed6a928ccbc422beba77b"
    },
    {
      "sections": [
        "Average browser (end user) page throughput example (v2)",
        "Average page throughput"
      ],
      "title": "Average browser (end user) page throughput example (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Browser examples (v2)"
      ],
      "external_id": "713534d353c7a66e7c02ec00f7d5340dab172740",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/browser-examples-v2/average-browser-end-user-page-throughput-example-v2/",
      "published_at": "2022-01-12T08:40:57Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The average browser throughput appears at the top right of the Throughput by browser chart on your Summary page. This is the average pages per minute (PPM) by browser type in the time range shown on the chart. Average page throughput To obtain the average for the time range (default is last 30 minutes), use the following command. Be sure to replace the ${APP_ID} and ${API_KEY} variables in this example with your specific application ID and REST API key. curl -X GET 'https://api.newrelic.com/v2/applications/${APP_ID}/metrics/data.json' \\ -H 'X-Api-Key:${API_KEY}' -i \\ -d 'names[]=EndUser&values[]=requests_per_minute&summarize=true' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.75502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "sections": "Average <em>browser</em> (end user) page throughput <em>example</em> (<em>v2</em>)",
        "tags": "<em>Browser</em> <em>examples</em> (<em>v2</em>)",
        "body": " minutes), use the following command. Be sure to replace the ${APP_ID} and ${<em>API</em>_KEY} variables in this example with your specific application ID and <em>REST</em> <em>API</em> key. curl -X GET &#x27;https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;${APP_ID}&#x2F;metrics&#x2F;data.json&#x27; \\ -H &#x27;X-<em>Api</em>-Key:${<em>API</em>_KEY}&#x27; -i \\ -d &#x27;names[]=EndUser&amp;values[]=requests_per_minute&amp;summarize=true&#x27; Copy"
      },
      "id": "604406cf28ccbc10652c6091"
    },
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.96826,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 250.07526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.95624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Get app and other IDs in New Relic One",
        "Find IDs using New Relic One",
        "APM: App ID",
        "Browser app ID",
        "Mobile app ID"
      ],
      "title": "Get app and other IDs in New Relic One",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "90dfb764139b1e4ad047635210a4ca7470293c8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/get-app-other-ids-new-relic-one/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using the New Relic REST API, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to get some of these IDs. You can also get a list of IDs using the REST API Explorer. Find IDs using New Relic One New Relic One includes the IDs of applications and some other components in a metadata panel. Click the icon next to the application name to open the metadata panel. Here are some examples: APM: App ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click APM and select an application. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Browser app ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click Browser and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Mobile app ID To locate the $MOBILE_ID from the New Relic UI: From one.newrelic.com, click Mobile and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $MOBILE_ID in your REST API calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.50494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> app and other IDs in New Relic One",
        "sections": "<em>Get</em> app and other IDs in New Relic One",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "When using the New Relic <em>REST</em> <em>API</em>, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to <em>get</em> some of these IDs. You can also <em>get</em> a list of IDs using the <em>REST</em> <em>API</em> Explorer. Find"
      },
      "id": "603ed46c64441f70d44e8839"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/get-app-other-ids-new-relic-one": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 250.07526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.90749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.95624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2": [
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.90749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.95615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "Get app and other IDs in New Relic One",
        "Find IDs using New Relic One",
        "APM: App ID",
        "Browser app ID",
        "Mobile app ID"
      ],
      "title": "Get app and other IDs in New Relic One",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "90dfb764139b1e4ad047635210a4ca7470293c8a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/get-app-other-ids-new-relic-one/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When using the New Relic REST API, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to get some of these IDs. You can also get a list of IDs using the REST API Explorer. Find IDs using New Relic One New Relic One includes the IDs of applications and some other components in a metadata panel. Click the icon next to the application name to open the metadata panel. Here are some examples: APM: App ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click APM and select an application. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Browser app ID To locate the $APP_ID from the New Relic UI: From one.newrelic.com, click Browser and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $APP_ID in your REST API calls. Mobile app ID To locate the $MOBILE_ID from the New Relic UI: From one.newrelic.com, click Mobile and select a monitored app. Click the icon next to the application name to open the metadata panel. Locate the App ID. Substitute this number for the $MOBILE_ID in your REST API calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.50494,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> app and other IDs in New Relic One",
        "sections": "<em>Get</em> app and other IDs in New Relic One",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "When using the New Relic <em>REST</em> <em>API</em>, you need to replace some ID placeholders (like $APP_ID, $KEYTX_ID, $COMPONENT_ID, etc.) with the ID for an app, transaction, or other component. You can use New Relic One to <em>get</em> some of these IDs. You can also <em>get</em> a list of IDs using the <em>REST</em> <em>API</em> Explorer. Find"
      },
      "id": "603ed46c64441f70d44e8839"
    }
  ],
  "/docs/apis/rest-api-v2/get-started/list-application-id-host-id-instance-id": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 250.07516,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 203.90749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.95615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    }
  ],
  "/docs/apis/rest-api-v2/labels-examples-v2/create-labels-apps-v2": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.95609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.98386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    }
  ],
  "/docs/apis/rest-api-v2/mobile-examples-v2/mobile-crash-count-crash-rate-example-v2": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.95609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.98386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    }
  ],
  "/docs/apis/rest-api-v2/troubleshooting/301-response-rest-api-calls": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.24728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    }
  ],
  "/docs/apis/rest-api-v2/troubleshooting/500-error-when-starting-api-explorer": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.24728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    }
  ],
  "/docs/apis/rest-api-v2/troubleshooting/http-200-status-api-explorer": [
    {
      "sections": [
        "Introduction to New Relic REST API (v2)",
        "Setup",
        "Tip",
        "URL",
        "API key $API_KEY",
        "Query details (PAYLOAD)",
        "Examples"
      ],
      "title": "Introduction to New Relic REST API (v2)",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "97d12808fc706366121b8c005edc2320a0c7797b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/introduction-new-relic-rest-api-v2/",
      "published_at": "2022-01-12T08:42:15Z",
      "updated_at": "2022-01-08T02:34:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's REST APIs let you retrieve data from, and push data to New Relic tools, and include configuration and delete capabilities. You can also use the API Explorer to understand the data available to you via the REST API, to obtain curl commands, and to see JSON responses. Setup The REST API command structure follows this template: curl -X GET <URL> -H \"Api-Key:$API_KEY\" -d '<PAYLOAD>' Copy The GET command could also be a POST or DELETE, depending on the query intent. To understand the placeholders, keep reading. Tip Our examples use curl as a common command line tool to pull metric timeslice data from the REST API. However, you can use any method to make your REST requests. The curl commands include target URLs, header information, and data which are relevant for any request mechanism. URL The API calls require a URL to specify the location from which the data will be accessed. You must replace the placeholder <URL> with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy The $APPID specifies the exact application or product for which the data is being requested. The information following this parameter will vary depending on the data request. If you have an EU region account, the URL is: api. eu .newrelic.com/v2/applications/$APP_ID/metrics/data.json Copy Tip You can retrieve XML data instead of JSON by replacing .json with .xml. API key $API_KEY New Relic API calls require an API key. This may be one of several API keys: A user key: This is recommended. It's our latest key implementation and has fewer limitations than a REST API key. The user key is also used for our NerdGraph API. A REST API key: This is our older key implementation. For more information about it, see REST API key. If you use this key, the required header is X-Api-Key and not Api-Key. If you have a New Relic partnership account, you'll use a different key: see Partnership authentication. In our REST API examples, we borrow the API key placeholder $API_KEY from Unix shell programming. Be sure to replace that and other user-specific variables when forming calls. Query details (PAYLOAD) The < PAYLOAD> contains the query details, which define: The metric name you want to query and the value you want to retrieve The defined time range for retrieving metrics (Optional): The average of the metric timeslice data by using summarize Examples See the following docs for example REST API use cases: APM examples (how to retrieve metric timeslice data from APM) Browser examples (how to retrieve metric timeslice data from browser monitoring). The REST API only returns the Lite browser agent script. For more information, see this table comparing Lite, Pro, and Pro+SPA types. Infrastructure alert examples Alerts examples (create alert conditions and configure notification channels, and more)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.00397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "sections": "Introduction to New Relic <em>REST</em> <em>API</em> (<em>v2</em>)",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": ". You must replace the placeholder &lt;URL&gt; with the appropriate URL which will change depending on the type of data being requested. In general the URL follows this template: https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;<em>v2</em>&#x2F;applications&#x2F;$APP_ID&#x2F;metrics&#x2F;data.json Copy The $APPID specifies the exact application or product"
      },
      "id": "604428f528ccbc84422c60ef"
    },
    {
      "sections": [
        "Default time zone setting",
        "Change your default time zone",
        "Exceptions"
      ],
      "title": "Default time zone setting",
      "type": "docs",
      "tags": [
        "Accounts",
        "Accounts and billing",
        "General account settings"
      ],
      "external_id": "3a7abaee77b5d140836c96007766fa8eb9109b6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts-billing/general-account-settings/default-time-zone-setting/",
      "published_at": "2022-01-12T08:16:27Z",
      "updated_at": "2022-01-08T04:21:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your personal timezone setting controls most time-related settings in the New Relic UI, with a few exceptions, as explained in this document. If you change your timezone setting, this may take up to 24 hours to be reflected in the UI. Change your default time zone To change your default time zone for your New Relic account: Go to one.newrelic.com. Select the account dropdown, then select User preferences. Exceptions Users managed via automated user management can't change their time zone in the UI. That must be configured in your identity provider. Some New Relic features do not rely on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren't affected by user preferences: Alerts REST API v2 There may be other features where the time zone doesn't rely on your default time zone settings.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 172.71938,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " on the User preferences time zone settings. The following use Coordinated Universal Time (UTC) and aren&#x27;t affected by user preferences: Alerts <em>REST</em> <em>API</em> <em>v2</em> There may be other features where the time zone doesn&#x27;t rely on your default time zone settings."
      },
      "id": "6043f38a28ccbc97e62c6090"
    },
    {
      "sections": [
        "New Relic partnership account authentication",
        "Custom headers and API calls",
        "Known limitations"
      ],
      "title": "New Relic partnership account authentication",
      "type": "docs",
      "tags": [
        "APIs",
        "REST API v2",
        "Get started"
      ],
      "external_id": "a4e139380383b634e44d288b7065597de60e6b84",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/rest-api-v2/get-started/admin-users-api-key-partnerships/",
      "published_at": "2022-01-12T08:41:36Z",
      "updated_at": "2021-10-31T04:03:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This approach adds a new authentication method to the customer-facing New Relic REST API (v2) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all REST API (v2) calls. It offers no new functionality for non-partner API users. When calling endpoints in the New Relic REST API (v2) that require the user key, New Relic suggests you use the described authentication method. Custom headers and API calls When making API calls, use the following custom headers with your partner API key, partner ID, and your account ID: X-Api-Key:YOUR_PARTNER_ACCOUNT_API_KEY NewRelic-Partner-Id:YOUR_PARTNER_ID NewRelic-Account-Id:YOUR_CUSTOMERS_ACCOUNT_ID Providing authentication to the REST API (v2) in this form allows you to complete any API operation on your customer’s accounts. This bypasses the customer-facing requirement that some API calls require an Admin user’s API key. This authentication method also works for API endpoints that require only the REST API key. This new authentication method works for all endpoints, not only those that require the Admin User’s API key. Known limitations This partner-only authentication method will only work with the New Relic REST API (v2). It does not work with the following: Deployment API Infrastructure API for alerts Insights API Insights Dashboard API Partner API Synthetics API",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.24728,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Custom headers and <em>API</em> calls",
        "tags": "<em>REST</em> <em>API</em> <em>v2</em>",
        "body": "This approach adds a new authentication method to the customer-facing New Relic <em>REST</em> <em>API</em> (<em>v2</em>) that allows partners (and enterprise-scale customers that use the partnership structure to manage their multiple accounts) to use their partnership credentials to authorize all <em>REST</em> <em>API</em> (<em>v2</em>) calls"
      },
      "id": "60440747e7b9d2a1465799f2"
    }
  ],
  "/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api": [
    {
      "sections": [
        "Synthetics REST API version 1 (deprecated)",
        "Caution",
        "Managing simple and scripted monitors",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Delete an existing monitor",
        "Get list of valid locations",
        "Managing scripted monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Synthetics attributes",
        "Specific monitor endpoint"
      ],
      "title": "Synthetics REST API version 1 (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "38f3b7d441889cea39fa8a10d1593473bffa8cf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1/",
      "published_at": "2022-01-12T18:27:54Z",
      "updated_at": "2021-10-31T10:08:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the Synthetics API: v1 and v3. Version 3 was released October 2016. Version 1 is deprecated and will eventually no longer be available. No termination date has been announced. However, no further development or modifications will be made to v1. Caution Recommendation: Create new monitors using the v3 Synthetics API and migrate v1 scripts to their v3 equivalent. To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls via the command line. Managing simple and scripted monitors You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. These examples show curl commands: Get all monitors To view a list of all monitors in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors. For example: curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"count\": integer, \"monitors\": [ { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } ] } Copy Get a specific monitor To view a single existing monitor in New Relic, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return the error 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your account in New Relic, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/monitors with a JSON payload that describes the monitor: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings (send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/locations to get a list of valid locations) [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, } Copy In addition, to add a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. Replace the Synthetics REST API attributes in the following example with your specific values. curl -v \\ -X POST -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. Replace the { id} in the following example with the specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} \\ -d '{ \"name\" : \"updated monitor name\", \"type\" : \"simple\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response, 404 Not Found: The specified monitor does not exist. Get list of valid locations To retrieve the list of valid locations in New Relic, use the following command. curl -v \\ -X GET -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/locations Copy Managing scripted monitors In addition to the general API, there are several API methods for the scripted browser (SCRIPT_BROWSER) and api test (SCRIPT_API) monitor types. These examples show curl commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script. Replace the { id} with the specific monitor ID. For example: curl -v -H 'X-Api-Key: {Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the ${MONITOR_UUID}/script endpoint. For more information, refer to the example. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script with a JSON payload that contains the scriptText (required). The scriptLocations data is required only for private locations with Verified Script Execution turned on. The password used to generate the HMAC string must match the password set for the private location. When generating the HMAC string, use the SHA256 algorithm. { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy Replace the { id} with the specific monitor ID. Here is an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation. curl -v -H 'X-Api-Key: '{Admin_User_Key}' -H 'content-type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4\"} ]}' Copy A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows curl commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example show the bash script that will create the SCRIPTED_BROWSER monitor. #!/bin/bash # Admin API key from your account settings adminAPIKey='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload='{\"scriptText\":\"'$encoded'\"}' curl -s -X PUT -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy Synthetics attributes Here are the attributes used with Synthetics REST API calls, listed in alphabetical order. Synthetics API attribute Definition apiVersion String: The version number. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific Synthetics monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected Synthetics monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.49413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "sections": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " the SCRIPTED_BROWSER <em>monitor</em>. #!&#x2F;bin&#x2F;bash # Admin <em>API</em> key from your account settings adminAPIKey=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>Type=&#x27;SCRIPT_BROWSER"
      },
      "id": "60452541e7b9d27829579a0a"
    },
    {
      "sections": [
        "Payload attributes for the Synthetics REST API",
        "Synthetic monitoring attributes",
        "Specific monitor endpoint"
      ],
      "title": "Payload attributes for the Synthetics REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "ed3202f6715ae367d5c7c58d63a332d073535995",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api/",
      "published_at": "2022-01-12T08:44:32Z",
      "updated_at": "2021-10-31T04:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For REST API requirements for synthetics, see Use the API. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the Synthetics REST API: Synthetics API attribute Definition apiVersion String: The version number. count Integer: The number of monitors returned. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific synthetic monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. options Object: options for SIMPLE and BROWSER monitor types. Options include: validationString: string verifySSL: boolean (true, false) bypassHEADRequest: boolean (true, false) treatRedirectAsFailure: boolean (true, false) Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected synthetic monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.43118,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "sections": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " <em>REST</em> <em>API</em> calls for a specific <em>monitor</em>, include the <em>monitor</em>_uuid as part of the endpoint. The <em>monitor</em>_uuid is the GUID which is part of the URL. For example, a selected synthetic <em>monitor</em> has this URL: https:&#x2F;&#x2F;<em>synthetics</em>.newrelic.com&#x2F;accounts&#x2F;nnnn&#x2F;monitors&#x2F;ab123-c456d-e78-90123-f45g Copy The <em>monitor</em>_uuid is the value that follows &#x2F;monitors&#x2F;."
      },
      "id": "6043f9ae28ccbc98002c607a"
    },
    {
      "sections": [
        "Use synthetic monitoring secure credentials APIs",
        "Requirements and rules",
        "API examples",
        "Add a secure credential",
        "Get all secure credentials",
        "Get a specific secure credential",
        "Update an existing secure credential",
        "Delete an existing secure credential"
      ],
      "title": "Use synthetic monitoring secure credentials APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Secure credentials examples"
      ],
      "external_id": "bd66e43160c1fd4c9f66bfdfa2d9a3223eb5d4d7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/secure-credentials-examples/use-synthetics-secure-credentials-apis/",
      "published_at": "2022-01-12T08:45:13Z",
      "updated_at": "2021-10-31T04:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Synthetics REST API, you can make API calls to change or retrieve secure credentials data. This document explains the API requirements and contains API curl command examples. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials. Requirements and rules For general rules about this feature, see the secure credentials requirements. API requirements and rules include: See general Synthetics REST API requirements. An account's rate of requests is limited to three requests per second. Requests that exceed this threshold will return a 429 response code. A key's value cannot be accessed via the API; an unauthorized user would not have access to the secure key values. API examples Add a secure credential To send a secure credential to your New Relic account, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials with a JSON payload that describes the secure credential. Here's an example: { \"key\": string [required, 1-64 characters uppercase], \"value\": string [required, 1-3,000 characters], \"description\": string [optional] } Copy Here's an example of doing this with a curl command: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy A successful request will return a 201 Created response, with the URI of the newly-created secure credential specified in the location header. Possible error codes include: 303 See Other: The specified key already exists. The returned location header will contain the URI to the key. 400 Bad Request: Key too long or missing, value too long or missing, non-parsable JSON payload. Get all secure credentials To view a list of all the secure credentials in your New Relic account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials. For example: curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"secureCredentials\": [ { \"key\": \"MYKEY1\", \"description\": \"Description of MYKEY1\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" }, { \"key\": \"MYKEY2\", \"description\": \"Description of MYKEY2\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" } ], \"count\": 2 } Copy Get a specific secure credential To view a single secure credential, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"key\": string, \"description\": string, \"createdAt\": date,​ \"lastUpdated\": date } Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Update an existing secure credential To update an existing credential in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Delete an existing secure credential To delete an existing credential in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy Please note that if the specified key does not exist, no error will occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.984856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "sections": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": "With the <em>Synthetics</em> <em>REST</em> <em>API</em>, you can make <em>API</em> calls to change or retrieve secure credentials data. This document explains the <em>API</em> requirements and contains <em>API</em> curl command <em>examples</em>. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials"
      },
      "id": "6044070d196a67b171960f76"
    }
  ],
  "/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api": [
    {
      "sections": [
        "Synthetics REST API version 1 (deprecated)",
        "Caution",
        "Managing simple and scripted monitors",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Delete an existing monitor",
        "Get list of valid locations",
        "Managing scripted monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Synthetics attributes",
        "Specific monitor endpoint"
      ],
      "title": "Synthetics REST API version 1 (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "38f3b7d441889cea39fa8a10d1593473bffa8cf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1/",
      "published_at": "2022-01-12T18:27:54Z",
      "updated_at": "2021-10-31T10:08:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the Synthetics API: v1 and v3. Version 3 was released October 2016. Version 1 is deprecated and will eventually no longer be available. No termination date has been announced. However, no further development or modifications will be made to v1. Caution Recommendation: Create new monitors using the v3 Synthetics API and migrate v1 scripts to their v3 equivalent. To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls via the command line. Managing simple and scripted monitors You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. These examples show curl commands: Get all monitors To view a list of all monitors in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors. For example: curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"count\": integer, \"monitors\": [ { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } ] } Copy Get a specific monitor To view a single existing monitor in New Relic, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return the error 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your account in New Relic, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/monitors with a JSON payload that describes the monitor: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings (send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/locations to get a list of valid locations) [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, } Copy In addition, to add a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. Replace the Synthetics REST API attributes in the following example with your specific values. curl -v \\ -X POST -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. Replace the { id} in the following example with the specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} \\ -d '{ \"name\" : \"updated monitor name\", \"type\" : \"simple\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response, 404 Not Found: The specified monitor does not exist. Get list of valid locations To retrieve the list of valid locations in New Relic, use the following command. curl -v \\ -X GET -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/locations Copy Managing scripted monitors In addition to the general API, there are several API methods for the scripted browser (SCRIPT_BROWSER) and api test (SCRIPT_API) monitor types. These examples show curl commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script. Replace the { id} with the specific monitor ID. For example: curl -v -H 'X-Api-Key: {Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the ${MONITOR_UUID}/script endpoint. For more information, refer to the example. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script with a JSON payload that contains the scriptText (required). The scriptLocations data is required only for private locations with Verified Script Execution turned on. The password used to generate the HMAC string must match the password set for the private location. When generating the HMAC string, use the SHA256 algorithm. { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy Replace the { id} with the specific monitor ID. Here is an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation. curl -v -H 'X-Api-Key: '{Admin_User_Key}' -H 'content-type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4\"} ]}' Copy A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows curl commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example show the bash script that will create the SCRIPTED_BROWSER monitor. #!/bin/bash # Admin API key from your account settings adminAPIKey='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload='{\"scriptText\":\"'$encoded'\"}' curl -s -X PUT -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy Synthetics attributes Here are the attributes used with Synthetics REST API calls, listed in alphabetical order. Synthetics API attribute Definition apiVersion String: The version number. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific Synthetics monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected Synthetics monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.49413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "sections": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " the SCRIPTED_BROWSER <em>monitor</em>. #!&#x2F;bin&#x2F;bash # Admin <em>API</em> key from your account settings adminAPIKey=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>Type=&#x27;SCRIPT_BROWSER"
      },
      "id": "60452541e7b9d27829579a0a"
    },
    {
      "sections": [
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Caution",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Patch an existing monitor",
        "Delete an existing monitor",
        "Get a list of valid locations",
        "Script API for scripted browser and API test monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Using private location scripts with verified script execution",
        "Important",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Tip"
      ],
      "title": "Manage synthetic monitors via REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "83a3e8ad751c7f0865785a1c2fad193604a7f7da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api/",
      "published_at": "2022-01-12T08:44:32Z",
      "updated_at": "2021-09-14T18:17:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api Copy For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api Copy Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Copy Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 50. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' Copy The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Copy Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } Copy In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' Copy PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Copy Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload Copy If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' Copy Important You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. Tip In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.9933,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "sections": "Manage <em>synthetic</em> <em>monitors</em> via <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " will disable line wrapping: base64 -w 0 $scriptfile #!&#x2F;bin&#x2F;bash # <em>API</em> key from your account settings <em>API</em>_KEY=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;<em>monitor</em>-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes <em>monitor</em>Name=&#x27;Test <em>API</em> Script&#x27; <em>monitor</em>"
      },
      "id": "60440d4628ccbc74532c606a"
    },
    {
      "sections": [
        "Use synthetic monitoring secure credentials APIs",
        "Requirements and rules",
        "API examples",
        "Add a secure credential",
        "Get all secure credentials",
        "Get a specific secure credential",
        "Update an existing secure credential",
        "Delete an existing secure credential"
      ],
      "title": "Use synthetic monitoring secure credentials APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Secure credentials examples"
      ],
      "external_id": "bd66e43160c1fd4c9f66bfdfa2d9a3223eb5d4d7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/secure-credentials-examples/use-synthetics-secure-credentials-apis/",
      "published_at": "2022-01-12T08:45:13Z",
      "updated_at": "2021-10-31T04:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Synthetics REST API, you can make API calls to change or retrieve secure credentials data. This document explains the API requirements and contains API curl command examples. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials. Requirements and rules For general rules about this feature, see the secure credentials requirements. API requirements and rules include: See general Synthetics REST API requirements. An account's rate of requests is limited to three requests per second. Requests that exceed this threshold will return a 429 response code. A key's value cannot be accessed via the API; an unauthorized user would not have access to the secure key values. API examples Add a secure credential To send a secure credential to your New Relic account, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials with a JSON payload that describes the secure credential. Here's an example: { \"key\": string [required, 1-64 characters uppercase], \"value\": string [required, 1-3,000 characters], \"description\": string [optional] } Copy Here's an example of doing this with a curl command: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy A successful request will return a 201 Created response, with the URI of the newly-created secure credential specified in the location header. Possible error codes include: 303 See Other: The specified key already exists. The returned location header will contain the URI to the key. 400 Bad Request: Key too long or missing, value too long or missing, non-parsable JSON payload. Get all secure credentials To view a list of all the secure credentials in your New Relic account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials. For example: curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"secureCredentials\": [ { \"key\": \"MYKEY1\", \"description\": \"Description of MYKEY1\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" }, { \"key\": \"MYKEY2\", \"description\": \"Description of MYKEY2\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"lastUpdated\": \"2016-09-26T23:12:46.981+0000\" } ], \"count\": 2 } Copy Get a specific secure credential To view a single secure credential, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"key\": string, \"description\": string, \"createdAt\": date,​ \"lastUpdated\": date } Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Update an existing secure credential To update an existing credential in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY \\ -d '{ \"key\": \"MYKEY\", \"value\": \"my value\", \"description\": \"Description of MYKEY\" }' Copy An invalid key will return 404 Not Found: The specified key doesn't exist. Delete an existing secure credential To delete an existing credential in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY. curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/secure-credentials/$KEY Copy Please note that if the specified key does not exist, no error will occur.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.984856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "sections": "Use <em>synthetic</em> <em>monitoring</em> secure credentials <em>APIs</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": "With the <em>Synthetics</em> <em>REST</em> <em>API</em>, you can make <em>API</em> calls to change or retrieve secure credentials data. This document explains the <em>API</em> requirements and contains <em>API</em> curl command <em>examples</em>. For general guidelines for setting secure credentials and setting them in the UI, see Secure credentials"
      },
      "id": "6044070d196a67b171960f76"
    }
  ],
  "/docs/apis/synthetics-rest-api/secure-credentials-examples/use-synthetics-secure-credentials-apis": [
    {
      "sections": [
        "Synthetics REST API version 1 (deprecated)",
        "Caution",
        "Managing simple and scripted monitors",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Delete an existing monitor",
        "Get list of valid locations",
        "Managing scripted monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Synthetics attributes",
        "Specific monitor endpoint"
      ],
      "title": "Synthetics REST API version 1 (deprecated)",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "38f3b7d441889cea39fa8a10d1593473bffa8cf7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/synthetics/new-relic-synthetics/synthetics-api/synthetics-rest-api-version-1/",
      "published_at": "2022-01-12T18:27:54Z",
      "updated_at": "2021-10-31T10:08:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Currently New Relic supports two versions of the Synthetics API: v1 and v3. Version 3 was released October 2016. Version 1 is deprecated and will eventually no longer be available. No termination date has been announced. However, no further development or modifications will be made to v1. Caution Recommendation: Create new monitors using the v3 Synthetics API and migrate v1 scripts to their v3 equivalent. To use the REST API for New Relic's synthetic monitoring, you must activate API access and generate your Admin User's API key from your account settings. Then you can make standard API calls via the command line. Managing simple and scripted monitors You must use your Admin User's API key to make Synthetics REST API calls. The account's REST API key will not work. Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. These examples show curl commands: Get all monitors To view a list of all monitors in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors. For example: curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"count\": integer, \"monitors\": [ { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } ] } Copy Get a specific monitor To view a single existing monitor in New Relic, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return the error 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your account in New Relic, send a POST request to https://synthetics.newrelic.com/synthetics/api/v1/monitors with a JSON payload that describes the monitor: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings (send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/locations to get a list of valid locations) [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, } Copy In addition, to add a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. Replace the Synthetics REST API attributes in the following example with your specific values. curl -v \\ -X POST -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. Replace the { id} in the following example with the specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'X-Api-Key:{Admin_User_Key}' \\ -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} \\ -d '{ \"name\" : \"updated monitor name\", \"type\" : \"simple\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic, send a DELETE request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}. Replace the { id} in the following example with the specific monitor ID. curl -v \\ -H 'X-Api-Key:{Admin_User_Key}' \\ -X DELETE https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id} Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response, 404 Not Found: The specified monitor does not exist. Get list of valid locations To retrieve the list of valid locations in New Relic, use the following command. curl -v \\ -X GET -H 'X-Api-Key:{Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/locations Copy Managing scripted monitors In addition to the general API, there are several API methods for the scripted browser (SCRIPT_BROWSER) and api test (SCRIPT_API) monitor types. These examples show curl commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a GET request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script. Replace the { id} with the specific monitor ID. For example: curl -v -H 'X-Api-Key: {Admin_User_Key}' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the ${MONITOR_UUID}/script endpoint. For more information, refer to the example. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic for your account, send a PUT request to https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script with a JSON payload that contains the scriptText (required). The scriptLocations data is required only for private locations with Verified Script Execution turned on. The password used to generate the HMAC string must match the password set for the private location. When generating the HMAC string, use the SHA256 algorithm. { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy Replace the { id} with the specific monitor ID. Here is an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation. curl -v -H 'X-Api-Key: '{Admin_User_Key}' -H 'content-type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors/{id}/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4\"} ]}' Copy A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows curl commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example show the bash script that will create the SCRIPTED_BROWSER monitor. #!/bin/bash # Admin API key from your account settings adminAPIKey='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' https://synthetics.newrelic.com/synthetics/api/v1/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload='{\"scriptText\":\"'$encoded'\"}' curl -s -X PUT -H \"X-Api-Key:$adminAPIKey\" -H 'Content-Type: application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy Synthetics attributes Here are the attributes used with Synthetics REST API calls, listed in alphabetical order. Synthetics API attribute Definition apiVersion String: The version number. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific Synthetics monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected Synthetics monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.69438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "sections": "<em>Synthetics</em> <em>REST</em> <em>API</em> version 1 (deprecated)",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " the SCRIPTED_BROWSER monitor. #!&#x2F;bin&#x2F;bash # Admin <em>API</em> key from your account settings adminAPIKey=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;monitor-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes monitorName=&#x27;Test <em>API</em> Script&#x27; monitorType=&#x27;SCRIPT_BROWSER"
      },
      "id": "60452541e7b9d27829579a0a"
    },
    {
      "sections": [
        "Payload attributes for the Synthetics REST API",
        "Synthetic monitoring attributes",
        "Specific monitor endpoint"
      ],
      "title": "Payload attributes for the Synthetics REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "ed3202f6715ae367d5c7c58d63a332d073535995",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/payload-attributes-synthetics-rest-api/",
      "published_at": "2022-01-12T08:44:32Z",
      "updated_at": "2021-10-31T04:10:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For REST API requirements for synthetics, see Use the API. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the Synthetics REST API: Synthetics API attribute Definition apiVersion String: The version number. count Integer: The number of monitors returned. emails Array of strings: Email addresses for alert notifications with New Relic. frequency Integer: Number of minutes between checks. Valid values include 1, 5, 15, 30, 60, 360, 720, and 1440. id The UUID for the specific synthetic monitor. locations Array of strings: Array of locations by full label. name String: The monitor's name. scriptLocations String: The name and hmac values for private locations using Verified Script Execution. scriptText String: The BASE64 encoded text for scripted monitors. slaThreshold Double: Value for the Synthetics SLA report, in seconds. status String: Valid values include ENABLED, MUTED, and DISABLED. type String: Type of monitor. Valid values include: SIMPLE (Ping) BROWSER SCRIPT_BROWSER SCRIPT_API uri String: The URI for SIMPLE and BROWSER monitor types; for example, http://my-site.com. Optional for SCRIPT_BROWSER and SCRIPT_API. userID Integer: The specific user ID. options Object: options for SIMPLE and BROWSER monitor types. Options include: validationString: string verifySSL: boolean (true, false) bypassHEADRequest: boolean (true, false) treatRedirectAsFailure: boolean (true, false) Specific monitor endpoint When making REST API calls for a specific monitor, include the monitor_uuid as part of the endpoint. The monitor_uuid is the GUID which is part of the URL. For example, a selected synthetic monitor has this URL: https://synthetics.newrelic.com/accounts/nnnn/monitors/ab123-c456d-e78-90123-f45g Copy The monitor_uuid is the value that follows /monitors/.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.651184,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "sections": "Payload attributes for the <em>Synthetics</em> <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": "For <em>REST</em> <em>API</em> requirements for <em>synthetics</em>, see Use the <em>API</em>. Synthetic monitoring attributes Here are the attributes that can be used when creating and managing monitors with the <em>Synthetics</em> <em>REST</em> <em>API</em>: <em>Synthetics</em> <em>API</em> attribute Definition <em>api</em>Version String: The version number. count Integer: The number"
      },
      "id": "6043f9ae28ccbc98002c607a"
    },
    {
      "sections": [
        "Manage synthetic monitors via REST API",
        "Features",
        "Monitor types in API",
        "Use the API",
        "Caution",
        "Get all monitors",
        "Get a specific monitor",
        "Create a monitor",
        "Update an existing monitor",
        "Patch an existing monitor",
        "Delete an existing monitor",
        "Get a list of valid locations",
        "Script API for scripted browser and API test monitors",
        "Get monitor script",
        "Add scripted monitor",
        "Update monitor script",
        "Using private location scripts with verified script execution",
        "Important",
        "Scripted browser example",
        "Scripted browser API example",
        "Bash script example",
        "Tip"
      ],
      "title": "Manage synthetic monitors via REST API",
      "type": "docs",
      "tags": [
        "APIs",
        "Synthetics REST API",
        "Monitor examples"
      ],
      "external_id": "83a3e8ad751c7f0865785a1c2fad193604a7f7da",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/manage-synthetics-monitors-rest-api/",
      "published_at": "2022-01-12T08:44:32Z",
      "updated_at": "2021-09-14T18:17:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Use the Synthetics REST API to create and manage synthetic monitors of all types: ping, simple browser, scripted browser, and API test monitors. All synthetic monitoring data is available via the REST API. To use the Synthetics REST API, you must have a user role that allows that capability and a user key. For an overview of all available New Relic APIs, see Intro to APIs. Features The newest version of the Synthetics API (v3) adds these features: Synthetics API (v3) Features Options field for POST and PUT request You can specify the options for SIMPLE and BROWSER type monitors, similar to the way these options are available in the UI. PATCH request You can update only the fields of a monitor you want to change, rather than having to specify the entire monitor entity in a PUT. You can also specify the OPTION, assuming you are using the appropriate type of monitor. More detail with 400 Bad Request errors As of v3, the Synthetics API attempts to return as much information as possible when a validation failure occurs. This will help you figure out what might be wrong with the request. The API runs all validations and returns any failed validation messages, rather than failing on the first validation error as occurred in previous API versions. Pagination Large API responses are properly paginated. You can also use NRQL queries to analyze past changes made via the API. Monitor types in API These are the monitor types and how they're referred to in the API: Monitor type API name Ping SIMPLE Simple browser BROWSER Scripted browser SCRIPT_BROWSER API test SCRIPT_API Use the API To use the Synthetics REST API, you must have the ability to manage synthetics monitors and use a user key (the REST API key won't work). This API can be used for all Synthetics monitors. (Additional API methods for scripted browser and API test monitors are also available to update the script associated with those monitors.) All Synthetics data is available via the API. API examples show cURL commands. For US-based accounts, use the following endpoint: https://synthetics.newrelic.com/synthetics/api Copy For EU-based accounts, use the following endpoint: https://synthetics.eu.newrelic.com/synthetics/api Copy Caution The Synthetics REST API limits an account's rate of requests to three requests per second. Requests made in excess of this threshold will return a 429 response code. Get all monitors To view a list of all the monitors in your New Relic account, send a GET request to $API_ENDPOINT/v3/monitors. For example: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"monitors\": [ { \"id\": \"2a1bc369-7654-489d-918e-f6g135h7i2jk\", \"name\": \"monitor1\", \"type\": \"BROWSER\", \"frequency\": 60, \"uri\": \"http://example.com\", \"locations\": [ \"AWS_US_WEST_1\" ], \"status\": \"DISABLED\", \"slaThreshold\": 7, \"options\": {}, \"modifiedAt\": \"2016-09-26T23:12:46.981+0000\", \"createdAt\": \"2016-09-26T23:12:46.981+0000\", \"userId\": 0, \"apiVersion\": \"0.2.2\" } ], \"count\": 1 } Copy Query arguments: offset: The monitor count offset. Defaults to 0. For example, if you have 40 monitors and you use an offset value of 20, it will return monitors 21-40. limit: The number of results per page, maximum 100. Defaults to 50. You can include these in your cURL command as follows: curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors \\ -G -d 'offset=20&limit=100' Copy The headers include a Link to help you easily page your monitors. For example: <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=0&limit=20>; rel=\"first\", <https://synthetics.newrelic.com/synthetics/api/v3/monitors/?offset=40&limit=20>; rel=\"last\" Copy Get a specific monitor To view a single Synthetics monitor, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. curl -v \\ -H 'Api-Key:$API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"id\": UUID, \"name\": string, \"type\": string, \"frequency\": integer, \"uri\": string, \"locations\": array of strings, \"status\": string, \"slaThreshold\": double, \"userId\": integer, \"apiVersion\": string } Copy An invalid monitor ID will return 404 Not Found: The specified monitor doesn't exist. Create a monitor To add a new monitor to your Synthetics account, send a POST request to $API_ENDPOINT/v3/monitors with a JSON payload that describes the monitor. All fields in the following example are required unless stated otherwise: { \"name\": string [required], \"type\": string (SIMPLE, BROWSER, SCRIPT_API, SCRIPT_BROWSER) [required], \"frequency\": integer (minutes) [required, must be one of 1, 5, 10, 15, 30, 60, 360, 720, or 1440], \"uri\": string [required for SIMPLE and BROWSER type], \"locations\": array of strings [at least one required], \"status\": string (ENABLED, MUTED, DISABLED) [required], \"slaThreshold\": double, \"options\": { \"validationString\": string [only valid for SIMPLE and BROWSER types], \"verifySSL\": boolean (true, false) [only valid for SIMPLE and BROWSER types], \"bypassHEADRequest\": boolean (true, false) [only valid for SIMPLE types], \"treatRedirectAsFailure\": boolean (true, false) [only valid for SIMPLE types] } } Copy In addition, to add the script for a scripted monitor via the REST API, call an additional API endpoint to send the script for the monitor just created. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Replace the Synthetics REST API attributes in the following example with your specific values: curl -v \\ -X POST -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors \\ -d '{ \"name\" : \"monitor1\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"type\" : \"browser\", \"status\" : \"enabled\", \"slaThreshold\" : \"1.0\"}' Copy A successful request will return a 201 Created response, with the URI of the newly-created monitor specified in the location header. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example: the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 402 Payment Required: Creating the monitor will increase your scheduled checks past your account's purchased check limit. Update an existing monitor To update an existing monitor in New Relic, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. In addition, for scripted monitors, follow the procedures to update the BASE64 encoded script. All fields are required. However, the TYPE of the monitor cannot be changed. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PUT -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\", \"type\": \"monitor type\", \"frequency\" : 15, \"uri\" : \"http://my-uri.com/\", \"locations\" : [ \"AWS_US_WEST_1\" ], \"status\" : \"enabled\", \"slaThreshold\": \"7.0\" }' Copy PUT requests are intended to replace target entities, so all attributes required in the JSON payload when creating a new monitor are also required when updating an existing monitor. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Patch an existing monitor To patch an existing monitor in New Relic, send a PATCH request to $API_ENDPOINT/v3/monitors/$MONITOR_ID. Use a specific monitor ID, and replace the Synthetics REST API attributes with your specific values. curl -v \\ -X PATCH -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' $API_ENDPOINT/v3/monitors/$MONITOR_ID \\ -d '{ \"name\" : \"updated monitor name\" }' Copy PATCH requests are intended to update individual attributes of your New Relic Synthetics monitor rather than updating the entire entity, so you may provide only the attributes you want to update. A successful request will return a 204 No Content response, with an empty body. Possible error codes include: 400 Bad Request: One or more of the monitor values is invalid, or the format of the request is invalid. For example, the frequency is out of bounds, or one or more of the specified locations is invalid. (See the error message in the body of the response.) 404 Not Found: The specified monitor does not exist. Delete an existing monitor To delete an existing monitor in New Relic Synthetics, send a DELETE request to $API_ENDPOINT/v3/monitors/$MONITOR_ID: curl -v \\ -H 'Api-Key:$API_KEY' \\ -X DELETE $API_ENDPOINT/v3/monitors/$MONITOR_ID Copy A successful request will return a 204 No Content response, with an empty body. An unsuccessful request will return the response 404 Not Found: The specified monitor does not exist. Get a list of valid locations To retrieve the list of valid locations in New Relic Synthetics, use the following command: curl -v \\ -X GET -H 'Api-Key:$API_KEY' $API_ENDPOINT/v1/locations Copy Script API for scripted browser and API test monitors In addition to the general API, there are several API methods for the scripted browsers (SCRIPT_BROWSER) and API test browsers (SCRIPT_API). These examples show cURL commands. Get monitor script To view the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a GET request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script. For example: curl -v -H 'Api-Key: $API_KEY' $API_ENDPOINT/v3/monitors/$MONITOR_ID/script Copy A successful request will return a 200 OK response. The data returned will be a JSON object in the following format: { \"scriptText\": BASE64 encoded string } Copy Possible error codes include: 403 Forbidden: The specified monitor is not of type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor doesn't exist or the script associated with the monitor doesn't exist. Add scripted monitor To add a new scripted monitor to New Relic Synthetics with the REST API: Follow standard API procedures to add a new monitor, and identify the type as a SCRIPT_BROWSER or SCRIPT_API. Update the new monitor with a BASE64 encoded version of the script to the $MONITOR_UUID/script endpoint. For more information, refer to the example. If you are using private locations with verified script execution enabled, see script locations with verified script execution. Update monitor script To update the script associated with a specific SCRIPT_BROWSER or SCRIPT_API monitor in New Relic Synthetics for your account, send a PUT request to $API_ENDPOINT/v3/monitors/$MONITOR_ID/script with a JSON payload that contains the scriptText (required). scriptPayload='{\"scriptText\":BASE64 encoded string}' curl -v -X PUT \\ -H 'Api-Key:$API_KEY' \\ -H 'Content-Type: application/json' \\ $API_ENDPOINT/v3/monitors/$MONITOR_UUID/script \\ -d $scriptPayload Copy If you are using private locations with verified script execution enabled, see script locations with verified script execution. A successful request will return a 204 No Content response with an empty body. Possible error codes include: 400 Bad Request: Invalid BASE64 encoded string for scriptText or hmac. 403 Forbidden: The specified monitor is not of the type SCRIPT_BROWSER or SCRIPT_API. 404 Not Found: The specified monitor does not exist. Using private location scripts with verified script execution When creating or updating monitors for private locations that have verified script execution turned on, you must use scriptLocations to set the password: { \"scriptText\": BASE64 encoded String, \"scriptLocations\": [ { \"name\": Location name, \"hmac\" BASE64 encoded String of SHA256 HMAC for location } ] } Copy The password used to generate the HMAC string must match the password set for the private location. If you have multiple locations with Verified script execution enabled each location must have the HMAC calculated. When generating the HMAC string, use the SHA256 algorithm with the script and password. Here's an example for the script: var assert = require('assert'); assert.equal('1', '1'); Copy This example uses password as the password for the scriptLocation: curl -v -X PUT -H 'Api-Key: '$API_KEY' -H 'content-type: application/json' $API_ENDPOINT}/v3/monitors/$MONITOR_ID/script -d '{ \"scriptText\": \"dmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpOw0KYXNzZXJ0LmVxdWFsKCcxJywgJzEnKTs=\",\"scriptLocations\": [ { \"name\": \"my_vse_enabled_location\", \"hmac\": \"MjhiNGE4MjVlMDE1N2M4NDQ4MjNjNDFkZDEyYTRjMmUzZDE3NGJlNjU0MWFmOTJlMzNiODExOGU2ZjhkZTY4ZQ==\"} ]}' Copy Important You must remove the last newline character from both the script and the calculated HMAC value before encoding in BASE64. Calculation steps: Calculate the HMAC value from the script. One way is to use: cat script | openssl dgst -sha256 -hmac \"password\" > hmac Remove the newline character if one was added by openssl. Encode the HMAC in BASE64 without line breaks. Scripted browser example Here is an example of using New Relic's REST API and the bash script to create a scripted browser monitor. Scripted browser API example The following example shows cURL commands to create a scripted browser monitor. At the top of the script, replace the variables with your specific values. For the scriptfile variable, identify the filename for the script to be created. Here is a sample script that can be saved as sample_synth_script.js to use in the example: var assert = require(\"assert\"); $browser.get(\"http://example.com\").then(function(){ // Check the H1 title matches \"Example Domain\" return $browser.findElement($driver.By.css(\"h1\")).then(function(element){ return element.getText().then(function(text){ assert.equal(\"Example Domain\", text, \"Page H1 title did not match\"); }); }); }).then(function(){ // Check that the external link matches \"http://www.iana.org/domains/example\" return $browser.findElement($driver.By.css(\"div > p > a\")).then(function(element){ return element.getAttribute(\"href\").then(function(link){ assert.equal(\"http://www.iana.org/domains/example\", link, \"More information link did not match\"); }); }); }); Copy Bash script example This example shows the bash script that will create the SCRIPTED_BROWSER monitor. Tip In some cases you may want to use -w 0, which will disable line wrapping: base64 -w 0 $scriptfile #!/bin/bash # API key from your account settings API_KEY='' # Other attributes found at https://docs.newrelic.com/docs/apis/synthetics-rest-api/monitor-examples/attributes-synthetics-rest-api#api-attributes monitorName='Test API Script' monitorType='SCRIPT_BROWSER' frequency=1440 locations='\"AWS_US_WEST_1\", \"AWS_US_EAST_1\"' slaThreshold=7.0 # Location of the file with your script scriptfile=sample_synth_script.js # Test that the script file exists (does not validate content) if [ -e \"$scriptfile\" ] then script=$(cat \"$scriptfile\") payload=\"{ \\\"name\\\" : \\\"$monitorName\\\", \\\"frequency\\\" : $frequency, \\\"locations\\\" : [ $locations ], \\\"status\\\" : \\\"ENABLED\\\", \\\"type\\\" : \\\"$monitorType\\\", \\\"slaThreshold\\\" : $slaThreshold, \\\"uri\\\":\\\"\\\"}\" echo \"Creating monitor\" # Make cURL call to API and parse response headers to get monitor UUID shopt -s extglob # Required to trim whitespace; see below while IFS=':' read key value; do # trim whitespace in \"value\" value=${value##+([[:space:]])}; value=${value%%+([[:space:]])} case \"$key\" in location) LOCATION=\"$value\" ;; HTTP*) read PROTO STATUS MSG <<< \"$key{$value:+:$value}\" ;; esac done < <(curl -sS -i -X POST -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' https://synthetics.newrelic.com/synthetics/api/v3/monitors -d \"$payload\") # Validate monitor creation & add script unless it failed if [ $STATUS = 201 ]; then echo \"Monitor created, $LOCATION \" echo \"Uploading script\" # base64 encode script encoded=`echo \"$script\" | base64` scriptPayload=\"{\\\"scriptText\\\":\\\"$encoded\\\"}\" curl -s -X PUT -H \"Api-Key:$API_KEY\" -H 'Content-Type:application/json' \"$LOCATION/script\" -d $scriptPayload echo \"Script uploaded\" else echo \"Monitor creation failed\" fi else echo \"script file not found, not creating monitor\" fi Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.54666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Manage <em>synthetic</em> monitors via <em>REST</em> <em>API</em>",
        "sections": "Manage <em>synthetic</em> monitors via <em>REST</em> <em>API</em>",
        "tags": "<em>Synthetics</em> <em>REST</em> <em>API</em>",
        "body": " will disable line wrapping: base64 -w 0 $scriptfile #!&#x2F;bin&#x2F;bash # <em>API</em> key from your account settings <em>API</em>_KEY=&#x27;&#x27; # Other attributes found at https:&#x2F;&#x2F;docs.newrelic.com&#x2F;docs&#x2F;<em>apis</em>&#x2F;<em>synthetics</em>-<em>rest</em>-<em>api</em>&#x2F;monitor-<em>examples</em>&#x2F;attributes-<em>synthetics</em>-<em>rest</em>-<em>api</em>#<em>api</em>-attributes monitorName=&#x27;Test <em>API</em> Script&#x27; monitorType"
      },
      "id": "60440d4628ccbc74532c606a"
    }
  ],
  "/docs/apm/agents/c-sdk/get-started/apm-security-c-sdk": [
    {
      "sections": [
        "Introduction to the C SDK",
        "Monitor app performance",
        "Architecture: C library and daemon",
        "Get started with the C SDK",
        "Check the source code"
      ],
      "title": "Introduction to the C SDK",
      "type": "docs",
      "tags": [
        "Agents",
        "C SDK",
        "Get started"
      ],
      "external_id": "9f45dcee154d21769c5bffe822338f3355c3aaa1",
      "image": "https://docs.newrelic.com/static/e224c0fb3a99dac4ed9622f398d2db6d/8c557/c-apm-summary.png",
      "url": "https://docs.newrelic.com/docs/apm/agents/c-sdk/get-started/introduction-c-sdk/",
      "published_at": "2022-01-12T18:46:53Z",
      "updated_at": "2021-11-15T10:19:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The C SDK is designed to support the often complex, multi-threaded nature of C/C++ applications. You can gain a new level of visibility to help you identify and solve performance issues. You can also collect and analyze data to help you improve the customer experience and make data-driven business decisions. The C SDK can be used to instrument a wide range of applications beyond C or C++. If your application does not use other languages supported by New Relic and can import C libraries, then you can use the New Relic C SDK to take advantage of our monitoring capabilities and features. Monitor app performance one.newrelic.com > APM > (select an app): Here is an example of some of the data you can view in New Relic after you deploy the C SDK for your app. If your app meets the C SDK's compatibility and requirements in Linux environments, you can customize the generic library to communicate with New Relic, then start with APM to monitor your app's performance. What you can do How to do it See the big picture Start with the APM Summary page to monitor the throughput, response times, errors, memory and CPU usage transactions in your applications and services, then explore other details with additional APM dashboards. With deployment markers, see how code changes impact application performance and health. Use infrastructure monitoring to view detailed host and server data. When you install the infrastructure agent and APM on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by app in the Infrastructure UI. Identify and fix errors Use error analytics tools to find bottlenecks by seeing time spent on database calls, external system calls, and key blocks of code. Get alert notifications for problems or errors before they affect users. Create custom dashboards for important metrics. View logs for your APM and infrastructure data You can bring your logs and application's data together to make troubleshooting easier and faster. No need to switch to another UI page in New Relic One. With logs in context, you can see log messages related to your errors and traces directly in your app's UI. You can also see logs in context of your infrastructure data, such as Kubernetes clusters. Analyze business data Query user-related data and improve business processes. Send your own custom data to New Relic. Create custom queries of your application data. Create and share visual, interactive displays of your data. And more! Monitor and troubleshoot your application users' desktop experience with your application, including page load timing problems, JavaScript errors, session trace timelines, etc., by using browser monitoring. Use automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints with synthetic monitoring. Analyze and fine-tune your Android and iOS application performance, troubleshoot crashes, compare multiple versions, and examine the performance of HTTP and other network components with mobile monitoring. Architecture: C library and daemon The C SDK relies on two components to send data from your application to New Relic: The lC SDK calls: You download this library, then add the calls and instrumentation to your application's code. This allows you to identify and customize the kinds of data that matters the most to you. The C SDK daemon: This is a separate binary that accumulates data from the C SDK calls, and sends it to New Relic. This acts as a proxy between the SDK and New Relic. C SDK architecture: To send data from your application to New Relic, the daemon must be invoked before making calls to your application's C SDK instrumentation library. Working together, the C SDK instrumentation and the daemon forward data on to New Relic where you can view and query data about transactions. The workflow between your application and New Relic must occur in this order: An HTTPS link is established between the daemon and New Relic. The daemon must be invoked first, before your instrumented application is invoked. Next, socket communication is established between your instrumented application and the daemon. This occurs after successful calls to newrelic_new_app_config() and newrelic_create_app(). The call to newrelic_create_app() is non-blocking. Its second parameter allows you to specify an amount of time for your instrumented application to wait so that the socket communication is adequately established. For example: newrelic_app_t* app = newrelic_create_app(config, 10000); Copy If your instrumented application sends transactions before both the daemon connection and your application's socket communication are established, data reported from your application will be lost. Get started with the C SDK To use our C SDK agent: Make sure your application meets the compatibility and requirements for the C SDK. If you do not already have one, sign up for a free New Relic account. Use our launcher, or follow the installation and instrumentation procedures to install the agent. Within a few minutes, you will be able to view data from your application in your New Relic account's UI. Read the install docs Add C data Check the source code The C SDK is open source software. That means you can browse its source code and send improvements, or create your own fork and build it. For more information, see the README.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.19153,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to the <em>C</em> <em>SDK</em>",
        "sections": "<em>Get</em> <em>started</em> with the <em>C</em> <em>SDK</em>",
        "tags": "<em>Get</em> <em>started</em>",
        "body": " established. For example: newrelic_app_t* app = newrelic_create_app(config, 10000); Copy If your instrumented application sends transactions before both the daemon connection and your application&#x27;s socket communication are established, data reported from your application will be lost. <em>Get</em> <em>started</em> with the <em>C</em>"
      },
      "id": "617e6cda196a671853f7c605"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "2e87a574d5fcccc5f5775c0030f57d39d6672097",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2022-01-12T18:50:59Z",
      "updated_at": "2022-01-12T18:50:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Want to try out New Relic's Java agent? Create a New Relic account for free! No credit card required. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. In order to continue to innovate and efficiently provide new capabilities to our customers, we'll occasionally need to drop support for older JVM versions. When that happens, you can continue using a version of the agent that supports your older JVM version, but new features and fixes won't be included in those older agent versions. We recommend upgrading to a currently supported JVM version to take advantage of the latest agent releases. Please see the table of compatible agent versions to determine which JVM versions are compatible. Java version Compatible agent versions Not supported Java 5 Agent v1.3.0 to v2.21.7 v2.21.7 and lower Java 6 Agent v3.0.0 to v4.3.0 v4.3.0 and lower Java 7 Agent v3.0.0 to v6.5.0, v6.5.2, and v6.5.3 v4.9.0 and lower Java 8 Agent v3.10.0 to current v4.9.0 and lower Java 9 Agent v3.43.0 to current v4.9.0a and lower Java 10 Agent v4.4.0 to current v4.9.0 and lower Java 11 Agent v4.7.0 to current v4.9.0 and lower Java 12 Agent v4.12.0 to current NA Java 13 Agent v5.7.0 to current NA Java 14 Agent v5.11.0 to current NA Java 15 Agent v6.1.0 to current NA Java 16 Agent v7.3.0 to current NA Java 17 Agent v7.4.0 to current NA Compatible: IBM JVM versions 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 8 to 16 for Linux, Windows, and macOS Oracle Hotspot JVM versions 8 to 16 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS (Java 1.7) Compatible only with Java agent 6.5.x [ ZIP | 16.8 MB] legacy agent: OpenJDK and AdoptOpenJDK JVM versions 7 IBM JVM version 7 Oracle Hotspot JVM version 7 for Linux, Solaris, Windows, macOS (Java 1.6) Compatible only with Java agent 4.3.x [ ZIP | 9.9 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS (Java 1.5) Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 + Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest Cats Effect v2 Scala 2.12: 2.1 to latest Scala 2.13: 2.1 to latest Cats Effect v3 Scala 2.12: 3.2.x Scala 2.13: 3.2.x GraphQL 16.0 - 16.2 GraphQL 17.0 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 ZIO Scala 2.13: 1.0.9 to 2.0.0-M2 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to 1.39.0 HTTP4s Blaze client Scala 2.12: 0.21 - 0.23.0-M1 Scala 2.13: 0.21 - 0.23.0-M1 HTTP4s Blaze server Scala 2.12: 0.21 - 0.22.0-M8 Scala 2.13: 0.21 - 0.22.0-M8 HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to 2.8.1 (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest STTP v2 Scala 2.12: 2.2.3 to latest 2.x Scala 2.13: 2.2.3 to latest 2.x, 3.0.0 to latest 3.x Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon v1 DynamoDB 1.11.106 to latest Amazon v2 DynamoDB 2.1.0 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to 3.8.x jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to 3.3.x Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the browser JavaScript agent when you enable auto-instrumentation. After enabling browser injection, you can view browser data in the APM Summary page and quickly switch between the APM and browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.95984,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Compatibility</em> and requirements for the Java <em>agent</em>",
        "sections": "<em>Compatibility</em> and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": ": Instance-level information is not reported for calls to the <em>get</em>Bulk() API method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional"
      },
      "id": "617e61a1196a670ec4f7d6cf"
    },
    {
      "sections": [
        "C SDK compatibility and requirements",
        "Language versions",
        "Operating environments",
        "License key",
        "Processor type",
        "Security requirements",
        "Database and instance-level performance"
      ],
      "title": " C SDK compatibility and requirements",
      "type": "docs",
      "tags": [
        "Agents",
        "C SDK",
        "Get started"
      ],
      "external_id": "8f6f0ee939383fff5783892ed0b7cbb71113ec7e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/agents/c-sdk/get-started/c-sdk-compatibility-requirements/",
      "published_at": "2022-01-12T18:46:52Z",
      "updated_at": "2021-10-23T20:02:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's C SDK provides a generic library you can customize to communicate with New Relic. Before you install New Relic's C SDK, make sure your system meets these requirements. Also refer to the C SDK licenses documentation. Want to try out our C SDK? Create a New Relic account for free! No credit card required. Language versions The C SDK allows you to instrument any application on Linux, provided: You must have access to the source code. The target language must be able to import C libraries. You can use the C SDK to create instrumentation for applications written in C and C++. You can also use it in languages like Perl, which are implemented in C or C++, and in any language that has a foreign function interface with C. Operating environments The C SDK works in 64-bit Linux operating systems with: gcc 4.8 or higher glibc 2.17 or higher Kernel version 2.6.26 or higher libpcre 8.20 or higher libpthread cmake 2.8 or higher Compiling the New Relic daemon requires Go 1.7 or higher. License key You will need a New Relic license key for the account you want to report data to. Processor type Intel (and compatible) platforms only Support for SSE2 instructions is required Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Database and instance-level performance You can collect instance details for a variety of databases and database drivers. You can also view slow query trace details for the following SQL-based database platforms: Firebird Informix Microsoft SQL Server MySQL Oracle Postgres SQLite Sybase",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.12681,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": " <em>C</em> <em>SDK</em> <em>compatibility</em> and requirements",
        "sections": "<em>C</em> <em>SDK</em> <em>compatibility</em> and requirements",
        "tags": "<em>Get</em> <em>started</em>",
        "body": "New Relic&#x27;s <em>C</em> <em>SDK</em> provides a generic library you can customize to communicate with New Relic. Before you install New Relic&#x27;s <em>C</em> <em>SDK</em>, make sure your system meets these requirements. Also refer to the <em>C</em> <em>SDK</em> licenses documentation. Want to try out our <em>C</em> <em>SDK</em>? Create a New Relic account for free"
      },
      "id": "617e510464441fa31dfbc502"
    }
  ]
}